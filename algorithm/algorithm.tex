% !Mode:: "TeX:UTF-8:Hard"

\documentclass[a4paper,11pt,twoside]{book}
%\usepackage{CJKutf8}
\usepackage[T1]{fontenc}
\usepackage{pifont}
\usepackage{graphicx}
\usepackage{multirow} 
\usepackage{longtable}
\usepackage{capt-of}
\usepackage{color}
\usepackage{amsmath}
\usepackage{enumitem}

\setitemize[1]{itemsep=0pt,partopsep=0pt,parsep=1pt,topsep=0pt}
\setenumerate[1]{itemsep=0pt,partopsep=0pt,parsep=1pt,topsep=0pt}
\setdescription{itemsep=0pt,partopsep=0pt,parsep=1pt,topsep=0pt}

\usepackage[a4paper,left=2cm,right=2cm,top=3cm,bottom=3cm,]{geometry}

\newcommand{\linuxcommand}[1]{\texttt{\textcolor{blue}{\$ #1 \Pisymbol{psy}{191}}}}
\newcommand{\op}[1]{\textcolor{blue}{-#1}}
\newcommand{\hotkey}[1]{\framebox{#1}}
\newenvironment{screen}{\sffamily}{\rmfamily}

% for C/C++ frame box
\usepackage{listings}
\definecolor{mygray}{rgb}{0.9,0.9,0.9}

\lstset{ 
	backgroundcolor=\color{mygray},
	mathescape=true,
	frame=single,
	frameround=tttt,
	language=c++,
	basicstyle=\footnotesize,
	%literate={\ \ }{{\ }}1
	tabsize=2,
	numbersep=6pt,
	breaklines=true,
	%framextopmargin=0.5em,
	%framexbottommargin=0.5em,
	morecomment=[s][\color{red}]{/*-}{*/},
	%escapeinside={//*}{*//},
	numberstyle=\tiny\textit,  stepnumber=1,
	numbers=left,
}

\lstset{morecomment=[s][\color{red}]{/*-}{*/}}
\newcommand{\Hilight}[1]{\makebox[0pt][l]{\color{yellow}\rule[-3pt]{#1em}{11pt}}}
\newcommand{\HilightLine}[2][yellow]{\makebox[0pt][l]{\color{#1}\rule[-4pt]{#2em}{13.9pt}}}

\newenvironment{answer}{\ttfamily}{\par}

\newcommand{\specialcell}[2][c]{%
  \begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}

\begin{document}
%\begin{CJK*}{UTF8}{song}
\title{Data Structure, algorithm}
\author{yan zhao}
\date{}\maketitle

\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}
\tableofcontents


\chapter{Data structure} 

\section{Array}
\subsection{Basic syntax}
\begin{itemize}
	\item All language support array and it is a build-in data type in most of language.  
\begin{lstlisting}[frame=single, language=c++]
//C/C++ language
int a[3]; or int a[4][5].  
vector<int> vi(4,0); //STL
array<int, 4> al = {1, 2, 3 , 4};
  
//C# language 
object[] a1 = {"string", 123, true};
\end{lstlisting}

	\item Array support three basic operations: (random access)index, insert, delete (erase in STL library).  

	\item Dynamic two dimension array(ragged array) can be implemented below:  \texttt{char ** p}; should be used as ragged array. Pay attention to p[1][2] and pa[1][2]. They are all correct forms.

	\item All ragged array should include terminate flag, so you can know the length of each row.  For C-style string ragged array, the 'NULL' in the end of string can be used as terminate flag directly, so ragged array is idea container for C-style string array. 

\begin{lstlisting}[frame=single, language=c++]
char **p;
char* a[]={"zhao","yan","hello"}; 
p = a;    // use pointer of pointer to catch array of pointer.
printf("%c\n",*(*(p+1)+2)); //p[1][2]

int (*pa)[3];  //pointer to array.
int aa[2][3] = {{1,2,3},{4,5,6}};
pa = aa;
int bb[][3]; //bb must have 3 as last dimension. c++ syntax.
bb = aa;
printf("%d\n",pa[1][2]);//*(*(pa+1)+2);
\end{lstlisting} 
\begin{description}
	\item[line 7-10] this is array of \textbf{array}. so you have to use \textbf{a pointer to array} to catch it. Pay attention to the syntax of a pointer to array in C++ language: \texttt{int (*pointer\_to\_array)[3];}
\end{description}

\end{itemize}

\subsubsection{Basic operation}

\begin{itemize}
	\item If you want to insert an element into an array, you  \textbf{need to copy backward from end. }
if erase an element from an array, \textbf{copy forward from erasing point}. Most of time, you can just call insert(pos) or erase(pos) in STL container. \textbf{It inserts the element before the pos and erase the element at th pos}, and pos is an iterator.  

\includegraphics[scale=0.35]{pics/array_insert.png} \newline

	\item If you have an array of big object, and you need to sort it. You can build a array of pointer to point to each object in the array. When you sort the an array of big object,  you just move pointer instead, It is called \textbf{"indirect addressing"}, It can help you to avoid moving big chunk of data.  

	\item reverse array can be implemented by \textbf{swap + double pointers}, But reversing list need different algorithm, so in STL , \texttt{std::list} has its own reverse member function. Reverse list is a typical interview question, and you should know it very well. 
	
	\begin{enumerate}
		\item Remember: if \texttt{n} is size of array, \texttt{n/2} is the middle element(odd) or the first element in the second half(even). This pattern is very helpful for you to write reverse function. 
		
		\item Remember: if \texttt{end} is end of index, \texttt{end/2} is the middle element(odd) or the last element in the first half(even). Be careful with this, most of time, D\&C like to use start and end index. 
		
		\item distance(v.begin(), v.end()) is size of array/vector. 
	\end{enumerate}
	
\begin{lstlisting}[breaklines]
void reverseArray(int a [], int n){
	int i,j,temp;
	for(i=0,j=n-1;i<n/2;++i,--j){
		swap(a[i], a[j]);
	}
}
//another is based on iterator

for(auto i = v.begin() auto j = v.end()-1; i<next(i, distance(v.begin(), v.end())/2) ; ++i, --j)
	iter_swap(i,j);

//pay attention next and distance usage, put being in front of end.
//distance(v.end(), v.begin()) is just size of array/vector. 
\end{lstlisting}

	\item Write a function rotate(ar[], d, n) that rotates arr[] of size n by d elements.
\begin{enumerate}
	\item single rotate method
\begin{lstlisting}[breaklines]
while(d-->0){ //d-- >0 is good trick
  int temp = Array[0];
  for (int i = 0; i < n-1; i++){
    Array[i] = Array[i + 1];
  }
  Array[n-1] = temp;
}
\end{lstlisting}

	\item Reverse method. That is a very efficient implementation.
\begin{lstlisting}[breaklines]
rotate(arr[], d, n)
  reverse(arr[], 1, d) ;
  reverse(arr[], d + 1, n);
  reverse(arr[], l, n);
\end{lstlisting}
\textbf{Idea: middle part reverse twice, so keep origin value}

	\item for std::list, you can use std::rotate, but the time complexity is O(n), you can use splice function to reach O(1).  
\begin{lstlisting}
std::list l{1, 2, 3, 4, 5};
auto i2 = std::next(i1, 2);

l.splice(l.end(), l, l.begin(), i2 ); //output 3, 4, 5, 1, 2
\end{lstlisting}


	\item You can use \texttt{std::rotate} in insert sort method. also use in slide. Detail can be found in "Top 5 Beautiful C++ std Algorithms Examples"
\begin{lstlisting}[breaklines, basicstyle=\scriptsize]
for (auto i = start; i != end; ++i)
	std::rotate(std::upper_bound(start, i, *i), i, std::next(i));  
	//all stl algorithms deal with left open, right close space. 
	//i and std::next(i) is right close point                               

template <typename It> 
auto slide(It f, It l, randIter p) -> std::pair<It, It>{
  //  p < [f...l] < p, two possibles 
  if (p < f) return { p, std::rotate(p, f, l) };
  if (l < p) return { std::rotate(f, l, p), p };
  return { f, l };
}

ForwardIt rotate( ForwardIt first, ForwardIt n_first, ForwardIt last );
// rotate returns Iterator to the new location of the element pointed by first
\end{lstlisting}
\begin{description}
	\item[line 2:] rotate(a, b, c) is [a,b) and [b,c) scope. they are all left close, right open scope. In this way, you can understand why we need \texttt{std::next(i)} here.
\end{description}

	\item \textbf{reverse-->rotate--> insert order and slide}

\end{enumerate}

	\item We can also use partition to implement gather. \textbf{Partition return: Iterator to the first element of the second group.}

	\item Gather all eligible element around iterator p
\begin{lstlisting}[numbers=none]
template <typename BiIt, typename UnPred> 
auto gather(BiIt f, BiIt l, BiIt p, UnPred s) -> std::pair <BiIt, BiIt>{
	return { stable_partition(f, p, not1(s)), 
		stable_partition(p, l, s) };
}		
\end{lstlisting}



\end{itemize}

\subsection{Interview questions}
\begin{itemize}
	\item Two sum. 
\begin{enumerate}
\item Answer 1: Sort O(n*log(n))
\begin{lstlisting}[tabsize=3]
bool hasArrayTwoCandidates(int A[], int arr_size, int sum) { 
	int l, r; 
	sort(A, A + arr_size); 
	
	/* Now look for the two candidates in  the sorted array*/
	l = 0; 
	r = arr_size - 1; 
	while (l < r) { 
		if (A[l] + A[r] == sum) 
			return 1; 
		else if (A[l] + A[r] < sum) 
			l++; 
		else // A[i] + A[j] > sum 
			r--; 
	} 
	return 0; 
} 
\end{lstlisting}
\textbf{Idea: Don't need keep index information, so you can sort it. }

\item Answer 2: Hash O(n)
\end{enumerate}

\item Count triplets with sum smaller than a given value. 
\begin{lstlisting}[breaklines]
1) Sort the input array in increasing order. 
2) Initialize result as 0.
3) Run a loop from i = 0 to n-2.  An iteration of this loop finds all
   triplets with arr[i] as first element.
     a) Initialize other two elements as corner elements of subarray 
        arr[i+1..n-1], i.e., j = i+1 and k = n-1
     b) Move j and k toward each other until they meet, i.e., while (j < k)
            (i) if (arr[i] + arr[j] + arr[k] >= sum), then do k-- 

            // Else for current i and j, there can (k-j) possible third elements that satisfy the constraint.
            (ii) Else Do ans += (k - j) followed by j++ 
\end{lstlisting}
\textbf{Idea: Same Idea as previous question, Don't need keep index information, so you can sort it. brutal force, only sort can help here.}


	\item Given an array of positive integers. All numbers occur even number of times except one number which occurs odd number of times. Find the number in O(n) time and constant space.
Example: I/P = [1, 2, 3, 2, 3, 1, 3] and O/P = 3. The Best Solution is to do bitwise XOR of all the elements. XOR of all elements gives us odd occurring element. Please note that XOR of two elements is 0 if both elements are same and XOR of a number x with 0 is x.

\begin{lstlisting}[breaklines]
	result = result ^ a[i];
\end{lstlisting}
\textbf{Idea: Perform some calculation on all elements. }


	\item You are given a list of n-1 integers and these integers are in the range of 1 to n. There are no duplicates in list. One of the integers is missing in the list. Write an efficient code to find the missing integer.
\begin{lstlisting}[breaklines]
1) Get the sum of numbers 
       total = n*(n+1)/2
2  Subtract all the numbers from total and you will get the missing number.
\end{lstlisting}
\textbf{Idea: Perform some calculation on all elements. }

	\item Max product of the three numbers for a given array of size N. \textbf{Find the three largest numbers in the array (n1, n2, n3) and the two smallest numbers (m1, m2). The answer is either n1 x n2 x n3 or n1 x m1 x m2. The tricky thing here is there are two potential answers.}
\begin{lstlisting}[breaklines]
nth_element(...)
\end{lstlisting}
\textbf{Idea: Not sort, but nth max element based on heap}

	\item Given an unsorted array of non-negative integers, find a \textbf{continuous} subarray which adds to a given number.  Examples: Input: arr[] = {1, 4, 20, 3, 10, 5}, sum = 33; Ouptut: Sum found between indexes 2 and 4. 

\begin{lstlisting}[breaklines]
int arr[] = {1, 4, 20, 3, 10, 5};
int left = 0; int right = 0;
int sum = 0;
while(right< 6){
	sum+=arr[right];
	++right;
	
	while(sum>33){
		sum-=arr[left];
		++left;
		if (sum == 33){
			cout<<left<<" "<<right<<" "<<endl;
		}
	}	
}
\end{lstlisting}
\textbf{Idea: 1) You must keep index information, so you can't sort. }  \textbf{That is a typical sliding window problems. Keep left and right two index. } Sliding window can be found in algorithm chapter. 

	\item Given an array \texttt{arr[]} of integers, find out the difference between any two elements such that larger element appears after the smaller number in arr[]. Examples: If array is [2, 3, 10, 6, 4, 8, 1] then returned value should be 8 (Diff between 10 and 2). If array is [ 7, 9, 5, 6, 3, 2 ] then returned value should be 2 (Diff between 7 and 9). That is also a one time stock buy sell problem.
\begin{lstlisting}[breaklines]
In this method, instead of taking difference of the picked element with every other element, we take the difference with the minimum element found so far. So we need to keep track of 2 things:
1) Maximum difference found so far (max\_diff).
2) Minimum number visited so far (min\_element).
\end{lstlisting}
\textbf{Keep position, but this problem can be divided by sub-problem. Such as, [ 7, 9, 5, 6, 3, 2 ] can be seen as [7,9] [5, 6] [3] [2]  Once current element is less than min\_element, begin a new sub-problem.}


	\item Inversion Count for an array indicates -- how far (or close) the array is from being sorted. If array is already sorted then inversion count is 0. If array is sorted in reverse order that inversion count is the maximum. Formally speaking, two elements a[i] and a[j] form an inversion if a[i] > a[j] and i < j. Example: The sequence 2, 4, 1, 3, 5 has three inversions (2, 1), (4, 1), (4, 3).

\begin{lstlisting}[breaklines]
int main(){
	vector<int> vi = {2, 4, 1, 3, 5};
	set<int> si;
	int sum = 0;
	for(auto i :vi){
		si.insert(i);
		cout<<i<<endl;
		auto it1 = si.upper_bound(i);
		if (it1 != si.end())
		cout<<"***"<<*it1<<endl;
		sum += distance(it1, si.end());
	}
	
	cout<<sum<<endl;
	return 0;
}
\end{lstlisting}
\begin{description}
	\item[Line 10:] \textbf{set also support iterator, it will output sorted element from beginning to end }
	\item[Line 12] distance function, you have to input smaller iterator first. for set, if you input end, it will fall into dead loop.
\end{description}

For this questions, there are three points: 1) You need keep index(position) information. (No sort, no calculation).  2) you can't divid it to subj-problem. 3) You have to use auxiliary DS outside. such as set. which store how many element is greeter than current element.  


	\item Convert array into Zig-Zag fashion ? The converted array should be in form a < b > c < d > e < f. Just like bubble sort, use swap to make it satisfy order. Pay attention here, no global order requirement, so just \textbf{divide task to atomic operation. }
\begin{lstlisting}[breaklines]
void zigZag(int arr[], int n) {
	// Flag true indicates relation "<" is expected,
	// else ">" is expected. The first expected relation is "<"
	bool flag = true;	
	for (int i = 0; i <= n - 2; i++) {
		if (flag){ /* "<" relation expected */
			/* If we have a situation like A > B > C,
			we get A > C < B by swapping B and C */
			if (arr[i] > arr[i + 1])
			swap(arr[i], arr[i + 1]);
		}
		else{ /* ">" relation expected */
			/* If we have a situation like A < B < C,
			we get A < C > B by swapping B and C */
			if (arr[i] < arr[i + 1])
			swap(arr[i], arr[i + 1]);
		}
		flag = !flag; /* flip flag */
	}
}
// use i%2 == 0 to instead flag is also OK here. 
\end{lstlisting}

\end{itemize}


\subsubsection{mono stack}
\begin{itemize}
	
	\item  Write a program to print all the LEADERS in the array. An element is leader if it is greater than all the elements to its right side. And the rightmost element is always a leader. For example int the array {16, 17, 4, 3, 5, 2}, leaders are 17, 5 and 2.  
	
\begin{lstlisting}[breaklines]
Scan all the elements from right to left in array and keep track of maximum till now. When maximum changes it's value, print it.
\end{lstlisting}	

\begin{lstlisting}[breaklines]
can also use mono stack, from right to left,  when stack is empty, it's LEASDERS number. 
\end{lstlisting}	

	
	\item Next Greater Element.  Given an array, print the Next Greater Element (NGE) for every element. The Next greater Element for an element x is the first greater element on the right side of x in array. Elements for which no greater element exist, consider next greater element as -1. For the input array [4, 5, 2, 25], the next greater elements for
	each element are as follow.
\begin{verbatim}
4      -->   5  |  	5      -->   25 | 2      -->   25 | 25     -->   -1
\end{verbatim}

\begin{lstlisting}[breaklines]
void printNGE(int arr[], int n){
	stack<int> s;	
	/* push the first element to stack */
	s.push(arr[0]);

	// iterate for rest of the elements
	for (int i = 1; i < n; i++) {
		
		if (s.empty()) {
			s.push(arr[i]);
			continue;
		}		
		/* if stack is not empty, then pop an element from stack.
		If the popped element is smaller than next, then
		a) print the pair
		b) keep popping while elements are
		smaller and stack is not empty */
		while (s.empty() == false && s.top() < arr[i]) {
			cout << s.top() 
			<< " --> " << arr[i] << endl;
			s.pop();
		}	
		/* push next to stack so that we can find
		next greater for it */
		s.push(arr[i]);
	}	
	/* After iterating over the loop, the remaining
	elements in stack do not have the next greater
	element, so print -1 for them */
	while (s.empty() == false) {
		cout << s.top() << " --> " << -1 << endl;
		s.pop();
	}
}
\end{lstlisting}	

	\item One of the main ideas of a monotonic stack is to discard elements that do not meet certain conditions and avoid pushing them onto the stack, as they are irrelevant to the solution.

\end{itemize}	

\subsubsection{mono queue}
\begin{itemize}
	\item Given an array and an integer K, find the maximum for each and every contiguous subarray of size k. It looks like two sum problem. there are three different levels time complexity. 
\begin{enumerate}
	\item The first brute force, O(n*k). 
	\item The second, use balance Search Tree(std::set), O(n*log(k)). 
	\item the third, use queue O(n)
\begin{lstlisting}[breaklines]
std::deque<int> Qi(k);
/* Process first k (or first window) elements of array */
int i;
for (i = 0; i < k; ++i) {
	// For every element, the previous smaller elements are useless so
	// remove them from Qi
	while ((!Qi.empty()) && arr[i] >= arr[Qi.back()])
	
	Qi.pop_back();  	// Remove from rear	
	Qi.push_back(i);    // Add new element at rear of queue
}
// Process rest of the elements, i.e., from arr[k] to arr[n-1]
for (; i < n; ++i) {
	// The element at the front of the queue is the largest element of
	// previous window, so print it
	cout << arr[Qi.front()] << " ";	
	// Remove the elements which are out of this window
	while ((!Qi.empty()) && Qi.front() <= i - k)
	Qi.pop_front();  	// Remove from front of queue	
	// Remove all elements smaller than the currently
	// being added element (remove useless elements)
	while ((!Qi.empty()) && arr[i] >= arr[Qi.back()])
	Qi.pop_back();	
	// Add current element at the rear of Qi
	Qi.push_back(i);
}
// Print the maximum element of last window
cout << arr[Qi.front()];	    
\end{lstlisting}	
	

\end{enumerate}

	
\end{itemize}


\subsubsection{Hints for array questions.}

\begin{center}
	\includegraphics[scale=0.64]{pics/array.png} \newline
\end{center}

\begin{enumerate}
	\item Clue1: Get max and min value, based on heap, init a heap need O(n), when you get the second largest or third largest one, you only need O(log(n)). It's better than sort O(n*log(n) ). 
	
	\item Clue2: Sort, it will lose the index information. 
	
	\item Clue3: For continuous subarray, keep head and trail two index. two indexes can be used in reverse, and two sums. 
	
	\item Clue4: Calculate, such as sum and bit operator XOR. 
	
	\item Clue5: Use other auxiliary DS, such as, map, set or hash\_map.  They can be used as count and sort. 
\end{enumerate}


	
	
\section{Linked list}
\subsection{Basic}
\begin{itemize}
\item list in STL is bidirectional list(double-linked), in C++11, you can use \texttt{std::forward\_list} as single-linked list. 

\begin{lstlisting}[frame=single, language=c++]
//C 
struct node{ 
int a; 
 struct node* link
} ;

//C++ //I think that \texttt{std::list} is implemented in this way.
Template <class T>
Class ChainNode{
   friend Chain<T>;
   T data
  ChainNode<T> *link;
}

template<class T>
class Chain{
......
ChainNode<T> *head;
}
\end{lstlisting}

\end{itemize}


\subsection{Operations}
\begin{itemize}
\item insert after p node, \textbf{get an index to previous pointer}
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
//Consider if it's the first element. 
Insert(int k, const T &x)
chainNode<T> *i = new chainNode<T> (x);

//leftside is pointer pointed direction
//rightside is node, but in list, all nodes only can be accessed by a pointer.
//insert after p node 
i->link = p->link; //p->link is at right
p->link = i;       //p->link is at left now.
// i is inserted element, p is position.  
//You can remember i=p p=i  and fore three links.
\end{lstlisting}

\item insert before p node, what should I do?  \textbf{Just swap two node, then deal with next node. Don't touch next node in one atomic action. That is rule. }
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
1)create temp auto node, new  i node.
 
while(p->link) 
2) copy value from p to temp node
3) copy value i to p.
4) copy temp value to i value
p = p->link.  
\end{lstlisting}

\item delete the node after a given node.
\begin{lstlisting}[frame=single, language=c++]
Delete(int k, const T&x)
d = p->link;
p->link = d->link ;
delete d;
//d=p p=d and last three links
\end{lstlisting}

\item delete the given node. That is a typical question. you need to remember it. 
\begin{lstlisting}[frame=single, language=c++]
void deleteNode(Node* node_ptr){
	// If the node to be deleted is the last node of linked list
	if (node_ptr->next == NULL){
		free(node_ptr); // this will simply make the node_ptr NULL.
		return;
	}
	
	// if node to be deleted is the first or any node in between the linked list.
	Node* temp = node_ptr->next;
	node_ptr->data = temp->data;
	node_ptr->next = temp->next;
	free(temp);
}
\end{lstlisting}
\begin{description}
	\item[Source code] Psychically, still delete the next node, logically, we use next value to overwrite current node value, so we simulate "delete" in this way. remember, \textbf{We don't need while loop to reach the last node in the list}. 
\end{description}

%	\item Indirect addressing combines array and list. You should store pointer in array, and each pointer refer to random storage object. A typical usage is char* [] each item in array is char*(string), when you sort the strings, you just move pointers. It will save a lot of move time.  

\item Three different operations:
\begin{enumerate}
	\item Normal single link list: insert and delete given a node, always insert after the given node, or erase the next node of the given node. 
	
	\item Normal single link list: If you want to insert before or delete the given node, You still need to do it physically, but copy value to simulate the "insert" and "delete". 
	
	\item Double link list, such as \texttt{std::list}, insert value before the given node, and delete the given node. 
\end{enumerate}


\item How to rotate a List? This question in interesting, you need to understand splice usage. splice perform 1) move like question, 2) before node of next(i,3) points to null, 3) pointer of end(li) points to i. All these things perform automatically. 

\begin{lstlisting}[frame=single, language=c++]
list<int> li = {1, 2, 3, 4, 5};
auto i = begin(li);
//rotate(i, next(i, 3), end(li) );
li.splice(i, li, next(i, 3), end(li) );
\end{lstlisting}
\begin{description}
	\item[Line 3:] You can use generic algorithm, but must use next() time complexity is O(n).
	\item[Line 4:] You can also use splice, The complexity is O(1).
\end{description}

\end{itemize} 

\subsection{Application}
\subsubsection{Bucket sort}

\begin{itemize}
\item For each item, the value range is limited, and is integer. For example, sort all students score. (0<=score<=100). 

\item Basic step:  Here, Link list is best option to implement a bucket. Because Nobody will now how many elements will be put into the each bucket. 
\begin{enumerate}
\item Set up an array of initially empty "buckets".
\item Scatter: Go over the original array, putting each object in its bucket. 
\item Sort each non-empty bucket.(Optional )
\item Gather: Visit the buckets in order and put all elements back into the original array.
\end{enumerate}

\end{itemize}

\subsubsection{Radix sort}

\begin{itemize}
\item r is radix, $x\%r, (x\%r^{2})/r, (x\%r^{3})/r^{2}$  get each digit from least significant digit (LSD) radix sorts to most significant digit. 

\begin{lstlisting}[frame=single, language=c++]
int i ;
int k;
while(i%10){
	k = i%10;
	i = i/10;
}
\end{lstlisting}

\begin{enumerate}
\item according to r, prepare two arrays buckets A, B. 
\item Sort according to one position and put them into A array buckets. 
\item loop through A array buckets, and get next position digit. and then according to its value put into B array buckets.
\item swap A,B two array, then goto step 2.
\end{enumerate}

	\item Difference between radix sort and quick sort. Quicksort/Introsort is more flexible:Quicksort and Introsort work well with all kinds of data. All you need for sorting is the possibility to compare items. This is trivial with numbers but you can sort other data as well. Radix sort on the other hand just sorts things by their binary representation. It never compares items against each other. Radix sort needs more memory. All radix sort implementations that I've seen use a secondary buffer to store partial sorting results. This increases the memory requirements of the sorting algorithm. That may not be a problem if you only sort a couple of kilobytes, but if you go into the gigabyte range it makes a huge difference. If I remember right a in place radix-sort algorithm exist on paper though.
	
\begin{lstlisting}
void countSort(int arr[], int n, int exp)
{
	
	// Output array
	int output[n];
	int i, count[10] = { 0 };
	
	// Store count of occurrences
	// in count[]
	for (i = 0; i < n; i++)
	count[(arr[i] / exp) % 10]++;
	
	// Change count[i] so that count[i]
	// now contains actual position
	// of this digit in output[]
	for (i = 1; i < 10; i++)
	count[i] += count[i - 1];
	
	// Build the output array
	for (i = n - 1; i >= 0; i--) {
		output[count[(arr[i] / exp) % 10] - 1] = arr[i];
		count[(arr[i] / exp) % 10]--;
	}
	
	// Copy the output array to arr[],
	// so that arr[] now contains sorted
	// numbers according to current digit
	for (i = 0; i < n; i++)
	arr[i] = output[i];
}

// The main function to that sorts arr[] of size n using Radix Sort
void radixsort(int arr[], int n){
	
	// Find the maximum number to
	// know number of digits
	int m = getMax(arr, n);
	
	// Do counting sort for every digit.
	// Note that instead of passing digit
	// number, exp is passed. exp is 10^i
	// where i is current digit number
	for (int exp = 1; m / exp > 0; exp *= 10)
	countSort(arr, n, exp);
}
\end{lstlisting}

\item In order to understand previous code, you need to understand counting sort, Detail can be found here: //

https://www.geeksforgeeks.org/counting-sort/
//
it use prefix sum(std::partial\_sum). it's also interesting application of std::partial\_sum, you need to remember it. 
\end{itemize}


\subsection{Interview questions}
\begin{itemize}
	\item dumb head for easy delete node.
\begin{lstlisting}
while (head != NULL && head->val == val) { // pay attention while here, 
	ListNode* tmp = head;     //5-->5-->5--> for this condition.
	head = head->next;
	delete tmp;
}

// delete non head 
ListNode* cur = head;
while (cur != NULL && cur->next!= NULL) {
	if (cur->next->val == val) {
		ListNode* tmp = cur->next;
		cur->next = cur->next->next;
		delete tmp;
	} else {
		cur = cur->next;
	}
}
return head;
}
\end{lstlisting}
if we build dumb node, code is much easier now
\begin{lstlisting}
ListNode* dummyHead = new ListNode(0); // dumb node
dummyHead->next = head; 
// Set the virtual (dummy) head node to point to the head, which makes it easier to perform deletion operations later.
ListNode* cur = dummyHead;

while (cur->next != NULL) {
	if(cur->next->val == val) {
		ListNode* tmp = cur->next;
		cur->next = cur->next->next;
		delete tmp;
	} else {
		cur = cur->next;
	}
}
return dummyHead->next;
\end{lstlisting}
	
	\item print the middle. 
\begin{lstlisting}[breaklines]
/* Function to get the middle of the linked list*/
void printMiddle(struct Node *head) { 
	struct Node *slow_ptr = head; 
	struct Node *fast_ptr = head; 

	if (head!=NULL) {		 
		while (fast_ptr != NULL && fast_ptr->next != NULL) {  //this statement is very important.
			fast_ptr = fast_ptr->next->next; 
			slow_ptr = slow_ptr->next; 
		} 
		printf("The middle element is [%d]\n\n", slow_ptr->data); 
	} 
} 
\end{lstlisting}
\begin{description}
	\item[source code] when exit while, even node, fast\_ptr will be NULL, odd node, fast\_ptr->next will be null.
	\item[source code] \textbf{Just like n/2, odd number will be in the middle, even number will be the first element in the second half.}
\end{description}
	
	\item How to reverse a list \textbf{ There are two points: 1)while(p),  2) inside loop, do p = p->next, and necessary action( print out value and change pointer direction...)}
\newline

\includegraphics[scale=0.65]{pics/reverse.png} \newline

\begin{lstlisting}[breaklines]
node* lead, middle, *tail;
middle = nullptr;
tail = head;
while(tail){
	lead = middle;
	middle = tail;
	tail = tail->next;
	middle->next = lead;
}
head = middle;
\end{lstlisting}

%\begin{description}
%	\item[line] end condition
%	\item[line] end-input condition
%	\item[line] begin condition
%	\item[line] begin-input condition
%\end{description}

%\includegraphics[scale=0.60]{pics/link.png} \newline
%
\item Three steps to resolve this problem. this pattern can be applied on all link list problem. 
\begin{enumerate}
	\item The end status is like below figure.
	
	\item so normal status is also like this(previous atomic operation end statu and next atomic operation start status are all like below ), write while main logic.
	
	\item when you finish while main logic, according to this logic customize your beginning status. in this question, only tail = head and middle = nullptr;
\end{enumerate}

\begin{center}
\includegraphics[scale=0.60]{pics/reverse_list.drawio.png}
\end{center}


	\item Given a singly linked list, determine if its a palindrome. This method takes O(n) time and O(1) extra space.
\begin{enumerate}
	\item Get the middle of the linked list.
	\item Reverse the second half of the linked list.
	\item Check if the first half and second half are identical.
	\item \textbf{Idea: 1) find the middle 2)reverse}. If it's odd number,  you need to move the middle pointer to next position.
\end{enumerate}


	\item Swap nodes in a linked list without swapping data. 
\begin{lstlisting}[breaklines]
The idea it to first search x and y in given linked list. If any of them is not present, then return. While searching for x and y, keep track of current and previous pointers.
\end{lstlisting}



 
 \begin{lstlisting}[frame=single, language=c++] 
/* UTILITY FUNCTIONS */
/* Split the nodes of the given list into front and back halves,
     and return the two lists using the reference parameters.
     If the length is odd, the extra node should go in the front list.
     Uses the fast/slow pointer strategy.  */
void FrontBackSplit(struct node* source,
          struct node** frontRef, struct node** backRef)
{
  struct node* fast;
  struct node* slow;
  if (source==NULL || source->next==NULL){
    /* length < 2 cases */
    *frontRef = source;
    *backRef = NULL;
  }
  else{
    slow = source;
    fast = source->next;
 
    /* Advance 'fast' two nodes, and advance 'slow' one node */
    while (fast != NULL){
      fast = fast->next;
      if (fast != NULL){
        slow = slow->next;
        fast = fast->next;
      }
    }
 
    /* 'slow' is before the midpoint in the list, so split it in two
      at that point. */
    *frontRef = source;
    *backRef = slow->next;
    slow->next = NULL;
  }
}

\end{lstlisting}


	\item prints the given Linked List in reverse manner. 
\begin{lstlisting}[frame=single, language=c++]
void fun1(struct node* head){
  if(head == NULL)
    return;
  
  fun1(head->next);
  printf("%d  ", head->data);
}
\end{lstlisting}
\textbf{Idea: recursive}


	\item Write a program function to detect loop in a linked list
\begin{lstlisting}[breaklines]
This is the fastest method. Traverse linked list using two pointers.  Move one pointer by one and other pointer by two.  If these pointers meet at some node then there is a loop.  If pointers do not meet then linked list doesn't have loop.
\end{lstlisting}
\textbf{a circle has at last three nodes, so fast pointer each time step 2, So it will always go around inside the circle}

	\item Conclusion:
\begin{enumerate}
\item Just like tree, most link-list problems can be resolved by recursive. 

\item Most of time, In single link list, you need to keep previous pointer. 
\end{enumerate}

\begin{tabular}{|c|c|c|}
\hline 
 & array & list \\ 
\hline 
insert erase & O(n) & O(1) \\ 
\hline 
sort & quicksort & mergesort  \\ 
\hline 
reverse & swap element & just manipulate pointer  \\ 
\hline 
rotate & easy pointer manipulate & swap element  \\ 
\hline 
merge &  &  \\ 
\hline 
other  &  &  \\ 
\hline 

\end{tabular} 

\begin{enumerate}
\item in STL,  For assign, insert, erase and constructor, vector support two version, one is single element, other is range.  When we deal wih range input, we prefer to use range version. 
\item std::list and std::vector has different big O for insert and erase.
\item std::list has its own sort member function, but std::vector doesn't have. you can use std::sort algorithme. 
\item std::list has its own reverse,  std::vector doesn't have, just use std::reverse algorithm
\item list and vector don't have their own rotate function.
\item list has its own merge, vector use std::merge algorithm.

\end{enumerate}

\end{itemize}

\section{Matrix}
\begin{itemize}
	
	\item How to a kind of diagonal traversal matrix? this method is useful for matrix multiplication DP problem. 
	
\begin{lstlisting}
for(L = 2;L<n;L++)
  for(i = 1;i<n-L+1;++i)  //n-L+1  remember n-L+1 and i+L-1. 
     j = i+L-1            //i+L-1
  	for (k = i; k <= j - 1; k++){
  		...
\end{lstlisting}
	
	\item You can use two dimensions array to act as a matrix, square matrix, diagonal matrix, lower triangular, symmetric. 
	
	\item Some special square matrix
	\begin{enumerate}
	\item Diagonal  $i\neq j, M(i,j) = 0$ Can use one dimension array to describe it. 
	
	\item Low triangular $i<j, M(i,j) = 0$ We can use one dimension array to implement lower triangular because it will save many spaces.  Index can be calculated by $i*(i-1)/2+j-1$. and save it into a one dimension array. 
	
	\item Symmetric. Just like Low triangular, can be descriped by one dimenstion array. 
	\end{enumerate}
\end{itemize}

\subsubsection{sparse matrix}
\begin{itemize}
\item Sparse matrix can implemented by on dimension array or  linked list. 
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
class term{
int row, int col;
T value;
}

Term<T> *sparseMatrix;
\end{lstlisting}

\item Sparse matrix in linked list.  \textbf{Three level definition}
\begin{lstlisting}[frame=single, language=c++]
template<typenameT>
class CNode{
int col;
T value;
};



template<typename T>
class HeadNode{
int row, 
Chain< CNode<T> > colFirst
};
  
template<typename T>
class Matrix{
  Chain< HeadNode<T> > Frist
} 
\end{lstlisting}


	\item You can build a matrix class. use m(2,3) to access a element. And support +, - * . You also can define index begin from 1. It will more reasonable for you when you use a matrix. 
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
class Matrix{
T& operator()(int row, int col){
..}
}
\end{lstlisting} 

\end{itemize}

\subsection{Interview questions}
\begin{itemize}
	
	\item Two matrix multiply. \texttt{sum += v1[row][i]*v2[i][col];} is the key points to understand the whole problem. 
\begin{lstlisting}[]
int inner_product(int row, int col, int num, const vector<vector<int>> &v1, 
const vector<vector<int>> &v2){
	int sum = 0;
	for (int i =0 ;i<num ;i++){
		sum += v1[row][i]*v2[i][col];
	}
	return sum;
}

vector<vector<int> > m1 = {{1,2,3}, {4, 5, 6}}; //list initialization
vector<vector<int> >m2 = { {1,2}, {3,4}, {5,6}};
int m1_row = m1.size();
int m1_col = m1[0].size();
int m2_row = m2.size();
int m2_col = m2[0].size();
vector<vector<int> > result = {{0,0}, {0,0}};
for(int i = 0;i<m1_row;i++){
	for(int j= 0;j<m2_col;j++){
		int element = inner_product(i, j,3, m1, m2); //call function here.
		result[i][j] = element;
	}
}		
\end{lstlisting}
	
	\begin{description}	
		\item[line 1] In this questions, inner\_product is key point to resolve this problem. First, get atomic operation and change it into a function. Then, design this function parameter and in the end, design outside environment to call this automic function. This is very an important strategy. 
	\end{description}
	
	
	\item Sprial print a matrix
	\begin{lstlisting}[numbers=none]
		int
		print_out (int rb, int re, int cb, int ce, bool isrow, bool positive,
		const vector < vector < int >>&v)
		{
			if (isrow){
				if (positive){
					for (int i = cb; i <= ce; i++){
						cout << v[rb][i]<<',';
					}
				}
				else{
					for (int i = ce; i >= cb; i--){
						cout << v[re][i]<<',';
					}
				}
			}
			else
			{
				if (positive){
					for (int i = rb; i <= re; i++){
						cout << v[i][ce]<<',';
					}
				}
				else{
					for (int i = re; i >= rb; i--){
						cout << v[i][cb]<<',';
					}
				}
			}
		}
		
		int main ()
		{
			vector < vector < int >>m1 = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };
			int row = m1.size()-1;
			int col = m1[0].size()-1;
			
			int rb = 0, re = row, cb = 0, ce = col;
			int isrow = 1;
			int positive = 1;
			while (rb <= re && cb <= ce){
				
				if (isrow == 1 && positive == 1)
				{
					print_out (rb, re, cb, ce, isrow, positive,m1);
					rb++;
					isrow = 0;
					positive =1;
				}
				if (isrow == 0 && positive == 1)
				{
					print_out (rb, re, cb, ce, isrow, positive,m1);
					ce--;
					isrow = 1;
					positive = 0;
				}
				if (isrow == 1 && positive == 0)
				{
					print_out (rb, re, cb, ce, isrow, positive,m1);
					re--;
					isrow = 0;
					positive = 0;
				}
				if (isrow == 0 && positive == 0)
				{
					print_out (rb, re, cb, ce, isrow, positive,m1);
					cb++;
					isrow = 1;
					positive = 1;
				}
			}
			return 0;
		}	
		
	\end{lstlisting}		
	
	\begin{description}
		\item[line ] \textbf{In this questions, print\_out is key. }
		\item[line ] \textbf{Get atomic operation, print\_out, design the interface of this key function. after it, design the context which use this key function: print\_out. In this context, usually involve a loop and change boundary parameter.}
		
		\item[line ] rb, re, cb, ce very good clue, once you found these four parameters, then this question becomes easier. another two useful flag is isrow and positive. 
	\end{description}
	
	\item \textbf{matrix and spiral print all indicate a good hint:} 
	\begin{enumerate}
		\item identify a sub task(function).
		
		\item then design this function API (what information this function need to finish it's task.) 
		
		\item Once we have correct API, then loop call this function with correct parameter, this step will be easy now. 
	\end{enumerate}
	
\end{itemize}

 
\section{Stack}
\begin{itemize}
	\item In C++ STL , \texttt{std::stack} is container adaptor, specifically designed to operate in a LIFO context. 

	\item Stack is last-in first-out, and queue is frist-in and first-out
\end{itemize}


\subsection{Application of Stack}
\begin{itemize}
		
\item The most famous application about stack is \textbf{Recursive}. \textbf{The most famous applications based on stack is:  Maze(depth first). Hanoi tower. brace Match, recursive.}  


\item MinStack, all operation are constant time. Design a Data Structure SpecialStack that supports all the stack operations like push(), pop(), isEmpty(), isFull() and an additional operation getMin() which should return minimum element from the SpecialStack. All these operations of SpecialStack must have a time and space complexity of O(1). 
Note: To implement SpecialStack, you should only use standard Stack data structure and no other data structure like arrays, lists, etc 
\begin{lstlisting}[frame=single, language=c++, basicstyle=\scriptsize]
class MinStack {
	public:
	void push(int val) {
		if (stack.empty()) {
			stack.push_back({val, val});
		} else {
			stack.push_back({val, min(stack.back().second, val)});
		}
	}
	
	void pop() {
		stack.pop_back();
	}
	
	int top() {
		return stack.back().first;
	}
	
	int getMin() {
		return stack.back().second;
	}
	
	private:
	// first = val, second = min as of that insert
	vector<pair<int, int> > stack;
};
\end{lstlisting}

	\item some typical two stacks examples. One is expressions evaluation. we can build two stacks, one is for operands and the other for operators. When the operators precedence is higher than the stack top element, push the operators into the stack, otherwise, pop the operator and get two operatands from operands stacks, get the result and push back to the operands stack.  
	\begin{center}
			\includegraphics[scale=0.45]{pics/stacks_two.png} 
	\end{center}

	\item two stacks trick can also be used in browers back and forward function. Another typical two stack usage are use two stacks to implement queue
	
	\begin{center}
		\includegraphics[scale=0.3]{pics/sq1.png} 
	\end{center}
	\begin{center}
		\includegraphics[scale=0.3]{pics/sq2.png} 
	\end{center}
	
\end{itemize}

\subsubsection{Offline Equivalence class}
\begin{itemize}
	\item offline equivalence class, known n and R, get all Equivalence class. 
	
	\item n = 9, r = 11 and relation pairs are:
	(1,5), (1,6),(3,7),(1,5), (4,8),(5,2)
	(6,5), (4,9),(9,7),(7,8), (3,4),(6,2)
	
	\item Two phases to determine equivalence class
	
	\item One word, \textbf{from relation pairs build a graphs(adjacency list), Then use stack to perform DFS search, use equivalence class record if we have visited.}
	
	
	
	Phase 1: Equivalence pairs (i, j) are read in and adjacency (linked) list of each object is built.
	Phase 2: Trace (output) the equivalence class containing object i with stack (depth-first search). Next find another object not yet output, and repeat.
	
\begin{lstlisting}[frame=single, language=c++, basicstyle=\scriptsize]
	for (int i = 1; i <= n; i++)  // output equivalence classes
	if  (!out[i]) { // start of a new class
		out[i] = true;
		unprocessedList.push(new Integer(i)) ;
		while (!unprocessedList.empty()) { 
			// get rest of class from unprocessedList
			int j = ((Integer) unprocessedList.pop()).intValue();
			while  (!list[j].empty()) { 
				// elements on list[j] are in the same class
				int q = ((Integer) list[j].pop()).intValue();
				if (!out[q]) { // q not yet output
					System.out.print(q + " ");
					out[q] = true;
					unprocessedList.push(new Integer(q));  }
			} //end of while
		}  //end of while 
	} //end of if
\end{lstlisting}		

	
	\includegraphics[scale=0.35]{pics/offline_1.png} \newline
	\includegraphics[scale=0.35]{pics/offline_2.png}  \newline
	\includegraphics[scale=0.35]{pics/offline_3.png} \newline
	\includegraphics[scale=0.35]{pics/offline_4.png} \newline
	\includegraphics[scale=0.35]{pics/offline_5.png} \newline
	\includegraphics[scale=0.35]{pics/offline_6.png} \newline

\end{itemize}


\section{Queue}
\begin{itemize}
\item In STL, Queue has front() and back() interface. 

\end{itemize}


\subsection{Circule Queue}
\begin{itemize}
	
\item You can use three different way to implement queue, array, linked list and circular array.
	
\item circular array representation of a queue
\includegraphics[scale=0.35]{pics/cd.png} \newline
\begin{enumerate}
\item Initial condition : front = rear = 0
\item Empty queue:     front == rear
\item Full: (rear+1)\%length == front
\item \textbf{front point to an empty cell. So at most it can save length-1 elements. } Otherwise, we can't distinguish empty and full.

\item push only increase rear, so if (rear+1)\%length == front, means rear catch up front, it means full. 

\item how to understand (rear+1)\%length. an array with 10 element, length is 10, the last index is 9.  (9+1)\%10 = 0, it help use change 9 to 0(from end array to begin array)

\item \textbf{just remember front is for pop, rear is for push. rear+1\%length == front means full;  front==rear is empty. That is all. }

\begin{lstlisting}[frame=single, language=c++]
void push(T t){
	if ((rear+1)%length == front){
		throw "full" exception
	}
	rear = (rear+1)%length;
	array[rear] = t;
}	
\end{lstlisting}

\item pop only increase front, so if front == rear, means front catch up rear, it means empty.
\begin{lstlisting}[frame=single, language=c++]
T pop(){
	if (front == rear){
		throw "empty" exption
	}
	front = (front+1)%length;
	return array[front];
}
\end{lstlisting}

\end{enumerate}

\end{itemize}


\subsection{Application of queue}
\begin{itemize}
\item  BFS maze 
\begin{lstlisting}[frame=single, language=c++]
here=root of T;
here is end?
enqueue(Q,v);

while(!empty(Q)){
    dequeue(Q, here);
    if(here is end)
    for (each next position of here){
        if(next position is not end){
             mark next position
             enqueue(Q, next position);
        }
    }
}
\end{lstlisting}

\item For BFS, path is not save in stack. So you need a new kind of data type. 
\begin{lstlisting}[frame=single, language=c++]
struct position {
        int x;
        int y;
        struct position* parent;
}
\end{lstlisting}
\item Just like DFS, before you add a position to queue, mark it first. 

\end{itemize}



\section{Heap}
\subsection{Basic}
\begin{itemize}
	
\item Why heap sort has nlog(n)?

\verb|https://stackoverflow.com/questions/54078858/why-is-the-time-complexity-of-heap-sort-onlogn|
	
\item Max(min) tree is each node is greater or equal to its children node.

\item two basic operations: sink and swim.

\item Heap is \textbf{1)complete 2) binary 3)Max(min) tree.} Because Heap is complete binary tree. We can use an array to store it. 

\item insert is easier than you think, When you insert, put it on the end position, then exchange with parent.  
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
insert(x){
	int c = ++currentSize;
	while(c!=1 && x>heap[c/2]){ //get its parent node and compare
		heap[c] = heap[c/2];  //move down parent
		$\Hilight{20}$// move parent  down because it smaller
		c/=2;  //move up a level 
	}  
	heap[c] = x;  //the right position of insert. 
	//at this time heap[c] has been moved away by previous 
	//statement heap[c] = heap[c/2] 
}
$\Hilight{20}$ //c is used to control level,  c/=2 move up level
$\Hilight{20}$ //heap[c/2] get its parent	
\end{lstlisting}

\item \textbf{Heap just support delete Max(Min) value.} When delete, delete the first element, then put the end position element to the first position, then exchange it with either left child or right child. 
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
T y = heap[CurrentSize--];
int i = 1, ci = 2;
//because ci will increase to get bigger one from two children.
//so I have to use another i to keep current level
while(ci<=CurrentSize){
	if(heap[ci]<heap[ci+1]) ci++; // get the bigger child
	
	if(y>=heap[ci]{
		heap[i] = y;   // i always empty for a new value. 
		break; 
	}
	$\Hilight{10}$ //i is current node
	$\Hilight{10}$ //ci  is i biggest child node
	heap[i] = heap[ci]; //move up child, insert is "move down parent"
	i = ci;  //move to next level
	ci *=2;
}	
\end{lstlisting}



\item Initialize a Heap: \textbf{For an array, from the middle point, loop backward until reach to beginning( 0 index)}. the time complexity is O(n). 

\begin{lstlisting}[frame=single, language=c++]
void heapify(int arr[], int n, int i)
{
	int largest = i; // Initialize largest as root
	int l = 2 * i + 1; // left = 2*i + 1
	int r = 2 * i + 2; // right = 2*i + 2
	
	// If left child is larger than root
	if (l < n && arr[l] > arr[largest])
	largest = l;
	
	// If right child is larger than largest so far
	if (r < n && arr[r] > arr[largest])
	largest = r;
	
	// If largest is not root
	if (largest != i) {
		swap(arr[i], arr[largest]);
		
		// Recursively heapify the affected sub-tree
		heapify(arr, n, largest);
	}
}

// Function to build a Max-Heap from the given array
void buildHeap(int arr[], int n){
	// Index of last non-leaf node
	int startIdx = (n / 2) - 1;
	
	// Perform reverse level order traversal
	// from last non-leaf node and heapify
	// each node
	for (int i = startIdx; i >= 0; i--) {
		heapify(arr, n, i);
	}
}
\end{lstlisting}

\item Heap just guarantees that elements on higher levels are greater (for max-heap) or smaller (for min-heap) than elements on lower levels, whereas BST guarantees order (from "left" to "right"). If you want sorted elements, go with BST.

\item In STL, heap is called priority\_queue

\begin{lstlisting}[frame=single, language=c++, mathescape=true, basicstyle=\scriptsize]
//default compare function is less<T>
std::priority_queue<int, std::vector<int>, std::greater<int> > q2;
for(int n : {1,8,5,6,3,4,0,9,7,2})
	q2.push(n);
    // 0, 1, 2 ,3 ,4, 5...
\end{lstlisting}


\item STL support a basic heap operation

\begin{lstlisting}[frame=single, language=c++, mathescape=true]
	vector<int> vi = {2, 4, 1, 3, 5,6,7};
	cout<<"ddd"<<distance(end(vi),begin(vi))<<endl;
	make_heap(begin(vi),end(vi)); // inpace modify
	
	//after you pop_heap, you need to use v.pop_back()
	//to make begin(vi), end(vi) is still heap. 
	v.pop_heap(begin(vi),end(vi));
	v.pop_back();
	
	//if you want to use push_heap, you have to 
	//call push_back first. 
	v.push_back(10);
	v.push_heap(v.begin(vi) ,end(vi));
	
	//still inpace modify
	sort_heap(v.begin(vi) ,end(vi));
\end{lstlisting}
\begin{description}
	\item[source code] \textbf{push\_back and push\_heap must appear together. }. At the same time. \textbf{pop\_heap and pop\_back must appear together. }
\end{description}

A heap only supports three operations: initialization, insertion, and deletion of the maximum (or minimum) value. For insertion, the new element is placed at the last position and then repeatedly swapped with its parent to satisfy the heap condition. For deletion, the maximum (or minimum) value is removed, and the value from the last position is moved to the root. Then, it is compared with the left and right child nodes to decide which child to swap with in order to satisfy the heap condition. An important point during programming is the relationship between parent and child nodes, which is as follows:
\begin{lstlisting}
Root is at index 0 in array.
Left child of i-th node is at (2*i + 1)th index.
Right child of i-th node is at (2*i + 2)th index.
Parent of i-th node is at (i-1)/2 index.
\end{lstlisting}

\end{itemize}

\subsection{application}
\begin{itemize}
\item \textbf{Huffman tree use external nodes to represent a character, It assure no prefix is repeated }
\item You can use minHeap to build huffman tree. in the minHeap, each element is child tree, and then pop twice, combine two child trees. then insert it back to minHeap. Until there is only one element in the Heap. 

\item top k item in data steam. \textbf{use K minimum heap} 

\item median number in data steam. \textbf{use one minimum heap and one maximum heap, and keep these two heaps has at least 1 number difference size.} 
\end{itemize}

\section{Tree}
\subsection{Basic knowledge}
\subsubsection{Basic conception}
\begin{itemize}
\item List has a first node, every tree has a root node. Root node is a key component when you deal with most of tree problems.  

\item Pre-order, In-order and Post-order are based on middle node. \textbf{and they are all dfs algorithm.}

\item complete, full, perfect tree are different. Full Binary can be skewed shape. 
\begin{enumerate}
	\item Full Binary Tree: A Binary Tree is full if every node has 0 or 2 children. 
	
	
	\item Complete Binary Tree: A Binary Tree is complete Binary Tree if all levels are completely filled except possibly the last level and the last level has all keys as left as possible. (complete tree is heap, so complete tree is very important conception.)
	
	\item Perfect Binary Tree: A Binary tree is Perfect Binary Tree in which all internal nodes have two children and all leaves are at same level.
\end{enumerate}
	
\begin{verbatim}
     18  //full binary tree
   /    \   
  15      20    
 /  \       
40   50   
	/  \
	30  50
	
         18   //complete (heap is complete tree)
    /         \  
   15           30  
  /  \         /  \
 40    50     100   40
/  \   /
8   7  9 
	
	
      18     //perfect 
   /       \  
  15        30  
 /  \       /  \
40    50   100   40
\end{verbatim}


\item Heap is CBT(complete binary tree), not perfect binary tree. 

\item Balance search tree includes AVL and RB tree, in order to keep it balance, you need to rotate child tree. 

\item Tournament Tree: Tournament tree is a complete binary tree with some properties. Remove and  Replay of Tournament tree gives you "sorting". 

\item Binary Search Tree: BST is a binary tree with some properties (not necessarily CBT). In-order traversal of BST gives you "sorting" Can be skewed and unbalanced, so we need Balanced Tree.

\end{itemize}

\subsubsection{Other property of tree}
\begin{itemize}
	\item level, horizontal, and diagonal traversal.
	
	\item horizontal distance is distance between root node.  when you want to have bottom view or top view, you can use it.  detail can be found here: \newline
	\verb|https://www.techiedelight.com/print-bottom-view-of-binary-tree/|
	
\begin{lstlisting}[frame=single, language=c++]
map<int, pair<int, int>> map;
printBottom(root, 0, 0, map);
//---------------------------------------	
void printBottom(Node* node, int dist, int level, auto &map)
{
	// base case: empty tree
	if (node == nullptr) {
		return;
	}
	
	// if the current level is more than or equal to the maximum level seen so far
	// for the same horizontal distance or horizontal distance is seen for
	// the first time, update the map
	
	if (level >= map[dist].second)
	{
		// update value and level for the current distance
		map[dist] = { node->key, level };
	}
	
	// recur for the left subtree by decreasing horizontal distance and
	// increasing level by 1
	printBottom(node->left, dist - 1, level + 1, map);
	
	// recur for the right subtree by increasing both level and
	// horizontal distance by 1
	printBottom(node->right, dist + 1, level + 1, map);
}
\end{lstlisting}
\begin{description}
	\item[line 1] distance and level should be stack type value.
	\item[line 1] map is reference can shared by all recursive functions. And this is very important data structure in this question. 
\end{description}

	\item diagonal, Given a binary tree, calculate the sum of all nodes for each diagonal having negative slope \. Assume that the left and right child of a node makes a 45degree angle with the parent. \verb|https://www.techiedelight.com/find-diagonal-sum-given-binary-tree/|
\begin{lstlisting}[frame=single, language=c++]
// Recursive function to perform preorder traversal on the tree and
// fill the map with the diagonal sum of elements
 unordered_map<int, int> map;
void diagonalSum(Node* root, int diagonal, auto &map)
{
	// base case: empty tree
	if (root == nullptr) {
		return;
	}
	
	// update the current diagonal with the node's value
	map[diagonal] += root->data;
	
	// recur for the left subtree by increasing diagonal by 1
	diagonalSum(root->left, diagonal + 1, map);
	
	// recur for the right subtree with the same diagonal
	diagonalSum(root->right, diagonal, map);
}
	
\end{lstlisting}
\begin{description}
	\item[line 15] diagonal is just add 1 when you go to the left tree. Don't change when you go right tree. 
	\item[line 4] when you use sum of the whole tree, you must pass a reference type \texttt{auto\& map} here. 
\end{description}	

\end{itemize}

 
\subsection{Search Tree}
\begin{itemize}
\item Search tree is the key in each node must be \textbf{greater than all keys stored in the left sub-tree, and smaller than all keys in the right sub-tree.} 

\item Difference between BST and hash
\begin{enumerate}
\item So Hash Table seems to beating BST in all common operations. When should we prefer BST over Hash Tables? what are advantages? Following are some important points in favor of BSTs.

\item We can get all keys in sorted order by just doing Inorder Traversal of BST. This is not a natural operation in Hash Tables and requires extra efforts.

\item Doing order statistics, finding closest lower and greater elements, doing range queries are easy to do with BSTs. Like sorting, these operations are not a natural operation with Hash Tables.

\item BSTs are easy to implement compared to hashing, we can easily implement our own customized BST. To implement Hashing, we generally rely on libraries provided by programming languages.

\item With BSTs, all operations are guaranteed to work in O(Log(n) ) time. But with Hashing, O(1) is average time and some particular operations may be costly, especially when table resizing happens.
\end{enumerate}

\item ascending or descending order of BST. Pay attention here, they are all in order traversal.
\begin{lstlisting}[frame=single, language=c++]
void ascending(BST* root){
    if(root == NULL) return;
    ascending(root->left);
    std::cout<<root->data<<" ";
    ascending(root->right);
}
 
void descending(BST* root){
    if(root == NULL) return;
    descending(root->right);
    std::cout<<root->data<<" ";
    descending(root->left);
}
\end{lstlisting}

\end{itemize}


\subsection{Tree and recursion} 
\subsubsection{Base case}


\begin{itemize}
	

\item The problem of constructing a binary tree usually follows the "divide and conquer" approach: constructing the entire tree = root node + constructing the left subtree + constructing the right subtree.

\item There are two problems involving returning nodes: one is finding the lowest common ancestor, and the other is deleting a node with a certain value from a BST.
Binary tree recursive solutions can be divided into two thinking patterns. The first involves traversing the tree once to get the answer, and the second involves solving the problem by breaking it down. These two patterns correspond to the core frameworks of backtracking algorithms and dynamic programming, respectively.
The inorder position is primarily used in BST (Binary Search Tree) scenarios, and you can consider the inorder traversal of a BST as traversing a sorted array.
The preorder position doesnt inherently have any special properties. The reason you find that many problems seem to involve writing code in the preorder position is simply because we tend to place code that isnt sensitive to preorder, inorder, or postorder in the preorder position.

\item Youll notice that code in the preorder position executes from top to bottom, whereas code in the postorder position executes from bottom to top. This is significant because code in the preorder position can only access data passed from the parent node via function parameters, whereas code in the postorder position can access both parameter data and data returned from the subtrees via the function's return value.
	
\item Can we obtain the solution by traversing the binary tree just once? If so, implement it using a traverse function along with external variables. This approach is called the "traversal" thinking pattern.

\item Can we define a recursive function to derive the solution to the original problem using the answers from subproblems (subtrees)? If so, write the definition of this recursive function and fully utilize its return value. This is known as the "divide and conquer" thinking pattern.

\item No matter which thinking pattern you use, you must consider:

\item If you isolate a single node of the binary tree, what does it need to do? When should it do it (preorder/inorder/postorder)? You dont need to worry about other nodesthe recursive function will execute the same operation on all nodes.
Differences between global variables, reference variables, local variables, and return variables when used in tree recursion programs.

\item Referring back to the previous discussion: when encountering subtree problems, the first thing to consider is setting a return value for the function and focusing on postorder traversal.

\item Conversely, if youve written a recursive-in-recursive solution like in the beginning, its likely worth considering whether it can be optimized using postorder traversal.

\item \textbf{Nearly all the tree problems can be resolved by recursive}.

\item \textbf{Only focus on the current root logic.} For example, kth element problem, or lowest common ancester problem.

\item The basic patter is below: 
\begin{lstlisting}[frame=single, language=c++]
TreeFun(root*...){
	BaseCase;
	TreeFun(root->Left...);
	TreeFun(root->right...);
	Join
}
\end{lstlisting}

\begin{enumerate}
	
\item 95\% Base Case is very simple.\textbf{Forgetting to check if the root is null. It's an important base case. In nearly all interview questions, the first statement inside recursive should be check root, then return nullptr, return 0 or return nothing.}
	
	
\begin{lstlisting}
	if(root == nullptr){
		return ...
	}
\end{lstlisting}
	
	\item The easier part is recursive all with left child and right child. At this time, you should design the recursive interface according to specific question. For example, If it is required from you to write a function that returns a value (e.g. the number of nodes in a binary tree), you have to make sure that the function actually "returns". One of the common mistakes is just writing the recursive call without writing the word "return" before it.
	
	\item The most difficult part is \textbf{Join}, You should write some logic here according to specific problem.
	
	\item For example, for the height of tree, we need to get max value of the left and right tree and increment it. 
\begin{lstlisting}[frame=single, language=c++]
private int height(Node t){
	if(t == null)  {  //1) base case
		return -1;   //5) return value 
	}
	else
	{
		int height = 1 + max( height(t.left), height(t.right) );
		//5) put left and right recursive into assignment
		return height;
	}
}		
\end{lstlisting}	
	
\end{enumerate}

\end{itemize}


\subsubsection{span child tree}
\begin{itemize}
	\item Determine whether the given binary tree nodes are cousins of each other. Two nodes of a binary tree are cousins if they have the same depth, but have different parents.   \textbf{traversal all, use global variable to store the good result when you traversal all. } 
\begin{lstlisting}[frame=single, language=c++]
// Perform inorder traversal on a given binary tree and update `x` and `y`
void inorder(Node* root, Node* parent, int level, NodeInfo &x, NodeInfo &y)
{
	// base case: tree is empty
	if (root == nullptr) {
		return;
	}
	
	// traverse left subtree
	inorder(root->left, root, level + 1, x, y);
	
	// if the first element is found, save its level and parent node
	if (root->key == x.key)
	{
		x.level = level;
		x.parent = parent;
	}
	
	// if the second element is found, save its level and parent node
	if (root->key == y.key)
	{
		y.level = level;
		y.parent = parent;
	}
	
	// traverse right subtree
	inorder(root->right, root, level + 1, x, y);
}
\end{lstlisting}
\begin{description}
	\item[label] use two global valure as reference, then search the whole tree. 
\end{description}

\end{itemize}

\subsubsection{order}

\begin{itemize}
	

\item Next big question is pre-order, in-order or post-order. \textbf{90\% we use post-order.} But it also depends on practical requirement.


\begin{enumerate}
	\item inorder: two applications
	Find kth smallest and kth largest element in a BST:
\begin{lstlisting}[frame=single, language=c++]
int kthSmallest(Node* root, int *i, int k){
	// base case
	if (root == nullptr) {
		return INT_MAX;
	}
	// Left
	int left = kthSmallest(root->left, i, k);
	
	// Join
	if (left != INT_MAX) {
		return left;
	}
	
	// if the current element is k'th smallest, return its value
	if (++*i == k) {
		return root->data;
	}
	
	// right
	return kthSmallest(root->right, i, k);
}
\end{lstlisting}
\begin{description}
	\item[1] Only In order tranversal give ascending order, we have to use here.
	
	\item[1] for example, kth element, you only think that the element in left tree, then return it, current root, then return it.  if it's in right tree, then recursive call with root->right.
	
	\item[1] return INT\_MAX can be thought as a flag. if you want to look for a integer, you can use INT\_MAX to denote a flag.
	
	\item[1] I should be shared by all recursive call, so we use pointer or reference here. 
\end{description}

\item print an expression tree
\begin{lstlisting}[frame=single, language=c++]
     *
   /  \
  +    c
 / \
a   b
	
void inorder(Node* root)
{
	if (root == nullptr) {
		return;
	}
	
	// if the current token is an operator, print open parenthesis
	if (isOperator(root->data)) {
		cout << "(";
	}
	
	inorder(root->left);
	cout << root->data;
	inorder(root->right);
	
	// if the current token is an operator, print close parenthesis
	if (isOperator(root->data)) {
		cout << ")";
	}
}
\end{lstlisting}

\item preorder:
Print left view of a binary tree
\begin{lstlisting}[frame=single, language=c++]
// Recursive function to print the left view of a given binary tree
void leftView(Node* root, int level, int &last_level)
{
	// base case: empty tree
	if (root == nullptr) {
		return;
	}
	
	// if the current node is the first node of the current level
	if (last_level < level)
	{
		// print the node's data
		cout << root->key << " ";
		
		// update the last level to the current level
		last_level = level;
	}
	
	// recur for the left and right subtree by increasing the level by 1
	leftView(root->left, level + 1, last_level);
	leftView(root->right, level + 1, last_level);
}
\end{lstlisting}

\item postorder: 
Find maximum sum root to leaf path in a binary tree
\begin{lstlisting}[frame=single, language=c++]
// Function to calculate the maximum root-to-leaf sum in a binary tree
int getRootToLeafSum(Node* root){
	// base case: tree is empty
	if (root == nullptr) {
		return 0;
	}
	
	// calculate the maximum node-to-leaf sum for the left child
	int left = getRootToLeafSum(root->left);
	
	// calculate the maximum node-to-leaf sum for the right child
	int right = getRootToLeafSum(root->right);
	
	// consider the maximum sum child
	return (left > right? left : right) + root->data;
}	
\end{lstlisting}

\item combined:
find LCA
\begin{lstlisting}[frame=single, language=c++]
bool findLCA(Node* root, Node* &lca, Node* x, Node* y)
{
	// base case 1: return false if the tree is empty
	if (root == nullptr) {
		return false;
	}
	
	// base case 2: return true if either `x` or `y` is found
	if (root == x || root == y){  // 
		// set lca to the current node
		lca = root;
		return true;
	}
	
	// recursively check if `x` or `y` exists in the left subtree
	bool left = findLCA(root->left, lca, x, y);
	
	// recursively check if `x` or `y` exists in the right subtree
	bool right = findLCA(root->right, lca, x, y);
	
	// if `x` is found in one subtree and `y` is found in the other subtree,
	// update lca to the current node
	if (left && right) {
		lca = root;
	}
	
	// return true if `x` or `y` is found in either left or right subtree
	return left || right;
}
\end{lstlisting}
\begin{description}
	\item[] \textbf{Only focus on the current root logic}. If left anf right , then return root. otherwise just return left or right.  so simple!!
\end{description}


\item level order:
\begin{lstlisting}[frame=single, language=c++]
// Function to print spiral order traversal of a given binary tree
void spiralOrderTraversal(Node* root)
{
	if (root == nullptr) {
		return;
	}
	
	// create an empty double-ended queue and enqueue the root node
	list<Node*> deque;        // or use deque
	deque.push_front(root);
	
	// `flag` is used to differentiate between odd or even level
	bool flag = false;
	
	// loop till deque is empty
	while (!deque.empty())
	{
		// calculate the total number of nodes at the current level
		int nodeCount = deque.size();
		
		// print left to right
		if (flag)
		{
			// process each node of the current level and enqueue their
			// non-empty left and right child to deque
			while (nodeCount)
			{
				// pop from the front if `flag` is true
				Node* curr = deque.front();
				deque.pop_front();
				
				cout << curr->key << " ";
				
				// it is important to push the left child into the back,
				// followed by the right child
				
				if (curr->left != nullptr) {
					deque.push_back(curr->left);
				}
				
				if (curr->right != nullptr) {
					deque.push_back(curr->right);
				}
				
				nodeCount--;
			}
		}
		
		// print right to left
		else {
			// process each node of the current level and enqueue their
			// non-empty right and left child
			while (nodeCount)
			{
				// it is important to pop from the back
				Node* curr = deque.back();
				deque.pop_back();
				
				cout << curr->key << " ";    // print front node
				
				// it is important to push the right child at the front,
				// followed by the left child
				
				if (curr->right != nullptr) {
					deque.push_front(curr->right);
				}
				
				if (curr->left != nullptr) {
					deque.push_front(curr->left);
				}
				
				nodeCount--;
			}
		}
		
		// flip the flag for the next level
		flag = !flag;
		cout << endl;
	}
}
\end{lstlisting}
\begin{description}
	\item[] use BFS, so use queue, but we also need spiral, so have to use deque which support pop\_front and pop\_back.
	
	\item[] In order to print each level, use below source code pattern.
\begin{lstlisting}[frame=single, language=c++]
while (!deque.empty()){
	// calculate the total number of nodes at the current level
	int nodeCount = deque.size();	
	while(nodeCound){
		nodeCount--;
\end{lstlisting}	

\end{description}


\item conclusion: 
\begin{enumerate}
	\item Most of time, traversal order can be decided by the question itself very quickly.
	\item \textbf{any time when you find Maximum or ancestor, this is a strong indication which we can use postorder.}
	\item You can combined use preorder and postorder together. such as ??
\end{enumerate}

\end{enumerate}

\end{itemize}

\subsubsection{Interface}

\begin{itemize}
	\item Next questions is interface design. (all auxiliary parameter)
Find kth smallest and kth largest element in a BST:  \texttt{int *i} is shared variable among all recursive. which record how many nodes we have visited so far. return value is just your question answer. that is very easy to understand. 
	

\item \textbf{If you change inside function, sometimes, you need to change it back when you return.}
\begin{lstlisting}[frame=single, language=c++]
// Recursive function to find paths from the root node to every leaf node
void printRootToleafPaths(Node* node, vector<int> &path)
{
	// base case
	if (node == nullptr) {
		return;
	}
	
	// include the current node to the path
	path.push_back(node->data);
	
	// if a leaf node is found, print the path
	if (isLeaf(node))
	{
		for (int data: path) {
			cout << data << " ";
		}
		cout << endl;
	}
	
	// recur for the left and right subtree
	printRootToleafPaths(node->left, path);
	printRootToleafPaths(node->right, path);
	
	// backtrack: remove the current node after the left, and right subtree are done
	path.pop_back();
}	
\end{lstlisting}

\item Another simple is use local stack variable. If you don't use reference, you don't need to pop\_back.
\begin{lstlisting}[frame=single, language=c++]
// Recursive function to find paths from the root node to every leaf node
void printRootToleafPaths(Node* node, vector<int> path)
{
	// base case
	if (node == nullptr) {
		return;
	}
	
	path.push_back(node->data);
	
	// if a leaf node is found, print the path
	if (isLeaf(node))		{
		for (int data: path) {
			cout << data << " ";
		}
		cout << endl;
	}
	
	// recur for the left and right subtree
	printRootToleafPaths(node->left, path);
	printRootToleafPaths(node->right, path);
	
}		
\end{lstlisting}


\item Information flow:
\begin{enumerate}
	\item  return value from child to parent, (only return one value, so need some calculation inside from both left and right children)
	\item pass from parent to child, parameter to remember auto value(level) , 
	\item shared between children and parent. and pass a pointer parameter(max\_level) to remember static, which all recursive 
\end{enumerate}
	
\end{itemize}




\subsubsection{traps}
\begin{itemize}
	\item \textbf{Checking if one or both children are null. You SHOULD NOT do that.} When you do the recursive call and pass the root.left() or the root.right() as the parameter, the recursive function will call itself and treating the passed child as the new root. So, you don't need to explicitly check if the children are null.
	
\item The above statement should be understood correctly. If current operation 
\begin{lstlisting}[frame=single, language=c++]
int countLeaves(Node* t){
	if(t == null) 
	return 0;
	
	if(isLeaf(t))  {
		return 1;
	}
	else
		return countLeaves(t.left) +countLeaves( t.right);
}	
	
\end{lstlisting}	
	
	\item \textbf{Accessing the children values. You SHOULD NOT do that.} The same as the previous point. The child passed to the recursive call is treated as the new root. So, you don't need to explicitly access the children values. Just make sure you do that for the root.
	
	
\end{itemize}



\subsubsection{two trees}

\begin{itemize}
	\item recursive can be used to deal with two trees at the same time. 
\begin{lstlisting}[frame=single, language=c++]
	int identicalTrees(struct node* a, struct node* b){
		/*1. both empty */
		if (a==NULL && b==NULL)
		return true;
		
		/* 2. both non-empty -> compare them */
		if (a!=NULL && b!=NULL)    {
			return(
			a->data == b->data &&
			identicalTrees(a->left, b->left) &&
			identicalTrees(a->right, b->right)
			);
		} 
		
		/* 3. one empty, one not -> false */
		return false;
	} 
\end{lstlisting}	

\item some problems can be changed to two tree problems. such as if mirror. 

\begin{lstlisting}[frame=single, language=c++]
// Function to check if subtree rooted at `X` and `Y` mirror each other
bool isSymmetric(Node* X, Node* Y)
{
	// base case: if both trees are empty
	if (X == nullptr && Y == nullptr) {
		return true;
	}
	
	// return true if
	// 1. Both trees are non-empty, and
	// 2. The left subtree is the mirror of the right subtree, and
	// 3. The right subtree is the mirror of the left subtree
	return (X != nullptr && Y != nullptr) &&
	isSymmetric(X->left, Y->right) &&
	isSymmetric(X->right, Y->left);
}
\end{lstlisting}


\item Fill any nodes next pointer:
\begin{lstlisting}[frame=single, language=c++]
Node connect(Node root) {
	if (root == null) return null;
	connectTwoNode(root.left, root.right);
	return root;
}

void connectTwoNode(Node node1, Node node2) {
	if (node1 == null || node2 == null) {
		return;
	}

	node1.next = node2;
	//sibling	
	connectTwoNode(node1.left, node1.right);
	connectTwoNode(node2.left, node2.right);
	//cousin
	connectTwoNode(node1.right, node2.left);
}
\end{lstlisting}
\begin{description}
	\item[] \textbf{Any time you need to access cousin, you should use two nodes.}
	\item[] three branch recursive, That is very different with others. 
\end{description}


\end{itemize}


\subsubsection{Conclusion}
\begin{enumerate}
	\item According to question, if it will return a value, such as leaf count, height. It has to have a function return value. What value should we return? Usually, this is related to question. For example, kth element should return integer, LCA should return a pointer. At the same time, integer and pointer also can act as flag value. 

 
	\item Write base case 
\begin{lstlisting}[breaklines]
if(root == nullptr) 
       return [value] 
\end{lstlisting}

	\item \textbf{consider a node with two null children. that is the easiest tree. then finish the basic logic in side the recursive function.}
\begin{enumerate}
	\item decide pre-order, in-order, and post-order. 

	\item For some easy problems, you have finished the problems. Then for some difficult problems, you need to some logic comparison or calculation. such as Maximum path sum in a binary tree. or max height tree.
	
	\item Logic inside the function, an good example is LCA: there are four different possible. 1) The root node is x or y, 2) the x or y only in left tree, 3) the x or y only in the right tree, 4) the x and y in the two separate tree. That is all the possibles, then write all logic to deal previous 4 possibles. 
	
	\item That is ALL!, never try to recursive call in your head. 
\end{enumerate}

\end{enumerate}

\subsection{Interview questions}

\subsubsection{print part of tree}
\begin{itemize}
	\item \textbf{usually use pre-order, then use some condition to suppress cout. At the same time, also need to pass some condition as parameter,(left view, level) return some flag(path include a node)}
	
	\item print left view \textbf{When you return, the level will be local stack value, each value has stack scope.}

\begin{lstlisting}[frame=single, language=c++]
// Recursive function to print the left view of a given binary tree
void leftView(Node* root, int level, int &last_level)
{
	// base case: empty tree
	if (root == nullptr) {
		return;
	}
	
	// if the current node is the first node of the current level
	if (last_level < level)
	{
		// print the node's data
		cout << root->key << " ";
		
		// update the last level to the current level
		last_level = level;
	}
	
	// recur for the left and right subtree by increasing the level by 1
	leftView(root->left, level + 1, last_level);
	leftView(root->right, level + 1, last_level);
}	
\end{lstlisting}	

	\item print the certain level
\begin{lstlisting}[frame=single, language=c++]
// Function to print all nodes of a given level from left to right
bool printLevelLeftToRight(Node* root, int level)
{
	if (root == nullptr) {
		return false;
	}
	
	if (level == 1)
	{
		cout << root->key << " ";
		return true;  //return, don't go deeper to save time complexity.
	}
	
	// process left child before the right child
	bool left = printLevelLeftToRight(root->left, level - 1);
	bool right = printLevelLeftToRight(root->right, level - 1);
	
	return left || right;  //that is why we need to return bool. 
}

// Function to print level order traversal of a given binary tree
void levelOrderTraversal(Node* root)
{
	// start from level 1  till the height of the tree
	int level = 1;
	
	// run till printLevel() returns false
	while (printLevel(root, level)) {
		level++;
	}
}
\end{lstlisting}


	\item print path include a node. If target is present in tree, then prints all the ancestors and returns true, otherwise returns false. 
	
\begin{enumerate}
	\item The trick in this question is that it doesn't tell us the function should return bool, you should guess it out.
	
	\item preorder and postorder should be combined. when search key, use preorder, when print all ancester, use post order. 
	
	\item this combined order model also used in LCA.
\end{enumerate}
\begin{verbatim}
      1
    /   \
   2      3
  /  \
 4     5
/
7
key is 7, then your function should print 4, 2 and 1.
\end{verbatim}

\begin{lstlisting}[frame=single, language=c++]
bool printAncestors(struct node *root, int target){
	/* base cases */
	if (root == NULL)
		return false;
	if (root->data == target)
		return true;
	
	/* If target is present in either left or right subtree of this node, then print this node */
	if ( printAncestors(root->left, target) ||
	printAncestors(root->right, target) ){
		cout << root->data << " ";
		return true;
	}
	/* Else return false */
	return false;
}	
\end{lstlisting}
\begin{description}
	\item[Source cde:] \textbf{Idea: just like max height example, return bool instead value, logic || instead max. the basic idea are quite same. }
	
	\item[Source code:] use return bool value to suppress cout
	
	\item[Source code:] \textbf{focuse local root} principal also can be used here. for local root, there are only three possibles.  current == target,  target in left tree, target in right tree.    
\end{description}

\end{itemize}

\subsubsection{build tree}
\begin{itemize}
	
	\item serialize and deserialize a tree
	
\begin{lstlisting}
              11
            /   \
           /     \
          2       3
         /       / \
        /       /   \
       4       5     6
      / \
     /   \
    7     8
//11,2,4,.,.,.,3,5,7,.,.,8,.,.,6,.,.
\end{lstlisting}

\begin{lstlisting}[frame=single, language=c++]
string serialize(Node* root) {  //serialize the root
	if (root == NULL) {
		return ".";   //a '.' character represents a null node
	}
	
	string serialized = "";
	
	serialized += to_string(root->key);  
	//add the current node to the serialized string then traverser its left and right children respectively
	
	serialized += "," + serialize(root->left);     //add the seperator after each node
	serialized += "," + serialize(root->right);
	
	return serialized;
}

Node* deserializeUtil(vector<string>& serialized, int& i) {
	
	if (i == serialized.size()) {   //if the whole array is exhausted
		return NULL;
	}
	
	string val = serialized[i++];
	
	if (val == ".") {   //if we encounter the '.' character => a null pointer
		return NULL;
	}
	//build the tree using the serialized array
	Node* node = new Node{ stoi(val) };
	
	node->left = deserializeUtil(serialized, i);
	node->right = deserializeUtil(serialized, i);
	
	return node;
	
}
\end{lstlisting}
\begin{description}
\item[Source code:] with nullptr(.) in string, we can use in-order unique define a tree.
\end{description}
	
	
	\item Construct a binary tree from inorder and preorder traversal.
	
\begin{lstlisting}[frame=single, language=c++]
Node* construct(int start, int end, vector<int> const& preorder,
int& pIndex, unordered_map<int, int>& map, int level)
{
	
	// base case
	if (start > end) {
		return nullptr;
	}
	
	// The next element in `preorder[]` will be the root node of subtree
	// formed by sequence represented by `inorder[start, end]`
	Node* root = newNode(preorder[pIndex++]);
	
	// get the root node index in sequence `inorder[]` to determine the
	// left and right subtree boundary
	int index = map[root->key];
	
	// recursively construct the left subtree
	for (int i = 0; i < level; ++i)
	cout << " ";
	cout << root->key << " " << start << " " << index << " " << end << endl;
	
	root->left = construct(start, index - 1, preorder, pIndex, map, level+1);
	
	// recursively construct the right subtree
	root->right = construct(index + 1, end, preorder, pIndex, map, level+1);
	
	// return current node
	return root;
}

// Construct a binary tree from inorder and preorder traversals.
// This function assumes that the input is valid
// i.e., given inorder and preorder sequence forms a binary tree
Node* construct(vector<int> const& inorder, vector<int> const& preorder)
{
	// get the total number of nodes in the tree
	int n = inorder.size();
	
	// create a map to efficiently find the index of any element in a given inorder sequence
	unordered_map<int, int> map;
	for (int i = 0; i < n; i++) {
		map[inorder[i]] = i;
	}
	
	// `pIndex` stores the index of the next unprocessed node in preorder;
	// start with the root node (present at 0th index)
	int pIndex = 0;
	
	return construct(0, n - 1, preorder, pIndex, map, 0);
}
//output 

        1
      /   \
     /     \
    2       3
    /      / \
   /      /   \
  4       5     6
         / \
        /   \
       7     8

1 0 2 7
 2 0 1 1
  4 0 0 0
 3 3 6 7
  5 3 4 5
   7 3 3 3
   8 5 5 5
  6 7 7 7
\end{lstlisting}
\begin{description}
	\item[Source code:] iterate one time each time in pre-order
	\item[Source code:] build map to store in-order index, divide it into left tree and right tree.
	\item[Source code:] \textbf{just like quick\_sort}, pick an element from pre-order, then divide left and right according to index value in map
\end{description}

\end{itemize}

\subsubsection{Change tree}
\begin{itemize}
	\item flatten tree
\begin{enumerate}
	\item inorder and post order are both OK, but preorder is not good.
\end{enumerate}
\begin{lstlisting}[frame=single, language=c++]	
void flatten(struct Node* root)
{
	
	if (root == NULL || root->left == NULL &&
	root->right == NULL) {
		return;
	}
	
	// if root->left exists then we have
	// to make it root->right
	if (root->left != NULL) {
		
		// move left recursively
		flatten(root->left);
		
		// store the node root->right
		struct Node* tmpRight = root->right;
		root->right = root->left;
		root->left = NULL;
		
		// find the position to insert
		// the stored value  
		struct Node* t = root->right;
		while (t->right != NULL) {
			t = t->right;
		}
		
		// insert the stored value
		t->right = tmpRight;
	}
	
	// now call the same function
	// for root->right
	flatten(root->right);
}
\end{lstlisting}

\item Flatten A Binary Tree to Linked List (In-place) 
Go down through the left, when right is not null, push right to stack. \newline

\includegraphics[scale=0.39]{pics/flat.png} \newline



\item Truncate a binary tree to remove nodes that lie on a path having a sum less than k
\begin{enumerate}
	\item Only node on a path, should use postorder. 
	\item Only print(not print) or keep(delete), should return bool
	\item calculate sum, should input a parameter sum
	\item \textbf{When delete leaf, parent will become leaf, That is why we have to use postorder}
\end{enumerate}
\begin{lstlisting}
	
void trunc(Node* &curr, int k, int sum)
{
	// base case: empty tree
	if (curr == nullptr) {
		return;
	}
	
	// update sum of nodes in the path from the root node to the current node
	sum = sum + (curr->data);
	
	// Recursively truncate left and right subtrees
	trunc(curr->left, k, sum);
	trunc(curr->right, k, sum);
	
	// Since we are doing postorder traversal, the subtree rooted at the current
	// node may be already truncated, and the current node is a leaf
	
	// if the current node is a leaf node and its path from the root node has a sum
	// less than the required sum, remove it
	if (sum < k && isLeaf(curr))
	{
		// free the memory allocated to the current node
		delete(curr);
		
		// set current node to null (node is passed by reference)
		curr = nullptr;
	}
};
\end{lstlisting}

\item These two methods have common points: we both modify tree from bottom to top. When we modify current noe, we assume that all the child tree has finished. One use in-order, other use post-order. (Why? think about later.)


\end{itemize}

\subsubsection{Traversal + other data structure}
\begin{itemize}
	\item Maximum Path Sum in a Binary Tree.(Global variable)
	\begin{lstlisting}[breaklines]
		For each node there can be four ways that the max path goes through the node:
		1. Node only
		2. Max path through Left Child + Node
		3. Max path through Right Child + Node
		4. Max path through Left Child + Node + Max path through Right Child
		
		The idea is to keep trace of four paths and pick up the max one in the end. An important thing to note is, root of every subtree need to return maximum path sum such that at most one child of root is involved. This is needed for parent function call. In below code, this sum is stored in 'max_single' and returned by the recursive function.
	\end{lstlisting}
\end{itemize}

\subsubsection{Other}
\begin{itemize}
	
	
\item Given the root of a binary tree, return all root-to-leaf paths in any order. ( you need root == nullptr, also need to judge if it's leaf node). 
That is an interesting example. 

\begin{lstlisting}
void pathTree(TreeNode* root, string path, vector<string> & result){
	if(root == nullptr){
		return;
	}
	if(path ==""){
		path = to_string(root->val);
	}
	else{
		path+="->";
		path+=to_string(root->val);
	}
	if(root->left == nullptr && root->right == nullptr){
		result.push_back(path);
		return;
	}
	
	pathTree(root->left, path, result);
	pathTree(root->right, path, result);
}

vector<string> binaryTreePaths(TreeNode* root) {
	string s = "";
	vector<string> result;
	pathTree(root, s, result);
	return result;
}
\end{lstlisting}


\item \textbf{Idea: (recursive + return style)}

\item in order without recursive, 
\begin{lstlisting}[frame=single, language=c++]
// An iterative process to print preorder traversal of Binary tree
void iterativePreorder(node *root){
    // Base Case
    if (root == NULL)
       return;
 
    // Create an empty stack and push root to it
    stack<node *> nodeStack;
    nodeStack.push(root);
 
    /* Pop all items one by one. Do following for every popped item
       a) print it
       b) push its right child
       c) push its left child
    Note that right child is pushed first so that left is processed first */
    while (nodeStack.empty() == false)    {
        // Pop the top item from stack and print it
        struct node *node = nodeStack.top();
        printf ("%d ", node->data);
        nodeStack.pop();
 
        // Push right and left children of the popped node to stack
        if (node->right)
            nodeStack.push(node->right);
        if (node->left)
            nodeStack.push(node->left);
    }
}
\end{lstlisting}

\textbf{Idea: A common implementation of DFS, without check two unvisited condition. Because tree is a 1) minimally connected graph and having only one path between any two vertices. 2) no loop}

\item For search tree, look for lowest common ancestor(LCA). 
\begin{lstlisting}[frame=single, language=c++]
Node *LCA(Node *root, Node *p, Node *q) {
  if (!root || !p || !q) return NULL;
  if (max(p->data, q->data) < root->data)
    return LCA(root->left, p, q);
  else if (min(p->data, q->data) > root->data)
    return LCA(root->right, p, q);
  else
    return root;
}

\end{lstlisting}

\item Determine whether a binary tree is a subtree of another binary tree. both inorder and preorder together identify a tree quniquely.

\item \textbf{can be changed into a binary tree problem!}
\begin{enumerate}
	\item print all subsequence, select current or don't select
	\item stair case, walk one or two
	\item house robbery
	\item all possible combine in array. 
	
\begin{lstlisting}[frame=single, language=c++]	
Input:  digits[] = { 1, 2, 2, 1 }	
{1, 2, 2, 1} 
{1, 2, 21} 
{1, 22, 1} 
{12, 2, 1} 
{12, 21} 
\end{lstlisting}
\end{enumerate}

\end{itemize}

\section{Graph}
\subsection{Basic}
\begin{itemize}
\item \textbf{A Tree is just a restricted form of a Graph. They fit with in the category of Directed Acyclic Graphs (or a DAG). So Trees are DAGs with the restriction that a child can only have one parent.}

\item Graphs are generally search breath first or depth first. The same applies to Tree.

\item Basic represent way: \textbf{adjacency list} and \textbf{adjacency matrix}: \newline
\includegraphics[scale=0.6]{pics/adjacency.png} \newline

\item You want to mirror the problem using a tree-like structure:For this we have boost graph library. The BGL currently provides two graph classes and an edge list adaptor: adjacency\_list, adjacency\_matrix and edge\_list.  The adjacency\_list class is the general purpose "swiss army knife" of graph classes.
\end{itemize}

\subsection{DFS and BFS}
\subsubsection{DFS}
\begin{itemize}
\item DFS has three versions 1) recursive 2) recursive to loop version. 3) uniform version
\begin{enumerate}
\item recursive version:
\begin{lstlisting}[frame=single, language=c++]
DFS(current){
  visit current;
  for all(next to current){
     if(unvisited(next)){
          DFS(next);
      }
   }
}
\end{lstlisting} 
\item recursive to loop
\begin{lstlisting}[frame=single, language=c++]
DFS(start){
 S.push(start)  
  while(!S.empty()){
    current = top();
    visit current;
    If (current has one unvisited next){ 
         stack.push(next);
    }   
    else{
        stack.pop()
    }
}
}
\end{lstlisting} 
\item unified version:
\begin{lstlisting}[frame=single, language=c++]
DFS(start){
 S.push(start)  
  while(!S.empty()){
    current = S.pop
    if(unvisited(current){
          visit current.
          for all(next to current and unvisited)
             S.push(next);
    }
  }
 }
\end{lstlisting} 
\end{enumerate}

\item  Why we need two "unvisited" words in DFS unified version.  
\begin{enumerate}
\item When we pop node from S, then we visit it, then we add all adjacent nodes to S, In this way, When we pop 1 from S, we add 2, 3 to S. at this time, 3 is unvisited, then when we pop 2 from S, we will add 4, 3 to S. so there are two 3 in the S. 
\item Based on, we need to first unvisit to avoid visit 3 twice

\item When we reach 3; 1,2,4 have been visited, so when we want to add all 3 adjacent, we need second unvisited to avoid 1,2,4 to S.  
\end{enumerate}
\begin{verbatim}
     1
  /    \
 2----3
 \     /
    4      
\end{verbatim}

\item DFS is an algorithm to search a hierarchical structure. But, pre-order traversal seems to be something similar also. So, what is the difference between the two?? DFS says:
\begin{enumerate}
\item If element found at root, return success.
\item If root has no descendants, return failure
\item Recursive DFS on left subtree: success if element found
\item If not, Recursive DFS on right subtree: success if element found
\end{enumerate}
Pre-order Traversal says:
\begin{enumerate}
\item Visit the root
\item Recursive pre-order on left subtree
\item Recursive pre-order on right subtree
\end{enumerate}

\end{itemize}

\subsubsection{BFS}

\begin{itemize}
\item There are two version of BFS:
\begin{enumerate}
\item Form DFS unify version, We can change S(stack) to Q(queue) and get unified version. \textbf{That is why we call it unified version}
\begin{lstlisting}[frame=single, language=c++]
BFS(start){
 Q.push(start)  
  while(!Q.empty()){
    current = Q.pop
    if(unvisited(current){
          visit current.
          for all(next to current and unvisited)
             Q.push(next);
    }
  }
 }
\end{lstlisting} 

\item Common version:  Unified version will have multi-copy vertex in the queue. We can improve it as below:  1) when you add it to queue, visit it. In this way, avoid add multi-copy vertex in queue 2) Because All the vertex in queue is visited, when you pop it, you don't need to judge if it's visisted. 
\begin{lstlisting}[frame=single, language=c++]
DFS(start){
 D.push(start)  
  while(!D.empty()){
    current = D.pop  //2) no if here
    for all(next to current and unvisited){
         visit current.  //1) push and visit at the same time. 
         D.push(next);
     }
  }
 }
\end{lstlisting} 

\item conclusion:
\begin{enumerate}
\item  \textbf{Conclusion, just remember unified version. 1) pop current, push neighbor, 2) check two unvisited}
\item unified version will push two nodes into stack or queue, so for BFS, you can visit and push at the same time, in this way, you don't need to check current if it is unvisited. 

\item For DFS, you can't use this way, because you can only visit only one neighbor, or it will become BFS. so each time, you just push one node into stack. It leads to two other versions. recursive version, and loop version. 
\end{enumerate}


\end{enumerate}

\item Path is saved in the stack.  when you quit while loop. just pop up each position from stack, then you get a path. But for BFS, you need extra information to save parent information. 
\end{itemize}

\subsection{spanning tree}
\begin{itemize}
\item 	BFS and DFS will produce spanning tree. 
\item The minimum spanning tree can be obtained in polynomial time:
\begin{enumerate}
\item Kruskal's algorithm
\item Prim's algorithm
\item Sollin's algorithm
\end{enumerate}

\item Kruskal algorithm:
\begin{lstlisting}[frame=single, language=c++]
KRUSKAL(G):
 A = empty
 foreach v in G.V:
    MAKE-SET(v)
 foreach (u, v) ordered by weight(u, v), increasing:
    if FIND-SET(u) != FIND-SET(v):
       A = A  {(u, v)}
       UNION(u, v)
 return A
\end{lstlisting}
\begin{description}
	\item[Source code:] union find algorithm.
\end{description}

\end{itemize}


\subsection{Application}
\begin{itemize}
\item detect a cycle in the graph. \textbf{Undirected graph, not directed graph}.  The key point is just find visited[i], but if visited[i] is parent, then it's not a cycle. The whole logic is not complex. 
\begin{lstlisting}[frame=single, language=c++]
// A recursive function that uses visited[] and parent to detect
// cycle in subgraph reachable from vertex v.
bool Graph::isCyclicUtil(int v, bool visited[], int parent){
    // Mark the current node as visited
    visited[v] = true;
 
    // Recur for all the vertices adjacent to this vertex
    list<int>::iterator i;
    for (i = adj[v].begin(); i != adj[v].end(); ++i){
        // If an adjacent is not visited, then recur for that adjacent
        if (!visited[*i])        {
           if (isCyclicUtil(*i, visited, v))
              return true;
        }
        // If an adjacent is visited and not parent of current vertex,
        // then there is a cycle.
        else if (*i != parent)
           return true;
    }
    return false;
}
\end{lstlisting}

\begin{center}
		\includegraphics[width=0.7\linewidth]{pics/dc.png}
\end{center}

	\item Direct graph detect cycle. \textbf{need to add a onPath to detect cycle, different with undirected graph.} When we want to push node to stack, don't judge if we have visited them or not?  (undirected graph use visited[], directed graph use onPath[] )
	
\begin{lstlisting}
boolean[] onPath;
boolean[] visited;

boolean hasCycle = false;

void traverse(List<Integer>[] graph, int s) {
	if (onPath[s]) {
		// find cycle
		hasCycle = true;
	}
	if (visited[s] || hasCycle) {
		return;
	}

	visited[s] = true;

	onPath[s] = true;
	for (int t : graph[s]) {
		traverse(graph, t);
	}
	onPath[s] = false;
}
\end{lstlisting}

\end{itemize}

\section{Other customized data structure}

\subsection{union find}

\begin{itemize}
	\item it is also called as "Online Equivalence class"
	
	\item definition of Equivalence relationship
	\begin{enumerate}
		\item a ~ a. (Reflexivity)
		\item a ~ b if and only if b ~ a. (Symmetry)
		\item if a ~ b and b ~ c then a ~ c. (Transitivity)
	\end{enumerate}
	
	\item online equivalence class, also known union-find question.  
	\begin{enumerate}
		\item method 1: use array  \newline 
		\includegraphics[scale=0.55]{pics/online_1.png} 
		
		\item method 2: stimulate pointer \newline 
		\includegraphics[scale=0.55]{pics/online_2.png}  
	\end{enumerate}
	
\end{itemize}
	
\subsection{LRU and LFU}
\begin{itemize}
	\item  LRU is hash + list. (listedhashmap)
	\item  LFU is hash + heap. hashMap<key, pair{value, frequent}>. we still need key data structure to manage the frequency hashMap<frequent, hashLinkSet> freqToKeys.  freqToKeys is key to this question. 
	
	\item In LRU and LFU, The key data structure is LinkedHashMap, in LFU, it use LinkedSetMap, in fact, LinkedSetMap still use the LinkedHashMap behind the scene. 
\begin{center}
	\includegraphics[width=0.7\linewidth]{pics/LinkedHashMap}
\end{center}
	
\end{itemize}

	
\subsection{O(1) insert, delete and getRandom}
insert, delete get random O(1)  hash +vector(no need to keep vector sort). When you want to delete, swap it with the last element in the vector, then delete it. 

\textbf{Most of complex data structure need hash and list combine.}
	

\chapter{Algorithm}
\section{Math and geometry basic}
\subsection{geometry}
\begin{itemize}
\item Judge three points are in the same line?
\[
\dfrac{y_{2}-y_{1}}{x_{2}-x_{1}}  = \dfrac{y_{3}-y_{1}}{x_{3}-x_{1}}
\]

\item Get one points in the triangle. 

\[
x = \dfrac{\dfrac{x_{1}+x_{2}}{2}+x_{3}}{2}
\]

\item If two rectangles overlap?
\begin{verbatim}
l1: Top Left coordinate of first rectangle.
r1: Bottom Right coordinate of first rectangle.
l2: Top Left coordinate of second rectangle.
r2: Bottom Right coordinate of second rectangle.

1) One rectangle is above top edge of other rectangle.
2) One rectangle is on left side of left edge of other rectangle.
\end{verbatim}

\begin{lstlisting}[frame=single, language=c++]
// Returns true if two rectangles 
//(l1, r1) and (l2, r2) overlap
bool doOverlap(Point l1, Point r1, Point l2, Point r2){
    // If one rectangle is on left side of other
    if (l1.x > r2.x || l2.x > r1.x)
        return false;
    // If one rectangle is above other
    if (l1.y < r2.y || l2.y < r1.y)
        return false;
    return true;
}
\end{lstlisting}

\end{itemize}

\subsubsection{convex hull}

\begin{enumerate}
\item Find a point C that is inside the convex hull of S
( (sum of x coordinates)/ n, (sum of y coordinates)/n )
\item Sort S by polar angle and within polar angle by distance from C. Use atan2(y-Cy , x-Cx) c++ function.
\item Create a doubly linked circular list of points using above order
Let right link to the next point in the order and left link to the previous point

\includegraphics[scale=0.4]{pics/convex.png} \newline
\item Let p be the point that the smallest y-coordinate 
   (break a tie, if any, by selecting the one with largest x-coordinate)
   
\item use Law of cosines to calculate  angle formed by x, rx and rrx
\[
c^{2} = a^{2}+b^{2}-2ab\cos\lambda
\]

\begin{lstlisting}[frame=single, language=c++]
 for (x = p; rx = point to the right of x; x != rx) {
       rrx = point to the right of rx;
       if (angle formed by x, rx, and rrx is <=180 degrees) {
           delete rx from the list;
           rx = x; 
           x = point on left of rx;
       } 
       else { 
       x = rx; rx = rrx;}
   } 
\end{lstlisting}

\item For convex hull problem, you can use double link list to store all the extreme points. Because it need to use three consequence points to measure the degree to judge if it's less than 180 degrees. So double link list is the best data structure to use. 

\end{enumerate}


\subsection{Permutation and combination}
\begin{itemize}
\item repeated / unrepeated (Permutation/Combination)

\item repeated permutation: Three number, how many permutation $10^3$. Another Three position, For each position, you can select 10 options and fill it.  If three position, For each position, you can selet 2 options and fill it. You get powerset problem $2^3$ \{a,b, c\} all the subset. 

\item unrepeated permutation: $n! = factorial function$
\item unrepeated combination:  
\includegraphics[scale=0.6]{pics/UC.png} \newline
\item repeated combination: 
\includegraphics[scale=0.6]{pics/RC.png} \newline
\item detail can been seen here: https://www.mathsisfun.com/combinatorics/combinations-permutations.html

\end{itemize}

\subsection{solution space }
\begin{itemize}
	\item why this basic conception is so important, Because you can use these four to describe solution space. repeated permutation can be use in 0/1 backpack problem.  LCS problem.  

	\item nearest point pair's solution space is n*(n-1). It's $n^2$. A good hint is that it can be reduce $n*log(n)$. So We should consider D\&C (divide and conquer)

	\item 0/1 packback's solution's space is $2^n$, A good hint is that I can be reduce to $n^c$. (c is constant) by dynamic programming. 

	\item If there is not D\&C or DP, you have to use branch and bound or backtracking.  such as TSP travelling sales problem

	\item If you need optimal answer, You need to traversal the whole solution space. ( such as TSP and 0/1 backpacking). If you don't need optimal answer, you don't need to do that, In these two conditions, you all need to \textbf{backtracking.}

\item Why I can't use DP to TSP, but I can use DP to 0/1?  

\end{itemize}

\begin{itemize}

\item recursion is a mathematical induction. 
\item modeling is mapping your problem to a abstract structure.
\begin{enumerate}
\item Permutation: arrangement, tour,ordering sequence
\item subset: cluster, collection, committee, group, packaging, selection
\item tree:hieracrchy, dominance, ancestor/descendant, taxonomy
\item graphs: network, circuit, web, relationship
\item points
\item polygon
\item string 
\end{enumerate}

\end{itemize}

\subsection{bit}
\begin{itemize}
	\item Basic operations are: and, or, xor, not, right shift, left shit. 
\begin{lstlisting}[frame=single, language=c++]	
number |= 1UL << n; // set
number &= ~(1UL << n); //clear
number ^= 1UL << n;  //toggle, ^= can be used for toggle. 
\end{lstlisting}

	\item Many C compilers choose which right shift to perform depending on what type of integer is being shifted; often signed integers are shifted using the arithmetic shift, and unsigned integers are shifted using the logical shift.
	
\begin{lstlisting}[frame=single, language=c++]	
a|b|c|d //after we right shift, we change it to below
x|a|b|c
1) with a logical shift put 0 in x
2) with a arithmetic shift put a in x
\end{lstlisting}	
	
	\item XOR is exclusive or, You can think that it's subset of OR, for OR, if both bits are 1, the result is 1. but In XOR, we exclusive this possible,  You can think that it's "pure" or.  Based on previous definition. There are two characteristics:
\begin{lstlisting}
x^x = 0
x^0 = x
\end{lstlisting}
	from previous two examples, we can use it to find any number occur even number in the array. 
		
	\item change the last 1 to zeor. The basic idea is very interesting. 
\begin{lstlisting}[frame=single, language=c++]	
n&(n-1);
//110100-> 110000

//when we n-1: 110100, the right most 1 will become 0, all zeor after 
//right most 1 will become 1. 
110100
110011
*--	
\end{lstlisting}	
	
	\item Based on previous trip, we can test if a number is power of 2. There is only one 1 in the binary formation.
	\begin{lstlisting}[frame=single, language=c++]	
		bool isPowerOfTwo(int n) {
			if (n <= 0) return false;
			return (n & (n - 1)) == 0;
		}	
	\end{lstlisting}
	
	\item Hamming weight,  Hamming weight of an integer is defined as the number of set bits in its binary representation. 
\begin{lstlisting}[frame=single, language=c++]	
int hammingWeight(uint32_t n) {
	int res = 0;
	while (n != 0) {
		n = n & (n - 1); //change n, you need to assign new value back to n. 
		res++;
	}
	return res;
}	
\end{lstlisting}	

	\item As noted in this answer, n\&(n-1) unsets the last set bit.
So, if we unset the last set bit and xor it with the number; by the nature of the xor operation, the last set bit will become 1 and the rest of the bits will return 0
\begin{lstlisting}
	int set_bit = n ^ (n&(n-1));
\end{lstlisting}


\end{itemize}

\subsection{Usage of model \%}

\begin{itemize}
\item circular queue
\item hash
\item to know the last three digit. 
\end{itemize}

\section{two pointers}

\includegraphics[scale=0.6]{pics/two_pointers.png} \newline


\subsection{middle to both ends}
\begin{itemize}
	\item the longest palindrome substring
	
\begin{lstlisting}[breaklines]
string palindrome(string& s, int l, int r) {
	// check if it out boundary
	while (l >= 0 && r < s.size()
	&& s[l] == s[r]) {
		// both side move
		l--; r++;
	}
	// return result
	return s.substr(l + 1, r - l - 1);
}

string longestPalindrome(string s) {
	string res;
	for (int i = 0; i < s.size(); i++) {
		// s[i] is middle
		string s1 = palindrome(s, i, i);
		// s[i] and s[i+1] 
		string s2 = palindrome(s, i, i + 1);
		// res = longest(res, s1, s2)
		res = res.size() > s1.size() ? res : s1;
		res = res.size() > s2.size() ? res : s2;
	}
	return res;
}
\end{lstlisting}
	
	\item rain drop
	
\begin{lstlisting}[breaklines]
int trap(vector<int>& height) {
	if (height.empty()) return 0;
	int n = height.size();
	int res = 0;
	// memo
	vector<int> l_max(n), r_max(n);
	// base case
	l_max[0] = height[0];
	r_max[n - 1] = height[n - 1];
	// calculate l_max from left to right
	for (int i = 1; i < n; i++)
	l_max[i] = max(height[i], l_max[i - 1]);
	// calculate r_max from right to left
	for (int i = n - 2; i >= 0; i--) 
	r_max[i] = max(height[i], r_max[i + 1]);
	
	// calculate the last answer.
	for (int i = 1; i < n - 1; i++) 
	res += min(l_max[i], r_max[i]) - height[i];
	return res;
}
\end{lstlisting}

\end{itemize}


\subsection{slow and fast}
\begin{itemize}
	\item remove duplicate
\begin{lstlisting}[breaklines]
int removeDuplicates(int[] nums) {
	if (nums.length == 0) {
		return 0;
	}
	int slow = 0, fast = 0;
	while (fast < nums.length) {
		if (nums[fast] != nums[slow]) {
			slow++;
			// maintain nums[0..slow] without duplicate
			nums[slow] = nums[fast];
		}
		fast++;
	}
	// length should be  + 1
	return slow + 1;
}
\end{lstlisting}

	\item partition
\begin{lstlisting}[breaklines]
template<class ForwardIt, class UnaryPredicate>
ForwardIt partition(ForwardIt first, ForwardIt last, UnaryPredicate p)
{
	first = std::find_if_not(first, last, p);
	if (first == last) return first;
	
	for (ForwardIt i = std::next(first); i != last; ++i) {
		if (p(*i)) {
			std::iter_swap(i, first);
			++first;
		}
	}
	return first;
}
\end{lstlisting}

\item Note here, in removeDuplication, we ++ first, then assign, but in partition, we swap first, then ++. you need to know that slow pointer is pointing by these two methods. 

% remove and partition has the same idea, remove uses overwrite, partition uses swap, that is all. 
	
\end{itemize}
\subsection{slide windows}
\begin{itemize}
	\item Code template
\begin{lstlisting}[breaklines]
int left = 0, right = 0;

while (right < n) {`
	// increase windows
	window.add(a[right]);
	right++;
	
	//update windows
	//.......
	
	while (window needs shrink) {
		// decrease window
		window.remove(s[left]);
		left++;
		
		//update windows here.
		//......
	}
}			
\end{lstlisting}

	\item An example. minimal substring in source which includes all the letters of in target.
	s = "ADOBECODEBANC", t = "ABC, output "BANC"
	
\end{itemize}


\section{Recursive}
\subsection{Basic}
\begin{itemize}

	\item recursive is not an algorithm, it's just a method. D\&C, DP, backtrack, bound and boundary all use recursive in their implementation, but different ways. 
	
	\item First, the inline specification on a function is just a hint. The compiler can (and often does) completely ignore the presence or absence of an inline qualifier. With that said, a compiler can inline a recursive function, much as it can unroll an infinite loop. It simply has to place a limit on the level to which it will "unroll" the function.

	\item One recursive(Factorial),  Two recursive call( Hanoti) (Tree), Multi Recursive(Permutation)

	\item result is single (Factorial), Result is many steps,(Hanoti) (Maze), Result is a set( permutation). you can see that 1) any recursive function should at least one input parameter, and this parameter should to be pass sub-problem. 2) for return value, it has two different kind, if result is single value, you should return a value, such as Factorial. If result is set(permutation) or many steps(in-order traversal of treeor Hanoi tree), you can declare your function as void. 3) Some functions need input another parameter, such as level information in the tree or position information in the permutation. 4) Base case can be understood differently, most of time base case is 0 or null, but for permutation, base case is i==n.  most subproblem, i decrease, but for permutation, for each subproblem i increase. 
\begin{enumerate}
\item single result 
\begin{lstlisting}[frame=single, language=c++]
int Factorial(int n){
if (n == 1) 
     return 1;
 return n*Factorial(n-1);
}
\end{lstlisting}

	\item result is serial steps (Hanoti) DFS(Maze)
\begin{lstlisting}[frame=single, language=c++]
FUNCTION MoveTower(disk, source, dest, spare):
IF disk == 0, THEN:
    move disk from source to dest
ELSE:
    MoveTower(disk - 1, source, spare, dest)   // Step 1 above
    move disk from source to dest              // Step 2 above
    MoveTower(disk - 1, spare, dest, source)   // Step 3 above
END IF
\end{lstlisting}
Result is a set( permutation)

\end{enumerate}

	\item It includes direct recursive and indirect recursive. direct recursive is R() call R() again in it's funciton body. It has two parts: \textbf{1)base and 2) recursive component}
	
\subsection{Basic recursive pattern}
\begin{itemize}
	\item You should understand Big O here. for example 
	\begin{enumerate}
		\item O(n) is found max and min
		\item O(n*n) is sort
		\item O(n*n*n) is  solutions for a multi-variable equation. such as 3x+4y+5z = 108, then get all x, y z.
		\item O(n*logn) is quick sort. binary search. 
		\item O($2^{n}$) print all subsequences
		\item catalan number. print all parentheses.
		\item O($n!$) print all permutation.
		
	\end{enumerate}
		
	\item print all subsequences, why is power(2,n)?
	\begin{lstlisting}[frame=single, language=c++]
		void sub(string& s, int i, int j, string res) {
			
			if (i == j) {
				cout << res << endl;
				return;
			}
			//don't select current character
			sub(s, i + 1, j, res);
			
			//select current character.
			res.push_back(s[i]);
			sub(s, i + 1, j, res);
		}
	\end{lstlisting}
\item We can use another method to resolve this quesiton. That is bucket perspective, above code is ball perspective. 
\begin{lstlisting}
//get all subset
void backtrack(int[] nums, int start) {
	
	// pre-order, every node is a subset. such as, empty subset[]
	res.add(new LinkedList<>(track));
	
	
	for (int i = start; i < nums.length; i++) {
		// make a choice
		track.addLast(nums[i]);
		// Control the traversal of branches using the start parameter to avoid generating duplicate subsets.
		backtrack(nums, i + 1);
		// revoke a choice
		track.removeLast();
	}
}
\end{lstlisting}
	
	in this tree, each edge is choice, each node is an answer, for n = 4, there is 16 node below graph. we call it back track tree. 
	\begin{center}
		\includegraphics[width=0.7\linewidth]{pics/path1.png}
	\end{center}	
	
	\begin{center}
	\includegraphics[width=0.7\linewidth]{pics/path.png}
\end{center}	
	
	
	\item A similar idea is to LIS problem. it's also power(2,n)
	you can think in this way, previous one is 2*f(n-1), below is f(n-1) f(n-2)...f(1)
	but f(n-2)...f(1) is just another f(n-1), so equal 2*f(n-1). Detail is we have a lot of overlap problem.
	Time complexity is power(2,n) The time complexity of this recursive approach is exponential as there is a case of overlapping subproblems as explained in the recursive tree diagram above.
	\begin{center}
		\includegraphics[width=0.7\linewidth]{pics/lis}
	\end{center}
	
	\begin{lstlisting}[frame=single, language=c++]
		int _lis( int arr[], int n, int *max_ref)
		{
			/* Base case */
			if (n == 1)
			return 1;
			
			// 'max_ending_here' is length of LIS
			// ending with arr[n-1]
			int res, max_ending_here = 1;
			
			/* Recursively get all LIS ending with arr[0],
			arr[1] ... arr[n-2]. If arr[i-1] is smaller
			than arr[n-1], and max ending with arr[n-1]
			needs to be updated, then update it */
			for (int i = 1; i < n; i++)
			{
				res = _lis(arr, i, max_ref);
				if (arr[i-1] < arr[n-1] && res + 1 > max_ending_here)
				max_ending_here = res + 1;
			}
			
			// Compare max_ending_here with the overall
			// max. And update the overall max if needed
			if (*max_ref < max_ending_here)
			*max_ref = max_ending_here;
			
			// Return length of LIS ending with arr[n-1]
			return max_ending_here;
		}
	\end{lstlisting}
	
	
	\item If the answer is one, such as LIS, the result should be in the root node, we should use post order, If the answer are a lot , the result shoudl be in leaf node, we should use base case. such as all possible subsequence. 
	
	\item catalan number, all possible parentheses combination. (It's not good implementation, some child problems have been calcualted many time.  You should use dynamic programming to remember the child problems result. but child program result is very big.  It's a question for ALL , not for ONE result. So backtrace algorithm is more good for this questions. 
	
	\item Re-interpreting the symbol X as an open parenthesis and Y as a close parenthesis, Cn counts the number of expressions containing n pairs of parentheses which are correctly matched:
	\begin{lstlisting}
		((()))     (()())     (())()     ()(())     ()()()
	\end{lstlisting}
	
	Cn is the number of different ways n + 1 factors can be completely parenthesized (or the number of ways of associating n applications of a binary operator, as in the matrix chain multiplication problem). For n = 3, for example, we have the following five different parenthesizations of four factors:
	
	\begin{lstlisting}	
		((ab)c)d     (a(bc))d     (ab)(cd)     a((bc)d)     a(b(cd))
	\end{lstlisting}
	
	\begin{lstlisting}[frame=single, language=c++]
		vector<string> ap(string& s, int i, int j) {
			vector<string> result;
			if (i == j-1 && i<s.size()) {
				result.push_back("("+s.substr(i,1)+")");
				return result;
			}
			if (i == j - 2 && i<s.size()-1) {
				result.push_back("(" + s.substr(i, 2) + ")");
				return result;
			}	
			for (int k = i; k < j-1; ++k) {
				vector<string> v1 = ap(s, i, k+1);
				vector<string> v2 = ap(s, k+1 , j);
				
				string rs;
				for (auto e : v1) {
					for (auto e1 : v2) {
						rs =  e;
						rs += e1;
						result.push_back(rs);
					}
				}
			}
			return result;
		}
		
		string s = "abcd";
		auto com = ap(s, 0, 4);
		
		for (auto e : com) {
			cout << e << endl;
		}
		
		(a)(b)(cd)
		(a)(bc)(d)
		(ab)(cd)
		(a)(bc)(d)
		(ab)(c)(d)
	\end{lstlisting}
	
	\item The same idea is to build binary search tree
	\begin{lstlisting}[frame=single, language=c++]
		// Recursive function to return a list of tree pointers of all possible
		// binary trees having the same inorder sequence as `in[start, end]`
		vector<Node*> generateBinaryTrees(vector<int> &in, int start, int end)
		{
			// create an empty list to store the root of the constructed binary trees
			vector<Node*> trees;
			
			// base case
			if (start > end)
			{
				trees.push_back(nullptr);
				return trees;
			}
			
			// consider each element in the inorder sequence as the root
			for (int i = start; i <= end; i++)
			{
				// recursively find all possible left subtrees for root `i`
				vector<Node*> left_subtrees = generateBinaryTrees(in, start, i - 1);
				
				// recursively find all possible right subtrees for root `i`
				vector<Node*> right_subtrees = generateBinaryTrees(in, i + 1, end);
				
				// do for each combination of left and right subtrees
				for (Node* l: left_subtrees)
				{
					for (Node* r: right_subtrees)
					{
						// construct a binary tree with i'th element as the root and whose
						// left and right children point to `l` and `r`, respectively
						Node* tree = new Node(in[i], l, r);
						
						// add this tree to the output list
						trees.push_back(tree);
					}
				}
			}
			
			return trees;
		}
	\end{lstlisting}
	
	
	
	
\end{itemize}


\begin{lstlisting}
	void subset(int arr[], vector<int>& result, int k) {
		if (k == 6) {
			cout << "one answer is ( ";
			for (int i = 0; i < result.size(); i++) {
				cout << result[i] << " ";
			}
			cout << ")" << endl;
			return;
		}
		result.push_back(arr[k]);
		subset_bucket(arr, result, k + 1);
		result.pop_back();
		subset_bucket(arr, result, k + 1);
		return;
	}
\end{lstlisting}

	\item permutation, It is also worth noting that when you make a recursive call, you advance down an individual branch of the tree, and an additional branch is added with every iteration of a 'for' or 'while' loop. One confusing thing about this problem is the second swap after the recursive call to permute. This can be interpreted as 'unswap,' and is required because the char array is passed by reference, not by value, and every time you swap elements in the array the change is visible down stream.


\includegraphics[scale=0.25]{pics/permutation.png}


\begin{lstlisting}[frame=single, language=c++]
	void permute(char a[], int i, int n){
		int j;
		if (i == n)
		cout << a << endl;
		else   {
			for (j = i; j <= n; j++)       {
				swap(a[i], a[j]);          
				permute(a, i+1, n);
				swap(a[i], a[j]);
			}
		}
	} 	
\end{lstlisting}

compared with subset code, You will find that they are all recursive. permutation is n!
\begin{lstlisting}
	permute(i)
	for(j...)  //calculate j times same size(i+1) sub problem.
	permute(i+1)  //similar with n*f(n-1)
	
\end{lstlisting}


\end{itemize}

\section{Sort}
\subsection{Kth element}
\begin{itemize}
	\item There is a few options:
	\begin{enumerate}
		\item n*log(n) sort
		\item n*k partial insert 
		\item n*log(k) heap 
		\item O(n) median of medians 
	\end{enumerate}

	\item \textbf{basic idea is quick select, but we use median of median method to get good pivot, to make at the worst 30-70 partition.}
	
\begin{lstlisting}
int partition(vector<int>& arr, int l, int r) {
	int x = arr[r], i = l;
	for (int j = l; j <= r - 1; j++) {
		if (arr[j] <= x) {
			swap(arr[i], arr[j]);
			i++;
		}
	}
	swap(arr[i], arr[r]);
	return i;
}

// This function returns the k-th smallest 
// element in arr[l..r] using QuickSort-based method.
// ASSUMPTION: ALL ELEMENTS IN ARR[] ARE DISTINCT.
int kthSmallest(vector<int>& arr, int l, int r, int k) {
	
	// If k is smaller than the number of elements
	// in the array.
	if (k > 0 && k <= r - l + 1) {
		
		// Partition the array around the last 
		// element and get the position of the pivot 
		// element in the sorted array.
		int index = partition(arr, l, r);
		
		// If position is the same as k.
		if (index - l == k - 1) //index-L, not index -1 , note here. 
		return arr[index];
		
		// If position is more, recur for the left subarray.
		if (index - l > k - 1) 
		return kthSmallest(arr, l, index - 1, k);
		
		// Else recur for the right subarray.
		return kthSmallest(arr, index + 1, r, 
		k - index + l - 1);
	}
	
	// If k is more than the number of elements in the array.
	return INT_MAX;
}
\end{lstlisting}
	
	\item stable\_partition.
\begin{lstlisting}
#include <algorithm>

template <typename Iterator, typename Predicate>
Iterator my_stable_partition(Iterator first, Iterator last,
Predicate predicate) {
	auto n = std::distance(first, last);
	if (n <= 1) {
		if (n == 1 && predicate(*first))
		++first;
		return first;
	}
	auto middle = first;
	std::advance(middle, n / 2);
	auto a = my_stable_partition(first, middle, predicate);
	auto b = my_stable_partition(middle, last, predicate);
	return std::rotate(a, middle, b);
}	
\end{lstlisting}
	
	\item median of medians
\begin{lstlisting}[frame=single, language=c++, basicstyle=\scriptsize]
int array[] = { 1,12,3,4,1,      5,2,7,8,88,      5,2,32,1,35,   -1,7,5,38,-11 };

int insertSort(int left, int right) {
	for (int i = left + 1; i <= right; i++) {
		int temp = array[i], j;
		for (j = i; j > left && array[j - 1] > temp; j--) array[j] = array[j - 1];
		array[j] = temp;
	}
	return (left + right) >> 1;
}

int BFPRT(int, int, int);

int getPivotIndex(int left, int right) {
	if (right - left < 5) return insertSort(left, right);
	int back = left - 1;
	for (int i = left; i + 4 < right; i += 5) {
		std::cout << "i" << i <<" "<< right<<std::endl;
		int index = insertSort(i, i + 4);
		std::swap(array[++back], array[index]);
	}
	return BFPRT(left, back, ((left + back) >> 1) + 1);
}


int partition(int left, int right, int pivotIndex) {
	std::swap(array[right], array[pivotIndex]);
	int mid = left;
	for (int i = left; i < right; i++) {
		if (array[i] < array[right])
		std::swap(array[i], array[mid++]);
	}
	std::swap(array[right], array[mid]);
	return mid;
}

int BFPRT(int left, int right, int k) {
	int pivotIndex = getPivotIndex(left, right);
	int mid = partition(left, right, pivotIndex);
	int count = mid - left + 1;
	if (count == k) {
		return mid;
	}
	else if (count > k) {
		return BFPRT(left, mid - 1, k);
	}
	else {
		return BFPRT(mid + 1, right, k - count);
	}
}

int main() {
	int k = 5;
	int length = sizeof(array) / sizeof(array[0]);
	for (int i = 0; i < length; i++) {
		std::cout << array[i] << "  ";
	}
	std::cout << std::endl << " " << k << " ";
	std::cout << array[BFPRT(0, length - 1, k)] << std::endl;
	return 0;
}
	
\end{lstlisting}

\end{itemize}

\subsection{Simple sort}
\begin{itemize}
	\item Write Max and Insert functions to help to organize your algorithm
	\item All sort algorithm don't compare equal relationship. So some algorithm is Stable, and other is not stable
	\item Bubble is simple source code stable sorting. 
	\item All the sorting is from minimum to maximum.
\end{itemize}
 
\begin{enumerate}
	\item for all sort comparsion, there is good ref website: https://www.toptal.com/developers/sorting-algorithms/selection-sort

	\item Selection sort is an in-place comparison sort. O(n2). The algorithm finds the minimum value, swaps it with the value in the first position.  And repeat From the comparisons presented here, one might conclude that selection sort should never be used. It does not adapt to the data in any way (notice that the four animations above run in lock step), so its runtime is always quadratic. However, selection sort has the property of minimizing the number of swaps. In applications where the cost of swapping items is high, selection sort very well may be the algorithm of choice. Selection sort only need O(n) write, so if write is expensive operation, you need to use it. 
\begin{lstlisting}[frame=single, language=c++]
For(int size=n ;size>1;size--){
Int j = Max(a,size);
Swap(a[j],a[size-1]);
}
\end{lstlisting}

	\item Insertion sort is suitable for small list and mostly sorted list. Although it is one of the elementary sorting algorithms with O(n2) worst-case time, insertion sort is the algorithm of choice either when the data is nearly sorted (because it is adaptive) or when the problem size is small (because it has low overhead). For these reasons, and because it is also stable, insertion sort is often used as the recursive base case (when the problem size is small) for higher overhead divide-and-conquer sorting algorithms, such as merge sort or quick sort. Insertion sort is also stable sort. 

\begin{lstlisting}[frame=single, language=c++]
For(int I = 0;i<n;i++){
Int iv = a[i];
Insert(a,I, iv);
}
Insert(a[],int n,int lv){
For(int I = n-1;i>=0&&lv<a[i];i--)
    A[i+1]=a[i]  //move each element from tail to head one by one
A[i]  = lv;  //insert here. 
}
\end{lstlisting}

	\item Bubble sort is stable.
\begin{lstlisting}[frame=single, language=c++]
For (int I = n;i>0;i--){
	For(int j= 0;j<I;j++)
		If(a[j]<a[j+1]) swap(a[j],a[j+1]);
}
\end{lstlisting}

	\item Bubble sort can stops after reaching a sorted array. In the best case (already sorted), every insert requires constant time. So Bubble and insert can reach O(n) time in Best context. Bubble sort has many of the same properties as insertion sort, but has slightly higher overhead. In the case of nearly sorted data, bubble sort takes O(n) time, but requires at least 2 passes through the data (whereas insertion sort requires something more like 1 pass).


	\item In insertion sort elements are bubbled into the sorted section, while in bubble sort the maximums are bubbled out of the unsorted section.

\begin{lstlisting}
	//insert sort
	sorted  | unsorted
	1 3 5 8 | 4 6 7 9 2
	1 3 4 5 8 | 6 7 9 2
	
	bubble sort
	unsorted  | biggest
	3 1 5 4 2 | 6 7 8 9
	1 3 4 2 | 5 6 7 8 9
\end{lstlisting}

\end{enumerate}  


\subsection{quick  sort}
\begin{itemize}
\item Three quick heapSort, MergeSort, quickSort. (Olog(n))
\item MergeSort need O(N) extra space. When you merge two lists, this shortcoming can be avoid

\item partition 
\begin{lstlisting}[frame=single, language=c++]
/* This function takes last element as pivot, places
   the pivot element at its correct position in sorted
    array, and places all smaller (smaller than pivot)
   to left of pivot and all greater elements to right
   of pivot */
   
partition (arr[], low, high){
    // pivot (Element to be placed at right position)
    pivot = arr[high];   
    i = (low - 1)  // Index of smaller element
    for (j = low; j <= high- 1; j++)    {
        // If current element is smaller than or
        // equal to pivot
        if (arr[j] <= pivot)        {
            i++;    // increment index of smaller element
            swap arr[i] and arr[j]
        }
    }
    swap arr[i + 1] and arr[high])
    return (i + 1)
}
\end{lstlisting}

\includegraphics[scale=0.45]{pics/qsort1.png} \newline
\includegraphics[scale=0.45]{pics/qsort2.png} \newline
\item Quick sort need random access ability.  

\includegraphics[scale=0.45]{pics/quick_sort.png} \newline


\includegraphics[scale=0.45]{pics/merge_sort.png} \newline



\end{itemize}

\subsection{introsort}
\begin{itemize}
	\item This is the method used in STL.
	
\begin{lstlisting}[frame=single, language=c++]
// A Utility function to perform intro sort
void IntrosortUtil(int arr[], int * begin,
int * end, int depthLimit)
{
	// Count the number of elements
	int size = end - begin;
	
	// If partition size is low then do insertion sort
	if (size < 16)
	{
		InsertionSort(arr, begin, end);
		return;
	}
	
	// If the depth is zero use heapsort
	if (depthLimit == 0)
	{
		make_heap(begin, end+1);
		sort_heap(begin, end+1);
		return;
	}
	
	// Else use a median-of-three concept to
	// find a good pivot
	int * pivot = MedianOfThree(begin, begin+size/2, end);
	
	// Swap the values pointed by the two pointers
	swapValue(pivot, end);
	
	// Perform Quick Sort
	int * partitionPoint = Partition(arr, begin-arr, end-arr);
	IntrosortUtil(arr, begin, partitionPoint-1, depthLimit - 1);
	IntrosortUtil(arr, partitionPoint + 1, end, depthLimit - 1);
	
	return;
}	
\end{lstlisting}

\end{itemize}

\subsection{merge sort}

\begin{itemize}
	

	\item Merge sort is often preferred for sorting a linked list. The slow random-access performance of a linked list makes some other algorithms (such as quicksort) perform poorly, and others (such as heapsort) completely impossible. MergeSort(headRef)
\begin{verbatim}
	1) If head is NULL or there is only one element in the Linked List 
	then return.
	2) Else divide the linked list into two halves.  
	FrontBackSplit(head, &a, &b); /* a and b are two halves */
	3) Sort the two halves a and b.
	MergeSort(a);
	MergeSort(b);
	4) Merge the sorted a and b (using SortedMerge() discussed here) 
	and update the head pointer using headRef.
	*headRef = SortedMerge(a, b);
\end{verbatim}
\textbf{Idea: 1) No random access 2) recursive}

\begin{lstlisting}[frame=single, language=c++] 
/* sorts the linked list by changing next pointers (not data) */
void MergeSort(struct node** headRef)
{
	struct node* head = *headRef;
	struct node* a, b;
	
	/* Base case -- length 0 or 1 */
	if ((head == NULL) || (head->next == NULL)){
		return;
	}
	
	/* Split head into 'a' and 'b' sublists */
	FrontBackSplit(head, &a, &b); 
	
	/* Recursively sort the sublists */
	MergeSort(&a);
	MergeSort(&b);
	
	/* answer = merge the two sorted lists together */
	*headRef = SortedMerge(a, b);
}		
\end{lstlisting}

\begin{lstlisting}[frame=single, language=c++] 
/* See http://geeksforgeeks.org/?p=3622 for details of this function */
struct node* SortedMerge(struct node* a, struct node* b){
	struct node* result = NULL;	
	/* Base cases */
	if (a == NULL)
	return(b);
	else if (b==NULL)
	return(a);
	
	/* Pick either a or b, and recur */
	if (a->data <= b->data){
		result = a;
		result->next = SortedMerge(a->next, b);
	}
	else{
		result = b;
		result->next = SortedMerge(a, b->next);
	}
	return(result);
}	
\end{lstlisting}
\begin{description}
	\item[Source code:] \textbf{Idea: recursive}
\end{description}

\item inplace merge
\begin{lstlisting}
void swapNums(vector<int>&ivNums, int lo, int hi)
{
	--hi;
	while (lo<hi)
	{
		swap(ivNums[lo++], ivNums[hi--]);
	}
}

void MergeInPlace(vector<int>&ivNums, int lo, int mid, int hi)
{
	int i = lo, j = mid;
	while (j<hi)//stop when the latter half is empty
	{
		while (i < j&&ivNums[i] <= ivNums[j])
		{
			++i;
		}
		while (j<hi&&ivNums[i] > ivNums[j])
		{
			++j;
		}
		//just std::rotate
		swapNums(ivNums, i, j);
		swapNums(ivNums, i, i + j - mid);
		swapNums(ivNums, i + j - mid, j);
		
		//reset the boundary and continue.
		i = i + j - mid;
		mid = j;
	}
}
\end{lstlisting}

\begin{center}
	\includegraphics[scale=0.45]{pics/inplace}
\end{center}

\end{itemize}

\subsection{Bucket and radix sort}
\begin{itemize}


\item Bucket sort is not comparison algorithm.  
\item we must know the maximum value in the unsorted array
\item How many objects in the unsorted array
\item If maximum value is not big, and objects is a lot. such as all student score (<100) in a school(1000). At this time, we can use Bucket sort. 
	
\item Firstly, we must know how to handle duplicates. Secondly,  Thirdly, we must have enough memory. If you sort telephone which will not allow duplicated value, you can build an bit array. And set bit 1 if there are number exist. It will save a lot of memories.   For duplicate, you can store a link in each bucket. (array item)

\item Radix sort is cousin of Bucksort BucketSort is more efficient for 'Dense' arrays, while RadixSort can handle sparse (well, not exactly sparse, but spaced-out) arrays well. Use \% operator to get radix each digit. 

\item $ 1\sim n^c-1$. $ 1\sim10^3-1 $  You can use 10 as radix, and sort it 3 times. 

\end{itemize}


\section{Greedy}
\begin{itemize} 

\item idea of Greedy
\begin{enumerate}
\item Solve a problem by making a sequence of decisions.

\item Decisions are made one by one in some order.

\item Each decision is made using a greedy criterion. At each stage we make a decision that appears to be the best at the time.

\item A decision, once made, is (usually) not changed later. 
\end{enumerate}


\item	You need a \textbf{greedy criterion} to make a local decision.
\item 	Examples: makin change, 0/1 knappack,  activity selection (largest subset) sorted according to their finishing time, topological orders.  Dijkstra, Kruskal, prim and sollin

\item Applications: Container Loading, 0/1 knapsack problem, Topological sorting, Bipartite cover, Single-source shortest paths, Minimum-cost spanning trees. 

\end{itemize}

\subsubsection{intervals questions}
\begin{itemize}
	\item \textbf{two basic tricks, sort, then do something when it overlap}.
	
	\item Meeting room question. 
	\begin{enumerate}
		\item minimum empty time. That is 0/1 knapback problem.
		\item two group collision intervals.
	\end{enumerate}
	

	\item overlap. (three questions)
\begin{enumerate}
	\item Non-overlap number. one meeting room, maximum meeting number. sort by end time, delete(ignore) if overlap. 
\begin{lstlisting}
	public int intervalSchedule(int[][] intvs) {
		if (intvs.length == 0) return 0;
		// sort
		Arrays.sort(intvs, new Comparator<int[]>() {
			public int compare(int[] a, int[] b) {
				return a[1] - b[1];
			}
		});
		
		int count = 1;
		int x_end = intvs[0][1];
		for (int[] interval : intvs) {
			int start = interval[0];
			if (start >= x_end) {
				// find next non-overlap interval, 
				//update x_end. 
				count++;
				x_end = interval[1];
			}
		}
		return count;
	}
\end{lstlisting}
	
	\item maximum overlap number. minimum meeting room numbers. sort by start time. you can use scan line. 
	
	\item merge overlap. sort by left. if overlap, then update right point; if non-overlap, find a new current intervals. 
\iffalse
\begin{lstlisting}

def merge(intervals):
if not intervals: return []
# Sort in ascending order by the start of the interval.
	intervals.sort(key=lambda intv: intv[0])
	res = []
	res.append(intervals[0])

	for i in range(1, len(intervals)):
		curr = intervals[i]
		# res A reference to the last element.
		last = res[-1]
		if curr[0] <= last[1]:
			# find the maximum end
			last[1] = max(last[1], curr[1])
		else:
			# Process the next interval to be merged.
			res.append(curr)
	return res
\end{lstlisting}
\fi
\end{enumerate}
	
	\item interval cover. (two questions)
\begin{enumerate}
		
	\item minimum cover

\begin{lstlisting}
int videoStitching(int[][] clips, int T) {
	if (T == 0) return 0;
	// Sort in ascending order by the start point, and in descending order if the start points are the same.
	Arrays.sort(clips, (a, b) -> {
		if (a[0] == b[0]) {
			return b[1] - a[1];
		}
		return a[0] - b[0];
	});
	// Keep track of the number of selected short videos
	int res = 0;
	
	int curEnd = 0, nextEnd = 0;
	int i = 0, n = clips.length;
	while (i < n && clips[i][0] <= curEnd) {
		// Greedily select the next video within the interval of the res-th video.
		while (i < n && clips[i][0] <= curEnd) {
			nextEnd = Math.max(nextEnd, clips[i][1]);
			i++;
		}
		// Find the next video and update curEnd.
		res++;
		curEnd = nextEnd;
		if (curEnd >= T) {
			// The interval [0, T] can already be assembled.
			return res;
		}
	}
	// Unable to continuously assemble the interval [0, T].
	return -1;
}	
\end{lstlisting}

	\item erase cover. Once find overlap, update right,  find non-overlap, update left and right. 

	\begin{lstlisting}
		int removeCoveredIntervals(int[][] intvs) {
			// Sort in ascending order by the start point, and in descending order if the start points are the same.
			Arrays.sort(intvs, (a, b) -> {
				if (a[0] == b[0]) {
					return b[1] - a[1];
				}
				return a[0] - b[0]; 
			});
			
			// Record the start and end points of the merged intervals.
			int left = intvs[0][0];
			int right = intvs[0][1];
			
			int res = 0;
			for (int i = 1; i < intvs.length; i++) {
				int[] intv = intvs[i];
				// Case 1: Find the covering intervals.
				if (left <= intv[0] && right >= intv[1]) {
					res++;
				}
				// Case 2: Find the overlapping intervals and merge them.
				if (right >= intv[0] && right <= intv[1]) {
					right = intv[1];
				}
				// Case 3: Completely non-overlapping, update the start and end points.
				if (right < intv[0]) {
					left = intv[0];
					right = intv[1];
				}
			}
			
			return intvs.length - res;
		}
	\end{lstlisting} 

\end{enumerate}	
	
\end{itemize}

\subsection{application}
\begin{itemize}
\item  Machine Scheduling, \textbf{sort all task according to start time, and minheap of machine end time. }

\item Container Loading and 0/1 knapsack problem are different. For 0/1 knapsack problem, we consider the value and weight together,  For greed algorithm, it change time complexity from $2^{n}$to $n.log(n)$, but 583/600 is withing 10\%, so it's very practical algorithm.  Don't underestimate it. 

\item Topological sorting: 
\begin{verbatim}
1) Select any one among vertices having no incoming edge
2) Put the node into the solution &  Remove the node and its outgoing edges from the graph
4) Repeat the above steps until no nodes remain

You need to InDegree[n] array to save and update all the vetex InDegree, and stack to store all the vetex which indegree is 0.  
\end{verbatim}


\item Bipartite-cover problems are NP-hard
\begin{verbatim}
A greedy method to develop a fast heuristic
Construct the cover A in stages
Select a vertex of A  using the greedy criterion:
Select a vertex of A that covers the largest # of uncovered vertices of B
\end{verbatim}

\item Dijkstra algorithm.  \newline
\includegraphics[scale=0.45]{pics/Dijkstra.png} \newline
\begin{enumerate}
\item The greedy idea lies in line 8
\item In line 8, it must shortest path to this vetex,  Because if it's not, There is shorter path, then, according to we select min in line 8, shorter one will be selected first, and this value HAS BEEN updated before. 
\item $O(n^{2})$
\item the shortest value is saved, it's also idea of dynamic programming.
\item Just like vertabi, you can think that they are the same. 
\end{enumerate}

\end{itemize}

\section{Divide Conquer}
\subsection{Binary search}
\begin{itemize}
	
\item	A binary search (or divide-and-conquer) idea can be applied to the problem of finding the closest pair of points on a plane. By utilizing a subproblem, you can prune some candidate points. Another application is using merge sort to count the number of smaller elements to the right of each element, which is introduced by labuladong. The fundamental idea is still binary search, but the specifics come from the fact that merge sort maintains order, and this characteristic can be used to count the number of smaller elements on the right. This is a rather unique application.
	
\item	The key idea here is leveraging the sorting order inherent in merge sort to solve a problem related to counting elements, and it also shows the pruning advantage in divide-and-conquer algorithms.
	
	\item look for a certain number. 

\begin{lstlisting}[frame=single, language=c++]
int binarySearch(int arr[],int target, int i, int j) {
	int left = i;
	int right = j;
	while ( left<= right) {
		int mid = (left+right)/2;
		if (arr[mid] > target)
			right = mid - 1;
		else if (arr[mid] < target)
			left = mid + 1;
		else if (arr[mid] == target)
			return mid;
	}
	return -1;
} 
\end{lstlisting}

\begin{lstlisting}[frame=single, language=c++]
int left_bound(int arr[],int target, int i, int j) {
	int left = i;
	int right = j;
	while ( left<= right) {
		int mid = (left+right)/2;
		if (arr[mid] > target)
			right = mid - 1;
		else if (arr[mid] < target)
			left = mid + 1;
		else if (arr[mid] == target)
			right = mid-1;  //1) reduce to right in order to find left bound
	}
	
	if (left > j || arr[left] != target)
		return -1;  //3) in order to return left, left will go to the right boundary, 
	return left; //2) return left.   
}
\end{lstlisting}	


\begin{lstlisting}[frame=single, language=c++]
int right_bound(int arr[],int target, int i, int j) {
	int left = i;
	int right = j;
	while ( left<= right) {
		int mid = (left+right)/2;
		if (arr[mid] > target)
			right = mid - 1;
		else if (arr[mid] < target)
			left = mid + 1;
		else if (arr[mid] == target)
			left = mid+1;  //1) step left to find right bound
	}
	
	if (right < 0 || arr[right] != target)
		return -1;  //3) in order to return right, right will be too small
	return right; //2) return right.   
}	
\end{lstlisting}
	
\item Three methods summary are below:
\begin{enumerate}
	\item close left and right
	\item left bound reduce right, right bount add left;
	\item left bound return left, right bound return right.
	\item left may be too big, right maybe too small. 
	\item if no found, 
\begin{lstlisting}[frame=single, language=c++]
//if we want to find 4, then right point to 3, left point to 5
//when we quit while loop. 
//so left_bount return the 5 (smallest bigger than target),  
//right bount return 3( biggest smaller than target.)
right left
  3    5
\end{lstlisting}	


\begin{center}
		\includegraphics[width=0.7\linewidth]{pics/binary_search.drawio.png}
\end{center}

\end{enumerate}

\end{itemize}

\subsection{other }
\begin{itemize}
\item binary search:
\begin{enumerate}
\item only compare once, just  
\item avoid s+e overflow.
\item s will catch up e in the end, then break while loop 
\item check a[m] == k outside of while
\end{enumerate}

\begin{lstlisting}[frame=single, language=c++]
while(s<e) {
    //m=(s+e)/2;
    m = s/2+e/2 + s&e&1;
    if(a[m]<k)
        s = m+1;
    else 
       e = m;
}
if(a[m] == k) 
       return ture; 
\end{lstlisting}


\item An element in a sorted array can be found in O(log n) time via binary search. But suppose we rotate an ascending order sorted array at some pivot unknown to you beforehand. So for instance, 1 2 3 4 5 might become 3 4 5 1 2. Devise a way to find an element in the rotated array in O(log n) time.

The basic idea is DC(divided conquer.) 
\begin{enumerate}
	\item Use DC, The first part is end condition. For this question, the end atomic condition is e-b == 1(only two elements in it)
	\item If use array, better use index directly.
	\item When you have last atomic condition, you need to decide boundary  b, (e-b)/2, e. \textbf{When you decide boundary , you have to make half part of contents still includes answer. That is very useful hint for you to decide boundary value}
\end{enumerate}

\begin{lstlisting}[breaklines]
size_t find_rot(const vector<int> &vi, int b, int e){
	if (e-b ==1){
		return b;		
	}
	int pivot = b + (e-b)/2;
	cout<<"pivot"<<pivot<<endl;
	if (vi[b]<vi[pivot]){ 
		return find_rot(vi, pivot, e);
	}
	else{
		return find_rot(vi, b, pivot);
	}
}	
\end{lstlisting}
\begin{description}
	\item[label] \textbf{If you can divide it according certain condition, then you can use DC}
\end{description}

\end{itemize} 

\section{backtracking}
\subsection{Basic}

	Backtracking is particularly useful for solving problems where you need to explore all possible solutions, but you can prune certain paths that are unlikely to lead to a valid solution (i.e., "backtrack" when a partial solution cannot be completed). Problems suitable for backtracking typically involve making a sequence of decisions and can be described as "constraint satisfaction" problems.

Here are common types of questions suitable for backtracking:

1. Combinatorial Problems
Permutations and Combinations: Finding all permutations or combinations of a set of numbers or characters.
Example: Generate all permutations of a given array of numbers.
Subsets: Generating all subsets of a set.
Example: Finding all subsets of a given set of numbers (power set).
2. Constraint Satisfaction Problems (CSPs)
Sudoku Solver: Filling in numbers on a Sudoku board while satisfying the row, column, and grid constraints.
N-Queens Problem: Placing N queens on an NN chessboard so that no two queens attack each other.
Crossword Puzzle Filler: Filling a crossword grid while ensuring valid word placements.
3. Graph and Tree Search Problems
Maze Solver: Finding a path from start to finish in a maze.
Hamiltonian Path/Cycle: Finding a path or cycle in a graph that visits every vertex exactly once.
Word Search: Searching for words in a grid of characters by moving horizontally, vertically, or diagonally.
4. Partitioning Problems
Partition to K Equal Sum Subsets: Partitioning an array into K subsets such that the sum of elements in each subset is equal.
Palindrome Partitioning: Partitioning a string into substrings, where each substring is a palindrome.
5. Combinatorial Optimization Problems
Knapsack Problem: Finding combinations of items that maximize value without exceeding the capacity of a knapsack (although dynamic programming is often more efficient for this problem).
Job Scheduling: Scheduling jobs on a limited number of resources (machines) without conflicts.
6. String Matching
Regular Expression Matching: Checking if a string matches a given pattern with wildcard characters.
7. Puzzle Solving
Crossword or Word Puzzle: Solving word puzzles by filling blanks with valid words from a dictionary.
Solving Puzzles like the 8-Puzzle: Rearranging pieces on a grid to reach a specific target configuration.
In all these cases, backtracking explores the possible decisions recursively but abandons a path (backtracks) if it becomes clear that it cannot yield a valid solution, thus reducing unnecessary computation.


\begin{itemize}
	
	
	
	\item The basic backtracking code
\begin{lstlisting}[frame=single, language=c++]
result = []
def backtrack(track, select_list):
	if end_condition:
		result.add( track)
		return

	for option in select_list:
		select one
		backtrack(track, select_list)
		revert the select	
\end{lstlisting}

\item below is DFS. There is two different: 1) In DFS, we don't need to records all the path, so just don't use track. 2) DFS need to check if unvisited. but most backtrack problem deal with multi-branch tree problem(such as permutation or eight queen problem), so usually we don't check if node is unvisited. The basic idea is the same. 
\begin{lstlisting}[frame=single, language=c++]
DFS(current){
	visit current;
	for all(next to current){
		if(unvisited(next)){
			DFS(next);
		}
	}
}	
\end{lstlisting} 

	\item If we don't want to return all the result, but one, we can change it to below code. 
\begin{lstlisting}[frame=single, language=c++]
result = []
bool backtrack(track, select_list):
	if end_condition:
		result.add(track)
		return true;
	
	for option in select_list:
		select one
		if(backtrack(track, select_list))
			return true;
		revert the select	
\end{lstlisting}
\begin{description}
	\item[Line9-10] This if will stop the recursive and return the true direct to the root.
\end{description}

	\item If we want to remember all the result, we need to List<List>. List inside remember a track, List outside remember all the valid resule. 

\begin{lstlisting}
List<List<Integer>> res = new LinkedList<>();
 //remember recursive path
LinkedList<Integer> track = new LinkedList<>();

// main function
public List<List<Integer>> subsets(int[] nums) {
	backtrack(nums, 0);
	return res;
}


void backtrack(int[] nums, int start) {
	
	res.add(new LinkedList<>(track));
	
	// main frame
	for (int i = start; i < nums.length; i++) {
		// select
		track.addLast(nums[i]);
		//  use start to trim
		backtrack(nums, i + 1);
		// unselect
		track.removeLast();
	}
}


\end{lstlisting}


\subsection{permutation, combination and subset}
\subsubsection{no duplicate, single select}
\begin{itemize}
	\item Two important tree structures.
\begin{center}
	\includegraphics[width=0.7\linewidth]{pics/per}
	\includegraphics[width=0.7\linewidth]{pics/com}
\end{center}

	\item permutation n!,  subset is 2 to the power of n,  combination is c(n, k). six elements.  6! = 720,  2n = 64.  c(n, 2) = 15. 
		
	\item combination can be seen as a child question of subset. 
	\begin{center}
		\includegraphics[width=0.7\linewidth]{pics/subset}
	\end{center}
	
\end{itemize}

	\item \textbf{subset problem}. 
\begin{enumerate}
	\item Each node(from current node to root,including root(empty set)) is an answer
	\item Don't need base case here.  when i>=len, for will return without any execution.
	\item Refer the combination tree figure to help to understand this code
\end{enumerate}
	
\begin{lstlisting}
void sub(int arr[], int len, int start, vector<int>& result) {
	cout << "one answer is ( ";
	for (int i = 0; i < result.size(); i++) {
		cout << result[i] << " ";
	}
	cout << ")" << endl;
	
	for (int i = start; i < len; ++i) {
		result.push_back(arr[i]);  
		sub(arr, len, i + 1, result);
		result.pop_back();
	}
}

sub(arr, 3, 0, result)
\end{lstlisting}
	
	\item \textbf{combination problem}, the same idea as subset, just add a parameter k. When one answer length is k, print it out. 
\begin{lstlisting}
void com(int arr[], int len, int start, int k, vector<int>& result){
	if (result.size() == k) {
		cout << "one answer is ( ";
		for (int i = 0; i < result.size(); i++) {
			cout << result[i] << " ";
		}
		cout << ")" << endl;
	}
	
	for (int i = start; i < len; ++i) {
		result.push_back(arr[i]);  
		com(arr, len, i + 1, k, result);
		result.pop_back();
	}
}	
\end{lstlisting}

	\item \textbf{permutation problem}. 
\begin{enumerate}
	\item Base case is size == len
	\item You must use used array here to remember which element you have used. 
\end{enumerate}
\begin{lstlisting}
void per(int arr[], int len, int used[], vector<int>& result) {
	if (result.size() == len) {
		cout << "one answer is ( ";
		for (int i = 0; i < result.size(); i++) {
			cout << result[i] << " ";
		}
		cout << ")" << endl;
	}
	for (int i = 0; i < len; ++i) {
		if (used[i] == 1)
		continue;
		result.push_back(arr[i]); 
		used[i] = 1;
		per(arr, len, used, result);
		result.pop_back();
		used[i] = 0;
	}
}	
\end{lstlisting}
	\item For permutation problem, there is another easy implementation. You don't need extra result vector, but you have to use swap. They use the same basic backtrack idea.
\begin{lstlisting}
//all permutation. here there is a trick, we don't need track, but the basic idea is the same. 
void permute(char a[], int i, int n){
	int j;
	if (i == n){  //end_condition, 
		cout << a << endl;
		return;
	}
	
	for (j = i; j <= n; j++){  // all options in select_list
		swap(a[i], a[j]);     //select one
		permute(a, i+1, n);
		swap(a[i], a[j]);    //revoke select.
	}
} 	

\end{lstlisting}

\end{itemize}

\subsubsection{no duplicate, multi select}
\begin{itemize}
	\item The basic idea is just like before, for combination, we use i+1 to call recursion implementation single select, if you can multi select, just use i here. In order to avoid dead loop, this questions need a target to end loop, A typical question is coin problem.
\begin{lstlisting}
void sub_multi_select(int arr[], int len, int start, vector<int>& result, int target) {
	auto sum = std::accumulate(result.begin(), result.end(), 0);
	if (sum > target)
	return;
	if (sum == target) {
		cout << "one answer is ( ";
		for (int i = 0; i < result.size(); i++) {
			cout << result[i] << " ";
		}
		cout << ")" << endl;
	}
	
	for (int i = start; i < len; ++i) {
		result.push_back(arr[i]);
		sub_multi_select(arr, len, i, result, target);  //Pay attention here, not pass i+1, but pass i. 
		result.pop_back();
	}
}

int arr[3] = { 1,2,5};
vector<int> result;
sub_multi_select(arr, 3, 0, result, 10);

one answer is ( 1 1 1 1 1 1 1 1 1 1 )
one answer is ( 1 1 1 1 1 1 1 1 2 )
one answer is ( 1 1 1 1 1 1 2 2 )
one answer is ( 1 1 1 1 1 5 )
one answer is ( 1 1 1 1 2 2 2 )
one answer is ( 1 1 1 2 5 )
one answer is ( 1 1 2 2 2 2 )
one answer is ( 1 2 2 5 )
one answer is ( 2 2 2 2 2 )
one answer is ( 5 5 )

\end{lstlisting}

\begin{center}
	\includegraphics[width=0.7\linewidth]{pics/sub_multi}
\end{center}

	\item multi select permutation, Code is very easy, don't use used array. The time complexity is power(n, n). That is the only question which has so high time complexity. 
	

\end{itemize}

\subsubsection{duplicate, single select}
\begin{itemize}
	
	\item For combination, need to sort, then trim(prune) a branch which doesn't meet condition. For combination, first sort, then use a condition to trim
\begin{lstlisting}
	....
	for (int i = start; i < len; ++i) {
		if(i>start && arr[i] == arr[i-1]) // trimming happens in these two 
			continue;                     // statements, so we need to sort first. 
		result.push_back(arr[i]);  
		sub(arr, len, i + 1, result);
		result.pop_back();
	}	
	....
\end{lstlisting}

\begin{center}
	\includegraphics[width=0.7\linewidth]{pics/com_duplicate}
\end{center}
	

	\item For permutation, need to sort, then trim(prune) a branch which doesn't meet condition. 
\begin{lstlisting}
	....
	for (int i = start; i < len; ++i) {
		if(i>start && arr[i] == arr[i-1] && !used[i-1]) // trimming happens in these two 
			continue;                                // statements, so we need to sort first. 
		result.push_back(arr[i]);  
		sub(arr, len, i + 1, result);
		result.pop_back();
	}	
	....
\end{lstlisting}
	\item How to understand \verb|!used[i-1]|? 
	\begin{center}
		\includegraphics[width=0.7\linewidth]{pics/per_duplicate}
	\end{center}
	

\end{itemize}

\subsubsection{parenthesis}
\begin{itemize}
	\item The trimming idea can be applied in parenthesis problem, the basic problem is also permutation problem, but you need to trimming the branch. 
	anytime, left parenthesis should be greater or equal right parenthesis. 
\begin{lstlisting}

vector<string> generateParenthesis(int n) {
	vector<string> res;  //all results
	
	string track;
	// left and right parenthesis number are both n
	backtrack(n, n, track, res);
	return res;
}


void backtrack(int left, int right, 
string& track, vector<string>& res) {
	//left is less right, illegal.
	if (right < left) return;
	
	if (left < 0 || right < 0) return;
	// all is 0, get a legal result.
	if (left == 0 && right == 0) {
		res.push_back(track);
		return;
	}
	
	// try to put a left 
	track.push_back('('); 
	backtrack(left - 1, right, track, res);
	track.pop_back(); 
	
	// try to put a right.
	track.push_back(')'); 
	backtrack(left, right - 1, track, res);
	track.pop_back(); 
}
\end{lstlisting}
\end{itemize}

\subsubsection{summary}
\begin{itemize}
	
	\item four code compare: They are the most common used code template for back trace, you need to understand and 
\begin{enumerate}
	\item code 1: multi tree, call  call backtrace(i),  backtrace(i-1), backtrace(i-2)... //This will cause a multi branch tree, and the first level has n branches, 
	//The second level has n-1 branches, untill the last level has only 1 branches.   O(n*n)
\begin{lstlisting}
	for(i ..n )
	backtrace( i+1)
\end{lstlisting}
	
	\begin{center}
		\includegraphics[width=0.7\linewidth]{pics/sub}
	\end{center}
	
	\item code 2: multi tree, on each level,  i, i-1,  i-2 backtrace O(n!)
\begin{lstlisting}
	for(j = i ..n )  // on i level, each backtrace trun (n-i) times. 
		backtrace( i+1)
\end{lstlisting}

	\includegraphics[scale=0.25]{pics/permutation.png}

	\item code 3: binary tree, global result, need reverse
	
	\item code 4: binary tree, stack partial result, don't need reverse. global result.
\end{enumerate}

\end{itemize}

\subsection{interview questions}
\begin{itemize}
	


\item k equal subset.
	
	\begin{lstlisting}
		class Solution {
			public:
			bool canPartitionKSubsets(vector<int>& nums, int k) {
				int sum = accumulate(nums.begin(), nums.end(), 0);
				if (sum % k != 0) return false;
				sort(nums.begin(), nums.end(), greater<int>());
				vector<bool> visited(nums.size(), false);
				return helper(nums, k, sum / k, 0, 0, visited);
			}
			bool helper(vector<int>& nums, int k, int target, int start, int curSum, vector<bool>& visited) {
				if (k == 1) return true;
				if (curSum > target) return false; //return false is used to trim branch
				if (curSum == target) return helper(nums, k - 1, target, 0, 0, visited);  
				for (int i = start; i < nums.size(); ++i) {
					if (visited[i]) continue;
					visited[i] = true;
					if (helper(nums, k, target, i + 1, curSum + nums[i], visited)) return true;
					visited[i] = false;
				}
				return false;
			}
		};
	\end{lstlisting}
	
	
\end{itemize}

\section{Dynamic programming}
\subsection{Basic Idea}
\begin{itemize}
	
	\item \textbf{The basic question can be asked: can(bool), min or count(one number), all(list or vector)}. Usually, can and all can be used back track algorithm, but min is a typical indication of greed or dyanmic programming.
	
	\item The difference between dynamic programming and greedy algorithms is that with dynamic programming, the subproblems overlap. That means that by "memoizing" solutions to some subproblems, you can solve other subproblems more quickly. 
	
	\item three key words in dynamic programming are: state, transition and choice. state is most time defined by question directly,  the most difficult question is \textbf{How the current states is transitioned through choices from previous states, which is the transition equation}. If the state is defined in terms of the problem and you find it difficult to write the transition equation, then you must redefine the state; one example is Given an integer array nums, find the 
	subarray with the largest sum, and return its sum. (https://leetcode.com/problems/maximum-subarray/description/)
	
	
	\item The top-down approach is generally recursive (but less efficient) and more intuitive to implement as it is often a matter of recognizing the pattern in an algorithm and refactoring it as a dynamic programming solution.The bottom-up approach is generally iterative (and more efficient), but less intuitive and requires us to solve (and know!) the smaller problems first then use the combined values of the smaller problems for the larger solution.We refer to top-down solutions as memoization and bottom-up as tabulation.
	
	\item Recursive: Simple, intuitive code
	Unless care is taken to avoid recomputing previously computed values, the recursive program will have prohibitive complexity
	
	\item Iterative: Not require additional space for the recursion stack
	To minimize run time overheads, and hence to reduce actual run time, dynamic programming recurrences are almost always solved iteratively    (no recursion).
	
	\item If we dont need to solve all the problems and are just looking for the optimal solution, memorization is better.
	
	\item If we do need to solve all the problems, that means we are going to make a lot of recursive calls, and tabulation is better.
	
	\item The caveat is that memoization is generally more intuitive to implement especially when we dont know the solution to subproblems, whereas tabulation requires us to know the solutions, or bottom, in advance, in order to build our way up.
	
	\item In Divide and Conquer, the sub-problems are independent of each other while in case of Dynamic Programming, the sub-problems are not independent of each other (Solution of one sub-problem may be required to solve another sub-problem). Divide and Conquer works by dividing the problem into sub-problems, conquer each sub-problem recursively and combine these solutions. solves a problem by combining the solutions to sub-problems
	
	\begin{enumerate}
		\item Partition the problem into non-overlapping sub-problems
		\item Solve the sub-problems recursively
		\item Combine their solutions to solve the original problem
	\end{enumerate}
	
	
	\item Dynamic Programming is a technique for solving problems with overlapping subproblems. Each sub-problem is solved only once and the result of each sub-problem is stored in a table ( generally implemented as an array or a hash table) for future references. These sub-solutions may be used to obtain the original solution and the technique of storing the sub-problem solutions is known as memoization.
	
	\item You may think of DP = recursion + re-use
	
	
	\item The principle of optimality \\
	No matter what the first decision, the remaining decisions must be optimal with respect to the state that results from this first decision
	Dynamic programming may be used only when the principle of optimality holds. Useful when the sub-problems are overlapping
	
	Solve an optimization problem by caching  sub-problem solutions rather than recomputing them
	
	\begin{enumerate}
		\item Verify that the principle of optimality holds  \newline
		\includegraphics[scale=0.45]{pics/Recurrence.png} \newline
		
		\item Set up the dynamic-programming recurrence equations
		\item Solve the dynamic-programming recurrence equations for the value of the optimal solution
		\item Perform a traceback step in which the solution itself is constructed
	\end{enumerate}
	
\end{itemize}


\subsection{three questions}

\begin{itemize}
	
	\item The basic question can be ask: can(bool), min/max or count(one number), all(list or vector)
	
	
	\item  Write a function to return the minimum number of jumps to reach the end of the array (starting from the first element). Below is Min jump question
	
	\begin{lstlisting}[numbers=none]
		int arr[] = {1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9};
		
		int minj(int arr[], int last){
			
			if (last ==1 && arr[last]>=1){
				return 1;
			}
			
			int min = last;
			for(int i = last-1; i>=0;i--){
				if (i+arr[i]>=last){
					int step = 1+minj(arr,i);
					if( step<min){
						min = step;
					}
				}    
			}
			return min;
		}	
	\end{lstlisting} 	
	
	
	\item below is getting all questions.  
	\begin{lstlisting}[numbers=none]
		int arr[] = {1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9};
		
		vector<vector<int> >  minj(int arr[], int last){	
			if (last ==1 && arr[last]>=1){
				vector<int> v1 = {1};
				vector<vector<int> > v = {v1};
				return v;
			}	
			vector<vector<int> > result;
			
			int min = last;
			for(int i = last-1; i>=0;i--){
				if (i+arr[i]>=last){
					vector<vector<int> > result1 = minj(arr,i);
					for(auto e: result1){
						e.push_back(arr[i]);
						result.push_back(e);
					}
				}
			}
			return result;
		}				
	\end{lstlisting} 
	
	\item below is Can questions.  
	\begin{lstlisting}[numbers=none]
		int arr[] = {1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9};
		
		bool  minj(int arr[], int last){
			
			if (last ==1 && arr[last]>=1){
				return true;
			}
			
			bool result = false;
			
			for(int i = last-1; i>=0;i--){
				if (i+arr[i]>=last){
					result = true && minj(arr,i);
					if(result)
					break;
				}
			}
			return result;
		}	
	\end{lstlisting} 
	
	\item Conclusion:
	\begin{enumerate}
		\item can and min is little easy, min return one number, can return one bool. 
		\item "all" type question need return a list, because each answer is a list, so here we return vector< vector >. 
		\item "all" type question is suitable Top-bottom method. can and min is suitable for bottom-top method.
	\end{enumerate}
	
\end{itemize}


\subsection{one dimension}
\begin{itemize}
	
	\item Longest Increasing Subsequence, top bottom method. There are a lot of overlap problem, so efficient is not good.
	
	\begin{lstlisting}[numbers=none]
		int _lis( int arr[], int n, int *max_ref)
		{
			/* Base case */
			if (n == 1)
			return 1;
			
			// 'max_ending_here' is length of LIS ending with arr[n-1]
			int res, max_ending_here = 1;
			
			/* Recursively get all LIS ending with arr[0],
			arr[1] ... arr[n-2]. If arr[i-1] is smaller
			than arr[n-1], and max ending with arr[n-1]
			needs to be updated, then update it */
			for (int i = 1; i < n; i++){
				res = _lis(arr, i, max_ref);
				if (arr[i-1] < arr[n-1] && res + 1 > max_ending_here)
				max_ending_here = res + 1;
			}
			
			// Compare max_ending_here with the overall
			// max. And update the overall max if needed
			if (*max_ref < max_ending_here)
			*max_ref = max_ending_here;
			
			// Return length of LIS ending with arr[n-1]
			return max_ending_here;
		}
	\end{lstlisting}
	
	\item Longest Increasing Subsequence, bottom-top method. There are no overlap problem, so efficient is good
	
	\begin{lstlisting}[numbers=none]
		int lis( int arr[], int n ){
			int lis[n];
			lis[0] = 1;  
			
			/* Compute optimized LIS values in
			bottom up manner */
			for (int i = 1; i < n; i++ ){
				lis[i] = 1;
				for (int j = 0; j < i; j++ ) 
				if ( arr[i] > arr[j] && lis[i] < lis[j] + 1)
				lis[i] = lis[j] + 1;
			}
			
			// Return maximum value in lis[]
			return *max_element(lis, lis+n);
		}
	\end{lstlisting}
	
	
	\item house robber
	\begin{lstlisting}[numbers=none]
		for (i ->n)
		for(j->i)
		max(dp[j]...)
	\end{lstlisting}
	
	
	\item can target string be built by input string, top-bottom.
	
	\begin{lstlisting}[numbers=none]
		vector<string> input = {"ab", "abc", "cd", "def", "abcd", "ef" , "c"};
		string target = "abcdef";
		
		vector<vector<string> > ac(string target, const vector<string> & in ){
			if (target.size() == 0){
				return vector<vector<string>> {{}};
			}
			
			vector<vector<string>> last_result;
			
			for(auto i: input){
				if (target.find(i) == 0){
					string sub = target;
					sub.erase(0, i.size());
					vector<vector<string>> re = ac(sub, in);
					for(auto j : re){
						j.push_back(i);
						last_result.push_back(j);
					}
				}
			}
			return last_result;
		}
	\end{lstlisting} 
	
	\item how many way can target string be built by input string, top-bottom.
	\begin{lstlisting}[numbers=none]
		vector<string> input = {"purp", "p", "ur", "le", "purpl"};
		string target = "purple";
		
		int ac(string target, const vector<string> & in ){	
			int arr[7] = {1, 0, 0, 0, 0, 0, 0};
			for(int i = 0;i<7;i++){
				for (auto s: input){
					int length = s.length();
					if(target.substr(i, length) == s)
					{
						arr[i+length] += arr[i];
					}		
				}
			}
			
			return arr[6];
		}
	\end{lstlisting} 
	
\end{itemize}

\subsubsection{conclusion}
\begin{itemize}
	\item For this problem, first, decide to use one dimension dp(lis array in previous example)
	\item dp definition(state) should be match with your questions, here, state is the length of LIS. 
	\item dp and recursive use the same state. For example, dp and return value of recursive are both length of LIS.
	\item A common template
	\begin{lstlisting}[numbers=none]
		for (i ->n)
		for(j->i)
		max(dp[j]...)
	\end{lstlisting}
	
\end{itemize}


\subsection{two dimension}

\begin{itemize}
	\item The basic idea: \newline
	
	\includegraphics[scale=0.65]{pics/two_dimension.png} \newline
	
	\item LCS problem 
	\begin{lstlisting}[frame=single, language=c++]
		/* Returns length of LCS for X[0..m-1], Y[0..n-1] */
		int lcs( char *X, char *Y, int m, int n ) 
		{ 
			int L[m + 1][n + 1]; 
			int i, j; 
			
			/* Following steps build L[m+1][n+1] in 
			bottom up fashion. Note that L[i][j] 
			contains length of LCS of X[0..i-1]
			and Y[0..j-1] */
			
			for (i = 0; i <= m; i++) { 
				for (j = 0; j <= n; j++) { 
					if (i == 0 || j == 0)  
					L[i][j] = 0;   
					//base case, the first row and the first column are all zero
					
					else if (X[i - 1] == Y[j - 1]) 
					L[i][j] = L[i - 1][j - 1] + 1; 
					
					else
					L[i][j] = max(L[i - 1][j], L[i][j - 1]); 
				} 
			} 
			
			/* L[m][n] contains length of LCS 
			for X[0..n-1] and Y[0..m-1] */
			
			return L[m][n]; 
		} 	
	\end{lstlisting}
	
	\item minimal edit distance problem 
	\begin{lstlisting}[frame=single, language=c++]
		int min(int x, int y, int z) { return min(min(x, y), z); }
		int editDistDP(string str1, string str2, int m, int n)
		{
			// Create a table to store results of subproblems
			int dp[m + 1][n + 1];
			
			// Fill d[][] in bottom up manner
			for (int i = 0; i <= m; i++) {
				for (int j = 0; j <= n; j++) {
					// If first string is empty, only option is to
					// insert all characters of second string
					if (i == 0)
					dp[i][j] = j; // Min. operations = j
					
					// If second string is empty, only option is to
					// remove all characters of second string
					else if (j == 0)
					dp[i][j] = i; // Min. operations = i
					
					// If last characters are same, ignore last char
					// and recur for remaining string
					else if (str1[i - 1] == str2[j - 1])
					dp[i][j] = dp[i - 1][j - 1];
					
					// If the last character is different, consider
					// all possibilities and find the minimum
					else
					dp[i][j] = 1 + min(dp[i][j - 1], // Insert
					dp[i - 1][j], // Remove
					dp[i - 1][j - 1]); // Replace
				}
			}
			
			return dp[m][n];
		}	
	\end{lstlisting}
	
	\item longest panlindrom subsequence (LPS)
	\begin{lstlisting}[frame=single, language=c++]
		// Returns the length of the longest palindromic subsequence in seq
		int lps(char *str)
		{
			int n = strlen(str);
			int i, j, cl;
			int L[n][n];  // Create a table to store results of subproblems
			
			// Strings of length 1 are palindrome of lentgh 1
			for (i = 0; i < n; i++)
			L[i][i] = 1;
			
			// Build the table. Note that the lower diagonal values of table are
			// useless and not filled in the process. The values are filled in a
			// manner similar to Matrix Chain Multiplication DP solution (See
			// https://www.geeksforgeeks.org/matrix-chain-multiplication-dp-8/). cl is length of
			// substring
			for (cl=2; cl<=n; cl++){
				for (i=0; i<n-cl+1; i++){
					j = i+cl-1;
					if (str[i] == str[j] && cl == 2)
					L[i][j] = 2;
					else if (str[i] == str[j])
					L[i][j] = L[i+1][j-1] + 2;
					else
					L[i][j] = max(L[i][j-1], L[i+1][j]);
				}
			}
			return L[0][n-1];
		}
		
	\end{lstlisting}
	
	
	\item matrix multiply 
	\begin{lstlisting}[frame=single, language=c++]
		int MatrixChainOrder(int p[], int n)
		{
			
			/* For simplicity of the program, one
			extra row and one extra column are
			allocated in m[][]. 0th row and 0th
			column of m[][] are not used */
			int m[n][n];
			
			int i, j, k, L, q;
			
			/* m[i, j] = Minimum number of scalar
			multiplications needed to compute the
			matrix A[i]A[i+1]...A[j] = A[i..j] where
			dimension of A[i] is p[i-1] x p[i] */
			
			// cost is zero when multiplying
			// one matrix.
			for (i = 1; i < n; i++)
			m[i][i] = 0;
			
			// L is chain length.
			for (L = 2; L < n; L++){
				for (i = 1; i < n - L + 1; i++){
					j = i + L - 1;
					m[i][j] = INT_MAX;
					for (k = i; k <= j - 1; k++){
						
						// q = cost/scalar multiplications
						q = m[i][k] + m[k + 1][j]
						+ p[i - 1] * p[k] * p[j];
						if (q < m[i][j])
						m[i][j] = q;
					}
				}
			}
			
			return m[1][n - 1];
		}	
	\end{lstlisting}
	
	\item knapsack capacity
	\begin{lstlisting}[frame=single, language=c++]
		int knapSack(int W, int wt[], int val[], int n)
		{
			int i, w;
			int K[n + 1][W + 1];
			
			// Build table K[][] in bottom up manner
			for(i = 0; i <= n; i++)
			{
				for(w = 0; w <= W; w++)
				{
					if (i == 0 || w == 0)
					K[i][w] = 0;
					else if (wt[i - 1] <= w)
					K[i][w] = max(val[i - 1] +
					K[i - 1][w - wt[i - 1]],
					K[i - 1][w]);
					else
					K[i][w] = K[i - 1][w];
				}
			}
			return K[n][W];
		}	
	\end{lstlisting}
	
	\item egg drop
	\begin{lstlisting}[frame=single, language=c++]
		int eggDrop(int n, int k){
			/* A 2D table where entery
			eggFloor[i][j] will represent
			minimum number of trials needed for
			i eggs and j floors. */
			int eggFloor[n + 1][k + 1];
			int res;
			int i, j, x;
			
			// We need one trial for one floor and 0
			// trials for 0 floors
			for (i = 1; i <= n; i++) {
				eggFloor[i][1] = 1;
				eggFloor[i][0] = 0;
			}
			
			// We always need j trials for one egg
			// and j floors.
			for (j = 1; j <= k; j++)
			eggFloor[1][j] = j;
			
			// Fill rest of the entries in table using
			// optimal substructure property
			for (i = 2; i <= n; i++) {
				for (j = 2; j <= k; j++) {
					eggFloor[i][j] = INT_MAX;
					for (x = 1; x <= j; x++) {
						res = 1 + max(
						eggFloor[i - 1][x - 1],
						eggFloor[i][j - x]);
						if (res < eggFloor[i][j])
						eggFloor[i][j] = res;
					}
				}
			}
			
			// eggFloor[n][k] holds the result
			return eggFloor[n][k];
		}
	\end{lstlisting}
	
	
	
\end{itemize}

\subsection{three dimension}
\begin{itemize}
	\item A typical question is stock buy and sell. 
	\begin{lstlisting}
		for (int i = 0; i < n; i++) 
		for (int k = max_k; k >= 1; k--) {
			if (i - 1 == -1) {
				// deal i = -1  base case
				dp[i][k][0] = 0;
				dp[i][k][1] = -prices[i];
				continue;
			}
			dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
			dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);   // k-1 here. three dimension array, go to the next level, please refer the below picture.
		}
		return dp[n - 1][max_k][0];
	\end{lstlisting}
	
	\includegraphics[width=0.7\linewidth]{pics/stock.png} 
\end{itemize}



\subsection{Summary}

\begin{itemize}
	\item The general form of a dynamic programming problem is to find the optimal value. Since the goal is to find the optimal value, what is the core issue? The core issue in solving dynamic programming problems is enumeration. The steps are: define the base case, clarify the "states," clarify the "choices," and define the meaning of the dp array/function. I summarize this theory as "one model with three characteristics."
	
	\item First, let's look at what "one model" refers to. It describes the model of problems that dynamic programming is suited for solving. I define this model as the "optimal solution model with multi-stage decision-making." Let me explain this in detail.
	
	Dynamic programming is typically used to solve optimization problems. The process of solving such problems involves going through multiple decision stages. Each decision stage corresponds to a set of states. We then search for a sequence of decisions that, when followed, results in the optimal value we seek.
	
	Now, let's explore what the "three characteristics" are. They are optimal substructure, no aftereffect, and overlapping subproblems. These concepts are somewhat abstract, so I'll explain them one by one:
	
	Optimal Substructure
	Optimal substructure means that the optimal solution to the problem contains the optimal solutions to its subproblems. In other words, we can derive the optimal solution of the problem from the optimal solutions of its subproblems. When we map optimal substructure to the dynamic programming problem model we defined earlier, it means that the states in the later stages can be derived from the states in the earlier stages.
	
	No after effect (or Memorylessness)
	This has two meanings. The first is that when deriving the state of a later stage, we only care about the state values of the earlier stages, not how those states were derived step by step. The second meaning is that once the state of a certain stage is determined, it is not affected by decisions made in later stages. No after effect is a relatively "relaxed" requirement. As long as the dynamic programming problem model mentioned earlier is satisfied, the no after effect property will generally hold.
	
	Overlapping Subproblems
	This concept is easier to understand. As mentioned several times in the previous section, in summary, it means that different decision sequences may reach the same stage, potentially resulting in repeated states.
	
		
	Define the base case: This is simple. Clearly, when the target amount is 0, the algorithm should return 0, because no coins are needed to reach the target amount.
	
	Identify the "state": This refers to the variables that change between the main problem and subproblems. Since the number of coins is unlimited and the coin denominations are given by the problem, the only variable that changes as the solution progresses toward the base case is the target amount. Thus, the only "state" is the target amount (amount).
	
	Determine the "choices": These are the actions that lead to changes in the state. Why does the target amount change? Because you are selecting coins. Each time you choose a coin, it effectively reduces the target amount. Therefore, all the coin denominations represent your "choices."
	
	Clarify the definition of the dp function/array: In this case, we're discussing a top-down approach, so there will be a recursive dp function. Generally, the function's parameters are the variables that change during state transitions (the "state"), as mentioned earlier. The function's return value is what the problem asks us to calculate. For this problem, there is only one statethe target amountand the problem asks us to compute the minimum number of coins needed to reach the target amount.
	
	Of course, this isnt strictly a dynamic programming problem. It aims to illustrate that the optimal substructure is not unique to dynamic programming; most problems that involve finding an optimal value have this property. On the flip side, if the optimal substructure property is present, it usually means youre asked to find an optimal value. When you encounter challenging optimization problems, thinking about dynamic programming is often the right approachthats the pattern.
	
	Dynamic programming involves the following steps:
	
	Transform the current problem into subproblems: Once you break it down into subproblems, define the state transition equation, which explains how the solution to the current problem is derived from the combination (or transformation) of the subproblems.
	
	Decide whether to use top-down DP (subproblem, subproblem state 1, subproblem state 2, etc.) or bottom-up DP: For example, dp[subproblem], dp[subproblem state 1], dp[subproblem state 2], etc.
	
	Determine the traversal direction and base case based on the meaning of the dp function.
	
	Apply the template code to implement the solution.
	
	
	Below are some common examples: the egg-drop problem, subsequence problems and finding the minimum. The 0/1 knapsack problem and stock trading problem.
	
	Why does the n-floor egg-drop problem require considering all subproblems from 0 to i-1 for each i, while the stock trading problem only needs to consider the previous state?  One thing to note is that in the stock trading problem, k represents the maximum number of allowed transactions, not the number of transactions already completed. Its a way of describing the state.
	
	\textbf(Based on the problem, define the dp, then take dp[i-1] and try to see if you can combine dp[i-1] to form dp. Generally, there are two possibilities: either it involves all previous states (as in the egg-drop problem), or it involves just the previous two states (as in the stock trading problem). The current state can transition from buying or not buying.)"
	
	
	\item Four questions: matrix multiply, shoot ballon, gambling(piles stone, take from left and right) and maxium panlinmon subsequecne. The answer is located in the top-right corner of a 2D array, and you need to use diagonal traversal or reverse traversal. The transition equations are almost identical.
	
\begin{lstlisting}
for (int i = n; i >= 0; i--) {
	// j from left to right
	for (int j = i + 1; j < n + 2; j++) {
		// "Which balloon is the last to be burst?"
		
		for (int k = i + 1; k < j; k++) {
			// choose the best option
			dp[i][j] = Math.max(
			dp[i][j], 
			dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]
			);
		}
	}
}	
\end{lstlisting}	
	
	\item Two questions: Regular expressions and edit distance: The result is in the bottom-right corner, and a forward traversal is needed. The subfunction represents an edit or match operation.
\begin{lstlisting}
bool dp(string& s, int i, string& p, int j) {
	if (s[i] == p[j] || p[j] == '.') {
		// match
		if (j < p.size() - 1 && p[j + 1] == '*') {
			// 1.1 regex match 0 or more
			return dp(s, i, p, j + 2)
			|| dp(s, i + 1, p, j);
		} else {
			// 1.2 normal match 1 
			return dp(s, i + 1, p, j + 1);
		}
	} else {
		// not match 
		if (j < p.size() - 1 && p[j + 1] == '*') {
			// 2.1 regex match 0 times
			return dp(s, i, p, j + 2);
		} else {
			// 2.2 can't continue match
			return false;
		}
	}
}

// return s1[0..i] and s2[0..j] minimum edition distance
int dp(String s1, int i, String s2, int j) {
	// base case
	if (i == -1) return j + 1;
	if (j == -1) return i + 1;
	
	if (s1.charAt(i) == s2.charAt(j)) {
		return dp(s1, i - 1, s2, j - 1); // do nothing
	}
	return min(
	dp(s1, i, s2, j - 1) + 1,    // insert
	dp(s1, i - 1, s2, j) + 1,    // delete
	dp(s1, i - 1, s2, j - 1) + 1 // replace
	);
}		
\end{lstlisting}	
	

\begin{lstlisting}	
for (int i = 1; i <= n; ++i) {
	for (int j = 1; j <= min(i, m); ++j) {
		if (j == 1) {
			dp[i][j] = sum[i];
		} else {
			for (int k = 1; k <= i - 1; ++k) {
				dp[i][j] = min(dp[i][j], max(dp[k][j - 1], sum[i] - sum[k]));
			}
		}
	}
}
return dp[n][m]	
\end{lstlisting}	
	

	\begin{lstlisting}
		int knapSack(int W, int wt[], int val[], int n)
		{
			
			// Base Case
			if (n == 0 || W == 0)
			return 0;
			
			// If weight of the nth item is more
			// than Knapsack capacity W, then
			// this item cannot be included
			// in the optimal solution
			if (wt[n - 1] > W)
			return knapSack(W, wt, val, n - 1);
			
			//There are two options, so there's no need to write a for-loop. Based on the options, change the state, pass the state into the recursive call, and take the maximum of the returned results.
			
			// Return the maximum of two cases:
			// (1) nth item included
			// (2) not included
			else
			
			return max(
			val[n - 1]
			+ knapSack(W - wt[n - 1], 
			wt, val, n - 1),
			knapSack(W, wt, val, n - 1));
		}	
	\end{lstlisting}
	
\end{itemize}





\section{branch and bound}
\begin{itemize}
\item Backtracking:
\begin{enumerate}
\item It is used to find all possible solutions available to the problem.
\item It traverse tree by DFS(Depth First Search).
\item It realizes that it has made a bad choice \& undoes the last choice by backing up.
\item It search the state space tree until it found a solution.
\item It involves feasibility function.
\end{enumerate}


\item Branch-and-Bound
\begin{enumerate}
\item It is used to solve optimization problem.
\item It may traverse the tree in any manner, DFS or BFS.
\item It realizes that it already has a better optimal solution that the pre-solution leads to so it abandons that pre-solution.
\item It completely searches the state space tree to get optimal solution.
\item It involves bounding function.

\item Searches a solution space that is often organized as a tree (like backtracking)
\item Usually searches a tree in a breadth-first / least-cost manner (unlike backtracking)

\end{enumerate}

\item Difference between DFS and backtracking is:
\begin{enumerate}
\item Backtracking is a more general purpose algorithm. Depth-First search is a specific form of backtracking related to searching tree or graphic structures.  
\item For a problem, answer space can be described as a tree graphic structure, such as 0/1 backpack problem. at this time, backtracking use DFS to search the answer space, and use questions related condition to prune the sub-tree and com back. So in this way, you can think backtracking = DFS+prune. 

\item For mouse raze, because, prune is "no next neighbor", just like DFS, so DFS and backtracking are the totally same.
\end{enumerate}

\item Difference between branch-bound  and backtracking is about size
\begin{enumerate}
\item backtracking use stack and only add one child each time, so it use less memory compared with branch-bound
\item branch-bound store all possible child in queue, so if answer is near root, it will find answer quickly. 

\item win in size, but lose in time. backtracking will 1) find answer slowly, 2) branch-bound will find optimal answer. 
\end{enumerate}

\item dp and bound code for 0-1 back pack.  dp only can deal with integral weight. but bound can deal with float value. This code can run and print out all the value, it can help you to understand the idea behind these two important algorithms. 

\begin{lstlisting}
// C++ program to solve knapsack problem using
// branch and bound
#include <algorithm>
#include <queue>
#include <stack>
#include <iostream>
using namespace std;

// Structure for Item which store weight and corresponding
// value of Item
struct Item
{
	float weight;
	int value;
};

// Node structure to store information of decision
// tree
struct Node
{
	// level  --> Level of node in decision tree (or index
	//             in arr[]
	// profit --> Profit of nodes on path from root to this
	//            node (including this node)
	// bound ---> Upper bound of maximum profit in subtree
	//            of this node/
	int level, profit, bound;
	float weight;
};

// Comparison function to sort Item according to
// val/weight ratio
bool cmp(Item a, Item b)
{
	double r1 = (double)a.value / a.weight;
	double r2 = (double)b.value / b.weight;
	return r1 > r2;
}

// Returns bound of profit in subtree rooted with u.
// This function mainly uses Greedy solution to find
// an upper bound on maximum profit.
int bound(Node u, int n, int W, Item arr[])
{
	// if weight overcomes the knapsack capacity, return
	// 0 as expected bound
	if (u.weight >= W)
	return 0;
	
	// initialize bound on profit by current profit
	int profit_bound = u.profit;
	
	// start including items from index 1 more to current
	// item index
	int j = u.level + 1;
	int totweight = u.weight;
	
	// checking index condition and knapsack capacity
	// condition
	while ((j < n) && (totweight + arr[j].weight <= W))
	{
		totweight += arr[j].weight;
		profit_bound += arr[j].value;
		j++;
	}
	
	// If k is not n, include last item partially for
	// upper bound on profit
	if (j < n)
	profit_bound += (W - totweight) * arr[j].value /
	arr[j].weight;
	
	return profit_bound;
}

// Returns maximum profit we can get with capacity W
int knapsack(int W, Item arr[], int n)
{
	// sorting Item on basis of value per unit
	// weight.
	sort(arr, arr + n, cmp);
	
	// make a queue for traversing the node
	queue<Node> Q;
	Node u, v;
	
	// dummy node at starting
	u.level = -1;
	u.profit = u.weight = 0;
	Q.push(u);
	
	// One by one extract an item from decision tree
	// compute profit of all children of extracted item
	// and keep saving maxProfit
	int maxProfit = 0;
	while (!Q.empty())
	{
		// Dequeue a node
		u = Q.front();
		Q.pop();
		
		// If it is starting node, assign level 0
		if (u.level == -1)
		v.level = 0;
		
		// If there is nothing on next level
		if (u.level == n - 1)
		continue;
		
		// Else if not last node, then increment level,
		// and compute profit of children nodes.
		v.level = u.level + 1;
		
		// Taking current level's item add current
		// level's weight and value to node u's
		// weight and value
		v.weight = u.weight + arr[v.level].weight;
		v.profit = u.profit + arr[v.level].value;
		
		// If cumulated weight is less than W and
		// profit is greater than previous profit,
		// update maxprofit
		if (v.weight <= W && v.profit > maxProfit)
		maxProfit = v.profit;
		
		// Get the upper bound on profit to decide
		// whether to add v to Q or not.
		v.bound = bound(v, n, W, arr);
		cout << "look here" << v.weight << " " << v.bound <<" "<<maxProfit<<endl;
		
		// If bound value is greater than profit,
		// then only push into queue for further
		// consideration
		if (v.bound > maxProfit)
		Q.push(v);
		
		// Do the same thing,  but Without taking
		// the item in knapsack
		v.weight = u.weight;
		v.profit = u.profit;
		v.bound = bound(v, n, W, arr);
		if (v.bound > maxProfit)
		Q.push(v);
	}
	
	return maxProfit;
}

// driver program to test above function
int knapsack_back(int W, Item arr[], int n)
{
	// sorting Item on basis of value per unit
	// weight.
	sort(arr, arr + n, cmp);
	
	// make a queue for traversing the node
	stack<Node> S;
	Node u, v;
	
	// dummy node at starting
	u.level = -1;
	u.profit = u.weight = 0;
	S.push(u);
	
	// One by one extract an item from decision tree
	// compute profit of all children of extracted item
	// and keep saving maxProfit
	int maxProfit = 0;
	while (!S.empty())
	{
		// Dequeue a node
		u = S.top();
		S.pop();
		
		// If it is starting node, assign level 0
		if (u.level == -1)
		v.level = 0;
		
		// If there is nothing on next level
		if (u.level == n - 1)
		continue;
		
		// Else if not last node, then increment level,
		// and compute profit of children nodes.
		v.level = u.level + 1;
		
		
		// Do the same thing,  but Without taking
		// the item in knapsack
		v.weight = u.weight;
		v.profit = u.profit;
		S.push(v);
		
		
		// Taking current level's item add current
		// level's weight and value to node u's
		// weight and value
		v.weight = u.weight + arr[v.level].weight;
		v.profit = u.profit + arr[v.level].value;
		
		// If cumulated weight is less than W and
		// profit is greater than previous profit,
		// update maxprofit
		if (v.weight <= W && v.profit > maxProfit)
		maxProfit = v.profit;
		
		
		// If bound value is greater than profit,
		// then only push into queue for further
		// consideration
		
		S.push(v);
		
		
	}
	
	return maxProfit;
}


int knapsack_dp() {
	// base case 
	//{2, 40}, { 3.14, 50 }, { 1.98, 100 }, { 5, 95 }, { 3, 30 }
	int W = 10;
	int N = 5;
	int val[] = {40, 50, 100, 95, 30};
	int wt[] = { 2, 4, 2, 5, 3 };
	int dp[6][11];
	for (int i = 0; i <= N; i++) {
		for (int w = 0; w <= W; w++) {
			if (i == 0)
			dp[i][w] = 0;
			if (w == 0)
			dp[i][w] = 0;
		}
	}
	for (int i = 1; i <= N; i++) {
		for (int w = 1; w <= W; w++) {
			if (w - wt[i - 1] < 0) {
				
				dp[i][w] = dp[i - 1][w];
			}
			else {
				
				dp[i][w] = max(
				dp[i - 1][w - wt[i - 1]] + val[i - 1],
				dp[i - 1][w]
				);
			}
		}
	}
	
	for (int i = 1; i <= N; i++) {
		for (int w = 1; w <= W; w++) {
			cout << dp[i][w] << " ";
		}
		cout << endl;
	}
	
	return dp[N][W];
}

/* 
0 40 40 40 40 40 40 40 40 40
0 40 40 50 50 90 90 90 90 90
0 100 100 140 140 150 150 190 190 190
0 100 100 140 140 150 195 195 235 235
0 100 100 140 140 150 195 195 235 235
*/


int main()
{
	int W = 10;   // Weight of knapsack
	Item arr[] = { {2, 40}, {3.14, 50}, {1.98, 100},
		{5, 95}, {3, 30} };
	int n = sizeof(arr) / sizeof(arr[0]);
	
	cout << "Maximum possible profit = "
	<< knapsack(W, arr, n) << endl;
	
	//dp 
	knapsack_dp();
	
	//back track
	cout<<"back track"<< knapsack_back(W, arr, n) << endl;	
	return 0;
}
\end{lstlisting}


\item eight queen
\begin{lstlisting}
	vector<vector<string>> res;
	vector<vector<string>> solveNQueens(int n) {
		
		// '.' is  void, 'Q' is queen
		vector<string> board(n, string(n, '.'));
		backtrack(board, 0);
		return res;
	}
	
	
	void backtrack(vector<string>& board, int row) {
		// base case
		if (row == board.size()) {
			res.push_back(board);
			return;
		}
		
		int n = board[row].size();
		for (int col = 0; col < n; col++) {
			// exclude
			if (!isValid(board, row, col)) {
				continue;
			}
			// make decision
			board[row][col] = 'Q';
			// go deeper
			backtrack(board, row + 1);
			// reverse
			board[row][col] = '.';
		}
	}
\end{lstlisting}

\item recursive 0-1 pack pack. \textbf{this is back trace, but why don't we have reverse decision? because in eight queen, we use reference parameter pass it to function(all function share). Here, we use stack, in each level, we have saved the local variable( you can think that it has been reversed by poping stack.) } That is the difference.  Another important thing is that for 0-1 pack and eight queen,  we need a logically recursive tree. So we need to simulate a "level" conception.  \textbf{0-1 pack stack solution, we save level information to the each node. 0-1 recursive solution, we use int i (array index)as level information. in eight queen, we use row information as level information }. level is the level information in the recursive solution tree.  
\begin{lstlisting}
public int maxW = Integer.MIN_VALUE; 
// cw current weight, i: current item
// call with f(0, 0, a, 10, 100)
public void f(int i, int cw, int[] items, int n, int w) {
	if (cw == w || i == n) { // cw==w is full or select all items
		if (cw > maxW) maxW = cw;
		return;
	}
	f(i+1, cw, items, n, w);
	if (cw + items[i] <= w) {// bigger than w, give up
		f(i+1,cw + items[i], items, n, w);
	}
}
2.
\end{lstlisting}


\item A example can be see in ref PPT.  container and ship problems. 

\end{itemize}


\chapter{interview preparation}

\begin{itemize}
	
	\item \textbf{The most import rule:} Break the big problem down into atomic problems. If the atomic problem requires some global conditions, then include the necessary data and data structures. Write the logic to handle this atomic problem (you may need to use a if..else to handle different conditions inside this atomic problem). Then apply this atomic problem handling logic into recursion or iteration.

\begin{center}
	\includegraphics[scale=0.55]{pics/rule.drawio.png}
\end{center}

	\item Difference between backtracking and DP:
	\begin{enumerate}
		\item Both backtracking and dynamic programming involve a series of decisions. The difference is that in backtracking, certain constraints must be satisfied during the decision-making process (such as in the N-Queens problem). If the constraints are not met, you need to undo that decision. Dynamic programming, on the other hand, deals with the global optimal solution. So for each decision, you typically compare and record the optimal solution for the subproblem in order to eventually derive the global optimal solution.
		
		\item Another difference is that backtracking often uses recursion, while dynamic programming uses iteration (usually over a 2D array).
		
		\item However, sometimes the two approaches can be combined, such as in the partition problem, where backtracking is primarily used, but you can also record solutions to subproblems (using dynamic programming techniques) to reduce the number of recursive calls.
		
		\item typical question for DP is stock buy and sell k time.  typical question for backtrack is k equal subset. They all involve extra k parameter. With k parameter, you can think that it's k level, on each level, there is tree or array structure. That is the most complex problem you can meet in the interview questions. 
		
		\item with k, you can think it's multi layer, for back track, each layer has a tree (k equal subset). For dp, each layer has two dimension array (stock k buy and sell).

\begin{center}
	\includegraphics[scale=0.55]{pics/dp_back.drawio.png}
\end{center}

		
	\end{enumerate}
	
	  
\end{itemize}


\section{coding tips and traps}
\begin{itemize}
	\item for vector and array, pay attention to size-1 is the last index. also stick to left close and right ).  size/2 is what index?  
	\item Check variable name. 
	\item Return in lambda and recursive. 
	\item Check if miss ; in the endl
	\item Add () if expression is complicated. 
	\item Pay left edge (0) and right edge ( last element)
	\item Understand index and length. 
	\begin{lstlisting}
		while(index<length)
	\end{lstlisting}
	\item When while exist, understand index position and what it represent?
	\item use auto as possible.
	
	\item if you want to loop from length to 0, index must be int. can't be size\_t, otherwise, --index will never small than 0. (Must remember)
	
	\textbf{Most of complex data structure need hash and list combine.}
\end{itemize}

%\subsection{famous question}
%\subsection{array}
%\begin{itemize}
%	\item LEADER, Next Greater Element. Number of incursion.
%\end{itemize}

\section{code template}
\begin{itemize}
	
	\item six examples: partition and partition\_if, use slow and fast pointer and swap.  remove and unique. use slow and fast. find insert and sqrt(x) use mid=l+(r-l)/2.  one find right boundary, one find left boundary.  All these examples should be remembered. 
	
	\item leetcode 263, 292, 463, 530 561, 572. 680, 696, 700, 766, 821, 942,  (change serial equal to adjacent equal ) need to come back to learn. 1037, 1071, 1078
	
	\item inpace merge also need remember. 
	
	\item sliding windows. 
	
	\begin{lstlisting}
		int left = 0, right = 0;
		
		while (right < s.size()) {
			window.add(s[right]); // increase windows
			right++;
			***  //put you logic here.
			
			//anytime you increase window, check condition. 
			while (window needs shrink) {
				// reduce windows.
				window.remove(s[left]);
				left++;
				*** //put your logic here. 
			}
		}
		
		//1) only use right <s.size as main loop
		//2) "windows nees shrink" condition need to be customized. 
		//3) modify "window.add" and *** to your own logic. 
		//4) both left and right increments ++
	\end{lstlisting}
	
	\item When writing the backtrack function, you need to maintain the "path" that has been traversed and the current "list of available choices." When the "termination condition" is triggered, add the "path" to the result set.
	
	\begin{lstlisting}
		result = []
		def backtrack(path , "list of avaiable choices"):
		if (meet condition)
		result.add(path)
		return
		
		for choic in "list of avaiable choices":{
			choose choice;
			backtrack(path , "maybe new list of avaiable choices");
			revoke choice;
		}	
	\end{lstlisting}
	
	\item DFS and BFS code. For BFS, when D.pop we don't judge if it's visisted.  For all next current, visit them all and push them into the D. That is the difference with DFS.
	\begin{lstlisting}
		DFS(start){
			S.push(start)  
			while(!S.empty()){
				current = S.pop
				if(unvisited(current){
					visit current.
					for all(next to current and unvisited)
					S.push(next);
				}
			}
		}	
	\end{lstlisting}
	
	\begin{lstlisting} 
		BFS(start){
			D.push(start)  
			while(!D.empty()){
				current = D.pop  //2) no if here
				for all(next to current and unvisited){
					visit current.  //1) push and visit at the same time. 
					D.push(next);
				}
			}
		}
	\end{lstlisting}
	
\end{itemize}

\section{typical questions}
\subsubsection{array}
\begin{itemize}
	
	\item maximum difference from right element( one time stock buy and sell), 
	
	\item circular queue, three points: 1) empty, 2) full and 3) front+1/length = rear. 
	
	
	\item stock one buy ans sell
	\item next larger (leader problem) (mono stack)
	\item maximum sliding window(mono queue)
	\item partial sum used for random select with weight. 
	
	\item heap (child-1)/2 is parent.  Parent*2+1 is left child, parent*2+2 is right child. If you forget, just remember three element, 0, 1, 2, then  (2-1)/2 =0 , but 2/2 = 1, that is not correct. 
	
	
\end{itemize}
\subsubsection{list}
\begin{itemize}
	\item reverse link list
	\item judge if there is loop, where is the entry of loop? 
\end{itemize}

\subsubsection{tree}
\begin{itemize}
	\item LCA, (How to resolve if only one node is here? )
	\item Judge if tree is valid BST? (how to understand min and max) 
	\item Number of BST?  
	\item Build tree from serialize
	\item delete node if path sum < k
\end{itemize}

\subsubsection{graph}

\begin{itemize}
	\item union-find aglorithm and use this to find spanning tree.
	
\end{itemize}

\subsubsection{interval}
\begin{itemize}
	\item one meeting room and minimum meeting rootm (need end sort.)
	\item delete overlap interval
	\item combine overlap interval.
	\item video combine, 
	
\end{itemize}

\subsubsection{slide windows}
\begin{itemize}
	\item duplicate
	\item partition
	\item 
\end{itemize}

\subsubsection{D\&C}
\begin{itemize}
	\item nth element, find rotate, and left boundary. These three methods has different left and right boundary.  In these method, we usually input first index and last index (not size of array), and also left close, right close interval, this makes programming a little easier. 
	
	\item A variant is index is in the middle. these questions includes all parenthesis, child tree and matrix mulitplication.
	\begin{lstlisting}
		fun( int l, int r)
		
		for(int k = l ;k<r; k++){
			fun( l,k);
			fun( k, r)
		}	
		
	\end{lstlisting}
\end{itemize}


\subsubsection{binary search}
\begin{itemize}
	\item money eat banana 
	\item code template for binary search, left bound and right bound
\end{itemize}

\subsubsection{back track}
\begin{itemize}
	\item permutation, subset and combination 
\end{itemize}





\section{Basic Knowledge}
\begin{itemize}
	\item Data structure is known as ADT(Abstract Date Type),  which is independent of implementation. For example, stack can be implemented by array or linked list inside. Such as stack in STL library, It's implemented by \texttt{std::deque} default.   
	
	\item \textbf{Linear and hierarchical structures}. Array, linked lists, stacks and queue are linear structures. And tree, graph, heaps are hierarchical.
	
	\item STL is a good reference when you learn data structure, especially (API) design and interface of STL container. such as \texttt{push}, \texttt{pop}  and \texttt{top} for \texttt{stack} and \texttt{priority\_queue}. For \texttt{queue}, besides \texttt{push, pop},  there are also \texttt{front()} and \texttt{back()}. Just remember five words: \textbf{push, pop, front, back and top}
	
	\item All the normal container(not including adapter container, stack, queue, priority\_queue) includes four basic operations: begin(), end(), insert() and erase(). 
	
	\item Big O notation. Remember below English words: constant, logarithmic (log n), linear (n)  linearithmic (n*log(n)) , quadratic $2^{n}$ (2 to the power of n), polynomial(quadratic cubic),  exponential $c^{n}$.  factorial $n!$.  O($10^{N}$): trying to break a password by testing every possible combination (assuming numerical password of length N).  traveling salesman problem(TSP)is factorial $n!$.  Both factorial and exponential are non-polynomial(NP). 
	
	\item verb|https://webusers.imj-prg.fr/~jan.nekovar/co/en/en.pdf| list some common mathematical English.  
	
	\item space complexity is much simple, usually, we only use O(1), O(n) and O($n^{2}$), we don't use other forms very often.  
\end{itemize}





\section{code template}

\begin{itemize}
	
		\item A implementation of push\_back in \texttt{std::vector} based on \texttt{std::unique\_ptr}. 
	
	\begin{lstlisting}[numbers=none]
		template <typename T>
		void vector<T>::push_back(const T& value){
			cout<<"call push_back"<<endl;
			if(index_>=capacity_){
				capacity_ *=2;
				cout<<"new capacity"<<endl;
				unique_ptr<int[]> temp = make_unique<T[]>(capacity_);
				T* ps = data.get();
				copy(ps, ps+capacity_, temp.get()); //That is content copy
				data = std::move(temp); //That is uni_pointer copy
			}
			data[index_] = value;
			index_++;
		}		
	\end{lstlisting}
	
		\item Reverse link list, recursive. In line 1, reference to pointer is OK, pointer to reference is illegal. use here to set \texttt{new\_head} value
	\begin{lstlisting}[frame=single, language=c++]	
		void rev(Node* pre, Node* head, Node* & new_head ){ 
			if(head == NULL){
				new_head = pre;
				return; //don't forgot return here. 
			}
			cout<<head->data<<" "<<endl;
			Node* next = head->next;
			head->next = pre;
			rev(head, next, new_head);
		}	
	\end{lstlisting}
	
	
		\item Fast and slow pointer in linklist.	
	\begin{lstlisting}[frame=single, language=c++]	
		while (fast_ptr != NULL && fast_ptr->next != NULL) {
			fast_ptr = fast_ptr->next->next;	
			/*We need previous of the slow_ptr for linked lists with odd elements */
			prev_of_slow_ptr = slow_ptr;
			slow_ptr = slow_ptr->next;
		}
		
		/* fast_ptr would become NULL when there are even elements in list.And not 
		NULL for odd elements. We need to skip the middle node for odd 
		case and store it somewhere so that we can restore the original list*/
		if (fast_ptr != NULL) {
			midnode = slow_ptr;
			slow_ptr = slow_ptr->next;
		}		
	\end{lstlisting}
	
	\item \textbf{try you best to write zero bug code}
	
\begin{lstlisting}
A fun(B)   //must have return type
{
	C;      //must have ;
	return //must have return statment
}	

class A{
	public: //must have public, private
};  //must have ; here.
\end{lstlisting}

	\item double pointers, remove 0

\begin{lstlisting}
int arr[8]= {1, 2, 0, 2, 0, 3, 0, 4};

int i , j = 0;
while(j<8){
	if(arr[j] == 0){
		i = j;
		break;
	}
	j++;
}

while(j<8){
	if(arr[j]!=0){
		std::swap(arr[i], arr[j]);     
		i++;
	}
	j++;
}
\end{lstlisting}



	
\item BFS

\begin{lstlisting}
int matrix[3][3] = {{1,2, 3},
	{4, 5, 6},
	{7, 8, 9}};

int used[3][3];  //if this node has been visited.

	
	for(int i = 0;i<3;i++)
		for(int j = 0;j<3;j++)
			used[i][j] = 0;
	
	queue<pair<int, int> > q;
	cout<<matrix[0][0]<<endl;
	used[0][0] = 1;
	q.push(make_pair(0,0));
	while(!q.empty()){
		auto node = q.front();
		q.pop();              //All the nodes in queue have been visited. 
		auto i = node.first;
		auto j = node.second;
		
		if(i<2 && used[i+1][j] == 0){  //before push to queue, need to judge if visited.
			
			cout<<matrix[i+1][j]<<endl;  //push and visit, that is the BFS requirement.
			used[i+1][j] = 1;
			q.push(make_pair(i+1, j));
		}
		if(j<2 && used[i][j+1] == 0)
		{
			cout<<matrix[i][j+1]<<endl;
			used[i][j+1] = 1;
			q.push(make_pair(i, j+1));
		}
		if(i>0 && used[i-1][j] == 0)
		{   
			cout<<matrix[i-1][j]<<endl;
			used[i-1][j] = 1;
			q.push(make_pair(i-1, j));
		}
		if(j>0 && used[i][j-1] == 0)
		{
			cout<<matrix[i][j-1]<<endl;
			used[i][j-1] = 1;
			q.push(make_pair(i, j-1));
		}
	}

\end{lstlisting}

\item dfs
\begin{lstlisting}
	stack<pair<int, int> > s;
	s.push(make_pair(0,0));
	while(!s.empty()){
		auto node = s.top();
		auto i = node.first;
		auto j = node.second;
		if(used[i][j]!=1){   //different with BFS,  dfs also need to check if visited before visit
			cout<<matrix[i][j]<<endl;
			used[i][j] = 1;
		}
		if(i<2 && used[i+1][j] == 0)   //use if else, in the last, use pop
			s.push(make_pair(i+1, j));
		else if(j<2 && used[i][j+1] == 0)  // just like pre order traversal, first left tree, then right tree.
			s.push(make_pair(i, j+1));
		else if(i>0 && used[i-1][j] == 0)
			s.push(make_pair(i-1, j));
		else if(j>0 && used[i][j-1] == 0)
			s.push(make_pair(i, j-1));
		else
			s.pop();
		
	}
	return 0;
	
\end{lstlisting}

\item best sell problem, 

\begin{lstlisting}
std::array<int, 9> arr = {2, 3, 8, 100, 20, 1, 1, 2, 1 };
std::unordered_map<int, int> dic;
for(auto e: arr)
{
	dic[e]++;  //don't need find
}

std::vector< std::pair<int, int> > data( dic.begin(), dic.end() );  //build vector directly.

std::partial_sort( data.begin(), data.begin()+2, data.end(), [](auto &e1, auto &e2){return e1.second>e2.second;}); 
                                       //use lambda to descend order. 

for(auto &e: data){
	cout<<e.first<<"--->"<<e.second<<endl;
}	
\end{lstlisting}


\item k small number, use maxium heap(default)
\begin{lstlisting}
	
	std::priority_queue<int> pq;
	for(auto e: arr){
		if(pq.size()<3){
			pq.push(e);
		}
		else if(pq.top()>e){
			pq.push(e);
			pq.pop();
		}
	}
	
	while(pq.size()>0){
		cout<<pq.top()<<endl;
		pq.pop();
	}
	
\end{lstlisting}

\item FCU
\begin{lstlisting}
	
\end{lstlisting}



\begin{enumerate}
	\item binary search
	\item BFS
	\item DFS
	\item slide windows
	\item DP
\end{enumerate}

\end{itemize}

\chapter{project}
\begin{itemize}
	\item drop of knowledge C++, sixth edition. includes all modern C++ 17/20 features. Such as move semantic,  smart pointer, concurrency, brace initialization and generic programming. 
	
	\item A compiler project. Intermediate representation, Whirl to LLVM. 
	
	\item A Trade Repository or Swap Data Repository is an entity that centrally collects and maintains the records of over-the-counter (OTC) derivatives. CFTC. Commodity Futures Trading Commission.   Athena is a cross-asset platform transforming technology at JP Morgan. It delivers innovative and efficient applications to a wide range of the firm's businesses, including sales, trading, operations, risk and research. Athena combined the best of open source technologies
	
	\item There are two main types of RFID tags: battery-operated and passive. 
	
	
	\item Tell me about a time you worked hard at something but the end result was unsuccessful. Why? What did
	you learn?
	
	UH64 is a C++ compiler with its own intermediate representation (IR) called WHIRL. Clang, a highly successful commercial C++ compiler, uses LLVM as its IR. My role in the project was to convert WHIRL to LLVM. The goal was to extend LLVMs support for more CPUs while leveraging WHIRLs optimizations in certain areas, combining the strengths of both.
	
	The main challenge was the large codebase, which consists of 4 million lines of code. To address this, I focused primarily on the IR domain. I also used a powerful IDE called Understand, which helps analyze source code quickly and efficiently.
	
	\item What was the most demanding or time-consuming project or initiative in your recent work experience?
	
	We need to submit reports to the CFTC within 15 minutes, or we face a fine of \$15 per transaction. Initially, we used a single server for this task, but due to the volatility of the FX market, which is influenced by politics, we decided to deploy an additional server.
	
	The reporting system is developed in Python, but since Python doesnt handle concurrency well, we implemented multiprocessing. To manage synchronization, we also used a database. Additionally, we developed algorithms to make the system scalable, similar to a simple Kubernetes setup.
	
	The results were positive. Each year, the CFTC provides a statistical report on all major banks, and JPMorgan ranked number one, with 98\% of transactions being reported within 15 minutes.
	
	\item Can you tell me how you discovered a hidden requirement or non-obvious outcome in a recent project?
	
	move the bar to open the lid. But the bar 
	
	\item Share an example of when you changed a design approach because of someone elses input/better idea?
	
	
	
	
	\item Can you describe a time when you were stuck on a project or solution?
	
	Double-free errors are very challenging to debug, especially in embedded applications. I attempted to use tools like Valgrind, but it wasnt supported in this environment. I also tried implementing a custom new operator, but it wouldnt compile successfully.
	
	After reviewing the source code, I discovered that both processes were using the same thread pool. I resolved the issue by switching to a shared\_ptr, which fixed the memory problem. I was stuck on this for almost two weeks, but now I feel very confident in handling any memory-related issues, even in highly constrained environments.
	
	
	\item In the most recent case where a team member suggested a change that you disagreed with, what steps did
	you take to reach a resolution?
	
	I will develop a test case to approve my stand point view. Stop talking, Show me the source code. 
	
	\item Vizio was acquired by Walmart and is currently undergoing a transformation, outsourcing technical work to offshore teams while focusing on the advertising business. Ive been moved to developing GUI apps and interfaces, which doesnt allow me to fully use my skills in low-level algorithms and C++. Thats why Im looking for a new position.
	
	\item My wife is a resident doctor undergoing training at a hospital in Dallas. This is a rare opportunity and a family decision.
	
	\item I have expert-level knowledge of C/C++ and have published a book on C++ and you can purchase it from amazon website. I hold a Ph.D. and have a patent in algorithms, which enables me to handle complex algorithmic and machine learning challenges. I have experience working on a C++ compiler, giving me a strong understanding of optimization and machine code. I have many years of experience, including extensive teamwork and CI/CD expertise. Im familiar with the entire software development process and tools, essentially making me a full-stack developer. 
	
	
\end{itemize}

\iffalse

\chapter{Summary}

\section{tree}
\begin{itemize}
	
\item 1 traverse 

2



3//

\item     

\item 



\begin{lstlisting}
	// 
	void traverse(TreeNode root) {
		if (root == null) {
			return;
		}
		// 
		int leftMax = maxDepth(root.left);  //
		int rightMax = maxDepth(root.right);
		int myDiameter = leftMax + rightMax;
		// 
		maxDiameter = Math.max(maxDiameter, myDiameter);
		
		traverse(root.left);
		traverse(root.right);
	}
\end{lstlisting}

\item  =  +  + 

\item  BST

\item 	   


\item   BST  BST 



 

	
\end{itemize}

\section{dc}
\begin{itemize}
	\item   labuladon    	
\end{itemize}

\begin{itemize}

\section{other}
\begin{itemize}
	\item 	 
	
	\item 	
	
	\item   set, clear, toggle, check  clear  
	
	\begin{lstlisting}
		int msb = 0;
		n = n / 2;
		while (n != 0) {
			n = n / 2;
			msb++;
		}
	\end{lstlisting}

\item slow, fast remove unique.  copy, slow1. partition  copy, swap. 
	\begin{lstlisting}
int removeDuplicates(int[] nums) {
	if (nums.length == 0) {
		return 0;
	}
	int slow = 0, fast = 0;
	while (fast < nums.length) {
		if (nums[fast] != nums[slow]) {
			slow++;
			//  nums[0..slow] 
			nums[slow] = nums[fast];
		}
		fast++;
	}
	//  + 1
	return slow + 1;
}
	\end{lstlisting}

	\begin{lstlisting}
	int removeElement(int[] nums, int val) {
		int fast = 0, slow = 0;
		while (fast < nums.length) {
			if (nums[fast] != val) {
				nums[slow] = nums[fast];
				slow++;
			}
			fast++;
		}
		return slow;
	}
\end{lstlisting}

\end{itemize}
	

\section{greed}
\begin{itemize}

\item 7 1  2 

3   left and right.
\begin{lstlisting}
if (left <= intv[0] && right >= intv[1]) {
	res++;
}
// 
if (right >= intv[0] && right <= intv[1]) {
	right = intv[1];
}
// 
if (right < intv[0]) {
	left = intv[0];
	right = intv[1];
}
\end{lstlisting}
4) , 
\begin{lstlisting}
res.append(intervals[0])

for i in range(1, len(intervals)):
	curr = intervals[i]
	# res 
	last = res[-1]
	if curr[0] <= last[1]:
		#  end
		last[1] = max(last[1], curr[1])
	else:
		# 
		res.append(curr)
return res
\end{lstlisting}

5)  clips[0][1]

[0, T] -1

6 
\begin{lstlisting}
while i < len(A) and j < len(B):
a1, a2 = A[i][0], A[i][1]
b1, b2 = B[j][0], B[j][1]
# 
if b2 >= a1 and a2 >= b1:
	#  res
	res.append([max(a1, b1), min(a2, b2)])
	# 
	if b2 < a2: j += 1
	else:       i += 1
\end{lstlisting}

\end{itemize}
	
\section{template code}
	\item 
\begin{lstlisting}
	/*  */
	void slidingWindow(string s, string t) {
		unordered_map<char, int> need, window;
		for (char c : t) need[c]++;
		
		int left = 0, right = 0;
		int valid = 0; 
		while (right < s.size()) {
			// c 
			char c = s[right];
			// 
			right++;
			// 
			...
			
			/*** debug  ***/
			printf("window: [%d, %d)\n", left, right);
			/********************/
			
			// 
			while (window needs shrink) {
				// d 
				char d = s[left];
				// 
				left++;
				// 
				...
			}
		}
	}
\end{lstlisting}
	
	\item BFS, DFS template code
	\item dp, inorder, reverse order and diaginal traverse
	
	\item why palindrome and matrix need two dimension array. 
\begin{lstlisting}
for(int l = 2; l<n ; l++)
	for(int i = 0; i<n -1;i++)
	   int j = 1+i-1 ...
\end{lstlisting}
	
	\includegraphics[scale=0.25]{pics/dp.drawio.png}
	
	
	\item merge
\begin{lstlisting}
 // 
private static int[] temp;

public static void sort(int[] nums) {
	// 
	temp = new int[nums.length];
	// 
	sort(nums, 0, nums.length - 1);
}

//  nums[lo..hi] 
private static void sort(int[] nums, int lo, int hi) {
	if (lo == hi) {
		// 
		return;
	}
	//  (hi + lo) / 2
	int mid = lo + (hi - lo) / 2;
	//  nums[lo..mid] 
	sort(nums, lo, mid);
	//  nums[mid+1..hi] 
	sort(nums, mid + 1, hi);
	// 
	merge(nums, lo, mid, hi);
}

//  nums[lo..mid]  nums[mid+1..hi] 
private static void merge(int[] nums, int lo, int mid, int hi) {
	//  nums[lo..hi] 
	//  nums
	for (int i = lo; i <= hi; i++) {
		temp[i] = nums[i];
	}
	
	// 
	int i = lo, j = mid + 1;
	for (int p = lo; p <= hi; p++) {
		if (i == mid + 1) {
			// 
			nums[p] = temp[j++];
		} else if (j == hi + 1) {
			// 
			nums[p] = temp[i++];
		} else if (temp[i] > temp[j]) {
			nums[p] = temp[j++];
		} else {
			nums[p] = temp[i++];
		}
	}
}
}
\end{lstlisting}

	\item uf code, use recursive find is very tricky :)
\begin{lstlisting}
	class UF {
		// 
		private int count;
		// 
		private int[] parent;
		
		// n 
		public UF(int n) {
			this.count = n;
			parent = new int[n];
			for (int i = 0; i < n; i++) {
				parent[i] = i;
			}
		}
		
		//  p  q 
		public void union(int p, int q) {
			int rootP = find(p);
			int rootQ = find(q);
			
			if (rootP == rootQ)
			return;
			
			parent[rootQ] = rootP;
			// 
			count--;
		}
		
		//  p  q 
		public boolean connected(int p, int q) {
			int rootP = find(p);
			int rootQ = find(q);
			return rootP == rootQ;
		}
		
		public int find(int x) {
			if (parent[x] != x) {
				parent[x] = find(parent[x]);
			}
			return parent[x];
		}
		
		// 
		public int count() {
			return count;
		}
	}
\end{lstlisting}


	\item    . base case

\begin{lstlisting}
	vector<vector<int> > matrix;
	matrix.resize(m);
	for(auto &e : matrix)
		e.resize(n, 0);
\end{lstlisting}

	\item  1) hash list 2) FV  -> hash  hash list LRU LFU. 
	
	\item , 1) () + , 2) ()
	
	\item dummy node
	
	\item  
\begin{lstlisting}
	//  (i, j) 
	void dfs(char[][] grid, int i, int j) {
		int m = grid.length, n = grid[0].length;
		if (i < 0 || j < 0 || i >= m || j >= n) {
			// 
			return;
		}
		if (grid[i][j] == '0') {
			// 
			return;
		}
		//  (i, j) 
		grid[i][j] = '0';
		// 
		dfs(grid, i + 1, j);
		dfs(grid, i, j + 1);
		dfs(grid, i - 1, j);
		dfs(grid, i, j - 1);
	}
}
\end{lstlisting}

\item  \% 
\begin{lstlisting}
int[] arr = {1,2,3,4,5};
int n = arr.length, index = 0;
while (true) {
	// 
	print(arr[index % n]);
	index++;
}

int[] nextGreaterElements(int[] nums) {
	int n = nums.length;
	int[] res = new int[n];
	Stack<Integer> s = new Stack<>();
	// 
	for (int i = 2 * n - 1; i >= 0; i--) {
		//  i 
		while (!s.isEmpty() && s.peek() <= nums[i % n]) {
		s.pop();
	}
	res[i % n] = s.isEmpty() ? -1 : s.peek();
	s.push(nums[i % n]);
}
return res;
}
\end{lstlisting}

\fi

\begin{itemize}
	
\item C++ does not offer a collection template with the behavior that would mimic Java's LinkedHashMap<K,V>, so you would need to maintain the order separately from the mapping.

This can be achieved by keeping the data in a std::list<std::pair<K,V>>, and keeping a separate std::unordered\_map<k,std::list<std::pair<K,V>>::iterator> map for quick look-up of the item by key:

\begin{enumerate}
	\item On adding an item, add the corresponding key/value pair to the end of the list, and map the key to the iterator std::prev(list.end()).
	
	\item On removing an item by key, look up its iterator, remove it from the list, and then remove the mapping.
	
	\item On replacing an item, look up list iterator from the unordered map first, and then replace its content with a new key-value pair.
	
	\item On iterating the values, simply iterate std::list<std::pair<K,V>>.
\end{enumerate}

	
\end{itemize}




\ifx \allfiles \undefined
%\end{CJK*}
\end{document}
\fi
