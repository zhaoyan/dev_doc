% !Mode:: "TeX:UTF-8:Soft"
%\ifx \allfiles \undefined
\documentclass[a4paper,12pt,twoside]{book}
%\usepackage{CJKutf8}
\usepackage[T1]{fontenc}
\usepackage{pifont}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{capt-of}
\usepackage{color}
\usepackage{amsmath}
\usepackage{enumitem}

\newcommand{\linuxcommand}[1]{\texttt{\textcolor{blue}{\$ #1 \Pisymbol{psy}{191}}}}
\newcommand{\op}[1]{\textcolor{blue}{-#1}}
\newcommand{\hotkey}[1]{\framebox{#1}}
\newenvironment{screen}{\sffamily}{\rmfamily}
\newcommand{\tabincell}[2]{\begin{tabular}{@{}#1@{}}#2\end{tabular}}

\setitemize[1]{itemsep=0pt,partopsep=0pt,parsep=1pt,topsep=0pt}
\setenumerate[1]{itemsep=0pt,partopsep=0pt,parsep=1pt,topsep=0pt}
\setdescription{itemsep=0pt,partopsep=0pt,parsep=1pt,topsep=0pt}

\definecolor{mygray}{rgb}{0.96,0.96,0.96}
\lstset{ 
	backgroundcolor=\color{mygray},
	mathescape=true,
	frame=single,
	frameround=tttt,
	language=python,
	basicstyle=\footnotesize,
	%literate={\ \ }{{\ }}1
	tabsize=2,
	numbersep=6pt,
	breaklines=true,
	%framextopmargin=0.5em,
	%framexbottommargin=0.5em,
	morecomment=[s][\color{red}]{/*-}{*/},
	%escapeinside={//*}{*//},
	numberstyle=\tiny\textit,
	stepnumber=1,
	numbers=left
}

\begin{document}
%\begin{CJK*}{UTF8}{song}
\bibliographystyle{plainnat}
\title{Drop of knowledges of Python}
\author{Yan Zhao}
\date{}\maketitle

%\else
%\chapter{\ab}
%\fi

	
\chapter{Basic Syntax} 
\begin{table}[h!]
	\centering
	\begin{tabular}{|l|l|l|}
		\hline
		\textbf{Aspect} & \textbf{C++} & \textbf{Python} \\
		\hline
		Design Style & Generic \& Performance-focused & Object-oriented \& Readable \\
		\hline
		Sorting & Algorithm outside container & Method inside container \\
		\hline
		Flexibility & High control with iterators & High simplicity with methods \\
		\hline
		Typing System & Statically typed & Dynamically typed \\
		\hline
		Usage Focus & System-level, fine-grained control & High-level, developer-friendly \\
		\hline
	\end{tabular}
	\caption{Philosophical Differences Between C++ and Python}
\end{table}

\section{built-in type}

All built-in types are:
\begin{itemize}
	\item Numeric: int, float, complex
	
	\item Sequence: str, list, tuple, range. Range is not a function, but a class.
	
	\item set and dict
	
	\item Binary type: bytes, bytearray and memoryview
	
	item None type
\end{itemize}
Immutable sequenece: tuple, str and bytes. mutable sequences: list, bytearray, array.array, collections.deque,, and memoryview.
 
Parallel assignment (also called multiple assignment or unpacking assignment) in Python lets you assign multiple variables at once in a single line, using tuple/list unpacking.

\begin{lstlisting}
x, y, z = 1, 2, 3

a, b = 5, 10
a, b = b, a

coords = (3, 4)
x, y = coords

a, *b = [1, 2, 3, 4]
print(a)  # 1
print(b)  # [2, 3, 4] and b is list
\end{lstlisting}
	
Container sequences are list, tuple, and collections.deque. They can hold different type. Flat sequences are: str, bytes, bytearray, memoryview and array.array. They can only hold the same type. 
	
con.index(e), con.count(e) are two useful method for list and tuple class. In C++, we use std::find and std::count to implement this function. 

\subsection{list and tuple}

In Python code, line breaks are ignored inside pairs of [], \{\}, or ().
So you can build multiline lists, listcomps, tuples, dictionaries, etc.,

Listcomps do everything the map and filter functions do, without the contortions of the functionally challenged Python lambda.

\begin{lstlisting}
beyond_ascii = [ord(s) for s in symbols if ord(s) > 127]
[162, 163, 165, 8364, 164]

#use filter and map function below.
beyond_ascii = list(filter(lambda c: c > 127, map(ord, symbols)))
\end{lstlisting}

Listcomps can build lists from the Cartesian product of two or more iterables.
\begin{lstlisting}
colors = ['black', 'white']
sizes = ['S', 'M', 'L']
tshirts = [(color, size) for color in colors for size in sizes]
\end{lstlisting}

Genexps use the same syntax as listcomps, but are enclosed in parentheses rather than brackets. If the generator expression is the single argument in a function call, there is no need to duplicate the enclosing parentheses.

\begin{lstlisting}
>>> tuple(ord(symbol) for symbol in symbols)
(36, 162, 163, 165, 8364, 164)
>>> import array
>>> array.array('I', (ord(symbol) for symbol in symbols))
array('I', [36, 162, 163, 165, 8364, 164])
\end{lstlisting}

The *rest syntax in assignment unpacking collects remaining values into a list.  This is different from function parameters, where *args becomes a tuple.

\begin{lstlisting}
a, b, *rest = range(5) #rest is list

def fun(a, *rest):
	print(type(rest))
	print(rest)
fun(1, 2, 3, 4) # rest is tuple. 
\end{lstlisting}

nested unpacking

\begin{lstlisting}
l = ['a', (2, 3)]
a, (b, c) = l # a, b, c = l will report error here.
print(b)
\end{lstlisting}

	s.sort() will sort items in place in list, it with key and reverse. built-in sorted() will return new list
\begin{lstlisting}[frame=single, language=Python]
list1.sort(key=len, reverse = true)
newlist = sorted(list1)
\end{lstlisting}  


First of all, unlike other languages, both lists and tuples in Python support negative indexing. -1 represents the last element, -2 represents the second-to-last element, and so on.

\begin{lstlisting}[frame=single, language=Python]
l = [1, 2, 3, 4]
l[-1]  #4
\end{lstlisting}  

Slice is left close, right open, just like range in C++, that is very important to remember.
\begin{lstlisting}[frame=single, language=Python]
for x in range(len(l)-1, -1, -1) #iterate from end to beginning.
\end{lstlisting}  

list and tuple can be transformed each other.
\begin{lstlisting}[frame=single, language=Python]
list((1, 2, 3))
[1, 2, 3]

tuple([1, 2, 3])
(1, 2, 3)
\end{lstlisting}  

tuple is more efficient 
\begin{lstlisting}[frame=single, language=Python]
l = [1, 2, 3]
l.__sizeof__() #64

tup = (1, 2, 3)
tup.__sizeof__() #48
\end{lstlisting}  

\begin{tabular}{|c|c|c|}
	\hline
Python	& C++  &  \\
	\hline
pop/append	& push\_back/pop\_back  &  \\
	\hline
insert/del	& insert/erase &  \\
	\hline
remove	& remove &  \\
	\hline
sort & std::sort  &  \\
	\hline
sorted	& std::sort\_copy &  \\
	\hline
len	& size &  \\
\hline
reverse	& reverse &  \\
\hline
\end{tabular}
 
\begin{itemize}
	\item If you're unsure whether to use the del statement or the pop() method, here's a simple rule of thumb: if you want to delete an element from a list and won't use it in any way afterward, use the del statement; but if you want to continue using the element after deleting it, use the pop() method.
\end{itemize}


There's a strong culture of tuples being for heterogeneous collections, similar to what you'd use structs for in C, and lists being for homogeneous collections, similar to what you'd use arrays for. But I've never quite squared this with the mutability issue mentioned in the other answers. Mutability has teeth to it (you actually can't change a tuple), while homogeneity is not enforced, and so seems to be a much less interesting distinction.

\subsection{set and dict}

In Python 3.7 and above, dictionaries are guaranteed to be ordered (Note: In Python 3.6, the ordered behavior of dictionaries is an implementation detail, and it wasn’t officially a language feature until 3.7. Therefore, in 3.6, the order cannot be guaranteed 100\%). Before Python 3.6, dictionaries were unordered. Their size is dynamic, and elements can be freely added, removed, or modified.

Use below ways to create a dictionary and set. 
\begin{lstlisting}
d1 = {'name': 'jason', 'age': 20, 'gender': 'male'}
d2 = dict( {'name': 'jason', 'age': 20, 'gender': 'male'} )
d3 = dict([('name', 'jason'), ('age', 20), ('gender', 'male')])
d4 = dict(name='jason', age=20, gender='male') 
d1 == d2 == d3 ==d4
True

s1 = {1, 2, 3}
s2 = set([1, 2, 2, 3]) # use set constructor
s1 == s2
True
\end{lstlisting}

	set also use \verb|{}|, but it just include one element, not like dict, include colon and two items. 
	
	s.remove, s.discard(e) has different way to deal with non existing element. 


Atomic immutable types are all hashable, a tuple is hashable only if all its items are hashable. A frozen set is hashable. 

\begin{lstlisting}
d = {'b': 1, 'a': 2, 'c': 10}
d_sorted_by_key = sorted(d.items(), key=lambda x: x[0]) # 
d_sorted_by_value = sorted(d.items(), key=lambda x: x[1]) # 
d_sorted_by_key
[('a', 2), ('b', 1), ('c', 10)]
d_sorted_by_value
[('b', 1), ('a', 2), ('c', 10)]
\end{lstlisting}

\subsection{String and number}

In Python, there is no distinct char type like in C or C++. Instead, Python treats a single-character as a string too.

If you're working with characters (e.g., converting to/from Unicode), you can use: \texttt{ord('A') → 65} (get Unicode code point) and \texttt{chr(65) → 'A'} (get character from code point)

In Python, strings can be defined using single quotes, double quotes, or triple quotes, and there is no difference in meaning between them. Triple-quoted strings are typically used for multi-line string scenarios. 

Strings in Python are immutable (except for the '+' concatenation operation in newer Python versions, which is an exception). Therefore, arbitrarily changing the value of characters within a string is not allowed. 
\begin{lstlisting}
s = 'hello'
s[0] = 'H'
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment

s = 'H' + s[1:]
s = s.replace('h', 'H')

str1 += str2  # str1 = str1 + str2
\end{lstlisting}

\begin{lstlisting}
len(str(3.14159).replace('.', ''))
\end{lstlisting}

Since Python 2.5+, string concatenation has become much more efficient, so you can use it with confidence. 

String formatting using string.format is often used in situations like output and logging. If you don't have any fined requirement about format, you can use f"output\{var\}". 

\begin{lstlisting}
'Hello, {0}, improved {1:.1f}%'.format('Yan', 17.125)
\end{lstlisting}


\subsection{binary}

In c++, read binary use char array, but in python, we use bytes or bytearray.

\begin{table}[h!]
	\centering
	\begin{tabular}{|p{0.2\textwidth}|p{0.4\textwidth}|p{0.4\textwidth}|}
		\hline
		\textbf{Feature} & \textbf{bytes} & \textbf{bytearray} \\
		\hline
		Mutability & Immutable & Mutable \\
		\hline
		Type & \texttt{<class 'bytes'>} & \texttt{<class 'bytearray'>} \\
		\hline
		Use Case & Suitable for constant binary data & Suitable for binary data that needs to be modified \\
		\hline
		Syntax & \texttt{b'hello'} or \texttt{bytes([104, 101, 108, 108, 111])} & \texttt{bytearray(b'hello')} or \texttt{bytearray([104, 101, 108, 108, 111])} \\
		\hline
		Memory Efficiency & Slightly more memory efficient & Slightly more memory for mutability overhead \\
		\hline
		Support for Methods & Most string-like methods (excluding mutating ones) & Similar methods plus mutating ones like \texttt{append()}, \texttt{pop()}, etc. \\
		\hline
	\end{tabular}
	\caption{Comparison of \texttt{bytes} and \texttt{bytearray} in Python}
\end{table}

\section{operator}
Difference between = and is.
\begin{lstlisting}
x = [1, 2, 3]
y = x
z = [1, 2, 3]

print(x is y)  # True - same object
print(x is z)  # False - same content, but different objects
print(x == z)  # True - values are equal
\end{lstlisting}


Dividing any two numbers always results in a floating-point number, even if both numbers are integers and the division is exact.

Two for means multiply. if you want to combine, use zip function. 
\begin{lstlisting}[frame=single, language=Python]	
a = ['a', 'b', 'c']
b = [1,2,c]

c = {x:y for x, y in zip(a,b)}
c	{'a': 1, 'c': 3, 'b': 2}

c = {x:y for x in a for y in b} #c is dict, so only 'a': 3 is valid, 'a':1
# is overwritten.
C	{'a': 3, 'c': 3, 'b': 3}	
\end{lstlisting} 

Slice is built-in type. it only can be used in \verb|[], __getitem__()|.  [start:stop] includes start index, but excludes stop index. It does not mean “start at 1 and take 3 elements” — that’s a common misunderstanding.


\section{loop and if}
Use is None to judge if it's None

\begin{tabular}{|c|c|}
	\hline
string 	&  empty string is False\\
	\hline
int	& 0 is False  \\
	\hline
Bool	&  \\
	\hline
list/tuple/list/dict	& empty \\
	\hline
object	&  None is False, \\
	\hline
	
\end{tabular}


How to use index and value at the same time.
\begin{lstlisting}
l = [1, 2, 3, 4, 5, 6, 7]
for index in range(0, len(l)):
	if index < 5:
		print(l[index])        

l = [1, 2, 3, 4, 5, 6, 7]
for index, item in enumerate(l):
	if index < 5:
		print(item)  
\end{lstlisting}

It’s important to know that the range() function is implemented directly in C, so calling it is very fast. On the other hand, in a while loop, the operation i += 1 is indirectly executed through Python’s interpreter, which calls the underlying C implementation. Moreover, this seemingly simple operation involves object creation and deletion—because i is an integer and integers are immutable, i += 1 is essentially equivalent to i = new int(i + 1).Therefore, it's clear that a for loop is more efficient in comparison.	


\begin{lstlisting}
i = 0
while i < 1000000: 
	...
	i += 1
	
for i in range(0, 1000000):
	...
\end{lstlisting}

for and if at the same line, if you have else, put it in front, if no else, put after for.

\begin{lstlisting}
for item in iterable:
if condition:
	expression1
else:
	expression2	
	
expression for item in iterable if condition
expression1 if condition else expression2 for item in iterable

y = [value * 2 + 5 if value > 0 else -value * 2 + 5 for value in x]

text = ' Today,  is, Sunday'
text_list = [s.strip() for s in text.split(',') if len(s.strip()) > 3]
print(text_list)
['Today', 'Sunday']
\end{lstlisting}

ZeroDivisionError NameError and TypeError, three most used exceptions.

In this code, the try block attempts to read the file file.txt and perform a series of operations on its data. In the end—whether the file is read successfully or an error occurs—the program will execute the statements in the finally block, which closes the file stream to ensure the file’s integrity. Therefore, the finally block is typically used to place statements that must be executed no matter what.

\begin{lstlisting}
import sys
try:
	f = open('file.txt', 'r')
	.... # some data processing
except OSError as err:
	print('OS error: {}'.format(err))
except:
	print('Unexpected error:', sys.exc_info()[0])
finally:
	f.close()
\end{lstlisting}

\section{magic method}
For example, the statement for i in x actually causes the invocation of
iter(x), which in turn may call x.\_\_iter\_\_() if that is available, or use \_\_getitem\_\_().

Normally, your code should not have many direct calls to special methods. Unless
you are doing a lot of metaprogramming

The \_\_repr\_\_ special method is called by the repr built-in to get the string representation
of the object for inspection. Without a custom \_\_repr\_\_, Python’s console
would display a Vector instance <Vector object at 0x10e100070>.

Basically, bool(x) calls x.\_\_bool\_\_() and uses
the result. If \_\_bool\_\_ is not implemented, Python tries to invoke x.\_\_len\_\_(), and
if that returns zero, bool returns False. Otherwise bool returns True.

\_\_str\_\_ is called by str() and implicitly used by the print function. \_\_repr\_\_is called by repr() built-in. 
	
no custom \_\_str\_\_, then will call \_\_repr\_\_ as fallback. 
		
\section{Advance feature}
\subsection{Generator expression}

\textbf{Here’s the key point to remember: a generator is the lazy version of an iterator.} Any time you return back a list, you can use yield to replace

\begin{lstlisting}
def index_normal(L, target):
	result = []
	for i, num in enumerate(L):
		if num == target:
		result.append(i)
	return result

print(index_normal([1, 6, 2, 4, 5, 2, 8, 6, 3, 2], 2))

########## output ########## [2, 5, 9]
\end{lstlisting}

\begin{lstlisting}
def index_generator(L, target):
	for i, num in enumerate(L):
		if num == target:
			yield i

print(list(index_generator([1, 6, 2, 4, 5, 2, 8, 6, 3, 2], 2)))

########## output ########## [2, 5, 9]
\end{lstlisting}


Generator expression allows creating a generator on a fly without a yield keyword. However, it doesn’t share the whole power of generator created with a yield function. The syntax and concept is similar to list comprehensions:

\begin{lstlisting}[frame=single, language=Python]
list_comp = [x ** 2 for x in range(10) if x % 2 == 0]
gen_exp = (x ** 2 for x in range(10) if x % 2 == 0)

print(list_comp)
[0, 4, 16, 36, 64]
	
print(gen_exp)
<generator object <genexpr> at 0x7f600131c410>  
\end{lstlisting}  
	
		
listcomp is meant to do one thing: to build a new list
generator expression can also be used to build tuple and array.

\begin{lstlisting}
def is_subsequence(a, b):
	b = iter(b)
	return all(i in b for i in a)

print(is_subsequence([1, 3, 5], [1, 2, 3, 4, 5]))
print(is_subsequence([1, 4, 3], [1, 2, 3, 4, 5]))

########## output ##########
True
False
\end{lstlisting}

\subsection{name}

Roughly speaking, namespaces are just containers for mapping names to objects. 
	
From module import * will not import  any variable \_x. \_\_X\_\_ is system varaible, has specific meaning to interpreter. 

The LEGB rule in Python defines the scope resolution order — how Python looks up variable names. It stands for:
	\begin{enumerate}
		\item Local can be inside a function or class method.
		
		\item Enclosed can be its enclosing function, e.g., if a function is wrapped inside another function.
		
\begin{lstlisting}
def outer():
	x = 20  # Enclosing scope
	def inner():
		print(x)
\end{lstlisting}
		\item Global refers to the uppermost level of the executing script itself, and
		
		\item Built-in are special names that Python reserves for itself.
\begin{lstlisting}
len = 5  # Overrides built-in temporarily
print(len("abc"))  # Error
\end{lstlisting}
	\end{enumerate}

\begin{lstlisting}[frame=single, language=Python]
a_var = 'global value'

def outer():
	a_var = 'local value'
	print('outer before:', a_var)
	def inner():
		nonlocal a_var
		a_var = 'inner value'
		print('in inner():', a_var)
	inner()
	print("outer after:", a_var)

>>>outer()
outer before: local value
in inner(): inner value
outer after: inner value
	\end{lstlisting}  
	
The CPython implementation uses a special optimization for local variables: They aren't dynamically looked up at runtime from a dictionary, as globals are, but rather are assigned indices statically at compile time, and are looked up by index at runtime, which is a lot faster. This requires the Python compiler to be able to identify all local names at compile time, which is impossible if you have a wildcard import at function level.
\begin{lstlisting}[frame=single, language=Python]
g = 1
def fun():
	print g # this will cause error. 
	g = 2
	print g
	
fun()
print g
	
# output 
2  # create a local name g
1
\end{lstlisting}
	
In practice, it is usually a bad idea to modify global variables inside the function scope, since it often be the cause of confusion and weird errors that are hard to debug. If you want to modify a global variable via a function, it is recommended to pass it as an argument and reassign the return-value.
\begin{lstlisting}[frame=single, language=Python]
a_var = 2

def a_func(some_var):
return 2**3

a_var = a_func(a_var)
print(a_var)
\end{lstlisting} 

\begin{lstlisting}[frame=single, language=Python]
MIN_VALUE = 1
MAX_VALUE = 10
def validation_check(value):
	global MIN_VALUE
	...
	MIN_VALUE += 1
	...
	
validation_check(5)
\end{lstlisting} 

\begin{lstlisting}
def outer():
	x = "local"
	def inner():
		nonlocal x # nonlocal means x is outer defined x
		x = 'nonlocal'
		print("inner:", x)
	inner()
	print("outer:", x)
	
outer()
#output
inner: nonlocal
outer: nonlocal
\end{lstlisting}
	
For class and function, L and G are different, but for module, L and G are same.

For local, The locals are exposed there by the built-in locals() and vars() functions. \textbf{The locals should be considered a read-only namespace, as there is no language guarantee that changes you make to it directly will actually be applied.}


You can control global namespace inside a function.
\begin{lstlisting}[frame=single, language=Python]
X = 2
def fun():
	global X
	X = 44
	Y = 55
	globals()['Y'] = 3
	
>>>print(X,Y) # output 44 3
\end{lstlisting}  

Warning: For-loop variables “leaking” into the global namespace. That is why global variable should name by global\_*** to avoid conflict with local name. They all follow snake\_case style.
\begin{lstlisting}[frame=single, language=Python]
b = 1
for b in range(5):
	if b == 4:
		print(b, '-> b in for-loop')
	
print(b, '-> b in global')

>>>4 -> b in for-loop
4 -> b in global
\end{lstlisting}  

Regardless of the code block, the globals are exposed there by the built-in globals() function. 
\begin{lstlisting}[frame=single, language=Python]
global_var1 = 123
def f2():
	fc = 3
	fd = 4
	print(globals())
	print(locals())
\end{lstlisting}  
	
For some code blocks, like function and class bodies, the globals and locals are distinct; and the locals are inaccessible from outside that code block. For other code, like modules, they are the same thing (and thus equally accessible). With exec(), you can pass both in, thus controlling the distinction.

If you want to access them at the same time, you can:
\begin{lstlisting}[frame=single, language=python]
X = 99
def selector():
     import __main__   # import enclosing module
     print __main__.X  # qualify to get to global version of name
     X = 88            # unqualified X classified as local
     print X           # prints local version of name

>>> selector()
99
88
\end{lstlisting} 


\subsection{import and module}
\subsubsection{builtin}
\begin{itemize}
	\item builtins is conception for module.
	\item relationship between builtins and \_\_builtins\_\_, A good explanation is "What's the deal with \_\_builtins\_\_ vs \_\_builtin\_\_" link address is \begin{verbatim}
	http://mathamy.com/whats-the-deal-with-builtins-vs-builtin.html \end{verbatim}
	\item Why use builtin, we can add a name to builtin,  so in all the other modules, you can use it.
\end{itemize}
\subsubsection{dir an dict}
\begin{itemize}
	\item dir includes \_\_dict\_\_
	\item not all instance has \_\_dict\_\_. Some internal type use slot instead. 
	\item A good introduction is "whats-the-biggest-difference-between-dir-and-dict-in-python"
\end{itemize}

\begin{itemize}
	\item search path. modify sys.path dynamiclly. 
%#	\item sys.path的组成部分：（1）程序的主目录；（2）PYTHONPATH目录（如果已经进行了设置）；（3）标准链接库目录；（4）任何.pth文件的内容（如果存在的话） 
	\item import/from copies names but doesn't link.
	\item think it as a name space
	\item it just import once, then fetch imported module object
	\item package is different with module, you just put module into the different path to avoid name conflict. but you need to put \_\_init\_\_.py file in each path. 
	\item If you put code before the function definitions, it will execute before the \_\_name\_\_ check.
\begin{lstlisting}[frame=single, language=python]
print("This code executes before main.") 

def functionA():
	print("Function A")

def functionB():
	print("Function B")

if __name__ == '__main__':
functionA()
functionB()
	\end{lstlisting} 
If this module is indeed being used as the main script, this code results in:

This code executes before main. 
Function A 
Function B
If this module was imported instead of used as the main script, you get the following at import time:

This code executes before main. 

\end{itemize}

\begin{lstlisting}[frame=single, language=python]
gl = [1,2,3]
def fun():
	print gl
	gl[1] = 33
	print gl

fun()
print gl gl   ag 
# output 
[1,2,3]
[1,33,3]
[1,33,3]
\end{lstlisting}  

blow gl = [] will cause gl point to a local variable. so the first print gl will cause error.in order to correct this error, you need to use global declare

\begin{lstlisting}[frame=single, language=python]
gl = [1,2,3]
def fun():
	o = [4,5,6]
	def infun():
		o = [] # create a local name o
		o.append(1)
		print o  yan zhao
	print o

fun()
print gl
# output 
[1]
[4,5,6]
[1,2,3]
\end{lstlisting}  

\begin{lstlisting}[frame=single, language=python]
gl = [1,2,3]
def fun():
	o = [4,5,6]
	def infun():
		o = [] # create a local name o
		o.append(1)
		return o
	o = infun()
	print o

fun()
print gl
# output 
[1]
[1,2,3]
\end{lstlisting}  


\begin{lstlisting}[frame=single, language=python]
gl = [1,2,3]
if True:
	ol = [4,5,6]
	if True:
		ol = []
		gl = []
	print ol
	print gl
# output 
[]
[]
\end{lstlisting}  

\begin{itemize}
		\item reference always work, it will look for name from inside to outside.
		\item for immutable object, such as int. you only can use assignment. for mutable object, such as list, if you use assignment. result will be seen below item
		\item assignment will create a new name, if you want to modify outside, you need to global or make function return.
		\item for mutalbe object, if you use list[0] = 'change'. then it will modify outside object.
		\item gint = 3 will always create local name. list =[] will create local name, list[0] = 'change' will modify outside object.
		\item for if while block, will not create local name, always modify outside. 
\end{itemize}

\section{module}

By default, the Python interpreter searches the current directory, all built-in modules, and installed third-party modules. The search paths are stored in the path variable of the sys module:

\begin{lstlisting}
import sys
>>> sys.path
['', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', ...
\end{lstlisting}

We can import modules using absolute or relative paths. 

In large-scale projects, modularization is very important, and modules should be referenced using absolute paths, which start from the root directory of the program.

Also, remember to make good use of if
\begin{lstlisting}
__name__ == '__main__' 
\end{lstlisting}
to prevent code from being executed during an import.

\section{reference}

Put mutable items in tuples is not a good idea.

Different with C++, The key different is if the value is immutable.
\begin{lstlisting}
a = 1
b = a
a = a + 1

# b is 1, but a is 2. 

a-->1
-------------------
a-->1
b--/
-------------------
a-->2
    1
b--/
----------------------
\end{lstlisting}

Remember that arguments are passed by assignment in Python. Since assignment just creates references to objects, there’s no alias between an argument name in the caller and callee, and so no call-by-reference per Se
\begin{lstlisting}
def my_func1(b):
	b = 2  # 2 is value, not a variable.

a = 1
my_func1(a)
a  # a is still 1
\end{lstlisting}

\begin{lstlisting}
def my_func2(b):
	b = 2
	return b

a = 1
a = my_func2(a)
a #a is 2 now
\end{lstlisting}

\begin{lstlisting}
def my_func4(l2):
l2 = l2 + [4]

l1 = [1, 2, 3]
my_func4(l1)
l1 # l1 is still [1, 2, 3]
\end{lstlisting}

\begin{lstlisting}
def my_func5(l2):
l2 = l2 + [4]
return l2

l1 = [1, 2, 3]
l1 = my_func5(l1)
l1 #l1 is [1, 2, 3, 4]
\end{lstlisting}

Today, we learned about Python variables and the basic principles of assignment, and we also explained how parameter passing works in Python. Unlike other languages, Python’s parameter passing is neither pass-by-value nor pass-by-reference; instead, it is assignment passing, or more precisely, \textbf{object reference passing.}


It’s important to note that this assignment or reference passing does not refer to a specific memory address, but rather to a specific object. If the object is mutable, then when it changes, all variables referencing that object will reflect the change. If the object is immutable, a simple assignment will only change the value of one variable, while the others remain unaffected.


With this understanding, if you want to change the value of a variable through a function, there are generally two ways to do it. One is to pass a mutable data type (like a list, dictionary, or set) as an argument and modify it directly. The second is to create a new variable to store the modified value and then return it to update the original variable. In practice, we tend to prefer the second approach because it is clearer and less error-prone.


Assignment creates references, Not copies
\begin{lstlisting}[frame=single, language=Python]
	l = [1,2,3]
	m = ['a',L, 'b'] #shallow copy
	m1 =['a',L[:], 'b'] #deep copy
\end{lstlisting}  

Immutable Types can't be changed. 
\begin{lstlisting}[frame=single, language=Python]
	t=(1,2,3)
	t[2] = 4 # error
	t = t[:2] + (4,)  # OK
\end{lstlisting}  
Same value vs. Same object
\begin{lstlisting}[frame=single, language=Python]
	L1 = [1,2,3]
	L2 = [1,2,3]
	L1==L2  #True
	L1 is L2 #False
\end{lstlisting}  

there are three kind of "copy"
\begin{lstlisting}[frame=single, language=Python]
	L1 = [1,2,3]
	L2 = L1
	L2 = L1[:]
\end{lstlisting}  

You can use the builtin list.copy() method (available since python 3.3):
\begin{lstlisting}[frame=single, language=Python]
	new_list = old_list.copy()
\end{lstlisting}  
You can slice it:
\begin{lstlisting}[frame=single, language=Python]
	new_list = old_list[:]
\end{lstlisting}  
You can use the built in list() function:
\begin{lstlisting}[frame=single, language=Python]
	new_list = list(old_list)
\end{lstlisting}  
You can use generic copy.copy(): This is a little slower than list() because it has to find out the datatype of old\_list first.


\begin{lstlisting}[frame=single, language=Python]
	import copy
	new_list = copy.copy(old_list)
\end{lstlisting}  


If the list contains objects and you want to copy them as well, use generic copy.deepcopy():

\begin{lstlisting}[frame=single, language=Python]
	import copy
	new_list = copy.deepcopy(old_list)
\end{lstlisting}
Obviously the slowest and most memory-needing method, but sometimes unavoidable.

\section{Application}
\begin{itemize}
	\item for file, can read, readline and readlines, for output, only write.
	
	\item json
\begin{lstlisting}
import json

params = {
	'symbol': '123456',
	'type': 'limit',
	'price': 123.4,
	'amount': 23
}

with open('params.json', 'w') as fout:
params_str = json.dump(params, fout)

with open('params.json', 'r') as fin:
original_params = json.load(fin)

print('after json deserialization')
print('type of original_params = {}, original_params = {}'.format(type(original_params), original_params))

########## output ##########

after json deserialization
type of original_params = <class 'dict'>, original_params = {'symbol': '123456', 'type': 'limit', 'price': 123.4, 'amount': 23}	
\end{lstlisting}
	
	\item For python, you can use below code to see if it support wide-unicode.
\begin{lstlisting}[frame=single, language=python]
import sys
print(sys.maxunicode) 
1114111-->support wide-unicde.
65535 --> support usct	
\end{lstlisting} 	
	
	\item --enable-unicode=usc2 or usc4 is gone in Python 3.x. You now only have the choice to use the default (which is UCS2) or switch on the optional support for UCS4 by using --with-wide-unicode.
	
	\item blender --background --python script.py or blender --background --python-console
	
	\item re of python, pay attention to r'...'.
\begin{lstlisting}[frame=single, language=python, mathescape=false]
import re
re.match(r'^\d{3}\-\d{3,8}$', '010-12345'), 

re.split(r'\s+', 'a b   c')
['a', 'b', 'c']
\end{lstlisting} 

	\item re of c++, use a function to do this job. regex\_match
\begin{lstlisting}[frame=single, language=c++]
string s1 = "ab123cdef"; //
string s2 = "123456789"; //
regex ex("\\d+"); //

cout << s1 << " is all digit: " << regex_match(s1, ex) << endl; 
cout << s2 << " is all digit: " << regex_match(s2, ex) << endl; 
\end{lstlisting} 

	
\end{itemize}

\chapter{Array of sequences}
Container sequences: Can hold items of different types, including nested containers. Some examples:
list, tuple, and collections.deque.
Flat sequences: Hold items of one simple type. Some examples: str, bytes, and array.array.

\begin{lstlisting}
array('d', [1.2, 3.3, 4.5]) #just hold bytes, integers and floats
\end{lstlisting}

\chapter{function}
\section{basic}
\begin{itemize}
	\item Function in python are first-class objects.
	\begin{enumerate}
		\item created at runtime
		\item assigned to a varaible or element in a data structure
		\item passed as an argument to a function
		\item returned as the result of a function.
	\end{enumerate}
	\item 
\end{itemize}
\begin{lstlisting}
def my_func(message):
	print('Got a message: {}'.format(message))

my_func('Hello World')  #Got a message: Hello World
\end{lstlisting}

As mentioned earlier, one of the key differences between Python and other languages is that Python is dynamically typed, meaning it can accept any data type (integers, floats, strings, etc.). This also applies to function parameters.

For example, take the my\_sum function we just discussed—we can also pass in lists as arguments to concatenate them:
\begin{lstlisting}
def my_sum(a, b): 
	return a + b	
	
print(my_sum('hello ', 'world'))
\end{lstlisting}

Generally speaking, when we want to perform operations on elements in a collection, and the operations are relatively simple—such as addition or accumulation—we prefer to use functions like map(), filter(), reduce(), or list comprehensions.

\begin{itemize}
	\item As for choosing between the two approaches: when dealing with large amounts of data, such as in machine learning applications, we tend to favor functional programming expressions because they are more efficient. 
	
	\item When the data volume is small and you want your code to be more Pythonic, list comprehensions are also a good choice.
	
	\item However, if you need to perform more complex operations on the elements, for the sake of readability, we usually opt for a for loop, as it makes the logic clearer and easier to understand.
	
\end{itemize}


decorate, usually has two returns. 
\begin{lstlisting}
def log(func):
	def wrapper(*args, **kw):
		print('call %s():' % func.__name__)
		return func(*args, **kw)
	return wrapper
	
@log
def now():
	print('2024-6-1')
	
now = log(now) #above sytax sugar is just this statement
\end{lstlisting}

	A better version of log
\begin{lstlisting}
import functools

def log(func):
	@functools.wraps(func)
	def wrapper(*args, **kw):
		print('call %s():' % func.__name__)
		return func(*args, **kw)
	return wrapper
\end{lstlisting}

	Anonymous functions have a limitation: they can only contain a single expression. There's no need to write return—the result of the expression is automatically returned.
	
	An example of partial function
\begin{lstlisting}
import functools
int2 = functools.partial(int, base=2)
int2('1000000')	
\end{lstlisting}

\chapter{class}
\section{basic}

	
	But what if we want to restrict the attributes of an instance? For example, we only want to allow name and age attributes to be added to a Student instance.
	
	To achieve this restriction, Python allows us to define a special variable called \_\_slots\_\_ when defining a class. This limits the attributes that instances of the class can have:
\begin{lstlisting}
class Student(object):
	__slots__ = ('name', 'age') # use tuple here
\end{lstlisting}
	


\section{magic method}



\section{class attributes}
\begin{itemize}
	
	\item A good example is "Python Class Attributes: An Overly Thorough Guide" \verb!https://www.toptal.com/python/python-class-attributes-an-overly-thorough-guide!
\end{itemize}

\begin{lstlisting}
class MyClass:
class_var = "I am a class variable"

def __init__(self, instance_var):
self.instance_var = instance_var

@classmethod
def class_method(cls):
print(f"Class variable: {cls.class_var}")
# Can modify class variable:
cls.class_var = "Modified class variable"
return cls() # Can be used as a factory method

@staticmethod
def static_method(arg):
print(f"Static method called with: {arg}")
# Cannot access or modify class/instance variables directly

# Example Usage
obj = MyClass("I am an instance variable")

# Calling class method
new_obj = MyClass.class_method() 
print(MyClass.class_var)

# Calling static method
MyClass.static_method("Hello")
obj.static_method("World")
\end{lstlisting}

\begin{lstlisting}
class MyNumber:
	def __init__(self, value):
		self.value = value
	
	def __add__(self, other):
		if isinstance(other, MyNumber):
			return MyNumber(self.value + other.value)
		return NotImplemented
	
	def __radd__(self, other):
		return MyNumber(self.value + other)
	
	def __repr__(self):
		return f"MyNumber({self.value})"


a = MyNumber(10)
print(a + MyNumber(5))   # MyNumber(15) calls __add__
print(5 + a)             # MyNumber(15)  calls __radd__
print(a + 5)             # TypeError  __add__ returned NotImplemented and int doesn't know MyNumber
\end{lstlisting}





\chapter{meta}
\begin{itemize}
	\item There are two importants meta methods, customize class creation, and customize attribute access and set. 
	\item Heck, attributes are fundamental to everything in Python. The sooner you understand what attributes are, and how they work, the sooner you’ll have a deeper understanding of Python
	\item In other words, the dot notation that we use in Python all of the time is nothing more than syntactic sugar for “getattr”. Each has its uses; dot notation is far easier to read, and “getattr” gives us the flexibility to retrieve an attribute value with a dynamically built string.
\begin{lstlisting}[frame=single, language=python]
getattr(t, '__class__')
t.__class__
\end{lstlisting} 
	\item 
	
\end{itemize}
\section{descriptor}
\section{reference}
\begin{itemize}
	\item The magic behind Attribute Access in Python, \verb|https://codesachin.wordpress.com/2016/06/09/the-magic-behind-attribute-access-in-python/|
	introduces Attribute acess magic
	\item Another good article is  Understanding Python metaclasses \verb|https://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/#object-attribute-lookup|
	\item Python Types and Objects \verb|http://www.cs.utexas.edu/~cannata/cs345/Class%20Notes/15%20Python%20Types%20and%20Objects.pdf|. It tell two sides of type and object,  object is both a class and type. when it's a class, it's parent class of type. When it's instance, it's instance of type. 
\end{itemize}

\chapter{test}
\begin{lstlisting}
def add(a, b):
	"""
	Returns the sum of a and b.
	>>> add(2, 3)
	5
	>>> add(-1, 1)
	0
	"""
	return a + b
	
python -m doctest your_script.py # run test case in comment.
\end{lstlisting}

\chapter{GUI}

\chapter{useful module}
\section{re}
If you want to catch some specific part, you can use catch and match. 
\begin{lstlisting}
#config_add_or_set_int("SCAN_INTRVL_BLE", val);

re2 = re.compile(r'config_add_or_set_int\("([A-Z_]+)')
match2 = re2.search(y)
if(match2):
	print(match2.group(1)) # print SCAN_INTRVL_BLE
\end{lstlisting}


findall return list and is very useful function in re.
\begin{lstlisting}
text = "Hello, world!"
matches = re.findall(r'\W', text)
print(matches) #output , ' ' and !
\end{lstlisting}

\begin{lstlisting}
import re

text = "User_123 logged in."
matches = re.findall(r'\w+', text)
print(matches)  # User_123 logged in
\end{lstlisting}

\section{other}
\begin{itemize}
	\item collections has namedtuple function, can return named tuple class
\end{itemize}

\chapter{python and c++}
1) value, reference and reference count
2) copy and deepcopy
3) RAII
4) collection, range, iterate and iterable
5) lazy range, itertools(python) and views(C++)
6) functional: lambda, std::function in C++, decorator and partial in python
7) I/O and memory I/O
8) serialization and deserialization 
9) thread and coroutine
\begin{lstlisting}
	import itertools
	
	nums = range(10)
	evens = filter(lambda x: x % 2 == 0, nums)
	squares = map(lambda x: x * x, evens)
	
	print(list(squares))  # [0, 4, 16, 36, 64]
	
	
	/////////////////C++
	#include <iostream>
	#include <ranges>
	#include <vector>
	
	int main() {
		auto nums = std::views::iota(0, 10);
		auto evens = nums | std::views::filter([](int x) { return x % 2 == 0; });
		auto squares = evens | std::views::transform([](int x) { return x * x; });
		
		for (int x : squares) {
			std::cout << x << " ";  // 0 4 16 36 64
		}
	}	
\end{lstlisting}




%\ifx \allfiles \undefined
%\bibliography{../book}
%\end{CJK*}
\end{document}
%\fi
