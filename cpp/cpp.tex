% !Mode:: "TeX:UTF-8:Hard"
\documentclass[a4paper,11pt,twoside]{book}
%\documentclass[paper=8.5in:11in,pagesize=pdftex]{book}
%\usepackage{CJKutf8}
\usepackage[T1]{fontenc}
\usepackage{pifont}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{longtable}
\usepackage{capt-of}
\usepackage{color}  
%\usepackage[paperwidth=8.5in, paperheight=11in]{geometry}

%\usepackage[margin=1.1in]{geometry}
\usepackage[a4paper,left=2cm,right=2cm,top=3cm,bottom=3cm,]{geometry}
%\usepackage[pass]{geometry}

\newcommand{\linuxcommand}[1]{\texttt{\textcolor{blue}{\$ #1 \Pisymbol{psy}{191}}}}
\newcommand{\op}[1]{\textcolor{blue}{-#1}}
\newcommand{\hotkey}[1]{\framebox{#1}}
\newenvironment{screen}{\sffamily}{\rmfamily}

% for C/C++ frame box
\usepackage{listings}
\definecolor{mygray}{rgb}{0.96,0.96,0.96}

\lstset{ 
	backgroundcolor=\color{mygray},
	mathescape=true,
	frame=single,
	frameround=tttt,
	language=c++,
	basicstyle=\footnotesize,
	%literate={\ \ }{{\ }}1
	tabsize=2,
	numbersep=6pt,
	breaklines=true,
	%framextopmargin=0.5em,
	%framexbottommargin=0.5em,
	morecomment=[s][\color{red}]{/*-}{*/},
	%escapeinside={//*}{*//},
	numberstyle=\tiny\textit,  stepnumber=1,
	numbers=left,
}


\def\numdot{}
\ifdefined\numdot % false so skip to matching 
	\usepackage{totcount}
	\newcounter{maxlstnumber}
	\regtotcounter{maxlstnumber}
	\def\updatemaxlstnumber{%
		\ifnum\value{lstnumber}>\value{maxlstnumber}%
		\setcounter{maxlstnumber}{\the\value{lstnumber}}%
		\fi%
	}
	\newlength{\MaxSizeOfLineNumbers}%
	\makeatletter
	% The following command allows you to customize line number style, without affecting \ref{}.
	% Here, the style is "\thelstnumber." (with a dot at the end)
	\def\renderlstnumber{\normalfont\lst@numberstyle{\thelstnumber.}\kern\lst@numbersep}
	\def\lst@PlaceNumber{\updatemaxlstnumber\makebox[\MaxSizeOfLineNumbers][r]{\renderlstnumber}}
	\makeatother
\fi


%\def\pdfbook{}

\ifdefined\pdfbook
	\newcommand{\Hilight}[1]{\makebox[0pt][l]{\color{yellow}\rule[-3pt]{#1em}{11pt}}}
	\newcommand{\HilightLine}[2][yellow]{\makebox[0pt][l]{\color{#1}\rule[-4pt]{#2em}{13.9pt}}}
	\newcommand{\tophline}{\hline }
	\newcommand{\bottomhline}{\\ \hline }
	\newcommand{\ecline}{\cline }
\else
	\newcommand{\Hilight}[1]{}
	\newcommand{\HilightLine}[2][yellow]{}
	\newcommand{\tophline}{ }
	\newcommand{\bottomhline}{ }
	\newcommand{ \ecline }{}
\fi


\newcommand{\specialcell}[2][c]{%
  \begin{tabular}[#1]{@{}l@{}}#2\end{tabular}}

%\addtolength{\oddsidemargin}{-.375in}
%	\addtolength{\evensidemargin}{-.375in}
%	\addtolength{\textwidth}{1.25in}

%	\addtolength{\topmargin}{-.375in}
%	\addtolength{\textheight}{1.75in} 



\begin{document}
%\begin{CJK*}{UTF8}{song}
\title{Drops of knowledge of C++}
\author{Yan Zhao}
\date{}\maketitle

\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}
\tableofcontents

\chapter*{Preface}
\addcontentsline{toc}{chapter}{Preface}
This is the third edition, The first edition has almost 100 pages and the second one has 200 pages. Then guess what happen in the third edition? it has almost 300 pages now. \par \medskip

Bjarne Stroustrup, the creator of C++, said that modern C++  "feels like a new language". I totally agree with this view point. By now, modern C++ is quicker and safer. I love this language and want to spread it, teach more people to use it. That is the purpose of this book.  \par \medskip

I am a software developer, and have worked with C/C++ almost 30 years. I have published a very famous C language book "Drop of knowledge of C", and the link is:\\ \verb|http://product.dangdang.com/23340055.html.| I am able to provide C++ tutorial and training, online or onsite. please contact me if you need this kind of service.\par \par \medskip


The first edition is more like studying note than book, The third edition is more like book now. The book has three characters:
\begin{enumerate}
	\item \textbf{"Talk is cheap, Show me the code"}. OK, a lot of code. Just very short, concise description with each code block. You can even think that this is a book of source code, with some comment around it.
	
	\item \textbf{"A graph is Worth a 1000 Words"}. The book provides many graphs to help illustrate these complex conception.You can even see a figure on the cover of this book.
	
	\item \textbf{"Design is not how it looks, but how it works"}. The four chapters "pointer and smart pointer", "reference and rvalue reference", "OOP" and "Generic programming" introduce a lot of deep semantic knowledge in these field. You can learn not only language knowledge but also some design idea.
\end{enumerate}

\medskip

Compared with the third edition, The fourth edition added three chapters: functional programming, concurrent and style and guideline. Additionally, A lot of improvements on format and new contents on the existing chapter, specifically some new knowledge on the new C++ standard: C++20. \medskip  


I appreciate my two daughters: Millie and Ivy. C++ language will be still alive when you grow up.  Thank my wife Lina, you always said that writing a book was useless. You are right!. When husband says: "You are right!", the argument is over. When wife says: "you are right!", you are over. \par \par \medskip


Any suggestions and error reports are appreciated. You can contact me by: \\
Email          : \textbf{zhaoyan.hrb@gmail.com}  \\ 
Homepage       : http://zhaoyan.website  \\ 
Wechat account : zhaoyan\_rock   \\ 

I also have blog: http://zhaoyan.website/blog/. You can find some Chinese blogs there. 

\chapter*{How to?}
\addcontentsline{toc}{chapter}{How to}
\begin{itemize}
	\item \textbf{How to read this book in eReader?}
	\begin{enumerate}
		\item Because the book has a lot of source code. so it prefer to read the book in landscape mode. If you are using kindle, you can google how to read ebooks in landscape mode on kindle. 
		
		\item In some E-readers, such as kindle and ipad, the display in source code block sometimes get crowded togther. You can resolve this problems by doing:
		\begin{enumerate}
			\item Change to landscape mode to get wider screen.
			\item Decrease font size, until the source code can be displayed probably.
		\end{enumerate}
		
		\item If table is shown properly on the kindle, click the small icon below the table, then the whole table will be extracted and shown up in a separate page. 
		
		\item You can search keyword in the source code block.
		
		\item You can purchase the printed book from Amazon.com. Just search "Drops of knowledge of C++" in Amazon.com. Frankly speaking, I prefer to printed book for this kind of computer programming book, because we have spent so much time on screens.
		
		
	\end{enumerate}

	\item \textbf{How to run the source code?}
	\begin{enumerate}
		\item Most of source code can run directly. In order to save space, I omit the head files,so please add the required head files and \texttt{main} function when you run the source code.
		
		\item Most of source code illustrate the basic idea, so they are not long. You can use online C++ compiler. These light weight online tools are very suitable for the source code in the book. Just google "online C++ compiler" and select one with black background, because light abstracts bug. :)
	\end{enumerate}
	\item \textbf{Why some source code has line number on left side?}
	\begin{enumerate}
		\item If the source code has line number, below the source code you can see some explanation about the source code. These explanation refer to the line number and make you understand it more accurately.


		\item An example of source code:
\begin{lstlisting}
#include<iostream>
using namespace std:
int main(void){
	cout<<"hello world"<<endl;
	typedef HelloWorld<OutputPolicyWriteToCout, 
			LanguagePolicyEnglish> HelloWorldEnglish;
}
\end{lstlisting}
\begin{description}
	\item[Line 1:] Add more explanation about source code in line 1.
	\item[Line 3:] All the code has proper intent.
	\item[Line 4 and Line 5:] If the code is long, will add line break in the middle. 
	\item[Source code:] Tell the purpose of the whole code snippet.
	\item[Output:] The output of this code snippet if you run it.
\end{description}

		\item If the source code has not line number, Usually the source code doesn't need further description. In order to make the book more clear and clean, I omit the line number besides the source code.


	\end{enumerate}



\end{itemize}

\chapter{C++ Introduction}
\section{Overview}
\subsection{Multi-paradigm}
\begin{itemize}
	\item C++ is a Multi-paradigm language, there are five paradigms: 
	\begin{enumerate}
		\item Procedural programming. (Traditional C programming)
		\item Object-base programming. (Class and object)
		\item Object-orient programming. (Inheritance and polymorphism)
		\item Generic programming. (Template)
		\item functional programming.(Function object)
	\end{enumerate}
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.85\linewidth]{pics/whole.png}
		\caption{The main component of C++ language}
		\label{fig:whole}
	\end{figure}

\end{itemize}

\subsection{Statement and expression}
\begin{itemize}
	\item Statement and expression are two important conceptions, you can see their definition in cppreference.com to see academic explanation. Although these two conceptions are a little theoretic, a log of piratical knowledge and conceptions--xvalue, reference etc., are defined on these two conceptions. We need to understand them before we go deeper. 
	
	\item An expression is a sequence of operators and their operands, that specifies a computation. The general operators are assignment, increment, arithmetic, logical, comparison and member access.
\begin{lstlisting}[numbers=none]
a=b, a+=b  //assignment
++a, a++  //increment
a+b, a&b  //arithmetic
a&&b, !a  //logical
a<b, a!=b  //comarision
a[b], a->b, a.b  //member access
\end{lstlisting}
	
	\item Expression is different with statement. 
\begin{lstlisting} 
b=c;
a=b=c
\end{lstlisting}
\begin{description}
	\item[Line 1:] \texttt{b=c;} is statement, because it has semicolon after it. It represents an action-- assign a value to a variable.
	
	\item[Line 2:] \texttt{b=c} is expression, it yields value(\texttt{b}), then we can use this value for outside.
\end{description}


	\item For operator, there are two important characteristic: \textbf{Precedence} and \textbf{Associativity}. About Associativity, give an example below:
\begin{lstlisting}
a=b=c; //correct code
a<b<c; //error code
a<b && b<c //correct code
\end{lstlisting}

\begin{description}
	\item[Line 1:] assignment operator is \textbf{right-to-left}. It means that we 1)\texttt{b=c}, 2)\texttt{b=c} yields \texttt{b} 3) \texttt{a=b} 
	
	\item[Line 2:] logical operator is \textbf{left-to-right}. it means that 1)\texttt{a<b}, 2)\texttt{a<b} yields bool value 3) \texttt{bool<c}. That is error.code and not what you expect.  
	
	\item[Line 3:] That is correct expression.
\end{description}

	\item Function call is a expression, because it can yield a value.


	\item Statements are fragments of the C++ program that are executed in sequence. Only statement, which end with semicolon is executed.
	
	\item C++ mainly includes the following types of statement: 1) expression statement, 2) compound statement, 3)selection statement(\texttt{if, switch}), 4)iteration statement(\texttt{while, for}) and 5)Jump statement(\texttt{break,continue, return, goto}). Most statements are expression statements. 
\begin{lstlisting}[numbers=none]
int n = 1;               // declaration statement
n = n + 1;               // expression statement
std::cout << n << '\n'; // expression statement
return 0;               // return statement
\end{lstlisting}
	
\item Difference between statement and expression.
	\begin{enumerate}
		\item Expression: Something which evaluates to a value. Example: \texttt{1+2/x}
		\item Statement: A line of code which does something. Example: \texttt{GOTO 100;} and statements are all end with semi-comma.
	\end{enumerate}
	
	
	\item The designers of C realized that no harm was done if you were allowed to evaluate an expression and throw away the result. In C, every syntactic expression can be a made into a statement just by tacking a semicolon along the end:
	
\begin{lstlisting}[numbers=none]
x+y    //is expression;
x+y;   //is statement, but throw away the result
j=i;   //is a statement.
fun(i) //is expression;
\end{lstlisting} 

\end{itemize}


\section{Compilation and link}

\subsection{Separate compilation and header file}
\begin{itemize}
	\item Having only one source file for a large project is unrealistic, so we break the code up into its logical structure. In this way, only changed parts need to be recompiled, and reduce the compile time. When we use the multiple source file, each part needs to know what information about functions and variables "used" from other files. That is why we need declaring.
	
	\item Even you can declare variable, function and class many times, it's not good way to declare everywhere,\textbf{DO NOT copy declaration to the other positions in the other .cpp file. It will lead to many duplication.} If you modify it's name, you need to trace back all the declaration. If you need to use a function or variable in many different files, you should put them in a header filer. For example: export\_to.h for certain cpp source file or global.h file for the whole system.

	
	\item \textbf{In your project, you can global search function or variable declaration, if you find declaration statement more than two, It's strong indication to make a global head file and put these declaration statements into it.}
	
	\item When you write an single source file (.cpp, .cxx, etc),  your compiler generates a translation unit. That is to say, Each .cpp will become a translation unit. This is the object file from your source file plus all the headers you \#include in it.  A translation unit roughly consists of a source file after it has been processed by the \texttt{preprocessor}, meaning that header files listed in \#include directives are literally included, sections of code within \#ifdef may be included, and macros have been expanded.
	
	\item Basically, you should put each class definition into a single .cpp file, and make sure each .cpp file has a corresponding .h file.  If two classes are highly correlated, they maybe be put in the same .cpp file.
	
	\item If you just want a function or variable visible to only current translation unit. You can declare it as static. Or you can use unnamed namespace.  You don't need to put it into a header file.  Just remember in C++, you have to declare function and variable before you first use them. Different with C language, In C language, compiler will guess a function prototype from it's usage, but it's not good most of time.
	
	\item A better suggestion is to have a single global.h file for a complex system. Then put some common type, defined type, constant and global function in this single global.h file. So it will help to reduce duplication, just keep once appearance.
	
	\item Three main contents in header file:
	\begin{enumerate}
		\item "Everything" that should be exported (i.e., used in other files)
		
		\item "Nothing" that causes the compiler to immediately generate code
		
		\item Except, for a small number of exceptions. Such as const and inline function, which has \texttt{internal linkage.}
	\end{enumerate}
	
	\item Three rules about header file:
	
	\begin{enumerate}
		\item Use \textbf{\#pragma once} to add include guard, It's not standard, but It has been supported by many compiler. Including g++, clang and MSVC.
		
		\item \textbf{Put your local/private header file in front of system header file. }  Why? There are two advantages:
		\begin{enumerate}
			\item You can know what header file should be included, It's helpful to achieve the goal of demand.
			
			\item Sometimes, if you have your own function with same name as system or library, It can give you a compile error; Below example will give you a compile error. But if you put \texttt{<cmath>} before \texttt{myHead.h}. Then, main will use acos in cmath, and your acos will be override.
		\end{enumerate}
		
\begin{lstlisting}[numbers=none]
#include "myHead.h"  //double acos(double)
#include <cmath>
main{
	acos(0.5);
}
\end{lstlisting}
		
		\item You will need to put the minimal set of \#include statements that are needed to make the header compilable when your local/private header is included on the first place.  It will make your header file self-sufficient.
	\end{enumerate}
	
	\item In .h file, you can include template and inline function.  In fact, you have to put template into .h file. 
	
	\item \textbf{Putting a semicolon in the end of head file is good suggestion.} You also need semicolon after declare class. In .cpp file, no semicolon after each function definition.
	
	\item You can google "Advanced Software Engineering with C++ Templates".The first half part introduce separate compilation.
\end{itemize}

\subsection{Declaration and definition}
\begin{itemize}
	\item A declaration introduces an identifier and describes its type, be it a type, object, or function. \textbf{A declaration is what the compiler needs to accept references to that identifier.} 
	
\begin{lstlisting}
extern int bar;
extern int g(int, int);
double f(int, double);  //it is declaration.
class Foo; 
\end{lstlisting}
\begin{description}
	\item[Line 1:] Add extern keyword before variable name. It make it as declaration statement, not definition.
	
	\item[Line 3:] extern can be omitted for function declarations.
	
	\item[Line 4:] no extern allowed for type declarations.
\end{description}
	
	\item A definition actually instantiates/implements this identifier. It's what the linker needs in order to link references to those entities. These are definitions corresponding to the above declarations:

\begin{lstlisting}[numbers=none]
int bar;
int g(int lhs, int rhs) {return lhs*rhs;}
double f(int i, double d) {return i+d;}
class foo {}; //put {}; after calss definition.
\end{lstlisting}
	
	\item The difference between declaring a symbol and defining a symbol:
	\begin{enumerate}
		\item A declaration tells the compiler about the existence of a certain symbol and makes it possible to \textbf{refer to that symbol everywhere where the explicit memory address or required storage of that symbol is not required.}  A definition tells the compiler what the body of a function contains or how much memory it must allocate for a variable.
		
		\item One very important difference between declarations and definitions is that a symbol may be declared many times in different translating unit, but defined in on translating unit only once. For example, you can forward declare a function or class however often you want, but you may only ever have one definition for it. This is called the \textbf{One Definition Rule}.
	\end{enumerate}
	
	

\end{itemize}


\subsubsection{Forward declaration}
\begin{itemize}
	\item In C++, there exists the concept of forward declaring a symbol. We declare the type and name of a symbol so that we can use it where its definition is not required. There are three usages as below:
	\begin{enumerate}
		\item It will reduce compile-time dependencies --PIMPL.
		\item Hide all the detail. 
		\item Break cyclic references
	\end{enumerate}
	
\begin{lstlisting}[numbers=none]
// file.hpp
class C1;
class C2{
...
	C1* pc1;
}
\end{lstlisting}
\begin{description}
	\item[Line 2:] That is forward declaring.
\end{description}
	
	\item Forward declaration doesn't work if you need to build or access its member. It's only work when you refer it by pointer or reference.
\begin{lstlisting}[frame=single, language=c++]
class Foo; 
Foo* f1 = new Foo; //error,
	
fun(Foo* f1){
	f1->a;        //error,  
}
fun(Foo f1)       //error, 
\end{lstlisting}
\begin{description}
	\item[Line 2:]  You need \#include Foo.h, so compile can know all the size of Foo.
	
	\item [Line 5:] Compiler need to know if there is varaible a inside of Foo.
	
	\item [Line 7:] It's not pointer or reference type.
\end{description}
	
	\item About cyclic include, you need to know below:
	\begin{enumerate}
		\item You can't write the code below, because the compiler will not know the size of A and B. 
\begin{lstlisting}[numbers=none]
class A{
	B b;
}

class B{
	A a;
}
\end{lstlisting}
		\item Use pointer or reference to tackle cyclic dependent problem. But it still has include cyclic dependent problem. 
\begin{lstlisting}[numbers=none]
#include "b.h"
class A{
	B* b;
}
		
#include "a.h"
class B{
	A a;
}
\end{lstlisting}
		\item In the end, you can use forward declaration to remove \#include statement. 
\begin{lstlisting}[numbers=none]
//a.h file 
class B; 
class A{
	B* b;
}
\end{lstlisting}
	\end{enumerate}
	
	\item About pimpl, you need to know below:
	\begin{enumerate}
		\item In you .h file, when you use \texttt{Foo* p} or \texttt{Foo\& rp}; You don't need include Foo.h file. you can use forward declaration.
\begin{lstlisting}[numbers=none]
class Foo; //forward declaration
......
Foo* p; //use it, but only define a pointer.
\end{lstlisting}
		
		\item Base on previous forward declaration, you can use "Pimpl" idiom.
\begin{lstlisting}[numbers=none]
class Widget { // "widget.h" file
	private:
	struct Impl; // forward declaration
	Impl* pImpl;
};
		
#include "Foo.h"  // widget.cpp file, include Foo.h
struct Widget::Impl {
	Foo f1;
};
\end{lstlisting}
		
		\item Pimpl Idiom is one of \texttt{std::unique\_ptrs} most common use cases. But just like using raw pointer,  you can't avoid definine destructor even you have used \texttt{std::unique\_ptr}. 
		
\begin{lstlisting}
// widget.h file
class Widget { 
	Widget::~Widget()
	
private:
	struct Impl; // Forward declaration.
	std::unique_ptr<Impl> pImpl;
};
		
//widget.cpp file
#include "Foo.h" 
struct Wideget::Impl{
	Foo fo; 
}
Widget::~Widget() = default; 
\end{lstlisting}
\begin{description}
	\item[Line 3:] If you don't decare here, compiler will produce by itself, In the end, it will call delete struct* pIm and struct* pIm is a uncomplete type(definition is still unvisible)
	
	\item[Line 15:]here, Widget's destuctor can see the whole Impl definition, so delete struct* pIm is legal now.
	
	\item[Line 17:]You don't need write ~Widget() by youself, using default one is enough.
	
	\item[Source code:] The more explanation can be seen in "effective modern C++ item 22". 
\end{description}

	\end{enumerate}
\end{itemize}

\subsection{Linkage}

\subsubsection{ODR}
\begin{itemize}
	\item For C language, there is tentative definition rule. You can define the same variable in two different .c file. The result will be undefined. But in the C++, this is not allowed any more. 
	
\begin{lstlisting}[numbers=none]
a.c
int g_i = 100;
////////////////////////////////
b.c
int g_i;
fun(){
	printf("%d",g_i) //will print 100
}
\end{lstlisting}
	\begin{description}
		\item[gcc:] (gcc a.c b.c) report no error. in b.c, if you write \texttt{g\_i= 2}; gcc reports error.
		\item[g++:] (g++ a.c b.c) reports error.
	\end{description}

	\item For C++ language, tentative definition of variable is not allowed. At the same time, multi-definition of function is not allowed either. but there are another implicit risk as below. 
	
	\item In the same unit, you can't define class C1 again, but if you put two class C1 in two different .cpp file. compiler will not complain at all. When you run you application probably crash, it's dangerous. It's a little different with function and global variable. Because function and global variable all need allocation memory.
	
	\item \textbf{Either a name is for everyone (and declared in a header file) or is translation-unit-local in an anonymous namespace.} Detail can be found in "The One-Definition Rule  Andrzej's C++ blog".
\end{itemize}

\subsubsection{external and internal linkage}
\begin{itemize}
	\item Duration and scope are two different conceptions in C++. there are three kinds of duration: \textbf{automatic, static and dynamic.} There are four kinds of scopes:
	\begin{enumerate}
		\item global.
		\item In C++, we can use namespace to add more scopes to divide global scope.
		\item file(translation unit).
		\item local, function local and class local. 
	\end{enumerate}

	\item Scope is a property handled by compiler, whereas linkage is a property handled by linker. There are two Linkages: Internal linkage and External linkage. Internal linkage refers to everything only in scope of a translation unit. External linkage refers to things that exist beyond a particular translation unit. In other words, accessible through the whole program, which is the combination of all translation units.
	
	\item Linkage refers only to elements that have addresses at link/load time; thus, class declarations and local variables have no linkage. Only global scope variable or function definition has external or internal linkage. 
	
	\item A few examples:
\begin{enumerate}
	\item non-const global variable has external linkage.
	\item Const global variables have internal linkage by default.
	\item Functions have external linkage by default.
	\item static global variable has internal linkage.
	\item \textbf{static function has internal linkage too.}
\end{enumerate}

	\item \textbf{const variables internally link by default} unless otherwise declared as \texttt{extern}. It means that:
	

	\begin{description}
		\item[Many copies:] You can put \texttt{const int g\_num = 10;} into a header file or global.h file. Then when you need g\_num, just include this header file into you .cpp and it will not cause redefine linkage error. 
		
		\item[One copy, global access:] You also can put \texttt{const int g\_num = 10;} in one .cpp file. then declare \texttt{extern const int g\_num ;} in global.h file. 
		
		\item[One copy, local access:] For const used just in one .cpp, use static and put it in the .cpp file.
	\end{description}
	
	\item When a definition has internal linkage, it means that:
	\begin{enumerate}
		\item you can put two same static variable name in two different .cpp file, no linkage error. (Each definition will has his own memory, \textbf{do don't apply it on the large object.})
		\item You can't access internal linkage definition from another .cpp file. 
		\item You can't use \texttt{extern} with \texttt{static}, but you can use \texttt{extern} with \texttt{const}.
\begin{lstlisting}[numbers=none]
//file.h:
extern const int a_global_var;

//file.c:
#include "file.h"
const int a_global_var = /*const expression */;
\end{lstlisting}
\end{enumerate}


\end{itemize}


\subsubsection{Inline function}
\begin{itemize}
	\item Usage of inline keyword is very simple: \textbf{No matter for member or non-member inline function, put it into the header file.}
	\begin{enumerate}
		\item For non member function, put inline function into a header file, and when you need to use this function, include it.
		
		\item For member function, you have two options.
\begin{lstlisting}[numbers=none]
class Foo {  //option 1
public:
void method(){...};  //Give definition here
};

class Foo {  //option 2
public:
	void method(); //Don't put inline keyword here
};
inline void Foo::method(){  //Put inline keyword here
	...
}
\end{lstlisting}
	\end{enumerate}
	
	\item Why do we need follow these two rules about inline funciton? The explanation is a little complex, so if you don't want go deeper, you can skip now. If you are confident and like facing challenge, lets continue.
	
	\item \textbf{Inline function has external linkage.} We demonstrate this point by below code. We have a.cpp and b.cpp two files.
\begin{lstlisting}
inline int foo() { //File a.cpp
	return 6;
}
void g() {
printf("foo called from g: return value = %d, address = %p\n", foo(), &foo);
}

inline int foo() { //File b.cpp
	return 12;
}
void g();
int main(){
	printf("foo called from main: return value = %d, address = %p\n", foo(), &foo);
	g();
}
\end{lstlisting} 
\begin{description}
	\item[Line 1 and 8 without inline:] it will trigger multi-definition linkage error
	\item[Line 1 and 8 one inline:] Only on inline, because inline has external linkage, so it will trigger multi-definition linkage error too.
	\item[Line 1 and 8 two inline:] Redefining an inline function with the same name but with a different function body is illegal; however, the compiler does not flag this as an error, but simply generates a function body for the version defined in the first file entered on the compilation command line, and discards the others. Therefore, may not produce the expected results.
	\item[Delete line 8 to 10:] Compiling error, identifier doesn't found.
	\item[Source code:]  Inline just suppress multi-definition error. It is programmer's responsibility to ensure that inline function definitions with the same name match exactly across translation units, to avoid all above bad result. You can see the best way is:put inline function into header file.
\end{description}

	\item Inline functions are defined in the header because, in order to inline a function call, the compiler must be able to see the function body. For a naive compiler to do that, the function body must be in the same translation unit as the call. (A modern compiler can optimize across translation units, and so a function call may be inlined even though the function definition is in a separate translation unit, but these optimizations are expensive, aren't always enabled, and weren't always supported by the compiler)
	
	\item Functions defined in the header must be marked inline because otherwise, every translation unit which includes the header will contain a definition of the function, and the linker will complain about multiple definitions (a violation of the One Definition Rule). The inline keyword suppresses this, allowing multiple translation units to contain (identical) definitions.
	
	\item In the end. No matter how you designate a function as inline, it is a request that the compiler is allowed to ignore: the compiler might inline-expand some, all, or none of the places where you call a function designated as inline. (Donâ€™t get discouraged if that seems hopelessly vague. The flexibility of the above is actually a huge advantage: it lets the compiler treat large functions differently from small ones, plus it lets the compiler generate code that is easy to debug if you select the right compiler options.)
\end{itemize}


\subsection{Combine C and C++}
\begin{itemize}
	
	\item C++ inherits basic data type, variable name, statement, expression, and operator, control flow, function, file, head file and library, array, pointer and structure from C language. C++ is superset of C, so any C programs can be compiled by C++.
	
	\item When you use g++,  \texttt{\_\_cplusplus} will be defined automatically. (you can't undef it in fact.) When you use C compiler, such as gcc, \texttt{\_\_cplusplus} is not defined. At the same time, When you use C++ compiler, such as g++ to compile a C file, although file extension is .c, but g++ still use name mangling to change function name.  The conclusion is based on g++ and gcc on Linux system. \textbf{compiler will decide if \texttt{\_\_cplusplus} is defined, not based on source file name extension}
	
	\item The C++ compiler must be used to compile main(), and must be used to direct the linking process. \textbf{Most of time, you want your C++ application to call some existing C functions}
	
	\item If you have c and cpp source files together, you can just use g++ compile them all. You don't need any \texttt{\_\_cplusplus} syntax.  g++ compiles all files using name mangling. (look them all as c++ files). At this time file extension doesn't play a role at all.
	
	\item If your C++ file want to use a c function. You don't have C function source code(It is in a lib or obj file) or you don't want to recompile it( it's a very big C library). At this time, you have three options:
	

\begin{lstlisting}[numbers=none]
extern "C"{  // method 1
	c_function(int);
}
	
extern "C"{  // method 2
	#include "old_C_header.h"
}
	
#ifdef __cplusplus  //method 3
extern "C" {
#endif
	Foo (int a, int b);
#ifdef __cplusplus
}
#endif
\end{lstlisting}
	\begin{description}
	\item[Line 1:] You can put function declaration in to \texttt{extern "C"} directly.
	\item[Line 5:] You can put a head file into the \texttt{extern "C"}.
	\item[Line 9:] If you can control the header file, you can use \texttt{\_\_cplusplus + extern "C"}. it will used both in C and C++ compiler.
\end{description}

	\item If you define a function in .cpp file(You have to use g++ to compile it), and this function will be used in legacy C system, you need to use \texttt{\_\_cplusplus + extern "C".}  You can give lib and head file to C system,  and then the C system can include head file and linked to lib.
	
	\item \textbf{In one word, if you have obj code produced by C or C++, When you want to linked it to different language, you should consider using \_\_cplusplus + extern "C" }
	
	\item Can a C function directly access data in an object of a C++ Class. Yes,but with some restriction. C++ class has no virtual base and virtual function. no access control. If you just want to pass a object from or to C function, you can refer a article in "C++ FAQ, 36.05". It demonstrate how to pass object from main to cppCallingC (C++ to C), then call cCallingC++(C to C++). Pay attention to points:
	\begin{enumerate}
		\item We pass the class pointer.
		\item we use the same header file, but use \texttt{\#ifdef \_\_cplusplus} to defines one class(used by C++) and one struct(used by C), and they have the same name.
	\end{enumerate}
	
	\item There are three occasions which you need to use \texttt{extern "C"}
	\begin{enumerate}
		\item When you want to produce a DLL or SO. Why, because maybe your DLL or SO will be used in both C language and C++ language. Or different compiler which uses different name mangling rule.
		
		\item When the code will be used by java or python.
		
		\item When used with legacy C code.
	\end{enumerate}
\end{itemize}









\chapter{type, operator and expression}

\section{Arithmetic types}
\subsection{Numerical}
\subsubsection{Numerical Overflow}

\begin{itemize}
	\item Integer type has \textbf{overflow} problem, and float has \textbf{precision} problem. So prefer to use \texttt{long long} and \texttt{double} as your numerical type. In mordern hardware, memory usage is not big concern, type with enough width can save you a lot of trouble. 
	
	\item In C and C++, you can use limits.h or <limit> to get the all the type limit information.
	
\begin{lstlisting}[numbers=none]
INT_MAX //use in C
INT_MIN
	
std::numeric_limits<int>::lowest() //use in C++
std::numeric_limits<int>::max()
\end{lstlisting}
	
	\item There are three ways to deal with overflow:
	\begin{enumerate}
		\item Build your own template function.
\begin{lstlisting}[numbers=none]
template <class T>
void increment_without_wraparound(T& value) {
	if (value < numeric_limits<T>::max())
	value++;
}
\end{lstlisting}
		
		\item  Judge it before calculation.
\begin{lstlisting}
if ((x > 0) && (a > INT_MAX - x)) // a + x would overflow 
if ((x < 0) && (a < INT_MIN - x)) // a + x would underflow

if ((x < 0) && (a > INT_MAX + x)) //a - x would overflow 
if ((x > 0) && (a < INT_MIN + x)) //a - x would underflow

if (a > INT_MAX / x)  // a * x would overflow 
if ((a < INT_MIN / x)) // a * x would underflow 
\end{lstlisting}
\begin{description}
	\item[Line 1:] a is point, x>0 clockwise turn, then it will overflow
	\item[Line 2:] a is point, x<0 anti-clockwise turn,  so it will underflow It's easy to understand if you draw a clock figure.
\end{description}
		
		\item Judge it after calculation
\begin{lstlisting}[numbers = none]
uint32 a,b;
uint32 result = a + b;
if (result < a) {
	//Overflow
}
\end{lstlisting}
\end{enumerate}
	
	
	\item There's no simple, general, portable way to avoid integer overflow.
	
	\item You cannot safely check whether a signed integer addition or subtraction overflowed after the fact. An overflow in signed arithmetic causes undefined behavior. Typically the result wraps around, but in principle your program could crash before you have a chance to examine the result.
	
	\item Clang 3.4+ and GCC 5+ offer checked arithmetic builtins. They offer a very fast solution to this problem, especially when compared to bit-testing safety checks.
\begin{lstlisting}[frame=single, language=c++]
unsigned long b, c, c_test;
if (__builtin_umull_overflow(b, c, &c_test)){
	// returned non-zero: there has been an overflow
}
\end{lstlisting}
	
\item When you do some calculation, you can have some tricks to avoid overflow. If you  want to know the last three digits of \texttt{n!}. You need use mod to keep last two digits in each calculation.
\begin{lstlisting}[numbers = none]
(a+b)/2  //a+b maybe overflow
a/2+b/2 +(a&b&1);
\end{lstlisting}

\end{itemize}

\subsection{Numerical conversions}

\begin{itemize}
	\item There are two kinds of conversion, one is \textbf{implicit}, and the other is \textbf{explicit}.
	\item Numerical conversions happen in three contexts:
	\begin{enumerate}
		\item Assign a value of one \textbf{arithmetic type} to a variable of another arithmetic type.
		
		\item Combine mixed types in expressions.(Most of time, implicit conversion)
		
		\item Pass arguments to or return from a function.
	\end{enumerate}
	\item convert short type to long type is promotion, it happens when we need hardware bit alignment optimization. See next section. 
\end{itemize}

\subsubsection{Implicit promotion}
\begin{itemize}
\item In an expression, C++ makes three kinds of automatic promotion conversion.
\begin{enumerate}
	\item Some type are automatically converted whenever they occur. For example, when you add char to char. C++ converts bool, char, unsigned char, signed char and short to int. Because int type is generally chosen to be the computer's most natural type. \textbf{It does calculations faster for that type.} It's called \textbf{integer promotions.}
	
	\item Some type are converted when they are combined with other types in an expression. When an operation involves two types, the smaller is converted to the larger. For example, when you add an int to a float, int is converted to float type. (You have to do it, because two types have the different inside binary representations.)
	
	\item unsigned short convert to int if short is shorter than int, if they have the same size. unsigned short convert to unsigned int.  So no data loss in promoting.
\end{enumerate}



\begin{lstlisting}[frame=single, language=c++, mathescape=true]
char c1, c2, c //c1 and c2 convert to int first.
c = c1+c2;  // then change int result back to char.
	
/*  LLVM IR code below
store i8 97, i8* %c1, align 1
store i8 2, i8* %c2, align 1
%0 = load i8, i8* %c1, align 1
%conv = sext i8 %0 to i32
%1 = load i8, i8* %c2, align 1
%conv1 = sext i8 %1 to i32
%add = add nsw i32 %conv, %conv1
%conv2 = trunc i32 %add to i8 */
	
i+f // i will promoted to f
	
float f1, f2, f
f = f1+f2 
\end{lstlisting}
\begin{description}
	\item[Last line:] whether f1 change to double debpends on compiler. clang++ has fadd in LLVM IR, so it doesn't change f to double.
\end{description}
\end{itemize}

\subsubsection{Implicit conversion}

\begin{itemize}
	\item Assigned to a bool, zero converts to false, and nonzero converts to true.
	
	\item Assigning a value to a type with a greater range usually poses no problem. If shorter range or different type, maybe there are some problems.
	
	\item When conversion, maybe lost precision(\texttt{double -> float, long long ->float}) loss fragment(\texttt{float -> i}) or Undefined (\texttt{int i = 666,} then \texttt{char c = i;}).
	
\begin{lstlisting}
int i, float f;
i=f;

f = i;
\end{lstlisting}
\begin{description}
	\item[Line 2:] fragment will be lost,  f= 3.99, i will be 3 (not rounding). If f is too big.  undefined behave
	\item[Line 4:] will lost precision if i is big.
\end{description}

	\item A implicit conversion will happen when you call a function.(Just like you use assignment operator=). Below they all compile successfully. Compile with -Wconversion flag, it doesn't included in -Wall in g++; It just give warning when standard conversion happen. (no warning for promotion conversion).
\begin{lstlisting}[numbers=none]
bool isLucky(int number);
	
isLucky('a') // promotion ,NO warning
isLucky(false) // promotion, NO warning
isLucky(1.2f) //standard conversion.  Warning
\end{lstlisting}

	\item In C++, introduce braces initialization \{\}, It will not allow narrowing happen. But in g++, it just show a -Wnarrowing message, Anyway, I think that it's helpful.
\begin{lstlisting}[numbers=none]
int x = 66;  char c1 = {x}; //ok	
int x = 666; char c2 = {x};// not allowed;
	
int fun(){
	return 1.2f; //OK, no warning
	return {1.2f}; //ERROR, -Wnarrowing
}
\end{lstlisting}

\subsubsection{Explicit conversion}
	
	\item In order to suppress conversion warning, you can use explicit numerical conversion to state your intention clearly and loudly.
	
	\item In C language, there exist two main syntax for generic type-casting: functional and C-style cast.  \textbf{Prefer C-style cast}
	
\begin{lstlisting}[numbers=none]
double x = 10.3;
int y;
unsigned int n1 = (unsigned int)f; // C-style cast
unsigned int n2 = unsigned(f);     // functional cast
\end{lstlisting}
	\begin{description}
		\item[Line 4:] functional cast only be used in one word type. \texttt{unsigned int (f)} is not right, \texttt{int *(p)} is not right either.
	\end{description}
	
	\item In C++ language, \textbf{You should always use static\_cast}. 
\begin{lstlisting}[numbers=none]
float f = 3.5; 
int a = f; // implicit 
int a = (int) f; //explicit C style
int b = static_cast<int>(f);  //explicit C++ style
\end{lstlisting}

\end{itemize}



\section{type}

\subsection{Type cast in c++}

\subsubsection{Class implicit conversion}
\begin{itemize}
	
	\item Class implicit conversion can happen when it has:
	\begin{enumerate}
		\item Single ctor, it means that a class can be produced \textbf{from something.}
		\item operator Type, it means that a class can be converted \textbf{to something.}
	\end{enumerate}
	
\begin{lstlisting}
class A {
	A(int i); // bad style
	operator const char*(); //bad style
};
	
A a1, a2;
a2 = a1*2;  
a2 = 2;
\end{lstlisting}
\begin{description}
	\item[Line 7:] implicit conversion 2 to temp A obj.
	\item[Line 8:] implicit conversion 2 to temp A obj, then call operator =;
	\item[Source code:] That is not good style most of time.
\end{description}
	
	\item Implicit conversion can be called by compiler implicitly, (means that you don't know at all). It sometimes will lead to potential ambiguity problem and result which you don't expect. more detail can be seen effective c++ item 26.
\begin{lstlisting}[frame=single, language=c++]
class A{
	A(class B&);
};
class B{
	operator A()
};
	
void g(const A&);
B b;
g(b)
\end{lstlisting}
\begin{description}
	\item[Line 10:] 	it can call A's ctor in class A, or it can call B's opeartor A() in class B. Compiler stops because of ambiguity.
\end{description}	
	
	\item \textbf{You should always avoid implicit conversion}
	\begin{enumerate}
		\item use explicit before single parameter ctor.
		\item use name convert function instead of  "operator Type". So string has function \texttt{c\_str()} instead operator \texttt{char*()} const. 
	\end{enumerate}
	
	\item In an example below, with explicit keyword before ctor,  you have to use A(2) or (A)2 to explicitly build a A temperory obj in a1*A(2) expression. It's a good habit and you should follow. 
\begin{lstlisting}[numbers=none]
class A {
	explicit A(int i);     // good
	const char* getInternalPoint(); //good,a name function.
};
\end{lstlisting}
	
	\item  convert class to basic type, you need \texttt{operator basicTypeName}, no argument, and must be member function.
	
	\item For class, assignment operator() can support two different type assignment. But I don't think that it is a conversion. I didn't see any practical usage by now. 
\begin{lstlisting}[frame=single, language=c++]
class A {};
	
class B {
public:
	B& operator= (const A& x) {return *this;}
};
	
B b;
b = a; 
\end{lstlisting}
\begin{description}
	\item[Line 5:] Operator = receive different type. We don't see this usage very often in practical 
\end{description}
\end{itemize}

\subsubsection{type cast operator}
\begin{itemize}
	\item There are three operators, \texttt{dynamic\_cast}, \texttt{const\_cast} and \texttt{static\_cast}. \textbf{You should always use them in C++.}
	
	\item Unrestricted explicit type-casting allows to convert any pointer into any other pointer type, independently of the types they point to.  (syntax and compiling is right, but cause run-time error). In order to overcome this problem,  in C++ langauge, we introduce c++ cast operator, see below section.
\begin{lstlisting}[frame=single, language=c++]
char c = 10;    
int *p = (int*)&c; 
*p = 5;  //run time error 
	
int *p = static_cast<int*>(&c); 
\end{lstlisting}
\begin{description}
	\item[Line 2 and 3:] compile ok, but you will meet runtime error, the assignment statement cause stack corruption.
	\item[Line 5:] You will have comple error, so you avoid dangerous run time crash in the future.
\end{description}
	
	\item About void pointer:
	\begin{enumerate}
		\item void* type can be converted to any other type implicitly.
\begin{lstlisting}[frame=single, language=c++]
int* p = malloc(sizeof(int));
int* p = static_cast<int*>(malloc(sizeof(int)));
\end{lstlisting}
\begin{description}
	\item[Line 1:] \texttt{malloc} return void*, so you can assign it to \texttt{int *} directly in C language.
	\item[Line 2:] In C++, you have to use cast operator. A better way is to use new instead.
\end{description}

	\item You don't need any cast operator when you change any type pointer from void*, But when you want to use dereference void pointer , you'd better use \texttt{static\_cast }to change it back to a certain type pointer.
	\end{enumerate}
	
	\item \texttt{static\_cast<type-name>} expression will be valid only if type-name can be converted implicitly to the same type that expression has.  It will stop you from change a bird class to an apple class which  are two totally unrelated classes.  Even change int to double, encourage you to use \texttt{static\_cast<double>(i)}.  it also can help you to find cast easily in you source code by search "static\_cast".
	
	\item Changing the value of an const object through \texttt{const\_cast} pointers leads to  "undefined behavior". For const static data -- the compiler may put such variables in a read-only region, the program will crash if you try to modify it.
	
\begin{lstlisting}[frame=single, language=c++]
const int a = 12;
int* p = const_cast<int*>(&a); //Bad style
*p = 66;
\end{lstlisting}
	
	\item Using \texttt{const\_cast} is not good design. Sometimes for a const member function, you have to use \texttt{const\_cast} to change this pointer to modify a class member. If compiler support, always use "mutable"  keyword.  Only use \texttt{const\_cast} if your compiler doesn't support mutable
	
	\item Sometimes, For some legacy functions, You have a const object you want to pass to a function taking a non-const parameter, and you know the parameter won't be modified inside the function. The second condition is important, because it is always safe to cast away the constness of an object that will only be read, not written.
	
\begin{lstlisting}[numbers = none]
strlen( char* p);
const char* cp = "hello";

strlen(const_cast<char*>(cp));
\end{lstlisting}
	
	\item \texttt{dynamic\_cast} should only be used down-cast public inherited relationship. You can't use \texttt{dynamic\_cast} when
	\begin{enumerate}
		\item \textbf{Not for private or protected inherited relationship.}
		\item If a class doesn't have virtual function, you can't use dynamic\_cast on this object.
	\end{enumerate}
	
	\item A child pointer can always be assigned to base pointer directly. (That is how polymorphic implement.) \texttt{dynamic\_cast} use to \textbf{down-cast} a base pointer to child pointer. \texttt{dynamic\_cast} assure that down cast is valid. 
	
	\item If you frequently use \texttt{dynamic\_cast}, It can be a sign that your base class offer too little functionality, you'd better to re-desing you base class API(adding more member function to base class.)
	
	\item \texttt{dynamic\_cast} can also used in reference type. When cast fail, it will not return nullptr, (because it's reference), just throw a \texttt{bad\_cast} exception.
	
\begin{lstlisting}
struct A {};
struct D : public A {};

D d; // the most derived object
A& a = d;
D& new_d = dynamic_cast<D&>(a); // downcast
\end{lstlisting}
\begin{description}
	\item[Line 5:] That is up-cast,\texttt{ dynamic\_cast} may be used, but unnecessary.
	\item[Line 6:] That is downcast, you have to use \texttt{ dynamic\_cast} here. 
\end{description}
	
	
	\item \texttt{dynamic\_cast} can also be used in \textbf{side-cast in multi inheritance. }
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
struct V {
	virtual void f() {};
};
struct A : virtual V {};
struct B : virtual V {};
struct D : A, B {};
	
D d; // the most derived object
A& a = d; // upcast 
B& b = dynamic_cast<B&>(a); //sidecast
	\end{lstlisting}
\begin{description}
	\item[Line 2:] must be polymorphic to use runtime-checked \texttt{dynamic\_cast.}
	
	\item[Line 10:] That is sidecast. Change a to d first(from parent A to child D, maybe fail), then d to b, (from child D to parent B, always succeed)
	
\end{description}
	
	\item \texttt{dynamic\_cast} different with \texttt{static\_cast}:
	\begin{enumerate}
		\item \texttt{static\_cast} check on compile time.
		\item \texttt{static\_cast} no run time information, so sometimes it makes mistake.
	\end{enumerate}
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
struct V {
virtual void f() {};
};
struct A : virtual V {};
struct B : virtual V {};
A a;
V& v = a;
	
B& b = static_cast<B&>(v); //ok
B& b = dynamic_cast<B&>(v); //not ok
\end{lstlisting}

	\item About \texttt{dynamic\_cast}, "exceptional C++" item 44 give a good question and answer.
	
	\item \texttt{reinterpret\_cast} converts any pointer type to any other pointer type, even of unrelated classes. The operation result is a simple binary copy of the value from one pointer to the other. All pointer conversions are allowed: neither the content pointed nor the pointer type itself is checked. It can also cast pointers to or from integer types. \textbf{DON'T USE IT UNLESS YOU ARE IN THE CORNER.}
\end{itemize}

\subsubsection{RTTI}
\begin{itemize}
	\item It's a relatively new conception in C++, you should avoid using it on old C++ compiler. It inclueds two methods: \texttt{typeid}, \texttt{dynamic\_cast}.
	
	\item \textbf{It only work with class hierarchy that has virtual functions. }
	
	\item There are two kinds of types (for the purposes of RTTI): polymorphic types and non-polymorphic types. A polymorphic type is a type that has a virtual function, in itself or inherited from a base class. A non-polymorphic type is everything else; this includes POD types, but it includes many other types too.
	
	\item \texttt{typeid} operator will return a \texttt{type\_info} class.  You need to include typeinfo.h head file. Typeid operator receive pointer or class name.
	
\begin{lstlisting}
int myint = 50;
std::string mystr = "string";
double *mydoubleptr = nullptr;
	
cout << "myint has type: " << typeid(myint).name();
cout<< "mystr has type: " << typeid(mystr).name();
cout<< "mydoubleptr has type: " << typeid(mydoubleptr).name();
\end{lstlisting}
\begin{description}
	\item[Line 5:] typeid is operator, it return \texttt{type\_info} class. name is member function of \texttt{type\_info}.
\end{description}
	\item If you just want to assure up casting and you don't want to know more about the class, you should prefer to use \texttt{dynamic\_cast} . just know typeid when you have a more complicated demand, you can come back to take a look deeply.
	
	\item RTTI has legitimate uses but is prone to abuse, so you must be careful when using it. You may use it freely in unittests, but avoid it when possible in other code. consider one of the following alternatives to querying the type:
	\begin{enumerate}
		\item Virtual methods are the preferred way of executing different code paths depending on a specific subclass type. This puts the work within the object itself.
		
		\item If the work belongs outside the object and instead in some processing code, consider a double-dispatch solution, such as the Visitor design pattern. This allows a facility outside the object itself to determine the type of class using the built-in type system. Visitor design pattern can be seen in the later section.
	\end{enumerate}
	
	\item Just like exception, It has some loss in performance, you can use flag "-fno-rtti" to turn off it.
\end{itemize}


\subsection{cv-qualifier}
\subsubsection{const in function}
\begin{itemize}
	\item \textbf{Just like assert statement, Use \texttt{const} aggressively.}
	
	\item \texttt{const} must be initialized when you declare it. \texttt{static} will be initialized to default value(usually zero value) if you don't set value manually. 
	
	\item Top-level \texttt{const} to indicate that the pointer itself is a const. When a pointer can point to a const object, we refer to that \texttt{const} as a low level const.
	
	\item \textbf{For reference type, you always can't change it, so top-level const is default, you only can set low-level const.}
\begin{lstlisting}[frame=single, language=c++]
int i = 0;
int * const p1 = &i; // const is top-level
const int *p2 = &ci; // const is low-level
	
const int *const p3 = p2;
const int &r = ci;
\end{lstlisting}
\begin{description}
	\item[Line 5:] Right most const is top-level, left-most is low-level.
	\item[Line 6:] const in reference type is always low-level
\end{description}
	
	\item \texttt{const} mainly used in three places inside of function:
	\begin{enumerate}
		\item functions parameter.
		\item function return. ( just used for \texttt{const} reference, not for return value)
		\item member function.
	\end{enumerate}
	
	\item In fact, for value type parameter, the function signature is the same whether you include this const in front of a value parameter or not. It will cause redefine error. For example:
\begin{lstlisting}[frame=single, language=c++]
int f( int );
int f( const int ); // redeclares f(int)
// no overloading, there's only one function.
\end{lstlisting}
	
	\item  Consider not writing \texttt{const} on pass-by-value function parameters when only forward-declaring a function. You can always add it on the definition to express a read-only parameter.
\begin{lstlisting}[frame=single, language=c++]
int f( int );
int f( const int );    

int g( int& );
int g( const int& );   
\end{lstlisting}
\begin{description}
	\item[Line 2:] Value parameter: top-level const is not part of function signature.redeclares f(int): this is the same function.
	
	\item[Line 4:] Non-value parameter: top-level const is part of function signature. Overloads g(int\&): these are two functions.
\end{description}
	
	\item For \texttt{const} value type parameter in the example below, the \texttt{const} qualifier prevents code inside the function from modifying the parameter itself. Such an assurance helps you to quickly read and understand a function. Under some circumstances, this might even help the compiler generate better code. 
\begin{lstlisting}[frame=single, language=c++]
double cube (const double side){
	return side * side * side;
}
\end{lstlisting}
	
	\item \textbf{In C++, When you use pointer or reference as function parameter, You should always put \texttt{const} in front of it.} Because most of time you don't need to modify it.  Once you compiler bark, then you can delete \texttt{const}, It will help you to use const aggressively.
	
	\item \textbf{When function return build-in value, don't use const at return value at all. }
\begin{lstlisting}[numbers=none]
const int foo() {
	return 3;
}
int x = foo();  // copies happily
foo() = 4;  // not valid anyway for built-in types
\end{lstlisting}
	
\item \textbf{When function return user-defined type value, don't use const at all. It will not allow you to use rvalue and move. }
\begin{lstlisting}[frame=single, language=c++]
const time operator+(const time &t){
	time temp;
	return temp.bla = bla+t.bla;
}
	
time t3(t1+t2);
\end{lstlisting}
\begin{description}
	\item[Line 6:] because + return const, so below just copy. compiler will not use time move ctor, it is low efficient.
	
\end{description}
	
	\item \textbf{When function return reference or pointer, you can use const to restrict modify it.}
\begin{lstlisting}[numbers=none]
class String{
	const char& operator[](int position);
}
\end{lstlisting}
	
	\item Most of time, only index operator \verb=[]=, assignment operator and \verb|<<|, \verb|>>| support return reference. For assignment operator, we only need to return \texttt{\&}.  For istream and ostream overload, you don't need return \texttt{const} at all. 
\begin{lstlisting}[numbers=none]
Array &Array::operator=(const Array &right) {
	....
	return *this; //enables x=y= 
}
\end{lstlisting} 
	
	\item Common function interface: \textbf{you can see \texttt{const} only used in pointer or reference type. You should use more \texttt{const} in your projects. }
	
	\begin{tabular}{|c|c|c|}
		\tophline
		\textbf{type} & \textbf{read} & \textbf{write} \\ \tophline
		
		primitive (char, int, float) & pass value & pointer or reference \\ \tophline
		class, array, structure  & const pointer or reference &  pointer or reference \bottomhline
	\end{tabular}
\end{itemize}

\subsubsection{const in class}
\begin{itemize}
	
	\item When \textbf{const} used in class. There are four usages.
	\begin{enumerate}
		\item In \textbf{const} member function, you can't change member variable,(If you change it, it will report a compile error). It will make const obj can invoke this function.
\begin{lstlisting}[numbers=none]
void A::fun() const{
	this->m_a = 100 // will compile error
}
\end{lstlisting}
		
		\item \texttt{Const} obj can only call \texttt{const} function. But non-const obj can call ALL funcitons( const or non-const).
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
class Fred {
public:
	void inspect() const;
	void mutate();
};
		
void userCode(Fred& changeable, const Fred& unchangeable){
	changeable.inspect();   // Okay: doesn't change
	changeable.mutate();    // Okay: changes
	unchangeable.inspect(); // Okay: doesn't change
	unchangeable.mutate();  // ERROR:
}
\end{lstlisting}
\begin{description}
	\item[Line 3:] inspect member function promises NOT to change *this.
	\item[Line 5:] mutate member function might change *this.
\end{description}
		
		\item If you want to return a member of a object from a const method, you should return it using reference-to-const (const X\& inspect() const) or by value ( X inspect() const). \textbf{const member method return value or const reference.}
\begin{lstlisting}[frame=single, language=c++]
class Person {
public:
	const std::string& name_good() const;
	std::string& name_evil() const;
	int age() const;
};
		
void myCode(const Person& p){
	p.name_evil() = "Igor";  // But changed....!!
}
\end{lstlisting}
\begin{description}
	\item[Line 3:]  Good style, the caller can't change the Person's name.
	\item[Line 4:]  Bad style, the caller can change the Person's name.
	\item[Line 5:]  Good style, the caller can't change the Person's age
	\item[Line 9:]  Through a bad member function, you can change a const object. 
\end{description}

		\item The most common use of \texttt{const} overloading is with the subscript operator. You should generally try to use one of the standard container templates, such as std::vector, but if you need to create your own class that has a subscript operator, here's the rule of thumb:\textbf{ subscript operators often come in pairs.} One has const, the other has not const. 
\begin{lstlisting}[numbers=none]
class Fred { /*...*/ };
class MyFredList {
public:
	const Fred& operator[] (unsigned index) const;
	Fred&  operator[] (unsigned index);
};
\end{lstlisting}
		
	\end{enumerate}
	

	
	\item Do not use "volatile" except in low-level(embedded c) code that deals directly with hardware.1) don't optimized code, 2) each time you read volatile, load from memory instead of using old value.
\begin{lstlisting}[frame=single, language=c++]
void waitForSemaphore(){
	volatile uint16_t* semPtr = WELL_KNOWN_SEM_ADDR;
	/*well known address to my semaphore*/
	while ((*semPtr) != IS_OK_FOR_ME_TO_PROCEED);
}
\end{lstlisting}
	
	\item \texttt{mutable} allows you to modify a member variable in a class by a const method. Why do we need this conception? Behind "mutable", It's bitwise const and logical const. Logical const is when an object doesn't change in a way that is visible through the public interface. An example would be a class that computes a value the first time if required, then caches the result.
\begin{lstlisting}[frame=single, language=c++]
class TextBook  {
private:
	mutable int length_;
	mutable bool isValid;
public:
	void getLength() const {
		if(isValide == false){
			length_ = strlen(*p);
			isValid = true; 
		}
		return length_
	}
}
\end{lstlisting}
\begin{description}
	\item[Line 6:] In above example, \texttt{getLength()} is member-wise const function, It just read a length value, not set it from outside. But inside this function, you need to change some private member value, At this time, you need to use mutable keyword, so \texttt{const getLength()} function can modify and cache a \texttt{length\_} value.
	
	\item[Line 6:] const function just put restraint inside of function, it not ask caller to be a const object at all. Why I declare \texttt{getLength()} as const?
	\begin{enumerate}
		\item because if you don't do it. const obj can't call \texttt{getLength()} function at all. 
		\item "logically", we just read, not change something.
	\end{enumerate}
\end{description}
	
	
	
	
	\item \textbf{A const obj only can call const member function, and const member function just return const reference or pointer.} A example can be seen in vector example.  
	
\begin{lstlisting}
iterator begin() noexcept;
const_iterator begin() const noexcept;
	
const vector<int> cvi;
vector<int>::iterator vi = cvi.begin(); //Compile error
\end{lstlisting}
\begin{description}
	\item[Line 5:] cvi will call the second overload function anyway. but second just return const\_iterator. and const\_iterator can NOT be converted to iterator implicitly.
\end{description}
	
	\item Continue with previous item.\textbf{ If you define a const obj or you have const member function, all the member variable of const obj or inside const member function is const}. For example, because getArea is const funciton, when it is called by a const obj, points will become a const member variable, so error will happen below: 
	
\begin{lstlisting}[frame=single, language=c++]
class A{
	getArea() const{
		vector<int>::iterator vi = points.begin();
	}
	
	calArea(){
		vector<int>::iterator vi = points.begin();
	}
vector<int> points
};
	
const A ca;
aa.calArea(); // not compile	
A a;
a.calArea(); // obj can acces non-const member fun
a.getArea(); // obj can also access const member fun.
\end{lstlisting}

\begin{description}
	\item[Line 2:] because getArea is const member function, so points are const implicit. you have to use const\_iterator here
	
	\item[Line 3:] In order to resolve this problem, you have two options: one is use const\_iterator. 
\begin{lstlisting}[numbers=none]
class A{
	getArea() const{
		vector<int>::const_iterator vi = points.begin();
	}
\end{lstlisting}
	
	\item[Line 3:] another method is using auto
	
\begin{lstlisting}[numbers=none]
class A{
	getArea() const{
		auto vi = points.begin();
	}
\end{lstlisting}

\end{description}

	\item \textbf{\texttt(const) expand outside, and restraint inside}
	\begin{enumerate}
		\item If you declare getArea() const function, it will make both const obj and non-const obj can call this member function. This is good. if you don't define it as const member function, only non-const obj can invoke this function. \textbf{For outside, const increase interface applicable scope.}
		
		\item But inside const member function, You can't change member variable anymore, (if you really want, use mutable keyword.) Inside const member function, it will think all member variable const, so vector will be const implicitly, return non-const iterator will be error.
	\end{enumerate}

	\item A good reference article about const is GotW 6. 
	\item when you declare mutable, you'd better use mutex to synchronize it. It's called M\&M rule in "GotW \#6b Solution"
\end{itemize}


\subsubsection{const\_iterator}
\begin{itemize}
	\item You should know the difference between: \\
	\texttt{vector<int>::const\_iterator} and \texttt{const vector<int>::iterator}
\begin{lstlisting}[numbers=none]
vector<int>::const_iterator cvi;
*cvi = 12; //ERROR, can't change
cvi++;     //OK
	
const vector<int>::iterator vi;
*vi = 12; //OK
vi++;     //ERROR
\end{lstlisting}
	
	\item In C++11/14, we add cbegin for STL container and interface of container has changed from non-const iterator to const iterator, so we should use const iterator more. 
\begin{lstlisting}
iterator insert(iterator position, const value_type& val);//c++98
iterator insert(const_iterator position, const value_type& val);//c++11
	
vector<int> values:
auto it = std::find(values.cbegin(),values.cend(), 1983);
values.insert(it, 1998);
\end{lstlisting}
\begin{description}
	\item[Line 1:] In C++98, insert doesn't support \texttt{const\_iterator} interface.
	
	\item[Line 2:] In C++11, insert interface has changed. Because insert will not change the input iterator,(it only insert a new element after input iterator, but not change input iterator directly.) so it should be \texttt{const\_iterator}.
	
	\item[Line 5:] std::find is generic algorithm, it just receive a template parameter,  You should provide \texttt{const\_iterator} to it, But how can you get \texttt{const\_iterator} from a non const container. After C++11, you can use cbegin to get \texttt{const\_iterator} easily.
\end{description}

	\item A good article is "effective modern C++" item 13.It introduce the basic idea about \texttt{const\_iterator.}
\end{itemize}

\subsection{constexpr}

\subsubsection{Basic definition}
\begin{itemize}
	\item The first conception is \textbf{const expressions}. constant expression is expression that can be evaluated at compile time. It has many advantage, such as can be performance optimization and can be used in places that require compile-time evaluation, for example, template parameters and array-size specifiers.
\begin{lstlisting}
int n = 1;            //n is not a constant expression
std::array<int, n> a1; //ERROR 
const int cn = 2;     // cn is a constant expression
std::array<int, cn> a2;// OK 
\end{lstlisting}

	\item After C++11, by introducing constexpr specifier, we expand the constant expression scope. For example, a constexpr function with known parameter can be constant expression too. \textbf{That is the basic idea of constexpr, If you understand this, you can understand a lot of complex syntactic knowledge below.}
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.9\linewidth]{pics/constexpr.png}
		\caption{Basic idea of constexpr}
		\label{fig:constexpr}
	\end{figure}
	
	\item The \textbf{constexpr specifier} declares that it is possible to evaluate the value of the function or variable at compile time. Such variables and functions can then be used where only compile time \textbf{constant expressions} are allowed (provided that appropriate function arguments are given). 

	\item \texttt{constexpr} can be used in three places: 
\begin{enumerate}
	\item constexpr variable.
	\item constexpr obj.
	\item constexpr function. constexpr function can be thought as a kind of "metafunction".
\end{enumerate}

	\item constexpr has two advantages:
\begin{enumerate}
	\item Improve efficiencies(if it's possible, it will calculate at compile time, not run time). 
	
	\item expand usage scope (initialize constexpr obj and use in integer constexpr context)
\end{enumerate}
\begin{lstlisting}[frame=single, language=c++]
constexpr int fun(int a, int b){return a+b;}

constexpr int const foo = fun(2,3) ; 
int a[fun(2,3)];
\end{lstlisting}
\begin{description}
	\item[Line 3 and 4:] Without constexpr in function declaration, the two statmentments can't be compiled correctly.
\end{description}

	\item Difference between constant expression and constexpr:
	\begin{enumerate}
		\item Declaring a function as constexpr does not necessarily guarantee that it will be evaluated at compile time. It can be used for such, but it can be used in other places that are evaluated at run-time, as well.
		
		\item An object may be fit for use in constant expressions without being declared constexpr. for example: \texttt{const int N = 25}.
	\end{enumerate}

	\item Difference between \texttt{constexpr} with \texttt{const}:
	\begin{enumerate}
		\item when you declare constexpr obj, it implicit const. But not all const is constexpr.
		
		\item constexpr just used on top level.If you want to specify the low level const, you need to write it out.
\begin{lstlisting}
constexpr int const foo = 42;
constexpr int       foo = 42; 
constexpr int const *pb = &bar; 
\end{lstlisting}
	\begin{description}
		\item[Line 1 and 2:] They are the same.
		\item[Line 3:] pb itself is constexpr, when we initialize it, \&bar must be constant expression too.
		\item[Line 3:] pb points const int.
	\end{description}
	\end{enumerate}


\end{itemize}


\subsubsection{constexpr variable and object}
\begin{itemize}
	\item \textbf{All constexpr objects are const, but not all const object are constexpr}
	\begin{enumerate}
		\item constexpr variable is implicitly const. Just like const, constexpr can't be changed during run time.
		
		\item constexpr variable must be initilized when you declare it. The full-expression of its initialization, including all implicit conversions, constructors calls, etc, must be a constant expression.(You know the exact value in compiling time.)
		
		\item Value of constexpr \textbf{must be known at compile time}.If you want to get value from a function, you have to use constexpr function to assign value to it. 
		
\begin{lstlisting}
constexpr int sum(int i, int j){
	return i+j;
}
int i,j;
cin>>i>>j;
const int result = i+j; //OK
constexpr int result = i+j;  //ERROR
const int ce = sum(i,j); //OK
constexpr ce = sum(i,j); //ERROR
\end{lstlisting}
\begin{description}
	\item[Line 7 and 9:] Why they are error, they can't be calculated in compiling time.
\end{description}
		


	\end{enumerate}
	
	\item For constexpr object, it must has corresponding  constexpr constructor 
	\begin{enumerate}
		\item can only be invoked with constant expressions.
		\item can not use exception handling.
		\item has to be declared as default or delete or the function body must be empty (C++11).
		\item The constexpr user-defined type
	\end{enumerate}
	
	\item For class itself, it also need satisfy below:
	\begin{enumerate}
		\item can not have virtual base classes.
		\item requires that each base object and each non-static member has to be initialized in the initialization list of the constructor or directly in the class body. 
		\item Consequently, it holds that each used constructor (e.g of a base class) has to be constexpr constructor and that the applied initializers have to be constant expressions.
	\end{enumerate}

\begin{lstlisting}[frame=single, language=c++]
class MyInt{
public:
	constexpr MyInt()= default;
	constexpr MyInt(int fir, int sec): myVal1(fir), myVal2(sec){}
	MyInt(int i){ myVal1= i-2; myVal2= i+3; }
	
private:
	int myVal1= 1998;
	int myVal2= 2003;
};
	
constexpr MyInt myIntConst1;
MyInt myInt2;
constexpr int sec= 2014;
constexpr MyInt myIntConst3(2011,sec);
int arr[myIntConst3.getSum()];
static_assert( myIntConst3.getSum() == 4025, "2011+014 = 4025" );
constexpr MyInt myIntConst5(2000); //Error
\end{lstlisting}
\begin{description}
	\item[Line 12 and 13:] You can declare both constexpr and non-constexpr object.
	
	\item[Line 14 and 15:] If you want to use constexpr to initialize constexpr varaible, you must guarantee all the parameter are constexpr.
	
	\item[Line 18:] Single parameter constructor is not declared as constexpr function
\end{description}
	\item A good articles is: \\ \verb|https://www.modernescpp.com/index.php/constexpr-variables-and-objects|
	
\end{itemize}

\subsubsection{constexpr function}
\begin{itemize}
	\item \textbf{When you declare a function as constexpr, you just tell the compiler that this function is a kind of "pure function".} The pure function has no state, and when you run it, it has no side effect.
	\begin{enumerate}
		\item The return value is only determined by its input values.
		\item Given input values, the return value can be calculated in compiling time. 
	\end{enumerate}

	\item constexpr functions compile much quicker than the equivalent template-based solutions, which scale linearly with the depth of the template-recursion.
	
	\item The pure function has some advantages compared with ordinary funciton Return always the same result when given the same arguments, So the function call can be replaced by the result, and the order of function call is not important.(That is why you can run it at compiling time.) But the problem is compiler itself can't judge if a function is pure function, That's why programmer come to rescure. The programmar indicate this function is a "pure" function, so compiler can \textbf{For outside} use it in another constant expression context, \textbf{For inside} calculate it in comipling time. 
	
	\item On the first sight, you should declare constexpr function everywhere, but it's not good idea either. That makes a constexpr qualifier an irrevocable design decision. You cannot remove this qualifier without an incompatible change to your API. It also limits how you can implement that function, e.g. you would not be able to do any logging within this function. Not every trivial function will stay trivial in eternity. That means you should preferably use constexpr for functions that are inherently pure functions, and that would be actually useful at compile time (e.g. for template metaprogramming). It would not be good to make functions constexpr just because the current implementation happens to be constexpr-able.
	
	\item Where compile-time evaluation is not necessary, using inline functions or functions with internal linkage would seem more appropriate that constexpr. Both constexpr and inline are for performance improvements, inline functions are request to compiler to expand at compile time and save time of function call overheads. In inline functions, expressions are always evaluated at run time. constexpr is different, here expressions are evaluated at compile time.
	
	\item constexpr can be used with both member and non-member functions, as well as constructors. It declares the function fit for use in constant expressions. 
	
	\item A few examples of constexpr functions. 
	\begin{enumerate}
		\item you have something that can be evaluated down to a constant while maintaining good readability and allowing slightly more complex processing than just setting a constant to a number.
\begin{lstlisting}[numbers=none]
constexpr int MeaningOfLife ( int a, int b ) { return a * b; }
constexpr int meaningOfLife = MeaningOfLife( 6, 7 );
\end{lstlisting}
		
		\item It basically provides a good aid to maintainability as it becomes more obvious what you are doing. Take max( a, b ) for example: Its a pretty simple choice there but it does mean that if you call max with constant values it is explicitly calculated at compile time and not at runtime.
\begin{lstlisting}[numbers=none]
template< typename Type > 
constexpr Type max(Type a, Type b) {return a < b ? b : a; }
\end{lstlisting}
		
	\end{enumerate}
	
	\item Compared with ordinary function, constexpr functions:
	\begin{enumerate}
		\item \textbf{For outside}. is able to be used in the another constant expression(such as \texttt{constexpr int sum = cfun(2,3);} ) But it doesn't mean that it must be used in constant expression(such as \texttt{int sum = cfun(i,j);})
		

		\item \textbf{For inside}. constexpr function Add a lot of restraint on its implementation.


	\end{enumerate}
	
\begin{lstlisting}[frame=single, language=c++]
constexpr int cfun(int i, int j){
	return i+j;
}
int fun(int i, int j){
	return i+j;
}
	
int i, j;
constexpr int sum = fun(2,3);  //Error
constexpr int sum = fun(i,j);  //Error
constexpr int sum = cfun(2,3); //OK
constexpr int sum = cfun(i,j); //Error

int sum = fun(2,3);  //OK
int sum = fun(i,j);  //OK
int sum = cfun(2,3); //OK
int sum = cfun(i,j); //OK
\end{lstlisting}

\begin{description}
	\item[Line 9 to 12:] For constexpr variable, only cfun with constant expression is OK.
	\item[Line 14 to 17:] For Non-constexpr variable, all fun is OK.
\end{description}
	
	\item There are two contexts in which a constexpr function \textbf{MUST} to run at compile time. That's why\textbf{constexpr functions must be able to return compile-time results when called with compile-time values.}
	\begin{enumerate}
		\item The constexpr function is executed in a context which is evaluated at compile time. This can be a \texttt{static\_assert} expression such as with the type-traits library or the initialisation of a C-array.
		
		\item The value of a constexpr function is requested during compile time with constexpr: \texttt{constexpr auto res = func(5);}
	\end{enumerate}
	
	\item In C++11. For constexpr functions there are a few restrictions on it:
	\begin{enumerate}
		\item has to be non-virtual.
		
		\item has to have arguments and a return value of a literal type. Literal types are the types of constexpr variables.
		
		\item can only have one return statement.
		
		\item The function body must be non-virtual and extremely simple: Apart from typedefs and static asserts, only a single return statement is allowed. In the case of a constructor, only an initialization list, typedefs and static assert are allowed. (= default and = delete are allowed, too, though.)
	\end{enumerate}

\begin{lstlisting}[frame=single, language=c++]
constexpr int gcd(int a, int b){
	return (b== 0) ? a : gcd(b, a % b);
}
\end{lstlisting}
\begin{description}
	\item[Line 2:] Function body can only have one return statement. but thank for ternary operator and recursion.
\end{description}
	
	\item In C++14. constexpr function can include: 
	\begin{enumerate}
		\item conditional jump instructions or loop instructions and more than one instruction.
		
		\item fundamental data types that have to be initialized with a constant expression.
		
		\item \textbf{You can't define below:} asm declaration, a goto statement, a statement with a label other than case and default, try-block, definition of a variable of non-literal type, definition of a variable of static or thread storage duration, definition of a variable for which no initialization is performed.
		
		\item The arguments and the return type must be \textbf{literal types} (i.e., generally speaking, very simple types, typically scalars or aggregates)
		
		\item in C++11, constexpr member function is implicit const; C++14 lift it up.
	\end{enumerate}
\begin{lstlisting}[numbers=none]
constexpr auto gcd(int a, int b){
	while (b != 0){
		auto t= b;
		b= a % b;
		a= t;
	}
	return a;
}
\end{lstlisting}
	
	\item A good artical is "Demystifying constexpr". 
\end{itemize}

\subsection{static}
\begin{itemize}
	\item In C++, \textbf{global and static variables initialized to default values.}  But auto variable is random value, unless you use value initialization, because of efficiency consideration. 
	
	\item You can't initialize a static member variable inside the class declaration, you need to put it in a .cpp file.   But you can if the static data member is \texttt{const} of integer or enumeration. If you have a const member inside a class, better to use const static, because it can't be changed, so all the object can share the one static value.
\begin{lstlisting}[frame=single, language=c++]
class{  //in .h file
	static int obj_num;  // you can't initialize
	const static int months = 12; // you can  initialize
};
	
//In .cpp file
int class::obj_num = 0; // no static keyword anymore.

\end{lstlisting}
\begin{description}
	\item[Line 7:] obj\_num will be default value(0) even you don't init it.
\end{description}
	
	\item static member function has two usages:
	\begin{enumerate}
		\item It can be invoked just by class name, not object instance, so you can define math class and define a lot static math function inside it.  Just like name space.
		
		\item It can't access class data member, only can access class static member data. Because for static function, we don't pass \texttt(this) pointer.
	\end{enumerate}
	
	\item static can be used restrict the scope.
\begin{lstlisting}[frame=single, language=c++]
int global = 0;  //All files
static int s_i = 50; //just in this file
main(){
	static int s_i = 100;  //just in this block
	printf("%d %d", ::s_i, s_i); //print 50 and 100
}
\end{lstlisting}
\begin{description}

	\item[Line 5:] Not conflict, but if you define int s\_i in global scope it will conflict.

\end{description}
	
	\item Summary: static uses in three ways:
	\begin{enumerate}
		\item use it inside a function. unvisitable outside of function, valid until program end.
		
		\item use it inside a class. only copy for all instances, and access by static member function.
		
		\item use it inside a file. internal link, avoid name conflict.But by now, we prefer to use unname space in moder C++.
	\end{enumerate}
\end{itemize}

\subsection{size\_t and ptrdiff\_t}

\subsubsection{unsigned int}
\begin{itemize}
	\item unsigned int + signed int just wrapped on the clock. not overflow,just turn around on the clock. 
	
\begin{lstlisting}[numbers=none]
unsigned int ui = 0xfffffffe  // -2 or UNIT_MAX-1
int i = 1;
//ui+i will be expreseed 0xffffffff in memeory. 
printf("%d", ui+i); //print -1
printf("%u", ui+i); //print UINT_MAX;
\end{lstlisting}

	\item For integer addition or subtraction, It is just a round-trip. When you reach a position in the circle, how to understanding depends on its context and type.
\begin{lstlisting}
unsigned int ui = 1;
int i = -2;
int j = i+ui; // j is -1, CORRECT

(ui+i)<6  // ERROR!
\end{lstlisting}
\begin{description}
	\item[Line 3:] \texttt{i+ui} will stop in one position in the round clock. how to interpret it depends on the programe context, as int interpret this position correct.
	\item[Line 5:]  as unsigned interpret this position, so \texttt{(ui+i)} is bit positive number. Most unsigned implicit cast error happen when you compare with a constant number.
\end{description}
	
	\item When you 1) compare with other, 2) expand 3) multiply or sub, it will interpret according to its signed semantic. 
\begin{lstlisting}[frame=single, language=c++]
unsigned int ui = -2 // or UNIT_MAX-1
int i = 1;
ui+i< 6  // greater than 6
(ui+i)/4  //a bit positive number
int* p;
p+(ui+i);  //on 32 bits, this ok, 
\end{lstlisting}
\begin{description}
	\item[Line 6:] On 64 bits, ui+i will be promote to 64 bits first. At this time, it will be promoted according to unsigned int.
\end{description}
	
	\item You can see llvm, in this reference. 1) only i32, no ui32 2) only add.  3) but has umultiply and uge and zext or sext. That is to say, these three operations need interpret signed semantic differently. 
	
	\item For p+(ui+i) questions, we can use size\_t and ptrdiff\_t type. 
\end{itemize}

\subsubsection{size\_t}
\begin{itemize}
	\item \textbf{Why we need size\_t?, Semanticlly, it should be pointer type, but physically, it's a kind of integer, so when we use int or short or long to represent. it will cause cross-plat-form problem.}
	
	\item Type \texttt{size\_t} is a typedef that's an alias for some unsigned integer type, typically unsigned int or unsigned long, but possibly even unsigned long long. Each Standard C implementation is supposed to choose the unsigned integer that's big enough--but no bigger than needed--to represent the size of the largest possible object on the target platform.
	
	\item Using \texttt{size\_t} appropriately makes your source code a little more self-documenting. When you see an object declared as a \texttt{size\_t}, you immediately know it represents a size in bytes or an index, rather than an error code or a general arithmetic value.
	
	\item The main reason of \texttt{size\_t} is: size of something is dependent on pointer, but on different system, size of pointer is not same as size of int.  textbf{But size of pointer is always same as size\_t}.
	
	\item The size of size\_t and ptrdiff\_t always coincide with the pointer's size. Because of this, it is these types which should be used as indexes for large arrays, for storage of pointers and, pointer arithmetic.
	
	\item size\_t type is usually used for loop counters, array indexing, and address arithmetic.
	
	\item ptrdiff\_t type is a base signed integer type of C/C++ language. The type's size is chosen so that it can store the maximum size of a theoretically possible array of any type. On a 32-bit system ptrdiff\_t will take 32 bits, on a 64-bit one 64 bits.
\begin{lstlisting}[numbers=none]
int A = -2;   // should use ptrdiff_t here
unsigned B = 1; // should use ptrdiff_t here.
int array[5] = { 1, 2, 3, 4, 5 };
int *ptr = array + 3;
ptr = ptr + (A + B); //Error
printf("%i\n", *ptr);
\end{lstlisting}
	
	\item \textbf{In one word, int is not always same as bits of OS. but size\_t and ptrdiff\_t are always same.}
	
	\item A good article is "Why size\_t matters", another one is "About size\_t and ptrdiff\_t". just google them!   
\end{itemize}

\subsection{Aggregate and POD}
\subsubsection{Aggregate}
\begin{itemize}
	\item \textbf{The basic idea of Aggregate type is that you can use aggregate list initialization}. All the detail definition of an aggregate can be traced back to this main idea. 
	
	\item An aggregate is an array or a class with no user-declared constructors, no private or protected non-static data members, no base classes, and no virtual functions.
	
	\item  An aggregate can have a not Aggregate1 data member.
\begin{lstlisting}[numbers=none]
class NotAggregate1{
	virtual void f() {} //remember? no virtual functions
};
	
class NotAggregate2{
	int x; //x is private by default and non-static 
};
	
class Aggregate1{
public:
	NotAggregate1 member1;   //ok, public member
private:
	void f() {} // ok, just a private function
};
\end{lstlisting}
	
	\item Now let's see how aggregates are special. They, unlike non-aggregate classes, can be initialized with curly braces \{\}. 
\begin{lstlisting}[frame=single, language=c++]
struct X{
	int i1;
	int i2;
};
	
struct Y{
	char c;
	X x;
	int i[2];
	float f; 
protected:
	static double d;
private:
	void g(){}      
}; 
	
Y y = {'a', {10, 20}, {20, 30}};
\end{lstlisting}
\begin{description}
	\item[Line 17:] Even we don't assign value to f, f will use value init. 
\end{description}
	
	\item In C++11, Previously, an aggregate could have no user-declared constructors, but now it can't have user-provided constructors. Is there a difference? Yes, there is, because now you can declare constructors and default them:
\begin{lstlisting}[numbers=none]
struct Aggregate {
	Aggregate() = default; 
};
\end{lstlisting}
	
	\item In C++11, Now an aggregate cannot have any brace-or-equal-initializers for non-static data members. What does this mean? Well, this is just because with this new standard, we can initialize members directly in the class like this:
\begin{lstlisting}[numbers=none]
struct NotAggregate {
	int x = 5; // valid in C++11
	std::vector<int> s{1,2,3}; // also valid
};
\end{lstlisting}

	\item Now that we know what's special about aggregates, let's try to understand the restrictions on classes; that is, why they are there. We should understand that memberwise initialization with braces implies that the class is nothing more than the sum of its members. If a user-defined constructor is present, it means that the user needs to do some extra work to initialize the members therefore brace initialization would be incorrect. If virtual functions are present, it means that the objects of this class have (on most implementations) a pointer to the so-called vtable of the class, which is set in the constructor, so brace-initialization would be insufficient. You could figure out the rest of the restrictions in a similar manner as an exercise :).
	
\end{itemize}

\subsubsection{POD}
\begin{itemize}
	
	\item An aggregate class is called a POD if it has no user-defined copy-assignment operator and destructor and none of its nonstatic members is a non-POD class, array of non-POD, or a reference.
	
\begin{lstlisting}[numbers=none]
struct POD{
	int x;
	char y;
	void f() {} //no harm if there's a function
	static std::vector<char> v; //static members do not matter
};
	
struct AggregateButNotPOD1{
	int x;
	~AggregateButNotPOD1() {} //user-defined destructor
};
	
struct AggregateButNotPOD2{
	AggregateButNotPOD1 arrOfNonPod[3]; //array of non-POD class
};
\end{lstlisting}
	
	
	\item POD-classes, POD-unions, scalar types, and arrays of such types are collectively called POD-types.
	
	\item POD-classes are the closest to C structs. Unlike them, PODs can have member functions and arbitrary static members, but neither of these two change the memory layout of the object. So if you want to write a more or less portable dynamic library that can be used from C and even .NET, you should try to make all your exported functions take and return only parameters of POD-types.
	
	\item For objects of POD types it is guaranteed by the standard that when you memcpy the contents of your object into an array of char or unsigned char, and then memcpy the contents back into your object, the object will hold its original value. Do note that there is no such guarantee for objects of non-POD types. Also, you can safely copy POD objects with memcpy. The following example assumes T is a POD-type:
	
	
	\item In C++ 11, The idea of a POD is to capture basically two distinct properties:
	\begin{enumerate}
		\item It supports static initialization,
		\item Compiling a POD in C++ gives you the same memory layout as a struct compiled in C.
	\end{enumerate}
	
	\item Because of this, the definition has been split into two distinct concepts: \textbf{trivial classes} and \textbf{standard-layout classes}, because these are more useful than POD. The standard now rarely uses the term POD, preferring the more specific \textbf{trivial} and \textbf{standard-layout} concepts.
\end{itemize}

\subsubsection{trivial class}
\begin{itemize}
	\item If this is a trivial class, then it has trivial ctor/dtor/copy/assignment, When we build copy or destruct these type, we don't call these trivail ctor/copy... \textbf{but just call malloc() or memcpy()to improve efficiency.}
	
	\item For example, \texttt{std::copy} use \texttt{std::is\_trivially\_copyable} as a flag to decide whether to call memcpy or call object copy ctor.
	
	\item Static initialization is initialization of some variable with a compile-time value such that the value ends up being "baked into" the executable image (no code needs to be actually run):
\begin{lstlisting}[numbers=none]
struct Foo {
	int x;
	int y;
};
	
Foo foo = {0,1};
\end{lstlisting}
	
	\item Trivial is the first property mentioned above: trivial classes support static initialization. If a class is trivially copyable (a superset of trivial classes), it is ok to copy its representation over the place with things like memcpy and expect the result to be the same. The detail is not easy to explain, you can refer a good article in the end of section. 
\begin{lstlisting}[numbers=none]
struct Trivial4 {
public:
	int a;
private: // no restrictions on access modifiers
	int b;
};

struct NonTrivial1 : Trivial4 {
	virtual void f(); 
	// virtual members make non-trivial ctors
};
\end{lstlisting}
	
	\item a class is trivially copyable (a superset of trivial classes), A trivial class is a class that has a trivial default constructor (12.1) and is trivially copyable.
	
\begin{lstlisting}[numbers=none]
template <class T> 
void copy(T* source, T* destination, int n, trivial_false_type){
	for (; n > 0; n--,source++,destination++){
		//call ctor
	}
}
	
template <class T> 
void copy(T* source, T* destination, int n, trivial_true_type){
	memmove(source, destination, n); //much faster here!
}
\end{lstlisting}
	
	
\item std has some type trait class definition. 
\begin{lstlisting}[numbers=none]
cout<<  typeid ( T ).name();
cout<<std::is_pod  < T  >::value;
cout<<std::is_trivial <T >::value;
cout <<std::is_standard_layout <T>::value;
\end{lstlisting}
	
\item A good article about this topic is "What are Aggregates and PODs and how/why are they special?" in StackOverflow. 
\end{itemize}


\section{Name}
\subsection{Namespace}
\subsubsection{Basic knowledge}
\begin{itemize}
	\item Basic namespace style:
	\begin{enumerate}
		\item If you develop a library of functions or classes, put them in a namespace, just like std namespace in STL.
		
		\item Don't put a lot of stuff in global-scope, learn to using namespace to manage and split your global-scope. 
		
		\item Don't put your own class into namespace std; Usually, namespace should be your project name, you can add company name in front of it if you like.
	\end{enumerate}
	
	
	\item Use :: before function will means that global namespace, For example, ::max will hide std::max, in this way, you can define your own max function and use ::max call your own max function. 
	

	\item \textbf{Namespaces can be located at the global level or inside other namespaces. They can't be placed in a block.} So it has external linkage by default, that is to say it can be accessed by multi translation unit(files).


	\item There are three kinds of namespace usages.
\begin{lstlisting}[numbers = none]
using sp::name;   //1) using declaration
using namespace sp;   //2) using directive
sp::name   //3) specific refer it
	
namespace ns{
	int zy;
}
using namespace ns;
int main(){
	int zy = 0; //it will hide ns::zy
	cin>>zy; //read into local zy
}
\end{lstlisting}
	
	\item Using-declaration introduces a member of another namespace into current namespace or block scope.
	
\begin{lstlisting}[numbers=none]
#include <string>
using std::string;
int main(){
	string str = "Example";
	using std::cout;
	cout << str;
}
\end{lstlisting}
\begin{description}
	\item[Line 2 and 5:] They are using-declaration.
\end{description}
	
	\item For implementation code, there are four methods to put it into namespace. Prefer method 3 and method 4.
	
\begin{lstlisting}[frame=single, language=c++]
namespace Yan{ //a.h
	Class Foo{
		void mem_fun();
	};
}
	
using Yan::Foo;
void Foo::mem_fun(){.......}
	
using namespace Yan;
void Foo::mem_fun(){.........}
	
void Yan::Foo::mem_fun(){.........}

namespace Yan{ 
	void Foo::mem_fun(){......}
}
\end{lstlisting}
\begin{description}
	\item[Line 7:]mehtod 1. Then use name, using declaration.
	\item[Line 10:]method 2. Using directive. It's bad style.
	\item[Line 13:]method 3. It's good style.
	\item[Line 15:]method 4. Also good, when you have a lot of function need to be define, compared with method3, save your typing.
\end{description}
	
	\item About "using" directive usage
	\begin{enumerate}
		\item  \textbf{Don't use using directive in any .h file,  because It will pollute all the .cpp file which include this head file.}
		
		\item  Less use using directive in any .cpp file, you should using scope-resolution or using declaring more. It will avoid polluting namespace.
		
\item \textbf{You should remember below code. It's good C++ style!} 
\begin{lstlisting}[numbers=none]
#include <iostream>
using std::cout;
using std::endl;

int main(){
	cout<<"Hello world"<<endl;
}
\end{lstlisting}
		
		\item If you \textbf{have to} use using directory in your .cpp file, put it after all the include files.
	\end{enumerate}
	
	\item unnamed namespace just like static to specify it to local file scope. At the same time, make anonymous namespace as small as possible.  see C++ primer p492
	
\begin{lstlisting}[numbers=none]
// a.cpp file
static int count;
	
// A better method to use namespace.
namespace{
	int count;
}
\end{lstlisting}
	
\end{itemize}

\subsection{Name lookup}
\begin{itemize}
	
	\item \textbf{Phases of the function call process.}
	\begin{enumerate}
		\item Name lookup 
		\item Overload resolution 
		\item Access control
	\end{enumerate}
	
	\item Function name resolution:
	\begin{enumerate}
		\item First, compiler looks in the \textbf{immediate scope},  and makes a list of all functions that has right named  (regardless of whether they're accessible or even take the right number of parameters). Pay attentions here, \textbf{If found function name, even the parameter doesn't match, compiler will not continue outward search. It will stop here and bark}. It's a safe measure, compiler think the immediate scope is "priority zone". Maybe you omit parameter, compiler should not search outward implicitly. 
		
		\item Only if compiler doesn't find any same function name at all, then compiler continue "outward" into the next enclosing scope and repeat.
		
		\item If in the searching scope there are more than one candidate functions, the compiler then stops searching and works with the candidates that it's found, performing overload resolution and then applying access rules.
		
		\item \textbf{In one word, overload resolution will not go across scopes!}
	\end{enumerate}
	
	
	
	\item Overload resolution has a good introduction: "C++ Primer plus" chapter 8 "Which Function version the compiler pick". The main idea is: \textbf{exact match non-template > template > argument conversion(promotion or implicit conversion)}
	
	\item Name lookup include name invisibility or name hidden(introduced in the below subsection).
\end{itemize}

\subsubsection{Name hiding}
\begin{itemize}
	
	\item Compiler will first match function name and number of arguments, then look for template deducted function, then use implicit conversion to try match. So implicit conversion happens after template.
	
	\item There are four examples about immediate scope.
	\begin{enumerate}
		\item class scope:
\begin{lstlisting}[numbers=none]
void f1(int i ){...};

class Foo{
	void f1(string & str){};
	void f2(void){
		int i = 3;
		f1(i); //compiler bark here!
	}
};
\end{lstlisting}
\begin{description}
	\item[Line 7:] compiler bark here! because it only see f1(string\&)
\end{description}
		
		\item Child class scope: In child class scope, if it found name g, then it will stop looking for another name in outward scope. just use g, then found argument number is not match, then compiler bark.
\begin{lstlisting}[numbers=none]
struct B{
	int f( int );
	int g( int );
};
		
struct D : public B{
private:
	int g( std::string, bool );
};
		
D d;
int i;
d.f(i); // ok, means B::f(int)
d.g(i); //error: g takes 2 args
\end{lstlisting}
		
\item Nested namespace scope. (global includes namespace N)
\begin{lstlisting}
void f1(int i ){...};

namespace N{
	void f1(string & str){};
	void f2(void){
		int i = 3;
		f1(i); //compiler will bark
	}
};
\end{lstlisting}
\begin{description}
	\item[Line 7:] You can use ::f1(i) to specify global f1
\end{description}

		\item Nested scope.A class name or enumeration name can be hidden by an explicit declaration of that same name -- as an object, function, or enumerator -- in a nested declarative region or derived class.
\begin{lstlisting}[numbers=none]
int x =2;{
	int x = 3;
}
\end{lstlisting}
		
	\end{enumerate}
	
	\item overwrite is not standard conception in C++, most time, you can call it name hiding. There are two things: The first one is If you redefine the same name non-virtual function in both base and child classes, you can't use dynamic binding, just static binding. 
\begin{lstlisting}[frame=single, language=c++]
class A{
	f(int) {}
};
class B:public class A{
	f(int)  {} // overwrite A::f(int)
};
	
A* pa = new B();
pa->f(3) 
\end{lstlisting}
\begin{description}
	\item[Line 9:] Will call base f. Because pa is A* even it points to B
\end{description}
	
	\item How to resolve it.  There are two methods:
	\begin{enumerate}
		\item using declaration.
		
		\item You can use :: to specify global variable name or function if you have same name in you local scope.  Or use Base:: to specify Base scope name if you have same name in derived class.
\begin{lstlisting}[numbers=none]
struct B{
	int g( int );
};

struct D : public B{
private:
	int g( std::string, bool );
};

D d; 
int i;
d.B::g(i); // method 1,asks for B::g(int)
		
struct D : public B{ 
	using B::g; //method 2, introduce new name to D
private:
	int g( std::string, bool );
};
\end{lstlisting}
		
	\end{enumerate}
\end{itemize}

\subsubsection{ADL}
\begin{itemize}
	\item Koenig(ADL) lookup: If you supply a function argument of class type (here x, of type A::X), then to look up the correct function name the compiler considers matching names in the namespace (here A) containing the argument's type.
	
\begin{lstlisting}[numbers=none]
namespace NS{
	class T { };
	void f(T);
}
	
NS::T parm;
int main() {
	f(parm); // OK, calls NS::f
}
\end{lstlisting}
	
\item ADL is for resolve \texttt{operator<<} problem.
\begin{lstlisting}[frame=single, language=c++]
namespace sak { // SakBigNum.h
	struct bignum {
		bignum operator++();
	};
	std::ostream& operator<<(std::ostream&, bignum); 
}

namespace ajo { // AjoBigNum.h
	struct bignum {
		bignum operator++();
	};
	std::ostream& operator<<(std::ostream&, bignum);
}
	
namespace ajo {
	void bar(int& x) {
		sak::bignum b;   // refers to sak::bignum
		++b;             // calls sak::bignum::operator++()
		std::cout << b;  
	}
}
\end{lstlisting}
\begin{description}
	\item[Line 19:] UH-OH! should call yellow one in Line 5, but we call \texttt{operator <<} Line 12 in ajo namespace.
\end{description}
	
	\item compiler applies ADL whenever it's doing name lookup (building a candidate set) for an unqualified function call. If the name of the thing-being-called has any ::-qualification at all, then ADL won't kick in.
	
\begin{lstlisting}[numbers=none]
namespace A {
	struct A { operator int(); };
	void f(A);
}
namespace B {
	void f(int);
	void test() {
		A::A a;
		f(a);     // ADL, calls A::f(A)
		B::f(a);  // no ADL, calls B::f(int)
	}
}
	\end{lstlisting}
	
	\item  if the thing is not "a function call," then ADL won't kick in. (That is, we don't try to apply Argument-Dependent Lookup to names that don't have arguments.) 
	
	\item ADL can bring name lookup ambiguous problem.  When you call f(parm) f is in global scope, So number 2 is in the \textbf{searching scope} default. But ADL bring namespace NS scope into searching scope. In searching scope, there are two options, so compiler will bark.
	
\begin{lstlisting}[numbers=none]
namespace NS { // some header T.h
	class T { };
	void f( T ); //  number 1, add new function
}

void f( NS::T ); //number 2
	
int main(){
	NS::T parm;
	f(parm); // ambiguous: NS::f  or global f?
}
\end{lstlisting}
	
	\item Just like the previous example, g is in the namespace B, with help of ADL, \textbf{searching scope is namespace A + namespace B}. there are two f in the searching scope.
	
\begin{lstlisting}[numbers=none]
namespace A{
	class X { };
	void f( X ); // <-- new function
}
	
namespace B{
	void f( A::X );
	void g( A::X parm ){
		f(parm); // ambiguous: A::f or B::f?
	}
}
\end{lstlisting}
	
	\item In name lookup, the C++ language deliberately says that a member function is to be considered more strongly related to a class than a nonmember.
\begin{lstlisting}[numbers=none]
namespace A{
	class X { };
	void f( X );
}
	
class B{ // <-- class, not namespace
	void f( A::X );
	void g( A::X parm ){
		f(parm); // OK: B::f, not ambiguous
	}
};
\end{lstlisting}
	
	\item For a class X, all functions, including free functions, that both "Mention" X
	and "supplied with" X are logically part of X, because they form part of the interface of X. supplied with X means that that function is defined in the same .h file with type X. 
	
	\item Keep a type and its nonmember function interface in the same namespace, 1) in logic, these nonmember function can be regarded as type interface, 2) avoid name ambiguous problem in the future.
\begin{lstlisting}[numbers=none]
namespace N{
	class X {};
	X operator+( const X&, const X& );
}
	
x3 = x1+x2;
\end{lstlisting}
	
	\item On the contrary, Keep types and functions in separate namespaces unless they're specifically intended to work together.
	
\begin{lstlisting}[numbers=none]
#include <vector>
namespace N {
	struct X {};
}

// this template should not be put in the namespace N
template<typename T>
int* operator+( T , unsigned ) {/* do something */}
\end{lstlisting}
\end{itemize}


\section{operator overload}
\begin{itemize}
	
	\item  \textbf{Overloading just happens in the same name scope, not in the hierarchy}. So in this way, any same name is base class will not  visible in derived class. You can use using keyword to add it in your derived class. Then It will compile. Consider these complex things, \textbf{Don't redefine or overload base class non virtual functions in your child class}
	
	\item To provide two (or more) functions that perform similar, closely related things, differentiated by the types and/or number of arguments it accepts.
	
	\begin{enumerate}
		\item \textbf{In some cases it's worth arguing that a function of a different name is a better choice than an overloaded function.}
		
		\item  In the case of constructors, overloading is the only choice.
		
		\item  operator overload is also very common.
	\end{enumerate}
	
	\item Consider overloading to avoid implicit type conversion. In this way, we can avoid creating a temporary obj implicitly created by ctor.
	
\begin{lstlisting}[frame=single, language=c++]
class String{
	bool operator==(const String& lhs, const String& rhs);
}
String str;
if(str =="hello") //will build a temp obj String("hello");
	
bool operator==(const String& lhs, const char* rhs);
\end{lstlisting}
\begin{description}
	\item[Line 7:] You can define overload to avoid implicit type conversion.
\end{description}
	
	\item Sometimes, overload and default parameter have same client usage, such as
\begin{lstlisting}[numbers=none]
void f();
void f(int x);
f() or f(10);
	
void g(int x = 0);
g() or g(10);
\end{lstlisting}
	
	If there is a value that you can use for a default, use default parameter. The difference is logical - When overload, the two functions can behave completely different, whereas the second case will have more or less the same logic.
	
\end{itemize}


\chapter{Initialization}
\section{Basic knowledge}

\subsection{basic conception and rule}
\begin{itemize}
	\item \textbf{Always initialize variable before you use it.} Manually initialize non-member objects of built-in types,including a pointer.
	
	\item There are three names you need to distinguish: 1)initilizer list, 2) brace(list) initialization, 3) member initialization list(mem-init)
	\begin{enumerate}
		\item member initialization list is used in C++ ctor to initialize all members inside an object. it has some advantages: Detail can be found in "OOP" section. 
		
		\item brace initialization is a generic initialization syntax(method), it supports more initialization, such as class member and aggregation. At the same time, it will avoid narrowing and vexing parsing problem. 
		
		\item initilizer list is \texttt{std::initializer\_list}. It is a \textbf{new data type. just like std::list.}
	\end{enumerate}
\end{itemize}

\subsection{initialization order}
\begin{itemize}
	\item In the same translation unit, formally, C++ initializes static and global variables in three phases:
	\begin{enumerate}
		\item Zero initialization.
		\item Static initialization.
		\item Dynamic initialization.
	\end{enumerate}
	
\begin{lstlisting}[numbers=none]
int g0;  //zero initialization
int g1 = 42;    //  static initialization
extern int f();
int g2 = f();   //  dynamic initialization
\end{lstlisting}
	\item It will cause some subtle bug shown below:
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
int a = f(); // a exists just to call f
int x = 22;
int f() {
	++x;
	return 123; // unimportant arbitrary number
}
\end{lstlisting}
\begin{description}
	\item[Source code:] x equals to 23, not 22. Bcause static initialization is earlier than dynamic initialization.
\end{description}
	
	\item Pay attention to the global object which are initialized in right order. Because the order can be arranged in the same translation unit, but not \textbf{between translation units}, see effective c++ Item 47. So we don't encourage you to use global object unless it's very necessary.
	
	\item The initialization order uncertainty that afflicts non-local static objects defined in separate translation units. The questions is below:
	
\begin{lstlisting}[frame=single, language=c++]
#include "x.h" // File x.cpp
X x;
	
#include "y.h" // File y.cpp
extern X x;
Y y;
Y::Y(){ 
	x.goBowling();
}
\end{lstlisting}
\begin{description}
	\item[Line 2:] x maybe initialize before y or after y.
	\item[Line 8:] Here x maybe not be constructed
\end{description}
	
	\item  How to resolve: Using a singleton design pattern.
	\begin{lstlisting}[numbers=none]
#include "x.h"  // File x.cpp
X& getX(){
	static X x;
	return x;
	//another implementation.
	//static X* px = new X();
	//return *px;
}
	
#include "y.h" // File y.cpp
Y y;
Y::Y(){
	getX().goBowling();
}
\end{lstlisting}
\end{itemize}


\subsection{Init methods}

\subsubsection{Six init methods}
\begin{itemize}
	\item There are six \textbf{initializations forms}:
	\begin{enumerate}
		\item default initialization.
\begin{lstlisting}[numbers=none]
T t;
new T;  //default
\end{lstlisting}
		\item value initialization.
\begin{lstlisting}[numbers=none]
T t{};
T(); T{};
new T(); new T{};
: member(), member{}  
// class member initializer lists (value Init)
\end{lstlisting}
		\item direct initialization.
\begin{lstlisting}[numbers=none]
T object(arg, ... );
T(arg1, arg2, ... );
new T(args, ...)
: member(args, ...)   // class member initializer lists
T(other)              // function-style cast
static_cast<T>(other) // explicit static_cast
[arg](){...}          // lambda closure arguments captured by value
//lambda is object, so for this object, 
//lambda_1 obj(arg), is a direct init
\end{lstlisting}
		\item copy initialization.
\begin{lstlisting}[numbers=none]
T object = other;        // Initialization via assignment
T array[N] = {other};    // In array-initialization, the individual
// values are copy-initialized
f(other)                 // Pass-by-value
return other;            // Return-by-value
catch (T object)         // Catch-by-value
throw object;
\end{lstlisting}
		\item Aggregate initialization is used when initializing arrays or simple struct (all-member-public, no user-provided c'ctors.)
\begin{lstlisting}[numbers=none]
T object = {arg1, arg2, ...}; // If T is an array or a simple struct
T object{arg1, arg2, ...};    // If T is an array or a simple struct
\end{lstlisting}
		\item reference initialization. It must has a reference symbol.
\begin{lstlisting}[numbers=none]
T & ref = object ;
T & ref = { arg1, arg2, ... };
T & ref ( object ) ;
T & ref { arg1, arg2, ... } ;
\end{lstlisting}
	\end{enumerate}


	\item Summary:
\begin{enumerate}
	\item Without parentheses, it's default, tell the compiler to use it's default method;
	\item Use empty parentheses or brace, it's value, tell the compiler to init them, (if there is user define one, use user-define, otherwise zero)
	\item Use parentheses with value, direct init, just command compile to init what I want.
	\item When pass to function or return from function by value, is copy
	\item Aggregate init can only be used for aggregate type.
	\item reference init is the most easy.
	\item Many different syntax expression can be useful when you do generic programming.
\end{enumerate}

\item list init is not initializations forms, but just a new syntax. \textbf{You can use list init syntax on three initializations forms:}
\begin{enumerate}
	\item value list init
\begin{lstlisting}[numbers=none]
T object{};
T{};
new T{}
Class { T member{}; };
: member{}  // Class member initializer lists
\end{lstlisting}
	\item direct list init
\begin{lstlisting}[numbers=none]
T object{arg, ...};
T {arg, ...};
new T{arg, ...}

Class {  // Class member initializer
	T member{arg, ...}; 
};
 
: member{arg, ...} // Class member initializer lists
\end{lstlisting}
	\item copy list init
\begin{lstlisting}
T object = {arg, ...};
object = {arg, ...};
Class { T member = {arg, ...}; };
function({arg, ...}); 
return {arg, ...};  
\end{lstlisting}
\begin{description}
	\item[Line 3:] Class member default initializer
	\item[Line 4:] Initializes temporary for the function arg
	\item[Line 5:] Initializes temporary for return value
\end{description}
\end{enumerate}

\item \textbf{list init is just in syntax level, for the detail init form, it depends on the specific data type.}  For example: If T is an aggregate type, \textbf{aggregate initialization} is performed. Otherwise, If the braced-init-list is empty and T is a class type with a default constructor, \textbf{value-initialization} is performed.

\begin{lstlisting}
A a{};
A a{1};
\end{lstlisting}
\begin{description}
	\item[Line 1:] It's value init.
	\item[Line 2:] Even you see brace here, but it can be direct init or aggregate type. \textbf{You can't judge init form only by existing of brace.}
\end{description}

\item After you know six forms init, you also need to know more detail.I will introduce three differences in the next three sections: differences between value init and default init, differences between direct init and copy init and differences between traditional copy init and list copy init. The bad news is they are complicated, the good news is that a short summary is given in the end of each section. Let's Go!
\end{itemize}


\subsubsection{Value init and default init}
\begin{itemize}
	\item Basic knowlege. googling "Value-initialization with C++"
	
	\item For value init, It's depends on if you have user define ctor. if you don't have, set it to zero. But if you have one, compiler will not set it to zero any more. That is easy to understand, you have higher authorization than compiler. 
	
\begin{lstlisting}[frame=single, language=c++]
class exec{
	public:
	exec() = default;
	int i;
};
	
class exec2{
	public:
	exec2();
	int i;
};
exec2::exec2() = default;
	
const exec e;      
const exec2 e2;    

exec e    
exec e{}  
	
exec2 e  
exec2 e{}  
\end{lstlisting}
\begin{description}
	\item[Line 14:] erro, exec has default ctor
	\item[Line 15:] right, exec2 has user-define ctor
	\item[Line 17:] default init, so e.i is random
	\item[Line 18:] value init, but there is no user-define ctor, so e.i == 0
	\item[Line 20:] default init, so e.i is random
	\item[Line 21:] value init, but there is user-define ctor, so e.i is random
\end{description}
	
	\item Value init also kick in when you use \texttt{new}. Detail can be found: "Do the parentheses after the type name make a difference with new?"
	
\begin{lstlisting}[frame=single, language=c++]
struct A { int m; }; // POD
struct B { ~B(); int m; }; 
struct C { C() : m() {}; ~C(); int m; }; 
\end{lstlisting}
\begin{description}
	\item[Line 2:] non-POD,compiler generated default ctor.
	\item[Line 3:] non-POD, default-initialising m
\end{description}
	
	In a C++03 compiler, things should work like this:
	\begin{itemize}
		\item new A - indeterminate value
		\item new A() - value-initialize A, which is zero-initialization since it's a POD.
		
		\item new B - default-initializes (leaves B::m uninitialized)
		
		\item new B() - value-initializes B which zero-initializes all fields since its default ctor is compiler generated as opposed to user-defined.
		
		\item new C - default-initializes C, which calls the default ctor.
		
		\item new C() - value-initializes C, which calls the default ctor.
	\end{itemize}
\item \textbf{Summary:} 
\begin{enumerate}
	\item If there is empty parentheses or brace in the end, it maybe is value init.
	\item the result of value init is affected by if you have user-defined default ctor.
\end{enumerate}
\end{itemize}



\subsubsection{copy init and direct init}
\begin{itemize}

	\item \textbf{copy init is difference with copy ctor.} calling copy ctor  is  direct init? If it's copy init, so it need two steps, create temp, then copy temp.  If it's direct init, just call one ctor(by overload resolve). Above it's theoretical definition. When optimization kick in, it hides the deep theoretical definition.
	
	\item An example and analysis:
\begin{lstlisting}[frame=single, language=c++]
ClassTest ct1("ab"); //direct init
ClassTest ct2 = "ab"; //copy init 
ClassTest ct3 = ct1; //copy init
ClassTest ct4(ct1); //direct init
ClassTest ct5 = ClassTest(); //copy init Class has default ctor
ClassTest ct6 = {1,2} //copy init Class has two parameter ctor.
\end{lstlisting}
\begin{description}
	\item[Line 2:]  When optimization turn on, ct2 call single argument directly. But it's still copy init. ct2 is copy init. Compiler analyzes the syntax according theoretical definition, for ct2, if copy ctor is private, then compile will stop. if copy ctor is public, then optimizaiton kick in, it call single argument ctor directly.
	
	\item[Line 3:] for ct3, It's copy init. Compiler thinks the ct1(temp) has been created, then call copy ctor directly. but in fact, it's still copy init.
	
	\item[Line 4:] ct4 is direct init call copy ctor. because in theoretical it's only one step, call a ctor by overload. 
	
	\item[Line 5:] It's not direct init, nor a copy init. It's complex statements.
	
	\item[Line 6:] It's copy init.
	
	\item[Source code:] 
\end{description}

	\item copy init and direct init has different behavior:
	\begin{enumerate}
		\item Direct initialization behaves like a function call to an overloaded function: The functions, in this case, are the constructors of T (including explicit ones), and the argument is x. Overload resolution will find the best matching constructor, and when needed will do any implicit conversion required.
		While direct initialization has all constructors available to call, and in addition can do any implicit conversion it needs to match up argument types.
		
		\item Copy initialization constructs an implicit conversion sequence: It tries to convert x to an object of type T. (It then may copy over that object into the to-initialized object, so a copy constructor is needed too - but this is not important below) copy initialization can just set up one implicit conversion sequence.
	\end{enumerate}
\begin{lstlisting}
struct B;
struct A { 
	operator B() {cout<<"A-o-B,"; return B();}
};
struct B { 
	B() { }
	B(A const&) { cout <<"A-c-B,"; }
};
struct C{
	operator A() {cout<<"C-o-A,"; return A();}
};
 
A a;
B b = a;  //OK, print A-o-B
C c;
B b1(c); //OK, print C-o-A, A-c-B
B b2 = c; //ERROR
\end{lstlisting}
\begin{description}
	\item[Line 14:]  copy initialization will construct a conversion sequence when a has not type B or derived from it (which is clearly the case here). So it will look for ways to do the conversion, and will find the following candidates: 1) B(A const\&) and operator B(A\&). Because a is not const, so less const version wins. 
	
	\item[Line 16:] Direct initialization behaves like a function call. it will do any implicit conversion it needs to match up argument types.
	
	\item[Line 17:] copy initialization can just set up one implicit conversion sequence. Although there is two steps conversion: C-->A-->B, but there is not one step conversion C-->B. So copy init fail here.
	
\end{description}


\item \textbf{Summary:}
\begin{enumerate}
	\item In one word, Whether it's a copy init or direct init doesn't depend on whether it call copy ctor.  it depends on (in theoretical) whether it has two steps(has equal sign).
	
	\item For direct init, it call ctor directly, and do do any implicit conversion it needs to match up argument types..
	
	\item For copy init, 1) make sure copy ctor accessible(not private) 2) one the right side of =, just set up one implicit conversion sequence.
\end{enumerate}

		
\item a good link is \verb|https://www.cnblogs.com/pluse/p/7088880.html|
\item A good article is "Is there a difference between copy initialization and direct initialization?"

	
\end{itemize}

\subsubsection{traditional copy init and list copy init}
\begin{itemize}
	\item The most important differences:
	\begin{enumerate}
		\item traditional copy init uses notion of user-defined conversion sequences (and, particularly, requires availability of copy constructor, as was mentioned)
		
		\item list copy init just performs overload resolution among applicable constructors, i.e. brace initialization can't use operators of conversion to class type
	\end{enumerate}
\begin{lstlisting}
struct Intermediate {};
struct S{
	operator Intermediate() { return {}; }
};
struct S1{
	S1(Intermediate) {}
};

S s;
Intermediate im1 = s; // OK
Intermediate im2 = {s}; // ill-formed
S1 s11 = s; // ill-formed
S1 s12 = {s}; // OK
\end{lstlisting}

	\begin{description}
		\item[Line 10:] copy initialization uses notion of user-defined conversion sequences (and, particularly, requires availability of copy constructor, as was mentioned)
		
		\item[Line 11:] list copy initialization just performs overload resolution among applicable constructors, i.e. brace initialization can't use operators of conversion to class type. Intermediate has not ctor with S as argument.
		
		\item[Line 12:] copy initialization can just set up one implicit conversion sequence. In this case 1) S change to Intermediate by operator, 2) from Intermediate to S1 by constructor.  You can see there are two implicit conversion.
		
		\item[Line 13:] list copy initialization use constructors, and it will do any implicit conversion it needs to match up argument types. In this case 1) S change to Intermediate by operator, 2) call S1's constructor and pass this temporary Intermediate.
	\end{description}
	
	
\item copy list init also supports multiple arguments.
\begin{lstlisting}[frame=single, language=c++]
class A{
public:
	int i;
	explicit A(int a = 0):i(a){cout<<"one";}
	A(int a , int b ):i(a){cout<<"two";}
	A(const A &T){ cout<<"copy ctor";} 
};
	
A too = (1,2); 
A too = {1,2};
A fun(A);
fun({1,2}) {return{3,4};}
\end{lstlisting}
	\begin{description}
		\item[Line 9:] fail, it (1,2) became 2, then call single ctor() and comma is operator, it's different with {}
		
		\item[Line 10:] work, call two parameter ctor. 
		
		\item[Line 12:] Usually, we don't declare two parameter ctor as explicit. So we can also pass fun argument and return by using a copy list init form. You can see the expression is simple and it will call ctor directly. 
	\end{description}

\item Does the equal sign make a difference in brace initialization? eg. 'T a = \{\}' vs 'T a\{\}' The only significant difference I know is in the treatment of explicit constructors:
\begin{lstlisting}
struct foo{
	explicit foo(int);
};
foo f0 {42};    // OK
foo f1 = {42};  // not allowed
\end{lstlisting}

\item in C++11 that allows brace-elision only for the copy list init.
\begin{lstlisting}
struct aggr{
	int arr[5];
};
aggr a0 = {1,2,3,4,5};  // OK
aggr a1 {1,2,3,4,5};    // not allowed
\end{lstlisting}

\item \textbf{Summary:}
\begin{enumerate}
	\item copy list init just performs overload resolution among applicable constructors
	
	\item copy list init with multiple arguments ctor make function call and return easier, illustrated by the previous source code.
\end{enumerate}

	\item A good article is "Any difference between copy-list-initialization and traditional copy-initialization?"
	

\end{itemize}

\subsubsection{explicit}
\begin{itemize}
	\item When copy ctor is explicit.
\begin{lstlisting}[frame=single, language=c++]
class A{
public:
	A(int a = 0);
	explicit A(const A &a){} //EXPLICIT copy constructor
};
	
void funcX(A a) {
	//ERROR, take A by value (implicit copying)
}
A funcY(){ 
	A a;
	return a; //ERROR, returning A by value(implicit copying)
}
A a1 = a; //ERROR, implicit copying of A not allowed
A a1(a); //OK - EXPLICIT copying allowed
A a = 1;
\end{lstlisting}
	\begin{description}
		\item[Line 4:] Usually, we don't make copy ctor explicit, because it will disable function call and return value.
		
		\item[Line 14 and 15:] Difference between A a(a1) and A a = a1.  They are almost same. But When copy ctor is explicit,  A a1 = a will not work, but A a1(a) work.
		
		\item[Line 16:] \textbf{With explicit copy ctor, A a = 1 still work.But when the copy ctor is private, A a = 1 fail}.Although we don't call copy ctor directly, but we need to make sure it accessible. We don't consider copy ctor's explicit in this case.
	\end{description}
	
	\item When parameterized ctor and copy ctor are both explicit.
\begin{lstlisting}[frame=single, language=c++]
class A{
public:
	explicit A(int k):m_a(k){};
	explicit A(const A& rhs){m_a = rhs.m_a;};
	int m_a;
};
	
A a=110;// ERROR
A a(110) //this will work here.
A a1 = a; // ERROR, because copy ctor is explicit.
\end{lstlisting}
	\begin{description}
		\item[Line 8:] it's copy list init, It will call ctor directly, because \texttt{A(int k)} is explicit, so it fails.
		\item[Line 9:] Work, satisfy explicit requirement
		\item[Line 10:] it's copy list init, It will call ctor directly, because \texttt{A(const A\& rhs)} is explicit, so it fails.
	\end{description}
	
	\item  When single parameter ctor is explicit.
\begin{lstlisting}
class A{
public:
	explicit A(int k):m_a(k){};
	A(const A& rhs){m_a = rhs.m_a;};
	int m_a;
};
	
A a = 1; // fail. 
A a = {1}  //fail
A a = A{1}  //work
A a = A(1)  //work
\end{lstlisting}
	\begin{description}
		\item[Line 3 and 4:] Most of time, Single parameter ctor is explicit, copy ctor is not.
		
		\item[Line 7 and 8:] With explicict A(int i) ctor, A a = 1 will fail, but A a = A{1} will work.
	\end{description}


\item \textbf{Summary:}
\begin{enumerate}
	\item The first step is to see the right side of =, if converting ctor is explicit, we have to use A\{1\} to explicit call it. For example: A a = A\{1\} will work. A a = \{1\} will not work. 
	
	\item The second step is to see when you use brace init. if it has initlizer\_list ctor, it has strong preference. we will talk about it later.
	
	\item The third step is to see if copy ctor is explicit. if yes, A a = A\{1\} will fail, but A a = \{1\} work.
	
	\item \textbf{explicit copy ctor only disable A a1=a; but not disable A a1=1; But private copy ctor will disable both.}
	
\end{enumerate}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\linewidth]{pics/copy_init.png}
	\caption{}
	\label{Explicit and init }
\end{figure}

\begin{tabular}{|p{0.27\textwidth}|p{0.6\textwidth}|}
	\tophline
	Expression & meaning \\
	\tophline
	A a = (i), A a=\{i\} & explicit converting ctor will not work \\
	\tophline
	A a = A(i), A a = A\{i\} & explicit copy ctor will not work 
	\bottomhline
\end{tabular}

\item Last summary about previous three sections.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.9\linewidth]{pics/copy_list.png}
	\caption{difference between direct, copy and list-copy init}
	\label{fig:copylist}
\end{figure}


\end{itemize}


\subsubsection{How to analyze init expression}
\begin{itemize}
	\item I will analyze a real example, at the same time give C++ standard document. \textbf{The purpose of this example is how to analyze the complex init method in the future.}
\begin{lstlisting}{numbers=none}
#include <iostream>
struct A {
	A(int i) : i(i) {}
	A() = default;
	int i;
};
	
int main() {
	A a{};
	std::cout << a.i << std::endl;
}
\end{lstlisting}

	\begin{enumerate}
		\item List initialization of A, causes 2.Why it's list init, because it use \{\} in line 9;
		
		\item Non-aggregate, class type with a default constructor, and an empty braced-init-list causes value initialization, go to 3. refer *1 in the below C++ standard.
		
		\item No user-provided default constructor found, so zero-initialize the object, go to 4. refer *3 in the below C++standard.
		
		\item Invoke default-initialization if the implicitly-defined default constructor is non-trivial (it is in this case so nothing is done).
	\end{enumerate}


\begin{lstlisting}{numbers=none}
#include <iostream>
struct A {
A() = delete;
int i;
};

int main() {
	cout<<is_aggregate_v<A><<endl;
	A a{};
}
\end{lstlisting}

\begin{enumerate}
	\item List initialization of A, causes 2. Why it's list init, because it use \{\} in line 9;
	
	\item aggregate,  use aggregate init. go to 3, refer to *2 in the below C++ standard.
	
	\item Use default init, go to 4, refer to *5 in the below c++ standard.
	
	\item A a\{\} becomes A a;(default init), then because default ctor is deleted, so in the end it report error.
\end{enumerate}


	\item Below is C++ standard:
	\begin{quote}
*1 If the braced-init-list is empty and T is a class type with a default constructor, value-initialization is performed. \newline
*2 Otherwise, if T is an aggregate type, aggregate initialization is performed.
\newline

https://en.cppreference.com/w/cpp/language/value\_initialization \newline
*3 if T is a class type with no default constructor or with a user-provided or deleted default constructor, the object is default-initialized; \newline
*4 if T is a class type with a default constructor that is neither user-provided nor deleted (that is, it may be a class with an implicitly-defined or defaulted default constructor), the object is zero-initialized and then it is default-initialized if it has a non-trivial default constructor; \newline

https://en.cppreference.com/w/cpp/language/aggregate\_initialization \newline
*5 If the number of initializer clauses is less than the number of members and bases (since C++17) or initializer list is completely empty, the remaining members and bases (since C++17) are initialized by their default member initializers,
	\end{quote}



	\item \textbf{Summary:} Although C++ standard is not very easy to read, but it's very helpful, With the help of it. You can analyze the init syntax step by step, in the end, get the atomic and bottom level and to know what init expression really does.
	
	\item A good article about this is "Initialization in C++ is Seriously Bonkers"
	
\end{itemize}

\section{Brace Init}

\subsection{Basic syntax}
\begin{itemize}
	
	\item The basic syntax examples. 
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
int x1 = 27;  
int x2(27);   //before C++11

int x3{ 27 }; //after C++11
int x4={ 27 }; 
\end{lstlisting}
\begin{description}
	\item[Line 4:] Brace init, introudced in C++11.
	\item[Line 5:] Like line 3, but for class type, a trivial difference. can't use with explicit copy ctor(introduced before)
\end{description}
	
\item More detail syntax analysis.
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
widget w;               // (a)
widget w();             // (b)
widget w{};             // (c)
	
widget w(x);            // (d)
widget w{x};            // (e)
	
widget w = x;           // (f)
widget w = {x};         // (g)
	
auto w = x;             // (h)
auto w = widget{x};     // (i)
\end{lstlisting}
	
	\begin{enumerate}
		\item (a) is just default init with default ctor.
		
		\item \textbf{(b) is function declaration.} That is why we prefer use brace init (c), it will avoid this vex problem.
		
		\item For (d) and (e), These are both direct initialization. The variable w is initialized "directly" from the value of x by calling \texttt{widget::widget(x)}. If x is also of type widget, this invokes the copy constructor. Otherwise, it invokes a converting constructor.
		
		\item (e) is better than (d) to avoid narrowing, for example:
\begin{lstlisting}[numbers=none]
Class A{
	A(int){}
}
A a(1.2); //work
A a{1.2}; //fail
\end{lstlisting}
		\item For (e), it prefer constructor that takes an \texttt{initializer\_list.}
		
		\item For (f), when x is type of widget, just like (d), but can't work when copy ctor is explicit(introduced before)
		
		\item for (f), when x is not type of widget, it will convert x to a temporary If x is of some other type, \textbf{conceptually} the compiler first implicitly converts x to a temporary widget object, then move-constructs w from that temporary rvalue, using copy construction as "the slow way to move" as a backup if no better move constructor is available. Assuming that an implicit conversion is available, (f) means the same as widget w( widget(x) );. Note that I said "conceptually" a few times above. That's because practically compilers are allowed to, and routinely do, optimize away the temporary and, if an implicit conversion is available, convert (f) to (d), thus optimizing away the extra move operation. However, even when the compiler does this, the widget copy constructor must still be accessible, even if is not called, the copy constructor's side effects may or may not happen.

		\item For (g), This is called â€œcopy list initialization.â€ It means the same as \texttt{widget w{x}}; except that explicit constructors cannot be used. Itâ€™s guaranteed that only a single constructor is called.
		
		\item (h) just like type-of-x w(x), is same with (d), only single copy ctor is called
		
		\item (i) is the most consistent spelling when you do want to commit to a specific type and explicitly request a conversion if needed, and once again the \{ \} syntax happily avoids lossy narrowing conversions. In practice on most compilers, only a single constructor is called-similarly to what we saw with (f) and (g).
		
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
class Test{
public:
	int i;
	Test(int a = 0):i(a){}
	Test(const Test &T){ cout<<"copy ctor";} 
};
		
Test too = 2;  //test for (f) 
Test too = {2} // test for (g)
		
Test too;  
auto w = too //test for (h)
auto w = Test{2} //test for (i)
\end{lstlisting}
\begin{description}
	\item[Line 8 and 9:] Both (f) and (g) work and no call copy ctor (no output:"copy ctor"); If converting ctor has explicit both fail,but Test too{2} succeed; if copy ctor is private, (f) fail.

	\item[Line 11 and 12:] When copy ctor has explict --fail.
	
	\item[Line 13:] you can use auto w = Test(2), it just call ctor, and w is not const reference.
	\item[Line 13:]  \{\} is better, it more generic and avoid narrow auto w = Test\{1.2\} fail, auto w=Test(1.2) ok. Even converting ctor is explict, it can work too. don't call copy ctor at all.
\end{description}

	\end{enumerate}

\end{itemize}

\subsection{Brace init advantages}

\begin{itemize}
\item Compared with old C++(C++03), modern C++(C++11) introduced Brace init, (also called Uniform init) and it has some advantages.
\begin{enumerate}
	\item avoid narrow error.
	\item simple value init.
	\item uniform support for more types.(Aggregate, Container, class member etc)
	\item omit type when you pass or return from function by using copy list init.
	\item avoid vexing problem.
\end{enumerate}
I will introduce these advantages in the next subseciton.
\end{itemize}

\subsubsection{Basic advantage}
\begin{itemize}
\item First, let's introduce narrowing problem
\begin{lstlisting}{numbers=none}
double val = 7.4;
int i {val}; //error, possible truncation.
\end{lstlisting}


\item Second, let's introduce the simple value init. \textbf{empty brace is value init.} Value initialization of aggregate types usually means initialization to binary zeros, whereas for non-aggregate types, value initialization means default construction.
\begin{lstlisting}[numbers = none]
//C++11: default initialization using {}
int *p{}; 
char s[12]{}; 
char *p=new char [5]{}; 

int i{};                
std::string s{};        
std::vector<float> v{}; 
double d{};             
\end{lstlisting}
\begin{description}
	\item[Line 2:] initialized to nullptr
	\item[Line 3:] all 12 characters are initialized to '\\0'
	\item[Line 4:] all five chars are initialized to '\\0'
	\item[Line 6:] i becomes 0, can't use () here
	\item[Line 7:] s becomes "" can't use () here
	\item[Line 8:] v becomes an empty vector
	\item[Line 9:] d becomes 0.0, can't use () here
\end{description}



\item In C++, anonymous variables are primarily used either to pass or return values without having to create lots of temporary variables to do so. anonymous objects are treated as rvalues (not lvalues, which have an address). This means anonymous objects can only be passed or returned by value or const reference. Otherwise, a named variable must be used instead.

\begin{lstlisting}[frame=single, language=c++]
Cents add(const Cents &c1, const Cents &c2){
return Cents(c1.getCents() + c2.getCents());
// return anonymous Cents value
}

cout <<add(Cents{6}, Cents{8}).getCents();
\end{lstlisting}

\item Third, omit type when you pass or return from function by using copy list init. it's future proof. If you later rename the class, the brace one will continue to work as is, while the parenthesis one will require a name change.

\begin{lstlisting}
MyClass2 fun (MyClass2 m) 

fun ( {2011,3.14} ){
	return {2011,3.14};  //there is ; in the end
}

fun ( MyClass2(2011,3.14) ) 
// fun ( (2011,3.14) ) doesn't work

MyClass2 mc2;
mc2 = {2011,3.14}  // or MyClass2(2011, 3.14)
\end{lstlisting}


\end{itemize}

\subsubsection{Uniform init syntax}
\begin{itemize}

\item Uniform support for more types. \textbf{Next few example will demonstrate how to init aggregate, class member and STL container.} This feature make it easier to right more generic template function. 
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
// C++98 
double *pd= new double [3];
rectangle       w( origin(), extents() );     
vector<int>     v;
for( int i = 1; i <= 4; ++i ) v.push_back(i);

// C++11 (note: "=" is mostly optional)
double *pd= new double [3] {0.5, 1.2, 12.99};
rectangle       w   = { origin(), extents() }; 
vector<int>     v   = { 1, 2, 3, 4 };
\end{lstlisting}
\begin{description}
	\item[Line 2:] before C++11, you can't init it.
	
	\item[Line 3:] vexing parse, will introduce later.
	
	\item[Line 5:] need more code  to initialize this.
\end{description}
	
	\item Only brace init can be used to initialize \textbf{class aggregated member}

\begin{lstlisting}[frame=single, language=c++,mathescape=true]
class Array{
public:
	Array(): myData{1,2,3,4,5}{}    
private:
	int myData[5];
};
\end{lstlisting}

\item \textbf{direct init aggreaged varaible}
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
int intArray[]= {1,2,3,4,5};   
std::vector<int> intArray1{1,2,3,4,5};  
std::map<std::string,int> myMap{{"Scott",1976}, {"Dijkstra",1972}};
\end{lstlisting}
	
\item Init aggregate type date
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
class MyClass{ //aggregate type.
public: 
	int x;
	double y;
};
	
class MyClass2{ //non-aggregate type.
public:
	MyClass2(int fir, double sec):x{fir},y{sec} {};
private: 
	int x;
	double y;
};
	
MyClass myClass{2011,3.14};      
MyClass myClass1= {2011,3.14};    
	
MyClass2 myClass2{2011,3.14};     
MyClass2 myClass3= {2011,3.14};   
\end{lstlisting}

\item Brace init can be used on many different kind of type. this flexible ability is isn't just an aesthetic issue. Consider writing generic template code that should be able to initialize any type. Using perfect forwarding as an example:

\begin{lstlisting}[frame=single, language=c++,mathescape=true]
template<typename T, typename ...Args>
void forwarder( Args&&... args ) {
T local = { std::forward<Args>(args)... };
// ...
}

forwarder<int>            ( 42 );                  
forwarder<rectangle>      ( origin(), extents() ); 
forwarder<complex<double>>( 2.71828, 3.14159 );    
forwarder<mystruct>       ( 1, 2 );                
forwarder<int[]>          ( 1, 2, 3, 4 );          
forwarder<vector<int>>    ( 1, 2, 3, 4 );          
\end{lstlisting}
\begin{description}
	\item[Line 7 to 12:] All these statement can work because we have brace init. 
\end{description}


	\item A good reference article is GotW \#1 Solution: Variable Initialization or Is It? Another good one is Overview of C++ Variable Initialization. address is \\ \verb=https://greek0.net/cpp/initialization.html=
	
	\item \textbf{Summary}, Brace init is called uniform init, you can see uniform is the biggest strengthen of this new feature.Most of the time, you result is obvious and simple. But there are two things you need to know.
	\begin{enumerate}
		\item In order to acheive the uniform, \textbf{brace init must be able to deal with different kind of type, such as build in type, aggregate, class with different ctor etc.} it add its complexity of analysis. We must read boring CPP document carefully to understand the different branch, different action when we use brace init on the different type 
		
		\item A lot of people think that when we use brace init, it will prefer to use list\_initilaizer. or when we use auto and brace init, it has strange behaviour,(this will be introduce in auto init section). Based on previous point of view, I don't think that it's a problem, on the contrary, you can think that it's more "Uniform", That means that brace init can be used on more context. 
		
		\item In fact, brace init is very good, just pay attention when the class has list\_initiaizer, or when you use it with auto together.
	\end{enumerate}
\end{itemize}


\subsubsection{Vexing parsing}
\begin{enumerate}
	\item The basic reason behind of vexing parsing come from C++ standard: "If it can be a function declaration, it is".
	
	\item Use parentheses to group when you declare a variable. \textbf{When you declare something, It's legal to use parentheses to group variable name.} Sometimes, you have to use parentheses, such as declare a function pointer. 
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
int f(int);   //a function return a int
int *f(int);  //a function.return pointer
int (*f)(int); // function pointer;  
\end{lstlisting}
	
	\item It also means that you can have below C++ statements. The whole idea is just like to make (2+3)*4 work, you have to make parentheses applicable, so although unnecessary, (2)+(3) must be a legal statement.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
int x;
int (x); //same as above
int f(int x);
int f(int (x)); //same as above
\end{lstlisting}
	
	\item For function declaration, you can omit the parameter name.  
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
int f(int x);
int f(int (x));
int f(int); //three statements are same. 
\end{lstlisting}
	
	\item For object, thing becomes interesting.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
int (x); // just like int x;

class A{
	A(int a);
...}
	
A(a);  
int a = 10;
A(a)  
const A& ar = A(a); //this is OK

(A(a)); 
\end{lstlisting}
\begin{description}
	\item[Line 7:] You want to create a temporary obj, but compile think it as A a;
	\item[Line 9:] error, redefine a, because if it's decaration.
	\item[Line 12:] If you really want a temporary A object, use another parentheses. 
\end{description}
	
	\item For function, vexing problem happen below.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
int f(double (*pf)()); //standard way
int f(double pf()); //You can omit parentheses
// just like int x and int (x);
int f(double ()); //for function f, you can omit variable name.
\end{lstlisting}
	
	\item Based on all above all the knowledges. We have a complex problem.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
struct A{
	A (B const& b){};
	void doSomething(){};
};
	
int main(){    
A a(); // declare a function "a", return A
	
A a(B(x)); //declare a function "a",   
//type of parameter x is B

A a(B());  
\end{lstlisting}
\begin{description}
	\item[Line 12:] declare a function "a", receive function pointer, return B, void input and parameter name for "a" is omitted.  
\end{description}
	
	\item In previous example, Why B(x) equal B x; but B() equal a function pointer? If B(int), then it will be a function pointer.  function declaration need type name, not a variable name, such as x.
	
	\item The most complex problem. A range container constructor. 
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
list<int> data(istream_iterator<int>(dataFile), 
istream_iterator<int>()); 

\end{lstlisting}
\begin{description}
	\item[Line 1:] data is function. first parameter is dataFile, type istream\_iterator<int>, second parameter is function pointer. The First, you can add () around parameter name;  the second, you can omit parameter name
\end{description}
	
	\item Before C++11, you need add another pair parentheses to change it from declaration to expression. After C++11, you can use braces.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
A a{B{x}}; 
A a{B{}};
\end{lstlisting} 
	
	\item A non-static data member initializer (NSDMI) must use a brace-or-equal-initializer.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
class A{
	int equals = 42;                      //OK
	std::unique_ptr<Foo> braces{new Foo}; //OK
	std::vector<int> bad(6);  // not allow
	std::vector<int> good{6}; // OK  
}  
\end{lstlisting}
	
	\item a vexing parse example is below, there is another complex exmaple in previous section "vexing parse problem"
\begin{lstlisting}[frame=single, language=c++]
class float3{
	......
};
	
float3 x(); //x is function, not call default ctor
	
float3 x(float3());  // a function
float3 x(float3(i)); 
//vs.
float3 y{float3{}};  // a variable
\end{lstlisting}
\begin{description}
	\item[Line 8:] still a function, float3(i) equal float3 i; because () can be omitted by a compiler. 
\end{description}
 
	
	\item A good refernce is \verb|https://timesong-cpp.github.io/cppwp/n4140/stmt.ambig| or google search 
	"everything that can be a declaration is a declaration" 
\end{enumerate}


\section{Initilizaer\_list}
\subsection{why initilizaer\_list}
\begin{itemize}
	\item The whole problem comes from initializing method of array in C language. But this way can't be use in C++ vector object.
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
int array[] = {1,2,3,4,5}  //OK 
vector<int> vt = {1,2,3,4,5} 
\end{lstlisting}
\begin{description}
	\item[Line 2:] Can't work before C++11. because vt is class, class is not array in C. 
\end{description}	
	
	\item In the generic programming, we need to use the "uniform initializer". It  makes the vt and array use the same syntactic usage. In order to make it possible, C++11 introduces \texttt{std::initializer\_list} template. It's the proxy class. We need vector to have a ctor with \texttt{initializer\_list} parameter
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
vector( std::initializer_list<T> init)
vector<int> vt = {1,2,3,4,5} 
//will call previous ctor and it works. 
\end{lstlisting}
	
	\item If the values you are initializing with are a list of values to be stored in the object (like the elements of a vector/array, or real/imaginary part of a complex number), use curly braces initialization if available.
	
	\item In STL library, list, vector, map support \texttt{initializer\_list} ctor. You also can use it in your own class or function.
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
void f(const initializer_list<string> &slst){
	....
}
	
f({ "Good", "morning", "!" });
\end{lstlisting}
	
	\item \texttt{std::initilizer\_list} can be used in function parameter and return value. It also can use in for range.  
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
// A braced-init-list can be implicitly converted to a return type.
vector<int> test_function() { return {1, 2, 3}; }
	
// Iterate over a braced-init-list.
for (int i : {-1, -2, -3}) {}
	
// Call a function using a braced-init-list.
void TestFunction2(vector<int> v) {}
TestFunction2({1, 2, 3}); 
\end{lstlisting}

\end{itemize}

\subsection{difference with brace init}
\begin{itemize}
	\item  \textbf{You should not only judge initializer\_list by braces}. There are four points:
	\begin{enumerate}
		\item The class should have a \texttt{initializer\_list} ctor 
		\item It uses braces.
		\item The number of parameter inside of braces is changeable. 
		\item The type should be the same.
	\end{enumerate}

\begin{lstlisting}[frame=single, language=c++,mathescape=true]
vector( std::initializer_list<T> init)
vector<int> vt = {1,2,3,4,5}  
	
class A{
public:
	int i;
	int j;
};
	
A a = {1, 2} 
\end{lstlisting}
\begin{description}
	\item[Line 2:] will call the ctor in line 1.
	\item[Line 10:] It's brace init, not \texttt{initializer\_list}. because A has not ctor with \texttt{initializer\_list}
\end{description}
	
	\item Mostly, the two features I presented play very well together, for example if you want to initialize a map you can use an initializer-list of braced-init-lists of the key value pairs: Here, the type of the pairs is clear and the compiler will deduce, that '{"Alex", 522}' in fact means 'std::pair<std::string const, int>{"Alex", 522}'.
	
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
std::map<std::string, int> scores{ 
	{"Alex", 522}, {"Pumu", 423}, {"Kitten", 956} 
};
\end{lstlisting}

	\item An empty pair of braces can be:
	\begin{enumerate}
		\item Default initialization.
		\item An empty std::initializaer\_list.
	\end{enumerate}
	You should know how to distinguish them.  Empty braces mean no arguments, that is to say you get default construction, not an empty \texttt{std::initializer\_list}:
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
class Widget{
public:
	int i;
	Widget(){cout<<"default";}
	Widget(initializer_list<int>){cout<<"init";}
};
	
Widget w1; // calls default ctor
Widget w2{}; 
Widget w3(); // most vexing parse! declares a function!
	
Widget w4({}); 
Widget w5{{}}; 
\end{lstlisting}
\begin{description}
	\item[Line 9:] Calls default ctor, even  you have  initializer\_list ctor.
	\item[Line 12 and 13:] calls std::initializer\_list ctor with empty list
\end{description}
	
	\end{itemize}
	
\subsection{problem of initializer\_list}
	
\begin{itemize}

	\item When 1)Non-empty brace init is used, 2) and there are overload initializer\_list, \textbf{it always match initializer\_list}.
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
class Widget {
public:
	Widget(int i, bool b); // as before
	Widget(int i, double d); // as before
	Widget(std::initializer_list<long double> il);
};
	
Widget w1(10, true); //  calls first ctor
Widget w1{10, true}; // std::initializer_list ctor
// (10 and true convert to long double)

Widget w2(10, 5.0); //  calls second ctor
Widget w2{10, 5.0}; // std::initializer_list ctor
// (10 and 5.0 convert to long double)
\end{lstlisting}
	
	\item \textbf{ Compilers' determination to match braced initializers with constructors taking std::initializer\_lists is so strong, it prevails even if the best-match std::initializer\_list constructor can't be called.}
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
class Widget {
public:
	Widget(int i, double d); // as before
	Widget(std::initializer_list<bool> il); // added
};
Widget w2{10, 5.0}; // still match init_list,
//5.0 can't be convert bool, so compile fail.
\end{lstlisting}
	
	\item An example from vector, () and init brace are different in meaning.
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
std::vector<int> v1(10, 20); 
	
std::vector<int> v2{10, 20}; 
\end{lstlisting}
\begin{description}
	\item[Line 1:] use non\texttt{-std::initializer\_list} ctor: create 10-element vector, all elements 20.
	\item[Line 2:] use initializer\_list ctor: create 2-element vector, element are 10 and 20
\end{description}
	
	\item Based on previous vector example, choosing between parentheses and braces for object creation inside templates can be challenging.(it has different semantic meaning.)
\end{itemize}

\section{auto init(AAA)}

About the auto type deduction, please refer to the next chapter Generic programming type inference section. The basic idea is quite simple: \newline 
\textbf{take exactly the type on the right-hand side, but strip off top-level const/volatile and \&/\&\&.}

\subsection{auto declaration}
\subsubsection{Basic knowledge}
\begin{itemize}
	\item The basic usage of auto is below. \textbf{auto sets the type of a declared variable from its initializing expression while compiling.}
\begin{lstlisting}[numbers=none]
auto a = expr
auto a = T{expr} //when you want to commit to type
\end{lstlisting}


	\item When you use expr init a variable, prefer to use auto. expr can be:
\begin{enumerate}
	\item math express, auto a = b+c.
	\item function call, auto a = v.begin()
	\item new to avoid type name
	\item left hand type is same with right type auto a = b ( you can write Type a(b), but don't need write down the type name)
	\item lambda
	\item template 
\end{enumerate}
\begin{lstlisting}[numbers=none]
//const char* s = "Hello";             
auto s = "Hello";

//widget w = get_widget();             
auto w = get_widget();

//widget* w = new widget{};    
auto w = new widget{}; 

//unique_ptr<widget> w = make_unique<widget>();
auto w = make_unique<widget>();
\end{lstlisting}

	\item More interesting examples.
	
\begin{lstlisting}[frame=single, language=c++]
auto p = &x  
auto p = new vector<pair<int, string> >;

std::vector<std::pair<int, std::string>> array;
auto it = array.begin();    
     
double fm(double, int);
auto pf = fm          

for (const auto& element : myarray) {
	//do stuff that reads from element
}
\end{lstlisting}
\begin{description}
	\item[Line 1:] p is \texttt{int* type}, You prefer to use \texttt{auto* p;}
	\item[Line 2:] avoid complex verbose on left side.
	\item[Line 4:] avoid complex verbose on left side.
	\item[Line 7:] pf is double(*)(double,int)
\end{description}
	
	\item If you want your auto declaration to be const, or if you want your auto declaration to be a reference, you have to add them explicitly
	
\begin{lstlisting}[frame=single, language=c++]
const std::map<int, Module>::iterator iter = modmap.find(123);
Module& mod = vec[17];

//use auto, it's better
const auto iter = modmap.find(123);
auto& mod = vec[17];
\end{lstlisting}
\begin{description}
	\item[Line 5 and 6:] Specify const and reference explicitly.
\end{description}
	
	\item Both of these are the same and will declare a pointer. But auto* var; if you think it stresses the intent (that var is a pointer) better.
\begin{lstlisting}[frame=single, language=c++]
auto var = new int(1);
auto *var = new int(1);
\end{lstlisting}


	\item Four advantages:
	\begin{enumerate}
		\item avoidance of uninitialized variables.
\begin{lstlisting}[numbers=none]
auto x2; // error! initializer required
auto x3 = 0; // fine, x's value is well-defined
\end{lstlisting}

		\item avoidance of verbose variable declarations.
\begin{lstlisting}[frame=single, language=c++]
template<typename It>
void dwim(It b, It e) {
//typename std::iterator_traits<It>
                ::value_type currValue = *b;
                
	auto currValue = *b; //using auto is simple
	
	auto ii = find_if(people.begin(), 
	               people.end(), match_name );
	               
	if (ii != people.end()){...}
\end{lstlisting}

		\item avoid what I call problems related to "type shortcuts." \textbf{It's very importance here, it guarantee correct and performance}
\begin{lstlisting}[frame=single, language=c++]
std::vector<int> v;
		...
int sz = v.size();
auto sz = v.size();
		
std::unordered_map<std::string, int> m;
for (const std::pair<std::string, int>& p : m){
	... // do something with p
}

for (const auto& p : m){
	... // as before
}
\end{lstlisting}
\begin{description}
	\item[Line 4:] v.size() return size\_t.
	\item[Line 11:] pair type is <const std::string, int>. When you use auto, you don't have this error
\end{description}
	\item Good maintenance.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
struct record {
	std::string name;
	int id;
	//GUID id; 
};

//int find_id(const std::vector<record> &people...
auto find_id(const std::vector<record> &people, 
                                  const std::string &name)
\end{lstlisting}
\begin{description}
	\item[Source code] First, change id type in line 3 to line 4, if we use auto in line 9, we dont' need to change at all. But if we use int, then we need to change from int to GUID too.
\end{description}

	\end{enumerate}
\end{itemize}
	
\subsubsection{pitfall of auto}
	\begin{enumerate}
		\item "invisible" proxy classes.An invisible proxy class example is vector<bool> [] operator. vector<bool>::operator[] neither yields a bool nor a reference to a bool. It just returns a little proxy object that acts like a reference. This is because there are no references to single bits and vector<bool> actually stores the bools in a compressed way. So by using auto you just created a copy of that reference-like object. The problem is that C++ does not know that this object acts as a reference. You have to force the "decay to a value" here by replacing auto with T
\begin{lstlisting}
template <typename T>
void Test(const T& oldValue, const T& newValue, const char* message){
	vector<T> v;
	v.push_back(oldValue);
	cout << " before:  v[0] = " << v[0] << '\n';
	auto x = v[0]; // Should be a deep-copy
	x = newValue;
	cout << " after:   v[0] = " << v[0] << '\n';
}

int main(){
	Test<int>(10, 20, "Testing vector<int>");
	Test<bool>(true, false, "Testing vector<bool>");
}
\end{lstlisting}
\begin{description}
	\item[Line 6:] When we use auto here, it get proxy classes, not bool value. so when we modify x, it will modify x[0] directly.
	
	\item[Source code:] before:  v[0] = 1; after:   v[0] = 0;Because it returns reference,  so v[0] has been modified.
\end{description}

		\item init brace return init\_list. Prior to C++17 the type for all the following objects (a, b, c and d) is deduced to std::initializer\_list<int>. There is no difference between the direct-list-initialization and the copy-list-initialization on the result of the type deduction.
		
\begin{lstlisting}[numbers=none]
auto a = {42};   // std::initializer_list<int>
auto b {42};     // std::initializer_list<int>
auto c = {1, 2}; // std::initializer_list<int>
auto d {1, 2};   // std::initializer_list<int>
\end{lstlisting}
		\item  changed in C++17 that introduced the following rules: 1) for copy list initialization auto deduction will deduce a std::initializer\_list<T> if all elements in the list have the same type, or be ill-formed.
		\item for direct list initialization auto deduction will deduce a T if the list has a single element, or be ill-formed if there is more than one element.
\begin{lstlisting}[numbers=none]
auto a = {42};   // std::initializer_list<int>
auto b {42};     // int
auto c = {1, 2}; // std::initializer_list<int>
auto d {1, 2};   // error, too many 
\end{lstlisting}
	\end{enumerate}

\subsection{auto and function}

\subsubsection{parameter}
\begin{itemize}
\item \texttt{auto} can be used in function parameter, it is just another kind of template function.
\begin{lstlisting}[numbers=none]
void fun1(auto i){
	cout<<i<<endl;
}

fun1(23);  //produce two overload fun1 function.
fun1("abc");
\end{lstlisting}

\item Example auto\&\& comes(forward reference) from generic lambda. It can reserve if fun is rvalue.
\begin{lstlisting}[frame=single, language=c++]
struct Functor{
	void operator ()() const &  { std::cout << "lvalue functor\n"; }
	void operator ()() const && { std::cout << "rvalue functor\n"; }
};

int main(){
	auto perfectLambda = [](auto&& func, auto&&... params) {
		std::forward<decltype(func)>(func)(
		std::forward<decltype(params)>(params)...
		);
	};
	auto lambda = [](auto func, auto&&... params) {
		func(std::forward<decltype(params)>(params)...);
	};

	Functor fun;
	lambda(fun);
	lambda(Functor{});
	perfectLambda(fun);
	perfectLambda(Functor{});
}
\end{lstlisting}
\begin{description}
	\item[Line 7:] Define two lambdas.
	\item[Source code:]
\end{description}
\end{itemize}

\subsubsection{Generalized return type deduction}
\begin{itemize}
	\item C++11 permitted automatically deducing the return type of a lambda function whose body consisted of only a single return statement, so we don't need specify its return type.
\begin{lstlisting}[numbers=none]
[=]() -> some_type { return foo() * 42; } // ok
[=]  { return foo() * 42; } //ok,deduces "-> some_type"
\end{lstlisting}

\item This has been expanded in two ways. First, it now works even with more complex function bodies containing more than one return statement, as long as all return statements return the same type:
\begin{lstlisting}
// C++14
[=] {               // ok, deduces "-> some_type"
	while( something() ) {
		if( expr ) {
			return foo() * 42; // with arbitrary control flow
		}
	}
	return bar.baz(84); 
}                       
\end{lstlisting}
\begin{description}
	\item[Source code:] Although there are multiple returns, it will work if types are the same.
\end{description}

\item Second, it now works with all functions, not just lambdas: Of course, this requires the function body to be visible.
\begin{lstlisting}[numbers=none]
auto fun1(){
	return 12;
}
\end{lstlisting}

	\item Below will produce compile error, because it has ambiguity.
\begin{lstlisting}[numbers=none]
auto f(int i){  // It will cause compile error.
	if ( i < 0 )
		return -1;
	else
		return 2.0
}
\end{lstlisting}

\end{itemize}

\subsubsection{atuo in lambda and template}
\begin{itemize}
	\item the ability to directly hold closures(lambda), and in C++14, It can be used as lambda return type
\begin{lstlisting}[frame=single, language=c++]
auto derefUPLess =               
[](const std::unique_ptr<Widget>& p1,  const std::unique_ptr<Widget>& p2){
	return *p1 < *p2; 
};                 
	
//C++14 version
auto derefLess = 
[](const auto& p1,  const auto& p2){
	return *p1 < *p2; 
}; 
\end{lstlisting}
\begin{description}
	\item[Line 1:] comparison func. for Widgets pointed to by std::unique\_ptrs
	\item[Line 7:] C++14 comparison. values pointed to by anything pointer-like
\end{description}

		\item generic lambda( just like template lambda)
\begin{lstlisting}[frame=single, language=c++]
auto adder  = [](auto op1, auto op2){ return op1 + op2; };
\end{lstlisting}
	
\item For template function return type, we can use two different ways.

\begin{enumerate}
	\item C++ 11, use auto + trailing type.
\begin{lstlisting}[numbers=none]
template <class T>
auto addFooAndBar(T const& t) -> decltype(t.foo() + t.bar()) {
	return t.foo() + t.bar();
}
\end{lstlisting}
	\item C++ 14, directly use auto.
\begin{lstlisting}[numbers=none]
template <class T>
auto addFooAndBar(T const& t) {
	return t.foo() + t.bar();
}
\end{lstlisting}
	\item use decltype(auto), detail can be found in Effective Modern C++ item 3.
\end{enumerate}
	
	\item \textbf{prefer to use function return type deduction wherever applicable, avoid trailing return type unless you really need them.} they make your code harder to read
	
\end{itemize}

\section{summary}

\subsection{Init syntax summary}
\begin{itemize}
	\item Some syntactic examples: 
\begin{lstlisting}[frame=single, language=c++]
class A{
	public:
	A(){};
	A(int k):m_a(k){};
	A(const A& rhs){m_a = rhs.m_a;};
	int m_a;
};
	
void fun(const A &a){}
int i = 3;
\end{lstlisting}
	
	\item Default ctor example \newline
	\begin{tabular}{|p{0.23\textwidth}|p{0.7\textwidth}|}
		\tophline
		Expression & meaning \\
		\tophline
		\texttt{A a, A a\{\}} & default ctor \\
		\tophline
		\texttt{A a()} & \textbf{declare function a,vexing problem} \\
		\tophline
		\texttt{A()} & A temporary A obj\\
		\tophline
		\texttt{B b(A())} & \textbf{declare function, vexing problem}, A() is function pointer \\
		\tophline
		\texttt{B b(A\{\})} & ctor a b with temp A. \\
		\tophline
		\texttt{fun(A()),fun(A\{\})} & pass an parameter to fun
		\bottomhline
	\end{tabular}
	\item single parameter ctor example \newline
	
	\begin{tabular}{|p{0.23\textwidth}|p{0.7\textwidth}|}
		\tophline
		Expression & meaning \\
		\tophline
		\texttt{A a(i), A a\{i\}} & parameterized ctor\\
		\tophline
		\texttt{A (i)} & \textbf{just like A i, you have define i, so compile error.} \\
		\tophline
		\texttt{A\{i\}} & A temporary A obj\\
		\tophline
		\texttt{B b(A(i))} & declare a function B b(A i); vexing problem \\
		\tophline
		\texttt{B b(A\{i\})} & build b with temp A\\
		\tophline
		\texttt{fun(A(i)),fun(A\{i\})} & work, fun(A i) will not a declaration, because there are no return value.\\
		\tophline
		\texttt{B b(A a(i))}  & compile error, because A a(i) is not expression. \\
		\tophline
		\texttt{fun(A a(i))} & same as above. \textbf{We need value for functoin parameter, not statement} 
		\bottomhline
	\end{tabular}
	
	\item \textbf{If there is possible, it will use declaration first. }.
\begin{lstlisting}
int i = 5;
A(i);
A a = A(i);
B b(A(i));
B b(A a(i));
\end{lstlisting}
\begin{description}
	\item[Line 2:] redefine varaible i, just lkie A i; compiler error.
	
	\item[Line 3:] A(i) will build temporary A, because there is assignment sign, so A(i) can't be declaration, otherwise it can't be suitable for the context.
	
	\item[Line 4:] interpret A(i) as declaration, and it suitable for the context.
	
	\item[Line 5:] For B b(A a(i)), compiler will first interpret it as function declaration first, but A a(i) is not type, (A(i) and A() are both type). So it continue to interpret as B constructor, then it ask a value from expression. but A a(i) is not expression either, in the end, compiler is not happy. 
\end{description}

\end{itemize}

\subsection{How to understand init}
\begin{itemize}
	\item Basic rules:
	\begin{enumerate}
		\item If the object I'm creating conceptually holds the values I'm passing in the constructor (e.g. containers, POD structs, atomics, smart pointers etc.), then I'm using the braces.
		
		\item If the constructor resembles a normal function call (it performs some more or less complex operations that are parametrized by the arguments) then I'm using the normal function call syntax.
		
		\item For default initialization I always use curly braces.
\begin{lstlisting}
vector<int> a{10,20};
vector<int> b(10,20);
vector<int> c(it1,it2); 
\end{lstlisting}
\begin{description}
	\item[Line 1:] Curly braces -> fills the vector with the arguments
	\item[Line 2:] Parentheses -> uses arguments to parametrize some functionality, 
	\item[Line 3:] like filling the vector with 10 integers or copying a range.
\end{description}
	\end{enumerate}
	
	\item Understanding some basic conceptions. such as aggregate type. copy-list-init, converting ctor. All the high level usages are based on these basic conceptions. 
	
	\item \textbf{familier with Six Init methods.} You should know how to distinguish them. For example, when use = , it is called copy init. 
	
	\item \textbf{Six init methods and brace init are irrelevant. brace init syntax can be use in direct init or copy init and it brings its own advantage.} 
	
	\item Brace init is uniform init. How can it be uniform? Because ror differnt T type, it carry out different actions, such as carry out value init or call converting ctor.
	
	\item \textbf{Summary:}
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.95\linewidth]{pics/init.png}
		\caption{Overview of C++ init}
		\label{fig:command}
	\end{figure}
	
\end{itemize}

\subsection{How to init by youself}
\begin{itemize}

	\item \textbf{use \texttt{auto var = expr}}. Advantage has been introduced before.

	\item \textbf{Use braced initialization if possible.} Advantage has been introduced before.

	\item Pay attention two traps for \texttt{std::initilizaer\_list.} 
	\begin{enumerate}
		\item If type has list initialization ctor, braced initialization will use it first, and very strongly. vector is good example to explain this trap.
		
		\item When we combine \texttt{auto} and \texttt{std::initilizaer\_list} together, we have some unusual result. You can see the section "pitfall of auto" 
	\end{enumerate}
\end{itemize}


\chapter{Memory}

\section{malloc and remalloc}
\subsection{malloc}
\begin{itemize}
	\item That is a long story. In C language, if you forget a header file, what will happen? (I have add answer to my evernote). In one word, It will(c99) or will not produce(c89) warning, and compiler will assume a "implicit int" rule. That is to say, It presumes that the function without prototype (declaring in the header file) just return int type.
	
	\item Continue: if you have code below: you comment stdlib.h. Then compiler will assume that malloc return a \texttt{int}.  This code will run on 32 bit computer, because \texttt{int} and \texttt{int*} have same length. but on some 64 bit computer, int* is 64 bit and int is 32 bit.  so half data will be lost, and you code will crash.
	And if you add (int*) cast, it will suppress the warning message.(You kill the only clue, it's bad).
\begin{lstlisting}[frame=single, language=c++]
// include "stdlib.h"
int *sieve = (int *)malloc(sizeof(int)*length);
	
int *sieve = malloc(sizeof(int)*length);
\end{lstlisting}
\begin{description}
	\item[Line 2:] With explicit cast, it will NOT produce a (missing protype)warning.
	\item[Line 4:] Without explicit cast, will produce a warning.
\end{description}

	\item continue: So don't recommend to use (int*) cast at all. Next question is that malloc actually return void*. Can void* automatically implicit be cast to int* or other pointer type in assignment? the answer is \textbf{YES}.
	
	\item  continue: In C language:
\begin{lstlisting}[numbers=none]
#define NULL ( (void*) 0)
int *p = NULL;  //legal
FILE * f = NULL;  //legal
\end{lstlisting}
	
	\item continue: In C++, \texttt{int *p = (void *) 0} is not legal any more.(C++ is type safe language).  So in C++ NULL is literal 0. But It produce another ambiguity problem.  So In C++11, we define \texttt{nullptr} to resolve this problem.
\begin{lstlisting}[frame=single, language=c++]
#define NULL 0
int *p = NULL //legal
--------------------------------------
f(int i)
f(int * p);

f(NULL);  //which one will be called. Answer is f(int i).
f(nullptr) //will call f(int *p)
\end{lstlisting}
	
	\item calloc() zero-initializes the buffer, while malloc() leaves the memory uninitialized. Zeroing out the memory may take a little time, so you probably want to use malloc() if that performance is an issue. If initializing the memory is more important, use calloc(). For example, calloc() might save you a call to memset().
	
	\item With \texttt{memcpy}, the destination cannot overlap the source at all. With memmove it can. This means that \texttt{memmove} might be very slightly slower than memcpy, as it cannot make the same assumptions. For example, memcpy might always copy addresses from low to high. If the destination overlaps after the source, this means some addresses will be overwritten before copied. memmove would detect this and copy in the other direction - from high to low - in this case. However, checking this and switching to another (possibly less efficient) algorithm takes time.
\end{itemize}

\subsection{realloc}
\begin{itemize}
	
	\item Reallocates the given area of memory. It must be previously allocated by malloc(), calloc() or realloc() and not yet freed with a call to free or realloc. Otherwise, the results are undefined.
	
	
	\item Don't return value assign to input ptr, use another local pointer, such as new\_ptr;
\begin{lstlisting}[numbers=none]
void *new_ptr = realloc(ptr, new_size);
if (!new_ptr) {
	// deal with error;
}
ptr = new_ptr
\end{lstlisting}
\end{itemize}


\section{new operator}
\subsection{Basic}
\begin{itemize}
	
	\item There are four sub-topics about new operator:
	\begin{enumerate}
		\item new\_handler
		\item no throw, but return nullptr(since c++11)
		\item placement new (not allocate, just ctor)
		\item operator new (just allocate, no ctor)
	\end{enumerate}
	
\begin{lstlisting}[frame=single, language=c++]
std::set_new_handler(noMem);
MyClass * p1 = new MyClass;  

MyClass * p2 = new (std::nothrow) MyClass; 

new (p2) MyClass;  
	
MyClass * p3 = (MyClass*) ::operator new (sizeof(MyClass));
\end{lstlisting}
\begin{description}
	\item[Line 2:] if fail, call noMem
	\item[Line 4:] no throw
	\item[Line 6:] placement new
	\item[Line 8:] operator new, allocates memory by calling: operator new. but does not call MyClass's ctor
\end{description}	
	\item \texttt{new} will call constructor function of a class, but \texttt{malloc} will not call constructor function.  \textbf{So in C++, you should use new instead of \texttt{malloc}.}
	
	\item For default new operator, you can use \texttt{set\_new\_handler} to adjust the behavior when you can't allocate enough memory. Detail can be found in the below sub section.
	
	\item When you should provide your own operator new?  You want to add log function; You want to add some cookie before and after allocated memory(Visual Studio use this way to detect overflow in debug mode). You want to have quicker speed(memory pool). You want to have better alignment and so on..
	
	\item If you use new int[100], use delete [];  \textbf{Any time you want to use new to allocate an array, ask yourself if you can replace it with vector or string.}
\end{itemize}

\subsection{Inside of new operator}
\begin{itemize}
	\item There is three level knowledges: 
	\begin{enumerate}
		\item new operator.
		\item operator new.
		\item new\_handler
	\end{enumerate}
	\textbf{new operator calling operator new, operator new calling new\_handler.} 
	
	\item Basic logic of new operator and delete operator.
\begin{lstlisting}[numbers=none]
Point3d *origin = new Point3d;
	
//C++ pseudo code
if(origin = operator new(sizeof(Point3d))){
	try{
		origin = Point3d::Point3d(origin);
	}
	catch(...){
		operator delete(origin);
		throw
	}
}
\end{lstlisting}
	
\begin{lstlisting}[numbers=none]
delete origin;
	
if (origin != NULL) {
	origin->~Foo();
	operator delete(origin);
}
\end{lstlisting}
	
	\begin{enumerate}
		\item call operator new to allocate space in memory. (different with new opeator), in this way, ctor will not be called.
		\item call ctor of a class. (You can't call ctor explicit in this way, but compiler can.)
		\item If ctor throw an exception, no memory leak by calling operator delete.
		
		\item So for a class, if you declare its dtor private or protected, You can't use "delete p".
	\end{enumerate}
	
	
\item Basic logic of operator new and operator delete
\begin{lstlisting}[frame=single, language=c++]
void * operator new(std::size_t size) throw(std::bad_alloc){
using namespace std; 
	if (size == 0) {   
		size = 1;             
	}                 
	void *last_alloc;
	while (true) {
		*last_alloc = malloc(size)
		if (last_alloc)
			return last_alloc;
		new_handler globalHandler = set_new_handler(0);
		set_new_handler(globalHandler);
		if (globalHandler) 
			(*globalHandler)();
		else 
			throw std::bad_alloc();
		}
}
	\end{lstlisting}
\begin{description}
	\item[Line 1:] Your operator new might take additional params
	
	\item[Line 4:] handle 0-byte requests by treating them as 1-byte requests
	
	\item[Line ?:] allocation was unsuccessful; find out what the. current new-handling function is (see below)
\end{description}


\begin{lstlisting}[numbers=none]
operator delete (void *ptr){
	if (ptr)
		free(ptr)
	}
\end{lstlisting}
	\begin{enumerate}
		\item if size is 0, change it to 1.
		
		\item Why we need to call \texttt{set\_new\_handler} twice, The first one get the current handler, and the second one change it back. That is only way we can get the current handler.
		
		\item This idiom is also used in \texttt{set\_terminate} and \texttt{set\_unexpect}. 
		
		\item In C++11, introduce \texttt{get\_new\_handler()} function. We don't need to call \texttt{set\_new\_handler} twice. 
		
		\item Most of time, we use malloc and free to allocate and free physical memory.
	\end{enumerate}
\end{itemize}

\subsection{new\_handler}
\begin{itemize}
	\item At program startup, new-handler is a null pointer. allocation function finds that std::get\_new\_handler returns a null pointer value, it will throw \texttt{std::bad\_alloc}.
	
	\item  As shown by the previous section, The new\_handler function is the function called by allocation functions whenever a memory allocation attempt fails. Its intended purpose is one of three things:
	
	
	\begin{enumerate}
		\item make more memory available. \textbf{resolve the problem by myself.}
		
		\item throw exception of type \texttt{std::bad\_alloc} or derived from \texttt{std::bad\_alloc}. \textbf{resolve the problem by a user.}
		
		\item terminate the program. e.g. by calling \texttt{std::terminate}. \textbf{(No resolve)}
	\end{enumerate}
	
\begin{lstlisting}[frame=single, language=c++]
void noMemory(){
	closeIE; // method 1 release mem
	set_new_handler(nullptr); //mehtod 2 throw bad_alloc exception.
	abort();  //method 3, end application.
}
//in the beginning of main() function.
set_new_handler(noMemory)
\end{lstlisting}
	
	
	\item What can we do in side new handler function? Below choices give you considerable flexibility in implementing new-handler functions.
	\begin{enumerate}
		
		\item Make more memory available. This may allow the next memory allocation attempt inside operator new to succeed. One way to implement this strategy is to allocate a large block of memory at program start-up, then release it for use in the program the first time the new-handler is invoked.
		
		\item Install a different new-handler. If the current new-handler can't make any more memory available, perhaps it knows of a different new-handler that can. If so, the current new-handler can install the other new-handler in its place (by calling \texttt{set\_new\_handler}). The next time operator new calls the new-handler function, it will get the one most recently installed. (A variation on this theme is for a new-handler to modify its own behavior, so the next time it's invoked, it does something different. One way to achieve this is to have the new-handler modify static, namespace-specific, or global data that affects the new-handler's behavior.)
		
		\item Deinstall the new-handler, i.e., pass the null pointer to \texttt{set\_new\_handler}. With no new-handler installed, operator new will throw an exception when memory allocation is unsuccessful.
		
		\item Throw an exception of type \texttt{bad\_alloc} or some type derived from \texttt{bad\_alloc}. Such exceptions will not be caught by operator new, so they will propagate to the site originating the request for memory.
		
		\item Not return, typically by calling abort or exit.
	\end{enumerate}
	\item If you want to have customized new\_handler for specific class, "effective C++ item 49" gives a good example. It use Mixin idiom. Detail can be found in generic programming section in this book.
	
\end{itemize}
\subsection{placement new}

\begin{itemize}
	\item construct an object in memory you've already got a pointer to ,use placement new. If you use placement new to create an object in some memory, you should avoid using the delete operator on that memory.  Detail can be seen in C++ primer
\begin{lstlisting}[frame=single, language=c++]
Foo* p;
void* raw = operator new(sizeof(Foo)*100);
	
try {
	p = new(raw) Foo();  // call the ctor with raw as this
}
catch (...) {
	// oops, ctor throw an exception
	operator delete(raw);
	throw;  // rethrow the ctor's exception
}
\end{lstlisting}
\begin{description}
	\item[Line 2:] Don't catch exceptions thrown by the allocator itself. Return a void type pointer
\end{description}
	
	\item Another example to use placement new.
\begin{lstlisting}[numbers=none]
void* buffer = operator new(sizeof(FOO)*100);
p1 = new(buffer) FOO();
p2 = new(buffer+sizeof(FOO) ) FOO();
	
p1->~FOO(); // call dtor directly,
p2->~FOO(); //don't call delete p1.
	
delete[] buffer;
\end{lstlisting}
	
	\item placement operator new is defined as below. \textbf{You are not allowed to customize it.}
\begin{lstlisting}[numbers = none]
void operator new(size_t, void* p){
	return p;
}
\end{lstlisting}
	
	\item You can build a object on an existing object. Pay attention, this is only place where you can call destructor directly. Don't call delete. 
\begin{lstlisting}[numbers=none]
FOO* p1 = new(buffer) FOO();
	.....
p1->~FOO();
//Don't use delete p1!!!
	
//A new object in an existing object.
p1 = new(buffer) FOO(); 
\end{lstlisting}
	
	\item If operator new receive another parameter beside that size\_t, that is placement new.There is special version with void* pMemeory
	
\begin{lstlisting}[numbers=none]
void* operator new (std::size_t size, void* pMemeory) throw();
\end{lstlisting}
	
	\item If you define your own placement operator new(non-pMemeory version). You must provide your own placement operator delete. Because when the constructor throw exception, it will call the corresponding custimzied placement operator delete. Detail can be found in "effective C++ item 52"
\begin{lstlisting}[frame=single, language=c++]
void* operator new (std::size_t size, void* pMemeory) throw();
void* operator new (std::size_t size, ostream& logStream) throw();
Widget* pw = new(std::cerr) Widget

void operator delete(void* pM, ostream& logStream). 
\end{lstlisting}
\begin{description}
	\item[Line 5:] //When Widget ctor throw exception, it will call operator delete. if no such function, placement new do nothing and memory leak.
\end{description}
	
	\item A good article is "The many faces of operator new in C++", It give  detail information about operator new and how to rewrite it. I have added it to my ref.
\end{itemize}



\subsection{array new}
\begin{itemize}
	\item \textbf{When you use array new to allocate an arry, must use the array delete.} If you don't use array delete, maybe you just delete the frist object in array. If you use array delete to single new, it's undefined. 
\begin{lstlisting}[frame=single, language=c++]
Foo pa* = new Foo[10];
delete [] pa;
\end{lstlisting}
\begin{description}
	\item[Line 2:] system will remember the size corresponding with pa,  with [], it will iterate with size.  When you forget [], it will just free the first object.
\end{description}

	\item Basic logic of array new. An basic implementation can be found in"Inside the C++ Object Model" 6.2 chapter
\begin{lstlisting}[frame=single, language=c++]
vec_new(int elem_count, int size, funptr ctor){
	total_size = size*elem_count;
	ptr_array = new char[total_size];
	regist pair of ptr_array elem_count to system
	while(elem<end of address){
		(*ctor)(elem) //call the ctor
		elem+=size;
	}
}
\end{lstlisting}
	
	\item When you use array new with inheriance. There is one important thing to notice. Don't use base pointer to point the array with derived class. 
\begin{lstlisting}[frame=single, language=c++]
base *bp = new derived[10]
bp[2] 
	
delete [] bp;
\end{lstlisting}
\begin{description}
	\item[Line 1:] always use derived *dp = new derived[10];
	\item[Line 2:] dangerous, undefine. size is wrong: bp+sizeof(base)*2
	\item[Line 4:] dangerous, 1)size is wrong, 2)it will call base::~base() destructor. 
\end{description}

	\item Above code, Don't use pointer to understand it, When you use delete [] bp, it will think that is a base array, and each element in it is just base object, so virtual function doesn't play a role here. Please refer the section "inheritance" in this book for more detail.
\end{itemize}

\subsection{Customize operator new}
\begin{itemize}
	\item The operator new and nothrow version are also replaceable: A program may provide its own definition that replaces the one provided by default to produce the result described above, or can overload it for specific types. 
	\item For placement new, You can't replace it. There is no "operator new array", it use operator new to allocate memory. 
\begin{lstlisting}[numbers=none]
void* operator new (std::size_t size) throw (std::bad_alloc);
void* operator new (std::size_t size, 
const std::nothrow_t& nothrow_value) throw();

void* operator new (std::size_t size, void* ptr) throw();
\end{lstlisting}
	
	\item You can't change "new operator" behavior, but you can override global "operator new" and overload class its own "operator new". Pay attention its argument and return void*. 
	
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
//global operator new
void* operator new(size_t size){
	cout<<"Yan's own operator new" ;
	void* mem = malloc(size);
	if(mem)
		return mem;
	else
		throw bad_alloc();
	
class Foo{ //class operator new
public:
	static void* operator new(size_t size);
		..
	}
	
void* Foo::operator new(size_t size){
	cout<<"Foo's own operator new";
	....
}
	
int *p = new int[100]; //output Yan's own operator new
Foo* fp = new Foo();  //output Foo's own operator new
\end{lstlisting}
	
	\item Above code is just a simple demo, In the new\_handler section, you can see a better operator new demo with support of call your own new\_handler. You need to combine above code and code in new\_handler section together. 
	
	\item operator new usually call \texttt{malloc} function. \texttt{malloc} usually call \texttt{brk} for small chunk and \texttt{mmap} for big chunk. So in the end, C langauge is basic langauge.
	
	\item Why do I need my own operator new?
	\begin{enumerate}
		\item Performance: the default memory allocator is designed to be general purpose. Sometimes you have very specific objects you want to allocate, chapter 4 in "Modern C++ Design" presents a very well designed and implemented custom allocator for small objects.
		
		\item Debugging \& statistics: having full control of the way memory is allocated and released provides great flexibility for debugging, statistics and performance analysis.
		
		\item Customization to cluster related object together, and reduce size. put guard block to avoid overrun and underrun. More detail can be seen in effective c++( third edition) Item 50
	\end{enumerate}
	
	\item \textbf{Don't rewrite operator new unless you have to.} There are not as easy as you think. such as alignment. First consider some library, such as \textbf{Boost Pool library} for large number small object allocations. 
	
	\item If you have to rewrite operator new, You need to read  effective c++( third edition) Item 51 in detail. For example, All operator new should contain a loop calling a new-handling function.  should deal with request of zero size. you can see the pseudocode in Item 51.
	
	\item In C++, after you define a name in a scope (e.g., in a class scope), it will hide the same name in all enclosing scopes (e.g., in base classes or enclosing namespaces), and overloading never happens across scopes. And when said name is operator new, If you provide any class-specific new, provide all of the standard forms(plain, in-place, and nothrow)
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
class C {
	static void* operator new(size_t, MemoryPool&);
	// hides three normal forms
	};
	void* operator new(std::size_t);
	void* operator new(std::size_t, std::nothrow_t) throw();
	void* operator new(std::size_t, void*);
\end{lstlisting}
\begin{description}
	\item[Line 5:] plain new
	\item[Line 6:] nothrow new
	\item[Line 7:] inplace new
\end{description}
	
	\item Always provide new and delete together, see "C++ coding standards" item 45 and 46.
\end{itemize}



\chapter{pointer and smart pointer}

\section{pointer and new}
\subsection{function pointer}
\begin{itemize}  

\item A real example of function pointer is set\_new\_handler. It accepts a function pointer and return the same function pointer, so declaring such format is a little difficult.
\begin{lstlisting}[frame=single, language=c++]
void failNew(){
	cerr<<"Fail now"<<endl
	abort();
}
-----------------------------------------
extern void ( *set_new_handler ( void (*)() ) ) ();

set_new_handler(failNew);
\end{lstlisting}
\begin{description}
	\item[Line 6:] This function declaration is very complex.
\end{description}

\item A better method is to use typedef method.

\begin{lstlisting}[numbers = none]
typedef void(* FunPtr)();
FunPtr (*set_new_handler) (FunPtr);
set_new_handler(failNew);
\end{lstlisting}

\end{itemize}

\subsection{When to use new?}
\begin{itemize}

\item When do you use smart pointer? Here I change this questions to another question, When do you use pointer?
\begin{enumerate}

\item An new object remain in existence, until you delete it. (you control the life time of it, maybe you create it in fun1,then delete it in fun4. so the obj is neither stack life nor global life. You may or may not transfer \textbf{ownership} between functions.)

\item When you want to create a obj in runtime according runtime condition or user input dynamically. (maybe don't create it. ) Below code demonstrates previous two conditions.  \texttt{ToothBrush} need to be control life time and created dynamically.

\begin{lstlisting}[numbers=none]
class Person{
ToothBrush* pbrush;

buyNewBrush(string &name){
    if(pbrush != nullptr}{
	    	delete pbrush;
    }
    if(name == "Orlab")
          pbrush = new Brush();
    }
}
~Person(){
	if(pbrush != nullptr}{
		delete pbrush;
    }
}
///////////////////
Person Yan();
Yan.buyNewBrush("Oralb");
......Three months later...........
Yan.buyNewBrush("Philip");
}
\end{lstlisting}

\item Large array or resources,  if you allocate in stack, it will cause stack overflow. \textbf{In practices, this requirement is deprecated, because any time when you use [] or new [], you need consider to use array or vector ans string!}
\end{enumerate}

\end{itemize}

\section{basic smart pointer knowledge}

\subsection{Smart pointer Basic knowledge}

\begin{itemize}
\item A simple auto\_ptr source code: You can learn how to overload operator*() and operator->().
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
template <class T> class auto_ptr{
    T* ptr;
public:
    explicit auto_ptr(T* p = 0) : ptr(p) {}
    ~auto_ptr()                 {delete ptr;}
    T& operator*()     {return *ptr;}
    T* operator->()    {return ptr;}
    // ...
};

auto_ptr<int> aupr;
//aupr is nullptr even you don't initialize it.
\end{lstlisting}

\item Why do we need smart pointer?
\begin{enumerate}
\item "Just remember" is seldom the best solution! So we need smart pointer to perform delete operator automatically.

\item When throw an exception, or return in the middle of code. delete will not be invoked at all, It will cause memory leaking. When you use smart pointer, If an exception is thrown in the middle of fun, there will no be memory leak.
\begin{lstlisting}[numbers=none]
void methodA() {
   unique_ptr<int> buf(new int[256]);

   int result = fillBuf(buf))
   if(result == -1)
      return;
}
\end{lstlisting}

\item smart pointer is nullptr default if you don't initialize. You avoid wild pointer problem.

\item \textbf{smart pointer can manage exclusive ownership or shared ownership automatically. }
\end{enumerate}

\item There are four kinds of smart pointer: \texttt{auto\_ptr} \texttt{unique\_ptr} \texttt{shared\_ptr} and \texttt{weak\_ptr}  But only \texttt{unique\_ptr} , \texttt{shared\_ptr} and \texttt{weak\_ptr} are recommended to use. auto\_ptr is now deprecated, and should not be used in new code. When you get a chance, try doing a global search-and-replace of \texttt{auto\_ptr} to \texttt{unique\_ptr} in your code base. \texttt{weak\_ptr} is mainly used for observer, you can always use raw pointer or reference for this purpose. Raw pointer can't check if pointee object is still valid, \texttt{weak\_ptr} can accomplish this task.

\item Why \texttt{auto\_ptr} not recommended? 
\begin{enumerate}
	\item When you assign targetP = sourceP, it will cause sourceP set to be NULL, It will cause trouble when you use sourceP in the future. 
	\item You can't create container includes auto\_ptr, compiler prohibit you doing so!
\end{enumerate}
\begin{lstlisting}[numbers=none]
auto_ptr<string> ps (new string("hello world") );
auto_ptr<string> ps1;
ps1 = ps;   // ps will be set null.
ps->size() // it will crash the application.

auto_ptr<string> parray[5]; //compiling error.
auto_ptr<string> ps = parray[2];
//parray[2] will be set null;
\end{lstlisting}

\item \textbf{When you construct a smart pointer, you must use 1) a pointer and 2) this pointer must be produced by new.} You can't build smart pointer by address operator. such as \texttt{unique\_ptr<double> ptr(\&int);}   Why? because smart pointer will call delete when it is out of scope.  delete operator has to be used on pointer produced by new operator.

\item Obtain the raw pointer (get), to relinquish control of the pointed object (release), and to replace the object it manages (reset).
\begin{lstlisting}[numbers=none]
string * cp = new string("hello world");
shared_ptr<string> ps(cp);
string * cp1 = ps.get(); //use get() get normal pointer.
\end{lstlisting}


\item Smart pointer has bool operator, you can use if to test if it's nullptr directly.
\begin{lstlisting}[numbers=none]
std::unique_ptr<int> ptr(new int(42));
if (ptr) std::cout <<  *ptr << '\n';
ptr.reset();
if (ptr) std::cout <<  *ptr << '\n';
\end{lstlisting}

\item shared\_ptr<T> and shared\_ptr<const T> are not interchangable. It goes one way - shared\_ptr<T> is convertable to shared\_ptr<const T> but not the reverse.
\begin{lstlisting}[numbers=none]
shared_ptr<int> pint(new int(4)); 
// normal shared_ptr
shared_ptr<const int> pcint = pint; 
// shared_ptr<const T> from shared_ptr<T>
shared_ptr<int> pint2 = pcint; // error! 
\end{lstlisting}

\item Smart pointer and const:
\begin{lstlisting}[numbers = none]
shared_ptr<T> p;        //---> T * p;
const shared_ptr<T> p;   //---> T * const p;
shared_ptr<const T> p;   //---> const T * p;
const shared_ptr<const T> p; //---> const T * const p;
\end{lstlisting}

\end{itemize}

\subsection{unique\_ptr}

\subsubsection{basic}
\begin{itemize}

\item Basic 1-1: create \texttt{unique\_ptr} from new.    \textbf{make\_unique is better than inside new, inside new is better than outside new.}
\begin{lstlisting}[frame=single, language=c++]
string * cp = new string("hello world");

unique_ptr<string> ps = cp; // NOT allow
unique_ptr<string> ps (cp);
unique_ptr<string> ps (new string("hello world"));
unique_ptr<string> ps( std::make_unique<string>("hello") );
\end{lstlisting}
\begin{description}
	\item[Line 4:] ok, but not good style(outside new)
	\item[Line 5:] good style(inside new)
	\item[Line 6:] best style make\_unique
\end{description}

\item Basic 1-2: Create unique\_ptr from another unique\_ptr, you have to use move.
\begin{lstlisting}[frame=single, language=c++]
unique_ptr<string> ps1 (new string("hello world"));

unique_ptr<string> ps2 ( ps1 ); //compile error, not allow.
unique_ptr<string> ps2 ( move(ps1) ); //ok
\end{lstlisting}
\begin{description}
	\item[Line 4:] ownship transfer from ps1 to ps2, nothing delete.
\end{description}

\item Basic 2: When pass value into a function, \textbf{1) for some exist \texttt{unique\_ptr}, use move to transfer ownership, 2) for new \texttt{unique\_ptr}, use \texttt{make\_unique} to assure exception safe.}

\begin{lstlisting}[frame=single, language=c++]
void sink( unique_ptr<widget> arg1, unique_ptr<gadget> arg2);

sink( std::move(exist_uptr_wi), std::move(exist_uptr_ga))

sink( make_unique<widget>(new ...),
make_unique<gadget>(new ...) );  // exception-safe
\end{lstlisting}
\begin{description}
	\item[Line 3:] use move
	\item[Line 6:] use make function to assure exception safety.
\end{description}


\item Basic 3: \texttt{unique\_ptr} assignment.
\begin{lstlisting}[frame=single, language=c++]
unique_ptr<string> ps1 (new string("ps1"));
unique_ptr<string> ps2 (new string("ps2"));

ps1= ps2; //compile error, not allow

ps1 = std::move(ps2);

ps1.reset(cp); //ok

string* pstr = ps1.release();

\end{lstlisting}
\begin{description}
	\item[Line 6:] Method 1, pointer inside previous ps1 will be deleted. pointer inside ps1 point to "ps2" string now. pointer inside ps2 will set to null
	\item[Line 8:] method2: reset.pointer inside previous ps1 will be delete.
	\item[Line 10:] Use pstr get pointer managed by ps1.
\end{description} 

\item Basic 4-1: If a program attempts to assign one unique\_ptr to another. The compiler allows it if the source object is a temporary rvalue (It will call move ctor or assignment of unique\_ptr inside.) and disallows it if the source object has some duration. \textbf{It is a move-only type.}
\begin{lstlisting}[numbers=none]
unique_ptr<string> ps2 = uqique_ptr<string>(new string("yo") ); 

uqique_ptr<string> fun(){
	return unique_ptr<string> temp(new string("yan");
}
pu2 = fun(); //OK
\end{lstlisting}

\item Basic 4-2: unique\_ptr support source and sink idiom.
\begin{lstlisting}[numbers=none]
unique_ptr fun() //support source

fun(unique_ptr up);  //use move to support sink
fun(move(other_up));
\end{lstlisting}

\item Basic 5: Just observer, not transfer ownership , you can get pointer, or use \texttt{unique\_ptr} reference.
\begin{lstlisting}[numbers=none]
unique_ptr<string> ps1 (new string("ps1"));

fun(string* pstr);  //ps1.get()
fun(unique_ptr<string> & ref_ptr);
\end{lstlisting}

\item By default, \texttt{std::unique\_ptrs} are the same size as raw pointers, so efficiency of it is just like raw pointer.

\item Unique\_ptr has new [] version. The existence of std::unique\_ptr for arrays should be of only intellectual interest to you, because std::array, std::vector, and std::string are virtually always better data structure choices than raw arrays. About the only situation I can conceive of when a std::unique\_ptr<T[]> would make sense would be when you're using a C-like API that returns a raw pointer to a heap array that you assume ownership of it.
\begin{lstlisting}[numbers=none]
unique_ptr<double []>  pda(new double[5] );
// it will call delete [] inside.
\end{lstlisting}

\item When in doubt, prefer \texttt{unique\_ptr} by default, and you can always later move-convert to \texttt{shared\_ptr} if you need it. If you do know from the start you need shared ownership, however, go directly to \texttt{shared\_ptr} via make\_shared. If you compiler report error about \texttt{unique\_ptr}, then you should consider to use shared\_ptr

\item \texttt{unique\_ptr} can be used inside of class. Below class B disable value-copying (or to define a suitable copy-constructor  and operator= to handle it safely).
\begin{lstlisting}[numbers=none]
class B {  // this class can't be copy
public:
   unique_ptr<int> i;
   B():i(new int(0)) { }
};
\end{lstlisting}

\item A common use for \texttt{std::unique\_ptr} is as a factory function return type for objects
in a hierarchy. Detail can be seen "effective modern c++ item 18"

\begin{enumerate}
\item During construction, \texttt{std::unique\_ptr} objects can be configured to use custom deleters: arbitrary functions (or function objects, including those arising from lambda expressions) to be invoked when it's time for their resources to be destroyed. when a custom deleter can be implemented as either a function or a captureless lambda expression, the lambda is preferable.

\item When a custom deleter is to be used, its type must be specified as the second type argument to std::unique\_ptr.
\end{enumerate}

\begin{lstlisting}[frame=single, language=c++, mathescape=true]
//only c++ 14 support return type deduction
template<typename... Ts>
auto makeInvestment(Ts&&... params) {
auto delInvmt = [](Investment* pInvestment) {
	makeLogEntry(pInvestment); // makedelete
	delete pInvestment; // Investment
};

std::unique_ptr<Investment, decltype(delInvmt)>
pInv(nullptr, delInvmt);

if (...){
	pInv.reset(new Stock(std::forward<Ts>(params)...));
}
else if (... ) {
	pInv.reset(new Bond(std::forward<Ts>(params)...));
}
return pInv; // as before
}
\end{lstlisting}

\item std::unique\_ptr is the C++11 way to express exclusive ownership, but one of its
most attractive features is that it easily and efficiently converts to a std::shared\_ptr: This is a key part of why std::unique\_ptr is so well suited as a factory function return type. Factory functions can't know whether callers will want to use exclusive ownership semantics for the object they return or whether shared ownership
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
std::shared_ptr<Investment> sp = // converts std::unique_ptr
makeInvestment( arguments ); // to std::shared_ptr
\end{lstlisting}

\end{itemize}

\subsubsection{unique\_ptr and container}
\begin{itemize}

\item If your vector should hold std::unique\_ptr<Fruit> instead of raw pointers (to prevent memory leaks). vector need copy in and copy out. but unique\_ptr don't support copy. So 
\begin{enumerate}
	\item you can use \texttt{emplace\_back} with new pointer, but it will lead memory leak if extending vector size fail.
	\item use unname \texttt{unique\_ptr.}
	\item use make\_unique
\end{enumerate}
\begin{lstlisting}[frame=single, language=c++]
class Fruit { ... };
class Pear : Fruit { ... };
class Tomato : Fruit { ... };

std::vector<std::unique_ptr<Fruit> > m_fruits;
//method 1, bad
m_fruits.emplace_back(new Pear);

//method 2, good
m_fruits.push_back(std::unique_ptr<Fruit>(new Pear));
m_fruits.push_back(std::unique_ptr<Fruit>(new Tomato));

//method 3, best using std::make_unique:
m_fruits.push_back(std::make_unique<Pear>());
m_fruits.push_back(std::make_unique<Tomato>());
\end{lstlisting}

\item You can store unique\_ptr objects in an STL container providing you don't invoke methods or algorithm, such as copy(), that copy or assign one unique\_ptr to another.  see effective stl item 8.

\begin{lstlisting}[numbers=none]
bool compare_by_uniqptr(
               const unique_ptr<SomeLargeData>& a,
               const unique_ptr<SomeLargeData>& b) {
    return a->id < b->id;
}

sort(vec_byuniqptr.begin(), vec_byuniqptr.end(),
compare_by_uniqptr);
\end{lstlisting}


\begin{lstlisting}[frame=single, language=c++]
typedef std::unique_ptr<int> unique_t;
typedef std::vector< unique_t > vector_t;

vector_t vec2(5, unique_t(new Foo));     // Error (Copy)
vector_t vec3(vec1.begin(), vec1.end()); // Error (Copy)
std::copy(vec1.begin(), vec1.end(),
          std::back_inserter(vec2)); // Error (copy)

vector_t vec3(make_move_iterator(vec1.begin()),
                 make_move_iterator(vec1.end())); //Ok

std::sort(vec1.begin(), vec1.end());
// OK, because using Move Assignment Operator
\end{lstlisting}

\end{itemize}




\subsection{shared\_ptr}
\begin{itemize}
\item shared\_ptr basic 1: create shared\_ptr from new. \textbf{make\_shared is better than inside new, inside new is better than outside new.}
\begin{lstlisting}[frame=single, language=c++]
string * cp = new string("hello world");

shared_ptr<string> ps = cp; //NOT allow

//method1: use constructor
shared_ptr<string> ps (cp); //ok, but not good style
shared_ptr<string> ps (new string("hello world")); //good style

//method2: make_shared function
unique_ptr<string> ps( std::make_shared<string>("hello world") );
\end{lstlisting}

\item shared\_ptr basic 1-1: First, try to avoid passing raw pointers to a std::shared\_ptr constructor. 1) use make\_share(). 2) if you have custom deleter and can't use make\_share().  Pass the result of new directly instead of going through a raw pointer variable.

\begin{lstlisting}[frame=single, language=c++]
auto pw = new Widget; // pw is raw ptr

std::shared_ptr<Widget> spw1(pw, loggingDel);

std::shared_ptr<Widget> spw2(pw, loggingDel);
\end{lstlisting}
\begin{description}
	\item[line 3:] create control block for *pw
	\item[Line 5:] create 2nd control block for *pw! BAD! That will cause undefine result!
\end{description}

\item shared\_ptr basic 2: Create shared\_ptr from another shared\_ptr
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
shared_ptr<string> ps1 (new string("hello world"));

shared_ptr<string> ps2 ( ps1 );
//use_count of ps1 and ps2 are all 2

shared_ptr<string> ps2 ( move(ps1) );

\end{lstlisting}
\begin{description}
	\item[Line 6:] the original ps1 will become null, and the reference count does not get modified. Just transfer use\_count to ps2. 
\end{description}

\item shared\_ptr basic 3: shared\_ptr assignment
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
shared_ptr<string> ps1 (new string("ps1"));
shared_ptr<string> ps2 (new string("ps2"));

ps1 = ps2;
ps1 = std::move(ps2);
ps1.reset(cp); //ok
\end{lstlisting}
\begin{description}
	\item[Line 4:] method1: use assignment  1) previous use\_count decrements 1(If equal 0, will delete) 2) ps1 points to current use\_count 3) and current use\_count increments 1
	
	\item[Line 5:] //method2: use move 1) previous use\_count decrements 1(If equal 0, will delete) 2) ps1 points to current use\_count 3) ps2 is null now. 
	
	\item[Line 6:] //method3: reset //pointer inside previous ps1 will decrement 1.
	//by now, current ps1 reference count will be 1.
\end{description}

\item shared\_ptr basic 4: Difference between ctor and assignment.
\begin{enumerate}
\item When assignment, previous decrements 1 and current increment 1;
\item When copy ctor, current increment 1;
\item When ctor from raw pointer, current is 1;
\end{enumerate}

\item shared\_ptr basic 5: Just observer, not transfer ownership , you can get pointer, or use shared\_ptr reference. Or use reference directly!
\begin{lstlisting}[numbers = none]
shared_ptr<string> ps1 (new string("ps1"));

fun(string* pstr);
fun(shared_ptr<string>& ref_ptr);
\end{lstlisting}

\item inside of shared\_ptr: \newline
\includegraphics[scale=0.6]{pics/shared.png}

\item \textbf{When are control blocks created?}  It's very important conception, when you understand it, you will know what happen when you create or assign a shared\_ptr better. 
		
\begin{enumerate}
\item std::make\_shared  always creates a control block. It manufactures
a new object to point to, so there is certainly no control block for that
object at the time std::make\_shared is called.

\item A control block is created when a std::shared\_ptr is constructed from a
unique-ownership pointer (i.e., a std::unique\_ptr ). As part of its construction, the std::shared\_ptr assumes ownership of the pointed-to object, so the uniqueownership pointer is set to null.

\item When a std::shared\_ptr constructor is called with a raw pointer, it creates a control block.

\item std::shared\_ptr constructors taking std::shared\_ptrs or std::weak\_ptrs as constructor arguments. \textbf{NOT} create new control blocks, because they can rely on the smart pointers passed to them to point to any necessary control blocks

\end{enumerate}


\item Like std::unique\_ptr, std::shared\_ptr uses delete as its default resource-destruction mechanism, but it also supports custom deleters.
\begin{lstlisting}[frame=single, language=c++]
auto loggingDel = [](Widget *pw){ // custom deleter
	makeLogEntry(pw);
	delete pw;
};

std::unique_ptr< Widget, decltype(loggingDel) >
                               upw(new Widget, loggingDel);
// deleter type is ptr type

std::shared_ptr<Widget> spw(new Widget, loggingDel);
// deleter type is not part of ptr type
\end{lstlisting}

\item In order to correctly use shared\_ptr with an array, you must supply a custom deleter. But we don't recommend using shared\_ptr with array. \textbf{Any time you new a array, you should first consider using STL container directly.}
\begin{lstlisting}[numbers=none]
template< typename T >
struct array_deleter {
  void operator ()( T const * p){
    delete[] p;
  }
};

std::shared_ptr<int> sp( new int[10], array_deleter<int>() );
\end{lstlisting}

\item Usage of \texttt{enable\_shared\_from}. If you don't use it, multiple distinct shared\_ptr objects with separate reference counts. For this reason you must never create more than one shared\_ptr \textbf{from the same raw pointer.} It has become C++11 standard.
\begin{lstlisting}[frame=single, language=c++]
class Test : public boost::enable_shared_from_this<Test> {
public:
    boost::shared_ptr<Test> GetObject()
    {
        return shared_from_this();
        //return shared_ptr<test>(this); You can't do this way
        //Anytime you create shared_ptr
    }
};
int main(int argc, char *argv[]){
        boost::shared_ptr<Test> p( new Test( ));
        boost::shared_ptr<Test> q = p->GetObject();
    
    return 0;
}
\end{lstlisting}

\end{itemize}


\subsection{weak\_ptr}
\begin{itemize}

\item The relationship begins at birth. \texttt{std::weak\_ptrs} are typically created from std::shared\_ptrs. You can only create a weak\_ptr out of a shared\_ptr or another weak\_ptr. So the idea would be that the owner of the pointer hold a shared\_ptr instead of a raw pointer.


\item std::weak\_ptrs can't be dereferenced, nor can they be tested for nullness. That's because std::weak\_ptr isn't a standalone smart pointer. It's an augmentation of std::shared\_ptr. Almost the only things you can do are to interrogate it to see if the managed object is still there, or construct a shared\_ptr from it.

\begin{lstlisting}[frame=single, language=c++,mathescape=true]
auto spw =
std::make_shared<Widget>();

std::weak_ptr<Widget> wpw(spw);
...
spw = nullptr;

if (wpw.expired())

\end{lstlisting}
\begin{description}
	\item[Line 4:] the pointed-to Widget's ref count (RC) is 1.
	\item[Line 6:] wpw points to same Widget as spw. RC remains 1
	\item[Line 8:]RC goes to 0, and the Widget is destroyed. wpw now dangles, if wpw doesn't point to an object
\end{description}

\begin{lstlisting}[numbers=none]
std::shared_ptr<Widget> spw1 = wpw.lock();
// if wpw's expired, spw1 is null
auto spw2 = wpw.lock();
// same as above, but uses auto

std::shared_ptr<Widget> spw3(wpw);
// if wpw's expired, throw std::bad_weak_ptr
\end{lstlisting}


\item Potential use cases for std::weak\_ptr includes: caching, observer lists, and the prevention of std::shared\_ptr cycles.  All the detail can be seen in "Effective Modern ++" Item 20.
\begin{lstlisting}[frame=single, language=c++]
std::shared_ptr<const Widget> fastLoadWidget(WidgetID id){
	static std::unordered_map<WidgetID, 
	                std::weak_ptr<const Widget>> cache;
	auto objPtr = cache[id].lock();

	if (!objPtr) { // if not in cache,
		objPtr = loadWidget(id); // load it
		cache[id] = objPtr; // cache it
	}
	return objPtr;
}
\end{lstlisting}
\begin{description}
	\item[Line 6:] objPtr is std::shared\_ptr to cached object . (or null if object's not in cache)
\end{description}


\item For above requirement, you also can use raw pointer, But for raw pointer, you can't detect if original one has been delete. 

\item A truly smart pointer would deal with this problem by tracking
when it dangles, i.e., when the object it is supposed to point to no longer exists. That's precisely the kind of smart pointer std::weak\_ptr is. \textbf{You can't test if a raw pointer is dangle or not.}
\end{itemize}

\subsection{make function}
\begin{itemize}
	\item \textbf{Never say new in c++14!} Use make function instead of new operator.
	
	\item Don't use make\_unique if you need a custom deleter or are adopting a raw pointer from elsewhere.
	
	\item make\_unique doesn't joined the Standard Library until c++14.
	
	\item make\_unique just perfect-forwards its parameters to the constructor of the object being created, constructs a std::unique\_ptr from the raw pointer new produces, and returns the std::uniqu\_ptr so created. \textbf{make\_unique doesn't support arrays or custom deleters.}
	
	\item std::make\_unique and std::make\_shared are two of the three make functions: functions that take an arbitrary set of arguments, perfect-forward them to the constructor for a dynamically allocated object, and return a smart pointer to that object. The third make function is std::allocate\_shared
	
	\item make function has tree advantage: simply, exception safety and allocate once for efficiency.
	
	\begin{enumerate}
		\item The method of using new repeat the type being created, but the make functions don't.  
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
auto upw1(std::make_unique<Widget>()); // with make func
std::unique_ptr<Widget> upw2(new Widget); // without make func
		
auto spw1(std::make_shared<Widget>()); // with make func
std::shared_ptr<Widget> spw2(new Widget); // without make func
\end{lstlisting}
		
		\item The second reason to prefer make functions has to do with exception safety.

		\item It's obvious that this code entails a memory allocation, but it actually performs two. Item 19 explains that every std::shared\_ptr points to a control block containing, among other things, the reference count for the pointed-to object. That's because std::make\_shared allocates a single chunk of memory to hold both the Widget object and the control block.
		
	\end{enumerate}
	
	\item make function has its limitation:
	\begin{enumerate}
		\item For example, none of the make functions permit the specification of custom deleters.
		
		\item the perfect forwarding code uses parentheses, not braces. The bad news is that if you want to construct your pointed-to object using a braced initializer, you must use new directly. Using a make function would require the ability to perfect-forward a braced initializer, but, as Item 30 explains, braced initializers can't be perfect-forwarded.
\begin{lstlisting}
auto upv = std::make_unique<std::vector<int>>(10, 20);
//upv has 10 elements, each one is 20.

// create std::initializer_list
auto initList = { 10, 20 };
// create std::vector using std::initializer_list ctor
auto spv = std::make_shared<std::vector<int>>(initList);
\end{lstlisting}
		
		\item As long as std::weak\_ptrs refer to a control block (i.e., the weak count is greater than zero), that control block must continue to exist. And as long as a control block xists, the memory containing it must remain allocated. The memory allocated by a std::shared\_ptr make function, then, can't be deallocated until the last std::shared\_ptr and the last std::weak\_ptr referring to it have been destroyed
	\end{enumerate}
	
	\item If you can't use make function, you have to create shared\_ptr first, then pass it to function, but a better way is to move it.
\begin{lstlisting}[frame=single, language=c++]
std::shared_ptr<Widget> spw(new Widget, cusDel);
processWidget(spw, computePriority()); 
// correct, but not optimal; see below

processWidget(std::move(spw),computePriority());  
// both efficient and exception safe
\end{lstlisting}
	
\end{itemize}

\subsection{wrapping resource handler in smart pointer}

\subsubsection{basic idea}

\begin{itemize}
	\item The std::unique\_ptr template has two parameters: the type of the pointee, and the type of the deleter. This second parameter has a default value, so you usually just write something like std::unique\_ptr<int>.
	
	\item The std::shared\_ptr template has only one parameter though: the type of the pointee. But you can use a custom deleter with this one too, even though the deleter type is not in the class template. The usual implementation uses type erasure techniques to do this.
	
	\item Part of the reason is that shared\_ptr needs an explicit control block anyway for the ref count and sticking a deleter in isn't that big a deal on top. unique\_ptr however doesn't require any additional overhead, and adding it would be unpopular- it's supposed to be a zero-overhead class. unique\_ptr is supposed to be static.
	
	\item You can always add your own type erasure on top if you want that behaviour- for example, you can have \texttt{unique\_ptr<T, std::function<void(T*)>>}, something that I have done in the past.
	
	\item \textbf{shared\_ptr and std::functions use type erase technology.} About type erase, you can see the generic programming chapter.
	
	\item A common example can be found here:
\begin{lstlisting}[frame=single, language=c++]
typedef struct {
	int m_int;
	double m_double;
} Foo;
	
Foo* createObject(int i_val, double d_val) {
	Foo* output = (Foo*)malloc(sizeof(Foo));
	
	output->m_int = i_val;
	output->m_double = d_val;
	
	puts("Foo created.");
	return output;
}
	
void destroy(Foo* obj) {
	free(obj);
	puts("Foo destroyed.");        
}
	
std::shared_ptr<Foo> foo(createObject(32, 3.14), destroy);
\end{lstlisting}
	
\begin{lstlisting}[frame=single, language=c++]
struct FooDeleter {
	void operator()(Foo* p) const {
		destroy(p);
	}
};
	
using FooWrapper = std::unique_ptr<Foo, FooDeleter>;
FooWrapper foo(createObject(32, 3.14));
\end{lstlisting}
\end{itemize}


\subsubsection{Examples}
\begin{itemize}
	\item There are two different resource handlers: One is window api return value, The other is FILE* in C language
	
	\item Example for FILE* is below:
	
\begin{lstlisting}[frame=single, language=c++]
unique_ptr<std::FILE, decltype(&std::fclose)> 
			fp(std::fopen("demo.txt", "r"), &std::fclose);
			
if(fp) 
\end{lstlisting}
\begin{description}
	\item[Line 1:] For customized deleter, you need callable object.
	\item[Line 3:] Fopen could failed; in which case fp holds a null pointer
\end{description}
	
	\item We can make FILE* example better, use unique\_ptr source semantic.
\begin{lstlisting}[frame=single, language=c++]
struct FILEDeleter {
	void operator()(FILE *pFile){
		if (pFile)
			fclose(pFile);
		}
};
	
using FILE_unique_ptr = unique_ptr<FILE, FILEDeleter>;
	
FILE_unique_ptr make_fopen(const char* fname, const char* mode){
	FILE *fileHandle= nullptr;
	auto err = fopen_s(&fileHandle , fname, mode); 
	if (err != 0){
		// print info, handle error if needed...
		return nullptr;
	}
		return FILE_unique_ptr(fileHandle);
}
	
//usage in your code!
FILE_unique_ptr pInputFilePtr = make_fopen("test.txt", "rb");
if (!pInputFilePtr)
return false;
\end{lstlisting}
	
\item Just the same idea, if you want to use shared\_ptr wrap FILE*, see below example.
\begin{lstlisting}[frame=single, language=c++]
using FILE_shared_ptr = std::shared_ptr<FILE>;
	
FILE_shared_ptr make_fopen_shared(const char* fname, const char* mode){
FILE *fileHandle = nullptr;
auto err = fopen_s(&fileHandle, fname, mode);
if (err != 0){
	// handle error if needed
	return nullptr;
}
	
return FILE_shared_ptr(fileHandle, FILEDeleter());
	//Pay attention!, use FILEDeleter(), but unique_ptr use FILEDeleter
}
\end{lstlisting}
	
\item Just the same idea, You should know \textbf{HANDLE in windows is just void* type pointer}, so you can use this way to deal with windows handle.
	
\begin{lstlisting}[frame=single, language=c++]
struct HANDLEDeleter{
	void operator()(HANDLE handle) const{
		if (handle != INVALID_HANDLE_VALUE)
		CloseHandle(handle);
	}
};
	
using HANDLE_unique_ptr = unique_ptr<void, HANDLEDeleter>;
	
HANDLE_unique_ptr make_HANDLE_unique_ptr(HANDLE handle){
	if (handle == INVALID_HANDLE_VALUE || handle == nullptr){
		// handle error...
		return nullptr;
	}
	return HANDLE_unique_ptr(handle);
}
	
auto hInputFile = make_HANDLE_unique_ptr(
                            CreateFile(strIn, GENERIC_READ, ...));
if (!hInputFile)
	return false;
\end{lstlisting}
	
\item In unique\_ptr type. std::remove\_reference<Deleter>::type::pointer if that type exists, otherwise T*. Must satisfy NullablePointer.
	
\item For unique\_ptr, if you can deduct pointer type from deleter, unique\_ptr will use it directly, so you just know SC\_HANDLE is pointer, but you don't know exact type, you can write just like below: 
\begin{lstlisting}[frame=single, language=c++]
struct SvcHandleDeleter{
	typedef SC_HANDLE pointer;
	SvcHandleDeleter() {};
	
	template<class Other> SvcHandleDeleter(const Other&) {};
	
	void operator()(pointer h) const {
		CloseServiceHandle(h);
	}
};
	
typedef std::unique_ptr<SC_HANDLE,SvcHandleDeleter> unique_sch;
	
unique_sch scm(::OpenSCManagerA(0, 0, SC_MANAGER_ALL_ACCESS));
\end{lstlisting}
	
	\item For shared pointer, type-erasure makes it impossible with the current interface to achieve exactly what type you want. So you can use a dumb way, Just like a pointer to pointer. If you don't know what is behind SC\_HANDLE. If you know it's type is void, you can use void directly, it will save you a lot of trouble. 
	
\begin{lstlisting}[frame=single, language=c++]
std::shared_ptr<SC_HANDLE> sp(new SC_HANDLE(
              ::OpenSCManagerA(0, 0, SC_MANAGER_ALL_ACCESS)),
	[](SC_HANDLE* p){ ::CloseServiceHandle(*p); delete p; });
\end{lstlisting}
	

	
	\item Use shared\_ptr to wrap a handle, A good introduction is "Making a HANDLE RAII-compliant using shared\_ptr with a custom deleter" in stackoverflow
	
	
	\item Sometimes, I want to keep file alive, because foo and bar will use them. You can't use RAII auto object. And If you use raw pointer, It's difficult to trace and delete it. shared\_ptr is the best options right now.  you don't needs to worry about deleting file - once both foo and bar have finished and no longer have any references to file (probably due to foo and bar being destroyed), file will automatically be deleted.
	
	\item For C language, you can use FILE* and input the 
\begin{lstlisting}[frame=single, language=c++]
void setLog(const Foo & foo, const Bar & bar) {
	//File file("/path/to/file", File::append);  1) //RAII auto obj
	//File* file = new File("/path/to/file", File::append); //2) raw new
	shared_ptr<File> file =
		shared_ptr<File>(new File("/path/to/file");FILEDeleter())//3)best
	
foo.setLogFile(file);
bar.setLogFile(file);
}
	\end{lstlisting}
	
	\item for fstream, it's different with FILE*. It's based on value semantic. So common usage just fstream f1; f1.open and f1.close. If you want to manage it's time smartly, you can produce a fstream* pointer and wrapped by shared\_ptr.\textbf{Pay attention, you don't need input customized deleter, because fstream is RAII object, it does close automatically at the end of the scope}
	
	\item fstream is value semantic, so you can use shared\_ptr directly. just like to deal with other value semantic variable, such as int and class.
\begin{lstlisting}[numbers=none]
shared_ptr<fstream> fp{new fstream(name,mode)};
if(!*fp)
	throw No_file{};
		
foo.setLogFile(fp);
bar.setLogFile(fp);
\end{lstlisting}

\end{itemize}

\section{smart pointer and polymorphism}

\subsection{pointer\_cast function}
\begin{itemize}
	\item static\_pointer\_cast
\begin{lstlisting}
struct BaseClass {};

struct DerivedClass : BaseClass {
	void f() const {
		std::cout << "Sample word!\n";
	}
};

int main() {
std::shared_ptr<BaseClass> ptr_to_base(make_shared<DerivedClass>());
std::static_pointer_cast<DerivedClass>(ptr_to_base)->f();
std::dynamic_pointer_cast<DerivedClass>(ptr_to_base)->f();

static_cast<DerivedClass*>(ptr_to_base.get())->f();
}
\end{lstlisting}
\end{itemize}

\subsection{Usage}
\begin{itemize}
\item In this section, you need to know four things:
\begin{enumerate}
\item share\_ptr child to base;
\item share\_ptr base to chile (down cast);
\item unique\_ptr child to base;
\item unique\_ptr base to chile (down cast);
\end{enumerate}

		\item \textbf{Basic idea: smart pointer base and smart pointer are not covariant at all. You can think that just like vector<Base> and vector<derived>}.

		\item For shared\_ptr, it support derived to base shared\_ptr copy or assignment. Behind the hood, you need to know the template member function. Detail can be found in effective C++ item 45 "Use member function templates to accept "all compatible types". Why you can? because it get raw pointer and wrapped it again and compiler allow it.

		\item  For shared\_ptr base, you can't assign it to the shared\_ptr child, so you must use \texttt{static\_pointer\_cast} and \texttt{dynamic\_pointer\_cast}
		\begin{enumerate}
			\item they only support shared\_ptr.
			\item They use shared\_ptr aliasing ctor, get raw pointer, use static or dynamic cast, then build derived shared\_ptr too. Detail can be found: \\
			"std::static\_pointer\_cast vs static\_cast<std::shared\_ptr<A>>"
		\end{enumerate}

		\item For shared\_ptr base reference, You have to use const. Why do we need const?
		\begin{enumerate}
			\item from pd1 build temporary base shared\_ptr pointer.
			\item static\_pointer\_cast also return a temporary base shared\_ptr.
		\end{enumerate}
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
void doSomething(const std::shared_ptr<Base>& ptr) {
// you must use const
    std::cout<<ptr.use_count()<<std::endl; //cout 2
}

int main() {
	std::shared_ptr<Derived1> pd1 = std::make_shared<Derived1>();
	//doSomething(pd1);  Will not compile here.
	doSomething(shared_ptr<Base> temp(pd1));
	doSomething(static_pointer_cast<Base>(pd1));
}
\end{lstlisting}


\item Most of time, use smart pointer reference just for observe. at this time, you can use raw poiner or raw reference directly. 

\item From above, you can see static\_pointer\_cast mainly used to down cast shared\_ptr. From derived to base, you can use const reference directly.

\item static cast also can used for check down cast, it will check at compile time. not like dynamic cast, it will check at run time and also require class has at lease one virtual function.


\item For unique\_ptr, You can use move from derived pointer to base pointer directly.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
void doSomething(const std::unique_ptr<Base> ptr) {
    ptr->run();
}

int main() {
    std::unique_ptr<Derived1> pd1 = std::make_unique<Derived1>();
    doSomething(std::move(pd1));
}
\end{lstlisting}

\item For down cast unique\_ptr, There are no counter part of static\_pointer\_cast. So only way you can do is use release and wrap it agaion.

\begin{lstlisting}[frame=single, language=c++, mathescape=true]
template<typename TO, typename FROM>
unique_ptr<TO> static_unique_pointer_cast (unique_ptr<FROM>&& old){
	return unique_ptr<TO>{static_cast<TO*>(old.release())};
	//conversion: unique_ptr<FROM>->FROM*->TO*->unique_ptr<TO>
}

unique_ptr<Base> foo = fooFactory();
unique_ptr<Derived> foo2 = 
              static_unique_pointer_cast<Derived>(std::move(foo));
\end{lstlisting}

\item For const reference, there are some methods:.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
void f(const unique_ptr<Base>& base)
unique_ptr<Derived> derived = unique_ptr<Derived>(new Derived);
f(derived); //this fail;

f(std::move(derived)); //method 1 work, Why?
    //because int i = 3; const float& dr = i; compile OK
                       
void f(std::unique_ptr<Derived> const&); //method 2

std::unique_ptr<base> derived = std::make_unique<Derived>();//method 3 
std::unique_ptr<base> derived(new Derived);

void f(Base & b);  //method 4
f(*derived);
\end{lstlisting}


\end{itemize}

\section{smart pointer and class}
\subsection{RAII}
\begin{itemize}
	\item Whenever you deal with a resource that needs paired acquire/release function call, encapsulate that resource in an object.  Such as: fopen/fclose, lock/unlock, and new/delete.
	
	\item When implementing RAII, be conscious of copy construction and assignment. the compiler-generated version probably won't be correct. If it's not copyable, use =delete , if it's copyable, duplicate the resource.  You also can use smart\_pointer in this scenario too.
	
	\item The basic idea of RAII  is to represent a resource by a local object, so that the local object's destructor will release the resource.  That is to say: To prevent resource leaks, use RAII objects that acquire resources in their constructors and release them in their destructors.
\begin{lstlisting}[frame=single, language=c++]
//C version,
File* fp = fopen("/path/to/file");
// throw exception here, then resource leaking
fclose(fp);
	
//Java version
try {
	File file = new File("/path/to/file");
	// throw exception here, go to finally.
} finally {
	file.close();
}
	
//c++ version
fun{
	fstream if("path/to/file")
	if.getline
	// you don't need to if.close().
}
	
//c++ smart version.
std::unique_ptr<FILE, // the wrapped raw pointer type: FILE*
int(*)(FILE*)> // the custom deleter type: fclose() prototype
myFile( fopen("myfile", "rb"), //(FILE*) is returned by fopen()
fclose );              // the deleter function: fclose()
\end{lstlisting}
	
	\item Another good example RAII is unique\_ptr. The idea of smart pointer is putting *p into a local pointer-like object, then when it go out scope or unwind-stack when exception is thrown, It will call destructor, then delete p.
	
	\item We should consider resource generically, pointer *p pointed to a new object is resource, A handle to a file is a resource to. \textbf{We wrap handle to a file into ifstream, and wrap pointer *p into smart\_pointer}
	
	\item Just like return value,  Exception will skip all the statement below the throw, In C++, It doesn't support finally statement sometimes. At this time, we need to use RAII.
\begin{lstlisting}[frame=single, language=c++]
Int *p = new int;
string a   //a is ok, a will be destructed properly
//due to the C++ unwind stack.
throw exception.
delete p; // this will not run.
\end{lstlisting}
	
	\item For this problem, you should use smart pointer to declare a auto object.  If you use string object, It's ok.  So in previous example,  you can use smart pointer, it will help you to avoid memory leakage problem.
\begin{lstlisting}[numbers=none]
unique_ptr<int> aupr (new int(100);
string a   //a is ok, a will be destructed properly
//due to the C++ unwind stack.
throw exception.
// both a and aupr will call their own destructor  function.
\end{lstlisting}
	
	\item In you ctor, If you use new and new failed and throw a exception, the destructor will not be called. You can use auto\_ptr as member data and use init list to initialzie it. see  more effective C++ exception chapter.
	
	\item Don't use C FILE* and char [] as string. Use iofile class and string object, because they are exception safe
	\begin{enumerate}
		\item Any time when you use new, consider if there are c++ container or object.
		\item If not, use smart\_pointer.
	\end{enumerate}
	
\item Another example is when you make program based on Win API.
\begin{lstlisting}[numbers=none]
class module {
	public:
	explicit module(std::wstring const& name)
	: handle { ::LoadLibrary(name.c_str()) } {}
	
	~module{
	::FreeLibrary();
	}
	private:
	HMODULE handle;
};
	\end{lstlisting}
	
	\item There are three RAII implementation instances in your practical programming:
	\begin{enumerate}
		\item Use auto member; You have to keep m\_str and vc are RAII.  In this way, you don't need to build dtor manually.
\begin{lstlisting}[numbers=none]
class RAII {
private:
		string m_str;
		vector<int> vc;
};
		\end{lstlisting}
		
		\item Use pointer and handle; In this way, You have to use pointer, Maybe you need some customized action in runtime , \textbf{Use handle is only method to use this resource} or any other reason. And this time, you have to write your own dtor.
\begin{lstlisting}[numbers=none]
class RAII {
private:
		string* m_str;
		vector<int*> vc;
};
\end{lstlisting}
		
		\item Use smart point wrap pointer and handle; When you wrap handle, you can custom this delete behavior. See source code below:
\begin{lstlisting}[numbers=none]
class RAII {
private:
		unique_ptr<string>  m_str;
		vector<unique_ptr<int> > vc;
};
		\end{lstlisting}
		
\begin{lstlisting}[numbers=none]
class module {
public:
	explicit module(std::wstring const& name)
	: handle { ::LoadLibrary(name.c_str()) } {}
private:
	using module_handle=std::unique_ptr<void,decltype(&::FreeLibrary)>;
	module_handle handle;
};
\end{lstlisting}
	\end{enumerate}
	
	\item Another question is ownership of resource:
	\begin{enumerate}
		\item For auto member resource: \textbf{1)Same life duration(RAII), 2)exclusive ownship to a single obj, but it's copyable(A a1 = a2).  3)move with efficiency(A a1 = A() ) }. If auto member has it's own copy and move special function, You don't need to write any special function in your class. You follow the "Rule of Zero".
		
		\item For raw pointer and handle: \textbf{1) default copy ctor will cause two pointer or handle refer the same resource, It's absolutely BAD SMELL of code 2) So you have to follow "Rule of five" to build your special member function. 3) After you build five special member function, you get RAII and exclusive ownship to a single object, and copyable and efficient move}
\begin{lstlisting}[numbers=none]
Class RawPointer{
		...........
	RawPointer(const RawPointer& rhs){
		pRes = new Resource( *(rhs.pRes));
	}
		
	RawPointer(RawPointer&& rhs){
		pPes = rhs.pRes;
		rhs.pRes = nullptr;
	}
private:
Resource* pRes;
}
\end{lstlisting}
		
		\item For uniqu\_ptr; \textbf{1) Same life(RAII) 2)exclusive ownship but not copyable 3) uniqu\_ptr support move operation. } You still follow "rule of zero"

		\item Even with uniqu\_ptr member, If you follow "rule of zero", that is to say that you don't provide any customized special member function, then the class is not copyable. But if you build copy ctor by youself, get raw pointer from origin side, and build a new uniqu\_ptr member from origin side's raw pointer, you can implement copyable, and code smell better than raw pointer with "Rule of Five". So in this way, \textbf{It's not recommended to use raw pointer in RAII and ownership context}.
		
		\item For shared\_ptr; \textbf{1) Not a RAII 2) shared ownship, 3) copyable and moveable}. When you move a shared\_ptr, origin one is set to nullptr and ref count doesn't increas.  You still follow "rule of zero".
		
	\end{enumerate}
	
	\item \textbf{ Conclusion, If you consider RAII and ownship at the same time, thing will become complex}  so I would like to give you some examples to illustrate them.
	
	\begin{enumerate}
		\item Prefer to use auto member for most of time! It follow "Rule of Five" and support copyable and movable. Such as std::string
		
		\item  For special demand, for example Car class,  people can \textbf{custom} its engine, and buy \textbf{two} at the same time. In this context, you car class should use raw pointer, 1) auto member doesn't support custom 2) uniqu\_ptr doesn't support copyable.  And you have to follow "Rule of Five"
\begin{lstlisting}[numbers=none]
class Car{
		//follow "Rule of Five"
		Engine *pEn;
		~Car(){delete pEn} // assure RAII
}
\end{lstlisting}
		
		\item For special context, It doesn't support object copy: for example 1) Person class in semantic;  2) other  perform consideration, Class Big{int [30000];};  3) Other implementation constrain, such as iostream class.   Under such context, you can use uniqu\_ptr to manage the resource and implement uncopyable.
\begin{lstlisting}[frame=single, language=c++]
class Person{
		uniqu_ptr<Resource> pRes;
}
		\end{lstlisting}
		
		\item For special context, shared resource, you can use shared\_ptr.  You still can follow "Rule of zero" and resource will be deleted when ref count is 0.
\begin{lstlisting}[numbers=none]
class Student{
		shared_ptr<SchoolBus> pBus
}
\end{lstlisting}
		
		\item To know semantic of two smart pointers. Don't use them just replace raw pointer.
	\end{enumerate}

\end{itemize}


\section{smart pointer Summary}

\subsection{principle}

\begin{itemize}
\item Three policy of smart pointer usage:
\begin{enumerate}
	\item \textbf{Owership policy: use smart pointer.}
	\item \textbf{Observer Policy : use raw pointer, reference or weak\_ptr}
	\item Nullity Policy: Not allow nullptr, prefer to use reference. \textbf{prefer reference than pointer}
\end{enumerate}

\item Smart pointer general guides:
\begin{enumerate}
\item \textbf{There are three places you can use smart pointer: braced scope(function), class member and container item.} In these three places, you can have exclusive ownership, shared ownership or observer.

\item If the program uses more than one pointer to an object, shared\_ptr is your choice.  Such as you have two objects that contain pointers to the same third object. Or you may have an STL container of pointers.

\item You must ensure that there is only one manager object for each managed object. You do this by writing your code so that when an object is first created, it is immediately given to a shared\_ptr to manage, \textbf{and any other shared\_ptrs or weak\_ptrs that are needed to point to that object are all directly or indirectly copied or assigned from that first shared\_ptr.} The customary way to ensure this is to write the new object expression as the argument for a shared\_ptr constructor, or use the make\_shared function template described below.

\item The exception to this immediate assignment rule is things like factory methods that return a plain pointer to the object they create. in this case however, the callee still should generally be immediately assigning this returned object to a shared\_ptr or unique\_ptr.  Methods should return a plain-pointers when it is up to the caller to handle ownership of the object(exclusive ownership or shared ownership).

\item Besides above method, objects can also be produced by factory pattern or factory function. Then in three kinds of place to mange it's lifetime. 

\item Methods can take plain-pointers as their arguments for just observe it. Or use smart pointer to transfer or get ownership.
\begin{lstlisting}[frame=single, language=c++]
ObserveFun(Foo* p);
ObserveFun(smart_pointer.get() );
ObserveFun(unique_ptr<Foo> &p);


UniqueFun(unique_ptr<Foo> p);
UniqueFun(make_unique_ptr<Foo>(new Foo() )); //get ownership
UniqueFun(move(other_unique_ptr) )  //transfer ownership

SharedFun(shared_ptr<Foo> p);
\end{lstlisting}
\begin{description}
	\item[Line 3:] Not use very often, can be used as fun\_obj in a container of unique\_ptr.
\end{description}

\item If you want to get the full benefit of smart pointers, your code should avoid using raw pointers to refer to the same objects; otherwise it is too easy to have problems with \textbf{dangling pointers and double deletions}. In particular, smart pointers have a get() function that returns the pointer member variable as a built-in pointer value. This function is rarely needed. As much as possible, leave the built-in pointers inside the smart pointers and use only the smart pointers.
\end{enumerate}


\item When you want to use raw pointer in STL container, There are two things you need to consider:
\begin{enumerate}
\item  Be wary of remove-like algorithms on containers of pointers. "effective STL item 33"

\item When using containers of newed pointers, remember to delete the pointers before the container is destroyed. "effective STL item 7". \textbf{All these two problems can be resolved by using smart pointer.}
\end{enumerate}

\item \textbf{Observer pointer,observing pointers are pointers which do not keep the pointed object alive} raw pointers are bad when used for performing manual memory management, i.e. new and delete. When used purely as a means to achieve reference semantics and pass around non-owning, observing pointers, there is nothing intrinsically dangerous in raw pointers. Just not to dereference a dangling pointer
\begin{lstlisting}[frame=single, language=c++]
observe(subject * s1)
\end{lstlisting}
\begin{description}
	\item[Line 1:] subject is a class ovserver is function. just use raw pointer subject, use weak\_ptr or raw pointer. observer doesn't have owner policy and life time policy with subject
\end{description}

\end{itemize}

\subsection{Function interface}

\begin{itemize}

\item \textbf{Function example 1: Inside a function}
\begin{enumerate}
\item If you don't want to create dynamically or large array, don't use new. Just use local auto object. Even you need large array, consider STL container first.
\item When you have to use new, and this function has \textbf{Ownership of pointer, means that they have the same life time},  use unique\_ptr. In this way, you don't need delete and it's exception safe.
\end{enumerate}
\begin{lstlisting}[numbers=none]
fun(){
	Foo fo();
	// it make obj directly,
	//when you don't need dynamic.

	if(input == "Foo")
		uniqu_ptr<Foo> up(new Foo() );
		//When you need new, use uniqu_ptr
}
\end{lstlisting}


\item \textbf{Function example 2 : argument of a function.}
\begin{enumerate}
\item As a parameter, pass it to a function. if you don't want to create dynamicly or large array, don't use new. Just use reference.

\item Prefer passing parameters by * or \&.

\item Passing unique\_ptr by reference is for in/out unique\_ptr parameters. when the function is supposed to actually accept an existing unique\_ptr and potentially modify it to refer to a different object. 

\item In this sense, const unique\_ptr \& MUST be observer. So A better way is to sue raw pointer as observer directly.

\item \textbf{If you want to transfer ownership to callee from caller, use uniqu\_ptr, and use move.} Passing unique\_ptr by value means "sink."

\item \textbf{If you want to shared ownership to callee from caller, use shared\_ptr}

\item Use a non-const shared\_ptr\& parameter only to modify the shared\_ptr. Use a const shared\_ptr\& as a parameter only if you're not sure whether or not you'll take a copy and share ownership; otherwise use widget* instead (or if not nullable, a widget\&).

\item When you assign unique\_ptr to shared\_ptr, use move.
\end{enumerate}

\begin{lstlisting}[frame=single, language=c++]
Foo *fo = new Foo();  //bad smell here.
fun(Foo * p);
delete fo;

fun(Foo &p); //use reference to improve efficiency

uniqu_ptr<Foo> up(new Foo() );
fun(uniqu_ptr<Foo>& up); //use reference here
 //to avoid copy, uniqu_ptr can't copy

fun(uniqu_ptr<Foo> down);  //prototype
fun(std::move(up) );

std::unique_ptr<std::string> unique = std::make_unique<std::string>("test");
std::shared_ptr<std::string> shared = std::move(unique);
\end{lstlisting}

\item \textbf{Function example3: return from function.}
\begin{enumerate}
\item As a function return value. if you don't want to create dynamically or large array, don't use new. \textbf{Don't  use reference refer to a local object created inside of fun.}

\item If you have to use New, and you want to transfer Ownership from callee to caller. return unique\_ptr.

\item If there is no clear single owner, store and return shared\_ptr.(in this example, caller of fun() is single owner, so use unique\_ptr)

\begin{lstlisting}[frame=single, language=c++]
Foo* fun(){   //old c style.
	return new Foo();
}

unique_ptr<Foo> fun(){  // this is better.
........
	return unique_ptr<Foo>(new Foo()) ;
}
\end{lstlisting}

\item Below use shared\_ptr, because Server is public used, and no single owner.
\begin{lstlisting}[frame=single, language=c++]
shared_ptr<Server> buildNewServer(){  // this is better.
	return shared_ptr<Server>(new Server()) ;
}

shared_ptr<Server> serverForClass1 = buildNewServer();
shared_ptr<Server> serverForClass2  = serverForClass1;
\end{lstlisting}

\end{enumerate}

\item About smart pointer and function interface. There is a good article. "GotW \#91 Solution: Smart Pointer Parameters"
\end{itemize}


\chapter{reference and rvalue reference}
\section{reference basic}

\begin{itemize}
\item \textbf{Reference has two characteristics, no null, no change}.In other words, top level of const of reference is default. You can't change it. That is why you have to initiliaze it.
\begin{lstlisting}
int x = 12;
int* const p = &x; 
p  = &y ; 
\end{lstlisting}
\begin{description}
	\item[Line 2 and 3:] you have to init reference when you declare it. You can't point to different object. Because it can't change, reference is like a kind of top level const pointer.
\end{description}

\begin{enumerate}
\item No change, a reference always refers to the object with which it's initialized firstly.
\begin{lstlisting}[numbers = none]
string &rs = s1;
rs = s2; //modified s1's value,rs still refer to s1
\end{lstlisting}

\item Reference is different with pointer. Reference has not wild pointer problem. So a reference doesn't need to be test if it's null reference.
\begin{lstlisting}[numbers=none]
if(pointer) // don't need for a reference.
cout<< *pointer<<endl;
\end{lstlisting}

\item If you have a reference to a local variable inside a function, when the function finishes, it still have dangling reference problem. 
\end{enumerate}

\item you can have reference to pointer, but pointer to reference is illegal. In grammar level, reference to reference has different means, it's called rvalue reference. This doesn't exist. As stated earlier, a reference is merely an alias to another object. You can't "point" to a reference, because it isn't an object in itself but merely another name for a real object. Of course, you can have a pointer to the object that a reference is referring to. But now we are back in vanilla pointer territory.
\begin{lstlisting}[numbers=none]
int *p;
int *& rp = p; // reference to pointer is OK
int &* pr  //pointer to reference is ERROR
int && rv //rvalue reference.
\end{lstlisting}


\item non-const reference can't refer to const object.
\begin{lstlisting}[numbers=none]
const int i = 12;
int& j = i; //ERROR
\end{lstlisting}

\item A \texttt{const} object reference passed into a function, if you want to return it , it must be \texttt{const} too. Usually, It has no any practical meanings when you do in this way. 
\begin{lstlisting}[numbers=none]
const int &fun(const int& i){ //method 1
	return i;
}

int &fun(const int& i){ //method 2
	return const_cast<int&>(i);
}
\end{lstlisting}

\item Only \texttt{const} reference can bound to temporary and prolong temporary variable life. Temporary is not lvalue, and only lvalue can bound to reference to \texttt{non-const}. Only stack-base \texttt{const} reference can work in this way. If a \texttt{const} reference is class member, it can't work.  See two examples below:
\begin{lstlisting}[frame=single, language=c++]
Foo f(){ //case 1:
	return obj;
}
const Foo & rf = f();

class Foo(int i); // case 2:
f(const Foo & crf); //function declaration

f(1);
\end{lstlisting}
\begin{description}
	\item[Line 9:] temp obj build by ctor, if you skip const in line 7 function declartion, compiler will report error.
\end{description}

\item \texttt{const} reference bound to rvalue used in copy ctor widely. See example below: But in C++11, For a class with a lot allocated resource, please use move copy ctor which explained in the next section:

\begin{lstlisting}
class Foo{
	Foo(const Foo & foo);
}

Foo f3 = f1+f2;
\end{lstlisting}
\begin{description}
	\item[Line 5:] because a temp Foo is produced first from f1+f2 .without const in copy ctor, compiler will bark.
\end{description}
\end{itemize}

\section{lvalue, rvalue and xvalue}
\begin{itemize}
	\item In this section, there are four important points
	\begin{enumerate}
		\item Academic definition of xvalue.
		\item Give some practical expressions which are xvalue.
		\item Relationship between xvalue and rvalue reference.
		\item Why do we need a new value type--xvalue?
	\end{enumerate}
	
\end{itemize}

\subsection{Definition}

\begin{itemize}
	\item Each C++ expression (an operator with its operands, a literal, a variable name, etc.) is characterized by two independent properties: \textbf{a type and a value category}. Each expression is certain kind of type,such as int type, reference type or rvalue reference type. Each expression belongs to exactly one of the three primary value categories: \textbf{lvalue, prvalue, and xvalue;} 
	
	\item lvalue is not defined "can be put on the left side of =". Because \texttt{const int a} is also a lvalue, and you can't put a on the left side of = . It has three characteristics:
	\begin{enumerate}
		\item\textbf{lvalue has Identity}, (can get address by \& operator),
		\item \textbf{lvalue can be persist beyond the expression. }
		\item \textbf{lvalue can't be move(stolen),} because you need to keep original one intact.
	\end{enumerate}
	
	\item On the contrary, prvalue has no \textbf{identity}, and will not \textbf{persist} beyond expression and can be move(stolen)
	
	\item Why pvalue doesn't persist? because rvalues in C++ stored differently. It's freedom for the compiler to improve performances of your code. A more concrete way to understand this is to remember that a value can be stored in a register of your CPU and never actually be in your memory which more or less means that the value has no address. I won't bet everything i have on it but this is probably one of the main reasons why "we cannot get an address of an rvalue".
	
	\item In a more general way since an rvalue is semantically temporary it is more likely to be put in temporary places or optimised in a way where it cannot easily be mapped to an address and even if it can that would be counter productive in terms of performance.
	
	\item First, we can use \textbf{persist and identity} to classify value into lvalue and rvalue, then c++11 introduce \textbf{rvalue reference}. rref can persist and move at the same time.  So we divide lvalue into lvalue and xvalue.  and give them new name.  lvalue+xvalue = glvalue(persist)  and xvalue + prvalue = rvalue(move).
	
	\item \textbf{Any value must be one of three, lvalue, xvalue, or prvalue.} These three categories are complementary.  \textbf{lvalue pay attention to  identity and persist, rvalue=(xvalue + prvalue) shout "I can be moved" loudly.  So we call \&\& rvalue reference, don't call it xvalue reference. }
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.4\linewidth]{pics/xvalue1.png}
		\caption{lvalue, rvalue and xvalue.}
		\label{fig:xvalue1}
	\end{figure}
	
	
	\item To know this conception can help you to understand decltype. 
	
	\item Summary table: \newline
	\begin{tabular}{|c|c|c|}
		\tophline
		& persist(Identity) & move \\
		\tophline
		lvalue & Yes & No \\
		\tophline
		pvalue & No & Yes \\
		\tophline
		xvalue & Yes & Yes \bottomhline
	\end{tabular}

\item An example shows that xvalue has identity and persist, and will persist beyond expression and can be move(stolen). it usually near the end of its lifetime (so that its resources may be moved).
\begin{lstlisting}
string&& xvalue_fun();

xvalue_fun(); 
xvalue_fun() = "hello" 
&xvalue_fun(); //
string a = xvalue_fun(); 
\end{lstlisting}
\begin{description}
	\item[Line 3:] After you call this fun, value still exist.
	\item[Line 4:] You can modify because it persist.
	\item[Line 5:] You can get address because it has identity.
	\item[Line 6:] call move ctor, can move.
\end{description}

\item A method to judge if a var is lvalue.
\begin{lstlisting}[frame=single, language=c++]
template <typename T>
constexpr bool is_lvalue(T&&) {
	return std::is_lvalue_reference<T>{};
}

std::string a("Hello");
is_lvalue(std::string()); // false
is_lvalue(a); // true  
\end{lstlisting}

\begin{description}
	\item[Line 8:] in the case you pass a std::string lvalue, then T will deduce to std::string\& or const std::string\&, for rvalues it will deduce to std::string
\end{description}

\item \textbf{How to determine programmatic if an expression is rvalue or lvalue}
\begin{lstlisting}[numbers=none]
if (std::is_lvalue_reference<decltype(var)>::value) {
	// var was initialised with an lvalue expression
} else if (std::is_rvalue_reference<decltype(var)>::value) {
	// var was initialised with an rvalue expression
}

string&& xvalue_fun();
std::is_lvalue_reference<decltype(xvalue_fun())>::value
//return true
\end{lstlisting}

\end{itemize}

\subsection{Example of xvalue}

\begin{itemize}
	\item Remember that any expression that evaluates to an lvalue reference (e.g., a function call, an overloaded assignment operator, etc.) is \textbf{an lvalue}. Any expression that \textbf{returns an object by value is an rvalue}.
	
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
string& lvalue_fun();
lvalue_fun(); 
lvalue_fun() = "hello" 
&lvalue_fun(); 
string a = lvalue_fun 

string pvalue_fun();
pvalue_fun(); 
pvalue_fun() = "hello" 
&pvalue_fun(); 
string a = pvalue_fun() 
\end{lstlisting}
\begin{description}
	\item[Line 2 to 5:] After you call this fun, lvalue still exist. you can modify because it persist. you can get address because it has identity. call copy ctor, can't move
	
	\item[Line 8 to 11:]  After call this fun, value disappear. NOT modify because it doesn't persist. NOT get address because it no identity. call move ctor, can move
\end{description}
	
	\item An xvalue is the result of certain kinds of expressions involving rvalue references. \textbf{The result of calling a function whose return type is an rvalue reference is an xvalue.}
	
	\item textbf{fun return lvalue reference is lvalue, fun return value is pvalue, and fun return rvalue reference is xvalue.}
	
	\item In definition,  xvalue is just value with Identity and can be movable. \textbf{In real life, it's  return value of std::move() or static\_cast<A\&\&>}. A better introduction can be seen: " C++11 Tutorial: Explaining the Ever-Elusive Lvalues and Rvalues"
	
	\item More xvalue examples.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
struct A {
	int m;
};
	
A&& operator+(A, A); // a+a is xvalue
A&& f();  //f() is xvalue
f().m // f().m is also xvluae
A a;
A&& ar = static_cast<A&&>(a);
\end{lstlisting}
\begin{description}
	\item[Line 9:] static\_cast<A\&\&>(a) is xvalue, but ar is lvalue
\end{description}
	
	\item After C++11, we added two new xvalues.\\
	1) a[n], the built-in subscript expression, where one operand is an array rvalue;\\
	2) a.m, the member of object expression, where a is an rvalue and m is a non-static data member of non-reference
\end{itemize}

\subsection{xvalue and rvalue reference}

\begin{itemize}
	\item \textbf{xvalue is defined based on rvalue reference. But you can't think that a rvalue reference is a xvalue. }
	
	\item \textbf{A named rvalue reference is lvalue, and unnamed rvalue reference is xvalue};
	
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
void foo(int&& t) {

}
	
std::string a;   //a, b, c are all lvalue.
std::string& b;
std::string&& c;
\end{lstlisting}
\begin{description}
	\item[Line 1:] t is initialized with an rvalue expression, but is actually an lvalue expression itself
\end{description}
	

	\item Why is there such confusion? Here are the circumstances under which it is safe to move something:\\
	1) When it's a temporary or sub-object thereof. (prvalue) \\
	2) When the user has explicitly said to move it.
\begin{lstlisting}[frame=single, language=c++]
SomeType &&Func() { ... }
	
SomeType &&val = Func();
SomeType otherVal{val}; // Do you really want to move 
	....
cout<<val; 
\end{lstlisting}
\begin{description}
	\item[Line 6:] what happen if you have forget you have move? it will crash the probrem. so standard said that val is lvalue. because it's a named rvalue reference.
\end{description}
	
\item Another deep trap happen when you implement move ctor in derived class
\begin{lstlisting}[numbers=none]
Derived(Derived&& rhs):Base(rhs)//wrong: rhs is an lvalue
{
	// Derived-specific stuff
}
	
Derived(Derived&& rhs) : Base(std::move(rhs)){
	// good, calls Base(Base&& rhs)
	// Derived-specific stuff
}
\end{lstlisting}
	
\end{itemize}


\subsection{Why need xvalue}
\begin{itemize}
	\item given a type T, you can have lvalues of type T as well as rvalues of typeT. It's especially important to remember this when dealing with a parameter of rvalue reference type, because the parameter itself is an lvalue.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
int && i = 2;  
int && fun()
fun() 
\end{lstlisting}
\begin{description}
	\item[Line 1:] i expression is rvalue referene type lvalue
	\item[Line 3:] fun() expression is vralue reference type rvalue. 
\end{description}
	
	\item before C++11, we have used value category to overload function. plain lvalue reference can only bind to lvalue, can't bind to rvalue. So we use \textbf{const lvalue reference}.  Const lvalue reference can bind to both lvalue and rvalue, but you can't change it. We have used this technology in copy ctor very common before C++11. Because const reference can bind both lvalue and rvalue, so we can't distinguish when to move, when to copy, that is the problem of efficiency.
	
	\item After C++11, in order to improve efficiency when deal with rvalue, we introduced rvalue reference.  rvalue referencecan only bind to rvalue, (rvalue is composed of prvalue+ xvalue). \textbf{That is how funciton overload kick in?}

\begin{lstlisting}[frame=single, language=c++, mathescape=true]
int a = 7;  // a is lvalue, It has Identity
int && r1 = 13,  //r1, r2 and r3 are lvalue
int && r2= x+y; //x+y is prvalue
int && r3 = sqrt(2.0);  //sqrt(2.0) is prvalue
int && r4 = a 

cont int & lv = x+y; //lv is lvalue
int & r = x+y; 
\end{lstlisting}
\begin{description}
	\item[Line 5:] error, rvalue reference can't refer to lvalue.
	\item[Line 8:] error,lvalue reference can not bind with an rvalue.
\end{description}
	
	\begin{tabular}{|c|c|}
		\tophline 
		type & value category \\ 
		\tophline 
		lvalue reference & lvalue(non-const)  \\ 
		\tophline 
		rvalue reference &  rvalue(non-const)\\ 
		\tophline 
		const lvalue reference & lvalue or rvalue(const or non-const)  \bottomhline 
	\end{tabular} 
	
	\item C++11 allows you to use move semantics not just on rvalues, but, at your discretion, on lvalues as well. An good example is swap function, here if you can move lvalue, the efficiency will be better. 
	
\begin{lstlisting}[numbers=none]
template<class T> 
void swap(T& a, T& b) { 
	T tmp(std::move(a));
	a = std::move(b); 
	b = std::move(tmp);
} 
\end{lstlisting}
	
	\item So for std::move() function, return value can be value(rvalue), but it can't support dynamic binding in C++.  return value can be reference(lvalue), but it can't be used move context. So we have to use rvalue reference as return type. 
	
	\item for this kind of rvalue reference, we can put it on the left side of assignment, so it's not prvalue. At the same time, you can move it, so it's not lvalue.  \textbf{In this way, we have to introduced a new value type--xvalue.}    
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
string str = "hello"
std::move(str)[0] = 'z';
cout<<str<<endl 
\end{lstlisting}
\begin{description}
	\item[Lie 3:] print "zello" here. Because std::move() return a xvalue, it can persist and move.
\end{description}
	
	\item Summary:
	\begin{enumerate}
		\item We have rvalue reference to bind temporary value to move it.
		\item We want to move a lvalue, such as swap, so we have std::move() function.
		\item std::move() return neither lvalue nor prvalue, so we have to define a new type of value--xvalue.
	\end{enumerate}

	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.7\linewidth]{pics/xvalue.png}
		\caption{move semantic application}
		\label{fig:xvalue}
	\end{figure}	
\end{itemize}

\section{rvalue reference and move scenario}
\subsection{basic of rvalue reference}
\begin{itemize}

	\item rvalues denote temporaries or objects that want to look like a temporary. What is so particular about temporaries, is the fact that they will be used in a very limited way: their value will be read once, and they will be destroyed. This is a very useful observation in implementing "move semantics." 

	\item How to understand move semantics? Move is not really move a big chunk of data, It just move index of data. just like you move file in the hard disk. 

	\item rvalue references will implicitly bind to rvalues and to temporaries that are the result of an implicit conversion. i.e. float f = 0f; int\&\& i = f; is well formed because float is implicitly convertible to int; the reference would be to a temporary that is the result of the conversion.

	\item Rvalue references can be used to extend the lifetimes of temporary objects (note, lvalue references to const can extend the lifetimes of temporary objects too, but they are not modifiable through them):

\begin{lstlisting}[frame=single, language=c++, mathescape=true]
std::string s1 = "Test";

const std::string& r2 = s1 + s1; 
r2+="test" //Error

std::string&& r3 = s1 + s1;      
r3 += "Test";                    
\end{lstlisting}
\begin{description}
	\item[Line 1:] std::string\&\& r1 = s1; error: rvalue ref can't bind to lvalue.
	
	\item[Line 3:] okay: lvalue reference to const extends lifetime.

	\item[Line 4:] error: can't modify through reference to const.
	\item[Line 6:] okay: rvalue reference extends lifetime
	\item[Line 7:] okay: can modify through reference to non-const.
\end{description}

\end{itemize}

\subsection{move ctor and assigment}
\begin{itemize}
	\item \textbf{Typically, if your class allocate a lot of allocated resource (new, or manually manage some system resources).  You should implement two copy ctor}. One of them uses rvalue references, which allow a function to branch at compile time (via overload resolution) on the condition "Am I being called on an lvalue or an rvalue?" A few explanations are below:
	
	\begin{enumerate}
		\item Move ctor will not move resource automatically, you need to coding it by your self.
		
		\item You can't move in normal ctor. because, It must keep origin obj intact.  You can steal when Foo(f1+f2), but when you used Foo(f1).  It will destory f1.
		
		\item Without  move ctor, normal copy ctor will treat Foo f = f1+f2 and Foo f = f1 the same way.
		
		\item With move copy ctor, normal copy ctor deal with Foo f = f1, and move copy ctor deal with Foo f = f1+f2, for f1+f2, you can steal resource, because nobody need to use f1+f2 later any more.
		
		\item \textbf{In move ctor, always set rhs.ptr = nullptr;}
		
		\item No const qualifier in move ctor and move assignment
\begin{lstlisting}[numbers=none]
Foo::Foo(const Foo & foo){
	while(ptr++;)
	ptr[i] = foo.ptr[i]  //expensive copy
	}
		
Foo::Foo(Foo && rhs){ //no const here
	ptr = other.ptr;  //efficient move(steal)
	rhs.ptr = nullptr;
	}
		
Foo& Foo::operator=(Foo&& rhs){
	delete[] ptr;
	ptr = other.ptr;  //efficient move(steal)
	rhs.ptr = nullptr;
	return *this;
	}
\end{lstlisting}
		
	\end{enumerate}
	
\item When the move ctor will be called? Below are some examples.
\begin{lstlisting}[frame=single, language=c++]
class obj = 2 
	
obj =2         //call assignment operator
	
class obj1 = obj2 
	
obj1 = obj2         //call assignment operator
	
class obj1 = obj2+obj3   
	
obj1 = obj2+obj3 
\end{lstlisting}
\begin{description}
	\item[Line 1:] same as class obj(2), call single argument ctor
	\item[Line 5:] call  copy ctor, not call assignment operator
	\item[Line 9:] call move ctor, if you dont' have move ctor, It will call copy ctor
	\item[Line 11:] call move assignment operator  if you define.
\end{description}
	
	\item In below examples, Foo obj1=obj2+obj3. if you don't have move ctor, In operator + function, a temp obj is produced,  and when operator+ function return, another temp obj temp2 is produced .  Then in the end, objtemp2 is passed to ctor,  So, ctor is called three times. and copy content is also called three times.
	
\begin{lstlisting}[numbers=none]
Foo Foo::operator+( const Foo & f) const {
	Foo temp = Foo(n+f.n);
	//copy happen here.
	return temp;
}
	
Foo obj1=obj2+obj3  
// three ctor called without move ctor
\end{lstlisting}
	
	\item If you have move ctor. In operator + function, a temp objtemp1 is produced,  When return objtemp1, It will not produce objtemp2. (becasue objtemp1 is rvalue.) then objtemp1 is passed to move ctor. In side move ctor, the resource address has been move to new obj1.  Just one temp objtemp1 and one actual copy happen. ( just new pointer = old pointer; and old pointer = NULL).
\end{itemize}

\subsection{move semantic}
\begin{itemize}

\item First, Don't declare objects \texttt{const} if you want to be able to move from them. Move requests on \texttt{const} objects are silently transformed into copy operations.

\item Second, std::move not only doesn't actually move anything, it doesn't even guarantee that the object it's casting will be eligible to be moved. The only thing you know for sure about the result of applying std::move to an object is that it return a xvalue.

\begin{lstlisting}[frame=single, language=c++]
explicit Annotation(const std::string text)
: value(std::move(text)) 
\end{lstlisting}
\begin{description}
	\item[Line 1:] That is constructor, we want to "move" text into value; this code doesn't do what it seems to, because text is const
\end{description}

\item Move ctor and move assignment work with rvalue, What if you want to use them with lvalues? You can call std::move function, It will call you move ctor or assignment to "move" resource, not "copy" resource.
\begin{lstlisting}[frame=single, language=c++]
Foo choices[10];
Foo best;
best = choices[3];

best = std::move(choices[3]);
\end{lstlisting}
\begin{description}
	\item[Line 5:] I don't want to keep choices after I pick up what I want here, It will call normal move assignment, because choices[3] is not rvalue. It will call move assignment
\end{description}
\end{itemize}



\section{universal(forwarding) reference }
\subsection{definition}
\begin{itemize}
\item You need to know two prerequisites before you understand forwarding reference:

\begin{enumerate}
	\item In pre-11 C++, it was not allowed to take a reference to a reference: something like A\&\& would cause a compile error. C++11, by contrast, introduces the following reference collapsing rules1:
	
\begin{lstlisting}[numbers=none]
A& & becomes A&
A& && becomes A&
A&& & becomes A&
A&& && becomes A&&
\end{lstlisting}
	
	\item forwarding reference type deduction rules: For lvalue and rvalue, we use the different rule to deduct type.
\end{enumerate}

\item \textbf{Universal reference has been renamed as forwarding reference. It's more descriptive name, It tell you universal reference should always been used with forwarding.}

\item  Universal references arise in two contexts. The most common is function template parameters. The second context is auto\&\&\textbf{1)must be constrained T\&\& form, 2) type deduction happen.}

\item If the form of the type declaration isn't precisely type\&\&, or if type deduction does not occur, type\&\& denotes an rvalue reference.
\begin{lstlisting}[numbers=none]
auto&& var2 = var1; // universal reference

template<typename T>
void f(T&& param); // universal  reference

template<class T, class Allocator = allocator<T>>
class vector {
template <class... Args>
void emplace_back(Args&&... args);  //args is universal reference
};

//------------below are not universal reference----
template<typename T>
void f(std::vector<T>&& param); // rvalue reference
// form is quite constrained. It must be precisely "T&&".

template<typename T>
void f(const T&& param); // with const

template<class T, class Allocator = allocator<T>> // from C++
class vector { // Standards
public:
void push_back(T&& x); //no type deduction
};
\end{lstlisting}


\item For auto\&\&, basic idea just like universal reference, you need to use decltype(var) to get type information when you use forward function on the universal reference. 

\item If you then use \textbf{std::forward on your auto\&\& reference} to preserve the fact that it was originally either an lvalue or an rvalue, your code says: Now that I've got your object from either an lvalue or rvalue expression, I want to preserve whichever valueness it originally had so I can use it most efficiently.

\begin{lstlisting}[frame=single, language=c++]
auto&& var = some_expression_that_may_be_rvalue_or_lvalue;
use_it_elsewhere(std::forward<decltype(var)>(var));
\end{lstlisting}
\begin{description}
	\item[Line 1:] var was initialized with either an lvalue or rvalue, but var itself is an lvalue because named rvalues are lvalues
\end{description}

\item When to use auto\&\&. I will accept any initializer regardless of whether it is an lvalue or rvalue expression and I will preserve its constness. This is typically used for forwarding (usually with T\&\&). The reason this works is because a "universal reference", auto\&\& or T\&\&, will bind to anything. A good example of\\
"some\_expression\_that\_may\_be\_rvalue\_or\_lvalue;"
\begin{lstlisting}[frame=single, language=c++]
std::vector<int> global_vec{1, 2, 3, 4};

template <typename T>
T get_vector(){
return global_vec;
}

template <typename T>
void foo(){
auto&& vec = get_vector<T>(); 
auto i = std::begin(vec);
(*i)++;
std::cout << vec[0] << std::endl;
}

foo<std::vector<int>>();
std::cout << global_vec[0] << std::endl;
foo<std::vector<int>&>();
std::cout << global_vec[0] << std::endl;
\end{lstlisting}
\begin{description}
	\item[Line 10:] only auto\&\& work here. auto, auto\& , const auto\&, const auto\&\& all failed.
\end{description}

\end{itemize}

\subsection{pros}
\begin{itemize}
\item It can provide the unify interface, and it supports variadic number. That is make\_unique and make\_shared and emplace-kind function possible.

\item If you have a template class or template fun, universal reference is your only choice. An example can be seen in the last chapter, "decltype deduction" section.

\item For overload method, more source code to write and maintain (two functions instead of a single template). 

\item For overload method, it can be less efficient. For example, consider this use of setName: w.setName("Adela Novak"); With the version of setName taking a universal reference, the string literal "Adela Novak" would be passed to setName, where it would be conveyed to the assignment operator for the std::string inside w. w's name data member would thus be assigned directly from the string literal; no temporary std::string objects would arise. With the overloaded versions of setName, however, a temporary std::string object
would be created for setName's parameter to bind to, and this temporary std::string would then be moved into w's data member.

\begin{lstlisting}[numbers=none]
class Widget {
public:
	template<typename T>
	void setName(T&& newName) // newName is universal reference
	{ name = std::forward<T>(newName); }
...
	string name;    
};
\end{lstlisting}


\item overload has the poor scalability of the design. Widget::setName takes only one parameter, so only two overloads are necessary, but for functions taking more parameters, each of which could be an lvalue or an rvalue, the number of overloads grows geometrically: n parameters necessitates 2n overloads. Such as make\_shared function, It's also support variadic parameter

\begin{lstlisting}[numbers=none]
template<class T, class... Args> 
shared_ptr<T> make_shared(Args&&... args); 

template<class T, class... Args> 
unique_ptr<T> make_unique(Args&&... args); 
\end{lstlisting}

\subsection{cons}

\item You can use universal reference,  but inside, you have to use forward function, and implementation is a little difficult.  Detail can be seen "effective modern c++ item 41". As a template, implementation must typically be in a header file. It may yield several functions in object code, because it not only instantiates differently for lvalues and rvalues, it also instantiates differently for std::string and types that are convertible to std::string (see Item 25). 

\item There are argument types that can't be passed by universal reference (see Item 30), and if clients pass improper argument types, compiler error messages can be intimidating (see Item 27).

\begin{lstlisting}[numbers=none]
template<typename T> // reference
fun(T&& value){
	vector<Foo> vect;
	vect.push_back(std::forward<T>(value)); 
}
\end{lstlisting}


\item Overloading on universal references almost always leads to the universal reference overload being called more frequently than expected.

\item Perfect-forwarding constructors are especially problematic, because they're typically better matches than copy constructors for non-const lvalues, and they can hijack derived class calls to base class copy and move constructors. detail can be seen in "effective modern c++ item 26"

\end{itemize}

\subsection{Usage of forwarding reference}
\begin{itemize}
\item When to use universal references? universal means that:
\begin{enumerate}
	\item you have to support different type or a lot of parameter. 
	\item You have to use reference, means that need refer a existing one, you refer it because you want to copy it inside of your template function. 
\end{enumerate}

\item there are some points here:
	\begin{enumerate}
		\item \textbf{The first of first, it's only used in a template function.}
		
		\item \textbf{Inside the function, A copy will happen, if just read or write, use reference or const reference directly}
		
		\item \textbf{When copy, move is cheap, if there is no pointer or contaner, only has POD type value, move is just like copy. You don't need to use universal references.} Most of time, in your universial function, you have a container(string is container too), because move container is much cheaper than copy it.
		
		\item \textbf{For universial referene, you must forward it to ctor, container, object or function. and these four things will take different action toward lvalue and rvlaue.}
		
		\item \textbf{There are more than 2 parameters, and overload function will cause exponential increase.}

		\item I will accept any initializer regardless of whether it is an lvalue or rvalue expression and I will preserve its constness. 

		\item This is typically used for forwarding (usually with T\&\&). The reason this works is because a "universal reference", auto\&\& or T\&\&, will bind to anything.  

		\item You might say, well why not just use a const auto\& because that will also bind to anything? The problem with using a const reference is that it's const! You won't be able to later bind it to any non-const references or invoke any member functions that are not marked const.
\begin{lstlisting}[frame=single, language=c++]
auto&& vec = some_expression_that_may_be_rvalue_or_lvalue;
auto i = std::begin(vec);
(*i)++;

auto         
auto&       
const auto&
const auto&& 
\end{lstlisting} 
\begin{description}
	\item[Line 5:] will copy the vector, but we wanted a reference
	\item[Line 6:] will only bind to modifiable lvalues
	\item[Line 7:] will bind to anything but make it const, giving us const\_iterator
	\item[Line 8:] will bind only to rvalues with const, It's not univerisal reference any more.
\end{description}
	\end{enumerate}

\item There are three function emplace, make\_shared and make\_unique. They use:
	\begin{enumerate}
		\item \textbf{variadic template}, because it need to receive \textbf{any number and any type} parameter.

		\item \textbf{universal reference}, because it's template, and I also want to keep rvalue semantic to improve effiencie. 
		
		\item \textbf{Forward}, because I want to forward parameter to corresponding ctor.Forward only used inside a wrapper, that is to say, to receive universal reference from template wrapper, and forward it to the specific function. The specific function has "COPY" semantic. 
	\end{enumerate}
\end{itemize}
\subsection{std::move and std::forward implementation}
\begin{itemize}
	\item Basic implementation of move
\begin{lstlisting}[numbers=none]
template<typename T> // in namespace std
typename remove_reference<T>::type&&
move(T&& param){
	using ReturnType = typename remove_reference<T>::type&&; // see Item 9
	return static_cast<ReturnType>(param);
}
\end{lstlisting}
	
	\item Basic implementation of forward
\begin{lstlisting}numbers=none]
template<typename T>
T&& forward(typename remove_reference<T>::type& param){
	return static_cast<T&&>(param);
}
\end{lstlisting}

	\item basic usage of forward is like this:
\begin{lstlisting}
template<class T>
void wrapper(T&& arg) {
	foo(std::forward<T>(arg)); 
}
\end{lstlisting}
\begin{description}
	\item[Line 2:] arg is always lvalue.
	\item[Line 3:] Forward as lvalue or as rvalue, depending on T.
	
	
\end{description}
	\begin{figure}
		\centering
		\includegraphics[width=0.8\linewidth]{pics/rvalue_ref.png}
		\caption{move and forward implementation}
		\label{fig:rvalueref}
	\end{figure}

	\item In forward function, why parameter is std::remove\_reference\_t<T>\& t?
\begin{lstlisting}[numbers=none]
void fun(int&& r){
	//int& r1 = r;  //OK
	int&& r1 = r;  //error: cannot bind 'int' lvalue to 'int&&'
	cout<<r1<<endl;
}

int r = 2;
fun(std::move(r));
\end{lstlisting}

\end{itemize}


\section{function interface-parameter}

\subsection{Generic function parameter design}
\begin{itemize}
\item Main content in this section illustrated below: 

	\begin{figure}[h]
	\centering
	\includegraphics[width=1.0\linewidth]{pics/move.png}
	\caption{move and forward implementation}
	\label{fig:rvalueref}
\end{figure}


\item  By now, you imagine you have a function with parameter, then you have three main operations inside to operate on the parameter: \textbf{1) only read 2) copy from the parameter 3) write to parameter.}

\item For only read, "const type\&" is the best, For write, "type\&" is good, because I don't need to write any new thing into prvalue. Based on previous explanation, below code will not compile. 
\begin{lstlisting}[numbers=none]
writeFun(Foo &);

writeFun(foo1+foo2) //ERROR
\end{lstlisting}

\item For only read build-in type, such as int, char, short, double.. You can use value directly, it has the same performance as reference. If you want to change it, you still need to use reference.

\item If the function read in some values and \textbf{build} other something based on the value which just read in. You need to consider the parameter design. When I say \textbf{build}, it could be:
\begin{enumerate}
	\item call ctor inside fun
	\item assign these values to other.
	\item put values to container.
\end{enumerate} 
\end{itemize}

\subsection{read-copy function parameter design}
\begin{itemize}

\item For read-copy, thing become interesting. Because the move ctor and move assignment operator give us an idea how to improve the function interface design.  For rvalue, we can move directly. Our goal is that we can use move for rvalue, so there are four options: 

	\begin{enumerate}
		\item overload fun to support const Foo\& and Foo \&\&.  
		\item Use pass-value fun(Foo)  
		\item Use pass-rvalue-reference fun(Foo\&\&)
		\item Use universal reference
	\end{enumerate}
	
\begin{tabular}{|c|c|c|}
\tophline
 & lvalue  & rvalue \\
\tophline
copyFun(Foo foo) & \specialcell[t]{copy parameter\\move inside} & \specialcell[t]{move parameter \\ move inside} \\
\tophline
copyFun(Foo \&)  & copy inside & (NOT support) \\
\tophline
copyFun(const Foo \&) & copy inside & copy inside \\
\tophline
copyFun(Foo \&\&)  & (NOT support) & move inside \\
\tophline
\specialcell[t]{template<T\&\&> \\
copyFun(T \&\&)}  & copy inside & move inside 
\bottomhline
\end{tabular}

\subsubsection{overload solution}

\item Use Overload function to deal with rvalue only. So usually function which accepts rvalue reference doesn't exist by itself, it just stay with another version to accept lvalue, fun(const Foo\& foo);
\begin{lstlisting}[frame=single, language=c++]
//rvalue reference
fun(Foo&& foo);
fun(foo1+foo2) 
fun(f_return_foo()); // call move ctor.
\end{lstlisting}
\begin{description}
	\item[Line 3:] will compile, It means that inside fun, you will steal resource. 
\end{description}

\subsubsection{only value solution}

\item There is such scenarios:
\begin{enumerate}
	\item You have origin obj, but in your function , you want to copy from it, then modify, at last return this copied one
	\item Obviously, in your function, you have to return value.
	\item At this time you have two different options. Value parameter or reference parameter.
\end{enumerate}

\begin{lstlisting}[frame=single, language=c++]
std::vector<std::string> 
sorted(std::vector<std::string> names){
	std::sort(names);
	return names;
}

std::vector<std::string> sorted_names1 = sorted( names );

std::vector<std::string> sorted_names2 = sorted( get_names() );
\end{lstlisting}
\begin{description}
	\item[Line 7:] names is an lvalue; a copy is required so we don't modify names
	\item[Line 9:] get\_names() is an rvalue expression; we can omit the copy!
\end{description}

\begin{lstlisting}[numbers=none]
std::vector<std::string> 
sorted2(std::vector<std::string> const& names) {
	std::vector<std::string> r(names);   // and explicitly copied
	std::sort(r);
	return r;
}
\end{lstlisting}

\item A basic explanation can be found here: \\
\includegraphics[scale=1.0]{pics/value1.png}
\item basic analysis:
\begin{enumerate}
	
	\item For method 3, When return, you can have RVO, no copy or move when we return. Only one copy inside the function.
	
	\item In method1, when return for lvalue, you have one move, It's bad and color is blue.
	
	\item In method1, for rvalue, although one more move, but It doesn't need a copy (Copy-elision at parameter, compared with method3 red part)
\end{enumerate}

\item summary:
\begin{enumerate}
	\item For c++03, we don't have move semantic, all the move will be decayed to copy. \textbf{So reference WIN!}
	
	\item For non-cheap-move, such as all primitive type included class, move is just like copy, \textbf{So reference WIN!}
	
	\item For c++11 and cheap-move semantic, \textbf{value WIN!}
	
	\item For = operator, we don't need return value, but return reference, In this way, \textbf{value WIN!}. Detail can be found in use swap to implement = operator below. 
	
\end{enumerate}


\item The same idea can be seen in the "more effective C++ item 41" 

\item You can apply this guideline immediately is in assignment operators. The canonical, easy-to-write, always-correct, strong-guarantee, copy-and-swap assignment operator is often seen written this way:
\begin{lstlisting}[frame=single, language=c++]
T& T::operator=(T const& x){ 
	T tmp(x);          
	swap(*this, tmp);  
	return *this;      
}

T& operator=(T x){ 
	swap(*this, x);
	return *this;   
}
\end{lstlisting}
\begin{description}
	\item[Line 2 to 4:] x is a reference to the source. copy construction of tmp does the hard work. trade our resources for tmp's. our (old) resources get destroyed with tmp 
	
	\item[Line 7 to 10:] A better one is below. x is a copy of the source;hard work already done. trade our resources for x's. our (old) resources get destroyed with x
\end{description}

\item Two good articles about this topic are:"Want Speed? Pass by Value." and "WANT SPEED? DON'T (ALWAYS) PASS BY VALUE."

\subsubsection{only rvalue  reference solution}
\item A more academic optoins is to just pass rvalue  reference to deal with lvalue and rvalue at the same time. This idea can be googled by "Pass By Rvalue Reference Or Pass By Value";
\begin{lstlisting}[frame=single, language=c++]
struct S{
    void initByRef(SomeType&& param);
};

SomeType t;
s.initByRef(std::move(t)); 
s.initByRef(SomeType()); 
\end{lstlisting}
\begin{description}
	\item[Line 6:] this works, and even better (less moves)
\end{description}

\item But for lvalue, you need a help function here.
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
T copy_to_temp(const T& t) { return t; }

SomeType t; 
s.initByRef(copy_to_temp(t)); 

s.initByVal(t); 
\end{lstlisting}
\begin{description}
	\item[Line 5:] I'll need t later, so cannot std::move(t), but can copy
	\item[Line 7:] note that here t is also copied, it just happens implicitly
\end{description}

\item the same idea can be applied to move-only types (such as unique\_ptr<T>)
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
T move_to_temp(T& t) { return std::move(t); }

void foo(unique_ptr<SomeType>&& param);

unique_ptr<SomeType> p;
foo(move_to_temp(p)); 
foo(std::move(p)); 
\end{lstlisting}
\begin{description}
	\item[Line 7:] note: this does move, p will become empty
	\item[Line 8:] here, p will not become empty. 
\end{description}


\item More interesting example:
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
T move_to_temp1(T& t) { return std::move(t); }

T&& move_to_temp2(T& t) { return std::move(t);}


void foo(unique_ptr<SomeType>&& param);

unique_ptr<SomeType> p;
foo(move_to_temp1(p));  //compile ok, return value is prvalue
foo(move_to_temp2(p));  //compile ok, return value is xvalue
\end{lstlisting}
\begin{description}
	\item[Line 2:] here move ctor is called when return to a value
	\item[Line 4:] here no move ctor is called, just reference value assignment.
\end{description}


\subsubsection{forwarding reference}

\item The last option is universial reference. At this time, you have to use std::forward 
\begin{lstlisting}[numbers=none]
template<typename T>
Fraction // by-value return
reduceAndCopy(T&& frac) // universal reference param
{
	frac.reduce();
	return std::forward<T>(frac); // move rvalue into return
} 
\end{lstlisting}

\end{itemize}

\section{funciton interface-return}
\begin{itemize}
	\item \textbf{These are two most important knowledge to understand all the detail below.}
	\begin{enumerate}
		\item For no RVO, there are two steps when we return value.
		\item For RVO, we implicit pass the result by reference.
	\end{enumerate}
	
	\item \textbf{Three basic knowledges about function return when no RVO:}
	\begin{enumerate}
		\item It's very important understand there are two phrases when you return from function. The first step  is from inside fun fauto to ouside of function ftemp(unname tempory), then fauto disappear(call destructor for value).  Then in second step, \textbf{Move} from ftemp to flast. because ftemp is rvalue.
\begin{lstlisting}[numbers=none]
Foo fun(){
	return fauto;
}
		
Foo flast = (ftemp created here)fun();
\end{lstlisting}
		\item ftemp is not on the stack, so you can use const ref or rref to prolong its life.
		
		\item ftemp is same with fauto, but maybe not same with flast
\begin{lstlisting}[frame=single, language=c++]
Foo fun(){
	return fauto;
}
		
const Foo& flast = (ftemp created here)fun();
Foo&& flast = fun();
\end{lstlisting}
\begin{description}
	\item[Line 6:] fun return Value, if run return reference, it's dangerous.
\end{description}

	\end{enumerate}
	
	\item The basic RVO is implemented by this way:
\begin{lstlisting}[numbers=none]
X bar(){
	X xx;
	return xx;
}
	
void bar(x &__result){
	__result.X::X() // default ctor call
	....
	return
}
\end{lstlisting}
	
\end{itemize}

\subsection{return plain reference} 
\begin{itemize}
	\item \textbf{Don't return reference or pointer to private member variables through you public member functions. It will break encapsulation. }
	
	\item Now talk about return reference: Never return reference which refers to local variable, it will cause dangling problem, So return plain reference only heppen:
	\begin{enumerate}
		\item You input a reference first, such as overload \verb=<<=.
		\item member function return some member data, such as copy ctor and overload \verb=[]= inside a class
	\end{enumerate}
	
	\item About return reference, by now, I only know three functions which return reference. = and << are for support cascading syntactic usage: such as cout<<a<<b, a=b=c.  [] is for support assignment obj[3]= 12.  That is all.
\begin{lstlisting}[numbers=none]
operator =
operator []
operator << and >>
\end{lstlisting}
	
	\item  When the client programmer does something like this and uses a reference beyond its lifetime, the bug will typically be intermittent and very difficult to diagnose. Indeed, one of the most common mistakes programmers make with the standard library is to use iterators after they are no longer valid, which is pretty much the same thing as using a reference beyond its lifetime
	
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
string& a = FindAddr( emps, "John Doe" );
emps.clear(); 
cout << a; 
\end{lstlisting}
\begin{description}
	\item[Line 2:] This statement will invalid a.
	\item[Line 3:] may or may not work, It's difficult to debug.
\end{description}
	
	\item If you want to return reference,  there is a defensible option that allows returning a reference and thus avoiding a temporary. But it's your last resort.
\begin{lstlisting}[numbers=none]
const string&
FindAddr( /* pass emps and name by reference */ ){
	for( /* ... */ ){
		if( i->name == name ){
			return i->addr;
		}
	}
	static const string empty;
	return empty;
	}
\end{lstlisting}
	
	\item Why \textbf{don't} we usually return plain reference?
	\begin{enumerate}
		\item You want to return a reference to avoid copy of auto obj inside of function, but in fact it's totally wrong. We have RVO and implicit std::move.

		\item If you return non-auto obj, You have to 1) new a obj, in this way, you can return pointer directly. 2) input a reference for read, in this way, you can input const reference, You don't need to return it at all. 3) input a reference for write, in this way, you don't need return it either, modification will act on inputted reference directly. So when do we use return plain reference?
	\end{enumerate}
	
\end{itemize}

\subsection{return rvalue reference}
\begin{itemize}
	\item \textbf{rvalue reference is also reference first, so if we have reason don't return reference from function, all these reason is also valid for rvalue reference.}
	
	\item The most common case for returning rvalue reference is std::move. It doesn't involve any move action inside the function, but is just a type cast operation.
	
	\item return rvalue reference 1:   If you want to return plain reference, or rvalue reference from a function, you have to input a plain reference or rvalue reference first, because you can't return any reference bound to local auto obj.
	
\begin{lstlisting}[numbers=none]
A&& rrfun1(A&& arg){
	return std::move(arg);
	//arg is lvalue, so use move
}
	
A&& rrfun2(A& arg){
	return std::move(arg);
}
	
A a;
A b= rrfun1(std::move(a) );
A b = rrfun2(a);
\end{lstlisting}
	
	
	\item return rvalue reference 2:   below code will call move ctor once.  1) move ctor from arg to ftemp, 2) rvalue reference b bound to ftemp(rvalue). Only reasonable in syntax, No any practical meaning, and \textbf{It's dangerous,because a has been empty.}.
\begin{lstlisting}[frame=single, language=c++]
A rrfun(A& arg){
	return std::move(arg);
}
	
A a;
A&& b = rrfun(a);
\end{lstlisting}
\begin{description}
	\item[Line 6:] after this a is invalid, and b refer a ftemp.
\end{description}
	

	\item return rvalue reference 3:   below code will not call move ctor at all. So you mean that I want to keep watch for a while, and obj a is still intact right now.
\begin{lstlisting}[numbers=none]
A&& rrfun(A& arg){
	return std::move(arg);
}
	
A a;
A&& b = rrfun(a);
\end{lstlisting}
	
	
	\item You can understand all these examples by three function knowledge when no RVO in the begining of this section. And all these exmaples are just have academic meaning, no any practial sense at all. Why?

	
	\item Why return value is better than return rvalue reference?
	\begin{enumerate}
		\item more clear semantic 
		\item when use with auto, it's support RVO.
	\end{enumerate}


	
	\item \textbf{In Summary 1, Three operator overload return plain reference, one std::move return rref. It doesn't involve value semantic, just a type change. All the others return value, That's all!}
	
	\item \textbf{In summary 2, If function return value, For only copy lvalue, return value; for rvalue reference, move;  For universal refence, forward. }
	
\begin{lstlisting}[numbers=none]
Matrix operator+Matrix& lhs, const Matrix& rhs) {
	return lhs
}
	
Matrix operator+(Matrix&& lhs, const Matrix& rhs) {
	return move(lhs)
}
	
template<type T>
T operator+(T&& lhs) {
	return forward<T>(lhs)
}
\end{lstlisting}
	
	\item The ref-qualifier \&\& says that the second function is invoked on rvalue temporaries, making the following move, instead of copy
	
\begin{lstlisting}[numbers=none]
struct Beta {
	Beta_ab ab;
	Beta_ab const& getAB() const& { return ab; }
	Beta_ab && getAB() && { return move(ab); }
	// return && is not Good interface design.
	
	Beta_ab ab = Beta().getAB();
	// It will call move version.
	//Beta_ab && ab = Beta().getAB(); ab is dangling rref
	
	2) Beta_ab getAB() && { return move(ab); }
	//Good interface design.
};
\end{lstlisting}

\item the same idea just like previous example, but this time I use auto.
\begin{lstlisting}[frame=single, language=c++]
DataType data() && { return std::move(values); } // why DataType?
auto values = makeWidget().data();

DataType && data() && { return std::move(values); }
auto&& values = makeWidget().data();
\end{lstlisting}
\begin{description}
	\item[Line 2:] with ROV, just move once. 
	\item[Line 5:] values will be dangling because makeWidget() return value disappear.
\end{description}

	\item about rvalue reference qualifier, please google "C++ Gems: ref-qualifiers"
	
	\item A few article you need to read later; \\
	1) Efficiency of C++11 push\_back() with std::move versus emplace\_back() for already constructed objects \\
	
	2) view the default functions generated by a compiler?\\
	
	3) One variable init form to rule them all, via mandatory elision.\\
	
	4) Episode Eleven: To Kill a Move Constructor\\
\end{itemize}

\subsection{return value-RVO}

\subsubsection{common RVO case}
\begin{itemize}
	\item RVO is a kind of copy elision. 
	\begin{enumerate}
		\item \textbf{it happens when you return value from a function.}
		\item The type of the \textbf{local} object is the same as that returned by the function.
		\item the local object is what's being returned.
		\item parameter is not eligible for RVO. 
	\end{enumerate}
	
	\item Three common cases are:
	\begin{enumerate}
		\item Name RVO, \texttt{t} has a name. It's called NRVO.
\begin{lstlisting}[numbers=none]
Thing f() {
	Thing t;
	return t;
}
Thing t2 = f();
\end{lstlisting}

		\item RVO, No name, just return temporary.
\begin{lstlisting}[numbers=none]
Thing f() {
	return Thing();
}
Thing t2 = f();
\end{lstlisting}

		\item temporary is passed by value
\begin{lstlisting}[numbers=none]
void foo(Thing t);

foo(Thing());
\end{lstlisting}

\item exception is thrown and caught by value
\begin{lstlisting}[numbers=none]
void foo() {
	Thing c;
	throw c;
}

int main() {
	try {
		foo();
	}
	catch(Thing c) {  
	}             
}
\end{lstlisting}

	\end{enumerate}

\end{itemize}

\subsubsection{RVO limitations}
\begin{itemize}
	\item Different named object sample will not trigger RVO
\begin{lstlisting}[numbers=none]
RVO MyMethod (int i){
	RVO rvo;
	rvo.mem_var = i;
	if (rvo.mem_var == 10)
		return RVO();
	return rvo; 
}
\end{lstlisting}
	
	\item returning a parameter or Global
\begin{lstlisting}[numbers=none]
Snitch global_snitch;

Snitch ReturnParameter(Snitch snitch) {
	return snitch; //no RVO here
}

Snitch ReturnGlobal() {
	return global_snitch; //no RVO here either
}
\end{lstlisting}

\item return by std::move()
\begin{lstlisting}[numbers=none]
Snitch CreateSnitch() {
	Snitch snitch;
	return std::move(snitch);
}
\end{lstlisting}
	
\item In some cases even an unnamed variable can't RVO:
\begin{lstlisting}[numbers=none]
struct Wrapper {
	Snitch snitch;
};

Snitch foo() {
	return Wrapper().snitch;
}

int main() {
	Snitch s = foo();
}
\end{lstlisting}

\end{itemize}
\subsubsection{Some practical demos ans analysis}
\begin{itemize}
	
	\item given below code as experiment code:
\begin{lstlisting}[frame=single, language=c++]
class Snitch {   // Note: All methods have side effects
	Snitch() { cout << "c'tor" << endl; }
	~Snitch() { cout << "d'tor" << endl; }
	
	Snitch(const Snitch&) { cout << "copy c'tor" << endl; }
	Snitch(Snitch&&) { cout << "move c'tor" << endl; }
	
	Snitch& operator=(const Snitch&) {
		cout << "copy assignment" << endl;
		return *this;
	}
	
	Snitch& operator=(Snitch&&) {
		cout << "move assignment" << endl;
		return *this;
	}
};
	
Snitch CreateSnitch() {
	return Snitch();
}
	\end{lstlisting}
	
	\item test 1 and output 
\begin{lstlisting}[frame=single, language=c++]
int main() {
	Snitch s = CreateSnitch();
}
\end{lstlisting}
\begin{description}
	\item[Output:] The compiler switch and its output:
	\begin{verbatim}
		with -fno-elide-constructors
		c'tor    //Snitch()
		move c'tor  //Snitch() to return value
		d'tor       //Snitch() destory
		move c'tor //return value to s
		d'tor     //return value destory
		d'tor     //s destory
	------------------------------
		without -fno-elide-constructors
		c'tor   //s
		d'tor   //s destory
	\end{verbatim}
\end{description}
	
	\item test 2 and output
	\begin{lstlisting}[frame=single, language=c++]
int main() {
	Snitch s;
	s = CreateSnitch();
}
	\end{lstlisting}
\begin{description}
	\item[Output:] The compiler switch and its output:
	\begin{verbatim}
		with -fno-elide-constructors
		c'tor    //Snitch s
		c'tor    //Snitch() in side CreateSnitch
		move c'tor  //Snitch() to return value
		d'tor       //Snitch() destory
		move assignment //return value to s
		d'tor     //return value destory
		d'tor     //s destory
	----------------------	
		without -fno-elide-constructors
		c'tor   //Snitch s
		c'tor   //Snitch()
		move assignment //s has been implicit passed to CreateSnitch, 
		//so s = Snitch() happen inside CreateSnitch
		d'tor   //Snitch() destory
		d'tor   //s destory
	\end{verbatim}
\end{description}

	\item test 3 and output
\begin{lstlisting}[frame=single, language=c++]
Snitch CreateSnitch() {
	return Snitch();
}
	
Snitch CSnitch(Snitch&& rs) {
	return rs;
}
	
int main() {
	Snitch s = CSnitch(CreateSnitch());
}
\end{lstlisting}
\begin{description}
	\item[Output:] The compiler switch and its output:
	\begin{verbatim}
		with -fno-elide-constructors
		c'tor    //
		copy c'tor    //
		d'tor       /
		copy c'tor    //
		copy c'tor    //
		d'tor       /
		d'tor     //r
		d'tor     //
	-------------------------
		without -fno-elide-constructors
		c'tor   //Snitch s
		copy c'tor //
		d'tor   //Snitch() destory
		d'tor   //s destory
	\end{verbatim}
\end{description}
\end{itemize}


\subsubsection{RVO and move}
\begin{itemize}
	\item For local variable, don't use move. compiler will use RVO , so It has already had high efficiency.
	
\begin{lstlisting}[numbers=none]
Foo fun(){
	Foo foo;
	return foo; //Don't use move here.
}
\end{lstlisting}
	
	\item A common error is when there is no RVO, use std::move to avoid copy: but Although parameter is not eligbile for RVO, or different path is not eligible, but you don't need to explicit use std::move, the compiler will use them implicitly.
	
\begin{lstlisting}
Widget makeW(Widget w){
	.....
	return w
	//return std::move(w) 
} 
\end{lstlisting}
\begin{description}
	\item[Line 4:] don't write it, compiler will do it for you.
\end{description}
	
	\item If a function is value return, and you want to return a rvalue reference parameter, you have to use move in the return.
	\begin{enumerate}
		\item \textbf{lhs is not local object, but reference, so No RVO}
		\item you may say: but lhs is rvalue reference, but lhs is name rvalue reference. It's lvalue.
		
		\item Just like you pass a lvalue reference, you can't move it unless you want to do it explicitly. That is why we need std::move here.
	\end{enumerate}
\begin{lstlisting}[frame=single, language=c++]
Matrix operator+(Matrix&& lhs, const Matrix& rhs){
	lhs += rhs;
	return std::move(lhs); 
	//return lhs 
} 
\end{lstlisting}
\begin{description}
	\item[Line 1:] by-value return , by rvalue parameter.
	\item[Line 3:] move lhs into return value.
	\item[line 4:] will copy lhs into return value.
\end{description}

\subsubsection{RVO summary}

\item \textbf{First use RVO, then compiler implicit use std::move, the last one is use std::move explicitly.}

\begin{enumerate}
\item Apply std::move to rvalue references and std::forward to universal references
the last time each is used.

\item Never apply std::move or std::forward to local objects if they would otherwise
be eligible for the return value optimization.
\end{enumerate}


\end{itemize}


\chapter{OOP}
\section{Object based}

\subsection{class categories}
\begin{itemize}
	\item Basic class categories:
	\begin{enumerate}
		\item Value class, such as std::pair, std::vector, std::string.
		\begin{enumerate}
			\item Has a public destructor, copy ctor and assignment with value semantics
			\item Has no virtual function. so intended to be used as a concrete class, not as a base class.
			\item instantiated on stack or as a member of an other class.
		\end{enumerate}
		
		\item Base class.
		\begin{enumerate}
			\item Has a destructor that is public and virtual, But for some trait class, destructor can be protected, such as std::unary\_function
			\item Establish interface.
			\item Usually instantiated on heap, and used via a (smart) pointer or reference to support polymorphism.
		\end{enumerate}
		
		\item Trait class.
		\begin{enumerate}
			\item Contain only typedef and static functions, It has no modifiable state.
			\item Is not instantiated( ctor is private or disable)
			\item Usually instantiated on heap, and used via a (smart) pointer.
		\end{enumerate}
	\end{enumerate}
	
	\item Policies are classes (or class templates) to \textbf{inject behavior} into a parent class, typically through inheritance. Through decomposing a parent interface into orthogonal (independent) dimensions, policy classes form the building blocks of more complex interfaces. An often seen pattern is to supply policies as user-definable template (or template-template) parameters with a library-supplied default. An example from the Standard Library are the Allocators, which are policy template parameters of all STL containers
\begin{lstlisting}[numbers=none]
template<class T,class Allocator=std::allocator<T> > class vector;
\end{lstlisting}
	
	\item Traits are class templates to \textbf{extract properties} from a generic type. There are two kind of traits: single-valued traits and multiple-valued traits. Examples of single-valued traits are the ones from the header <type\_traits>. Single-valued traits are often used in template-metaprogramming and SFINAE tricks to overload a function template based on a type condition.
	\begin{lstlisting}[numbers=none]
template< class T >
struct is_integral{
	static const bool value
	/* = true if T is integral, false otherwise */;
	typedef std::integral_constant<bool, value> type;
};
	
template <class T>
T f(T i){
	static_assert(
		std::is_integral<T>::value, "Int required.");
	return i;
}

int main() {
	std::cout << f(123) << '\n'; //output 123
}
\end{lstlisting}
\end{itemize}


\subsection{Interface}
\begin{itemize}
	
	\item Nesting a class does not create a class member of another class. Instead, it defines a type that is known just locally to the class that contains the nested class declaration.  A good example is Class queue nest class node,  because node is just used inside the class Queue. Another good example is vector and it's iterator.
	
	\item Virtual function must be member, operator\verb=>>= and \verb=<<= are never be members, or It maybe be a friend. Only non-member functions get type conversions on their left-most argument.  In the previous example, If you want to use support 2* obj, You need make operator * to be non member function.  Detail can be seen in effective c++.
	
	\item Keep in mind that only a class declaration can decide which functions are friends, so the class declaration still controls which functions access private data.
	
	\item Protect keyword don't use very often, it is just used in inheritance context. Child class can access base class protected member. you should use private keyword first if you real want to have good \textbf{Encapsulation} and \textbf{Never return reference or pointer to a private or protected member data.}
	
	\item In C++ primer p653, you can see a good example class interface. You should remember it as a basic pattern.  If you use new allocate memory inside of your class, you should define: copy ctor, assignment operator and destructor, move copy ctor, and move assignment.
	
\begin{lstlisting}[frame=single, language=c++]
//below is string.h file
#pragma once
namespace Yan{
	class String{
	public:
		String();  //default constructor
		String(const char *a ); // specify constructor
		
		String (const String &);  //copy ctor
		String (String && other); //move copy ctor
		
		String& operator=(const String &); //assignment
		String& operator=(String&& other); //move assignment
		String& operator=(const char*a); // option.
		
		~String();  
		
		friend ostream& operator<<(ostream & os, const String & st);
		friend istream& operator>>(istream & is, String &st);
		
	private:
		const static int NUM= 1000; // const used inside of this class.
		char* m_str;
		
	};
	ostream& operator<<(ostream & os, const String & st);
	istream& operator>>(istream & is, String &st);
}
\end{lstlisting}
	
	\begin{enumerate}
		\item From Line 1 to Line 16: usually, you should have these Seven member. functions if you use new inside your class.
		\item Put class definition into a namespace.
		\item Use \#pragma once
		\item You need to declare operator \verb=<<= inside of namespace outside of class
		\item If you don't use smart pointer and allocate use \texttt{new operator}. you should follow five rules.( including move ctor and move assignment) if you class includes a resource.
		\item Member function can access all the instance private data, such as other.m\_str, and no semicolon after each function.
	\end{enumerate}
	
	
\begin{lstlisting}[numbers=none]
String s;
s = "aaa"  //two actions
String s("aaa");   //one actions
String s{"aaa"};  // new feature in c++11
String s={"aaa"}; // same as previous one
	
String str; char temp[40];
str= temp // make it more efficient
\end{lstlisting}
	
	\item String\& operator=(const char*a); is an option, why it make str=temp more efficient, see C++ Primer P652
	
	\item  Friend has three categories:
	\begin{enumerate}
		\item Friend Class: just as TV and RemoteControl, you can declare RemoteControl a friend class inside TV.
		\item Friend Member functions: You can select some member functions to be friend of another class, In this way, you need forward declaration.  When you write class TV;  It doesn't define a TV class, it just tell compile, TV is a class, definition can be done later.
		\item Common Friend method, a good example is overload \verb=operator <<=
	\end{enumerate}
	
	\item Prefer minimal classes to monolithic classes: big class is difficult to reach error-safe because it tackle multiple responsibilities. It's also difficult maintain, understand and deploy.
\begin{lstlisting}[numbers=none]
Class Matrix{
	//100 member function.
} ; //bad design.
	
//Good design with small class with
	nonmember function.
namespace MAT{
	Class Matrix{
	//core data and member function
	}
	
	Cal1(Matrix &);
	Cal2(Matrix m1, Matrix m2)
	......
}
\end{lstlisting}

	\item Interface Principle: For a class X, all functions, including free functions, that both:
	\begin{enumerate}
		\item "Mention" X.
		\item Are "supplied with" X
	\end{enumerate}
	are logically part of X, because they form part of the interface of X.  In this definition, 1) Cal1 Mention X,  and 2) Cal1 in the namespace MAT, so caller can use ADL(argument depend lookup) loop Cal1 in namespace MAT, so \textbf{Cal1 is an interface of class Matrix, even it's not a member function of it.} Detail can be see in "exceptional C++ item31 to item34.
	
	\item Prefer writing nonmember nonfriend functions
	\begin{enumerate}
		\item operator =, ->, [], () must be members
		\item needs a different type as its left-hand arguent, such as operator <<, use nonmember
		\item leftmost argument needs type conversion, use non-member
		\item can be implement using the class public interface alone, use nonmember.
	\end{enumerate}
	
\end{itemize}



\section{member function}

\subsection{Special member functions relationship}

\subsubsection{Basic}

\begin{itemize}

\item When you write an empty class, compiler will produce at least six member functions.  New compiler will produce move ctor and move assignment too.
\begin{lstlisting}[numbers=none]
class Empty{};

Empty();
Empty(const Empty& rhs);
Empty& oprator=(const empty & rhs);
Empty* operator&(){return this};
const Empty* operator&() const ;
~Empty();
\end{lstlisting}

\item Why you need to pay attention to these special member functions?  Given half a chance, the compiler will write them for you. Another reason is that C++ by default treats classes as value-like types, but not all types are value-like. Know when to write and disable them make you get correct code.

\item A good reference is "Everything You ever wanted to know about move semantics" in slideshare.net.

\item For these special member functions, main operations can be:
\begin{enumerate}
\item Compiler implicitly declare one
\item Use explicitly declare one
\item Once you define one, Compiler maybe Not declare another
\item You can ask compiler declare one
\item You can ask compiler delete one.
\end{enumerate}

\item First question is what "declare" mean?  \\
\includegraphics[scale=0.6]{pics/sm1.png} \newline

\item If you just define a class without any special member function, all six member function will be declared by compiler implicitly. \\
\includegraphics[scale=0.6]{pics/sm2.png} \newline


\item Default can mean "deleted", See an example below:

\begin{lstlisting}[frame=single, language=c++]
class A{
	A() = delete;
};

class B{
	A a;
};

int main(){
	B b;
}
\end{lstlisting}
\begin{description}
	\item[Output:] main.cpp:16:7: note: 'B::B()' is implicitly deleted because the default definition would be ill-formed:
\end{description}

\item Why defaulted move member sometimes "deleted"? Detail can be found in "CWG 1402 is (imho) the most important bug fix to C++11". Another good article is google "Why is the move constructor neither declared nor deleted with clang? " In clang, it support C++11 standard better. 

\item \textbf{There are two differences:}
\begin{enumerate}
	\item user define empty and declared default
	\item not declare and declare delete
\end{enumerate}


\includegraphics[scale=0.8]{pics/ctor.png} \newline



\item Next question is what differences are between \verb|=default| and user define empty ctor? problems of below code snippet are:
\begin{lstlisting}[numbers=none]
struct noncopyable  {
	noncopyable() {};
private:
	noncopyable(const noncopyable&);
	noncopyable& operator=(const noncopyable&);
};
\end{lstlisting}
\begin{enumerate}
	\item The copy constructor has to be declared privately to hide it, but because it's declared at all, automatic generation of the default constructor is prevented. You have to explicitly define the default constructor if you want one, even if it does nothing.

	\item Even if the explicitly-defined default constructor does nothing, it's considered non-trivial by the compiler. \textbf{It's less efficient than an automatically generated default constructor and prevents noncopyable from being a true POD type.}

	\item Even though the copy constructor and copy-assignment operator are hidden from outside code, the member functions and friends of noncopyable can still see and call them. If they are declared but not defined, calling them causes a linker error.

	\item Although this is a commonly accepted idiom, the intent is not clear unless you understand all of the rules for automatic generation of the special member functions.
\end{enumerate}


\item C++11 new keyword default and delete give below advantages:
\begin{lstlisting}[numbers=none]
struct noncopyable  {
  noncopyable() =default;
  noncopyable(const noncopyable&) =delete;
  noncopyable& operator=(const noncopyable&) =delete;
};
\end{lstlisting}

\begin{enumerate}
	\item Generation of the default constructor is still prevented by declaring the copy constructor, but you can bring it back by explicitly defaulting it.

	\item Explicitly defaulted special member functions are still considered trivial, so there is no performance penalty, and noncopyable is not prevented from being a true POD type.

	\item The copy constructor and copy-assignment operator are public but deleted. It is a compile-time error to define or call a deleted function.

	\item The intent is clear to anyone who understands =default and =delete. You don't have to understand the rules for automatic generation of special member functions.
\end{enumerate}

	\item Another question is what differences are between =delete and "not declare"
\\
\includegraphics[scale=0.6]{pics/sm5.png} \newline

\end{itemize}

\subsubsection{Rules of implicitly declare }
\begin{itemize}
	\item The Default ctor, will not be implicitly generated if:
	
\begin{enumerate}
	\item you have explicitly declared any constructor.  Compiler doesn't create a default constructor if we write any constructor even if it is copy constructor.

	\item There is a member in your class that is not default-constructible (such as a reference, a const object, or a class with no or inaccessible default constructor)

	\item (C++11) you have explicitly told the compiler to not generate one using A() = delete;
\end{enumerate}

\item The copy ctor, will not be implicitly generated if:
\begin{enumerate}
	\item you have explicitly declared a copy constructor (for class X a constructor taking X, X\& or const X\&)
	
	\item there is a member in your class that is not copy-constructible (such as a class with no or inaccessible copy constructor)
	
	\item (C++11) you have explicitly told the compiler to not generate one using A(const A\&) = delete;
\end{enumerate}


\item The Copy Assignment Operator will not be implicitly generated if
\begin{enumerate}
\item you have explicitly declared a copy-assignment operator (for class X an operator = taking X, X\& or const X\&) )
\item there is a member in your class that is not assignable (such as a reference, a const object or a class with no or inaccessible assignment operator)
\item (C++11) you have explicitly told the compiler to not generate one using A\& operator=(const A\&) = delete;
\end{enumerate}


\item The Destructor will not be implicitly generated if
\begin{enumerate}
\item you have explicitly declared a destructor
\item (C++11) you have explicitly told the compiler to not generate one using ~A() = delete;
\end{enumerate}

\item The Move Constructor or Move Operator(C++11) will not be implicitly generated if
\begin{enumerate}
\item you have explicitly declared a move constructor or move assignment(for class X, a constructor taking X\&\&)
\item there is a member in your class that cannot be moved (have deleted, inaccessible, or ambiguous)
\item you have defined a copy assignment operator, copy constructor, destructor, or move assignment operator
\item you have explicitly told the compiler to not generate one using A(A\&\&) = delete;
\end{enumerate}


\item The Move Assignment Operator (C++11) will not be implicitly generated if
\begin{enumerate}
\item you have explicitly declared a move assignment operator (for class X, an operator = taking X\&\&)
\item you have defined a copy assignment operator, copy constructor, destructor, or move constructor
\item you have explicitly told the compiler to not generate one using A\& operator=(A\&\&) = delete;
\end{enumerate}

\item  The justification is that declaring a copy operation (construction or assignment) indicates that the normal approach to copying an object(memberwise copy) isn't appropriate for the class, and compilers figure that if memberwise copy isn't appropriate for the copy operations, memberwise move probably isn't appropriate for the move operations either.

\item The same idea as the previous item, declaring a move operation (construction or assignment) in a class causes compilers to disable the copy operations.

\item The two copy operations are independent: declaring one doesn't prevent compilers
from generating the other. The two move operations are not independent. If you declare either, that prevents compilers from generating the other.

\item C++11 deprecates the automatic generation of copy operations for classes declaring
copy operations or a destructor. This means that if you have code that depends on
the generation of copy operations in classes declaring a destructor or one of the copy
operations, you should consider upgrading these classes to eliminate the dependence.
Provided the behavior of the compiler-generated functions is correct (i.e, if memberwise
copying of the class's non-static data members is what you want), your job is
easy, because C++11's "= default" lets you say that explicitly:

\item If you declared a destructor, implicitly defaulted copy member are deprecated.  \\
\includegraphics[scale=0.6]{pics/sm4.png} \newline


\item A summary can be seen blow \\
\includegraphics[scale=0.6]{pics/sm3.png} \newline

\end{itemize}

\subsubsection{initializer list}
\begin{itemize}
\item \textbf{Always use initializer list instead of assignment inside ctor.}

\item When to use member initalize list?
\begin{enumerate}
\item to non-static const data members.
\item reference member
\item  member objects which do not have default constructor: (why I need default ctor can be explained here too)
\item need pass argument to base class ctor
\begin{lstlisting}[numbers=none]
class A {
    int i;
public:
    A(int );
};

class B: A {
public:
    B(int );
};

B::B(int x):A(x) { //Initializer list must be used
    cout << "B's Constructor called";
}
\end{lstlisting}

\item need to by copy between obj to member obj. (only one copy ctor, more efficient! see below source code.)
\end{enumerate}

\begin{verbatim}
http://www.geeksforgeeks.org/when-do-we-use-initializer-list-in-c/
\end{verbatim}

\begin{lstlisting}[frame=single, language=c++]
//method 1:
class(string &a, string &b): m_a(a),m_b(b){}

//method 2:
class(string &a, string &b){   
	m_a = a;  
	m_b = b; 
}
\end{lstlisting}
\begin{description}
	\item[Line 2:] just call string copy ctor, so you don't need string default ctor.
	\item[Line 5:] two action. call default constructor to build m\_a. then call assignment operator.
\end{description}

\item List member in a initialization list in the order in which they are declared in class. see effective c++ item 13. Order is important.

\item Member variables are always initialized in the order they are declared in the class definition. The order in which you write them in the ctor initialization list is ignored.  \textbf{So you'd better not have one member's initialization depend on other members}.
\begin{lstlisting}[numbers=none]
class Student{
	string m_email;  //m_email will be init first, ingore order
	string m_first_name;  // in the ctor initialization list.
	Student(first_name) :m_first_name(first_name),
                m_email(m_first_anme+"@gmail"){}
\end{lstlisting}


\item If GetType() is a static member function, or a member function that does not use its this pointer (that is, uses no member data) and does not rely on any side effects of construction (for example, static usage counts), then this is merely poor style, but it will run correctly. Otherwise (mainly, if GetType() is a normal nonstatic member function), we have a problem.
\textbf{Nonvirtual base classes are initialized in left-to-right order as they are declared}, so ArrayBase
is initialized before Container. Unfortunately, that means we're trying to use a member of the
not-yet-initialized Container base subobject.

\begin{lstlisting}[numbers=none]
template<class T>
class Array : private ArrayBase, public Container

typedef Array AIType;
public:
	Array( size_t startingSize = 10 ): Container( startingSize ), 
	          ArrayBase( Container::GetType() ),
\end{lstlisting}

\end{itemize}

\subsection{Basic pattern}
\subsubsection{constructor and destructor}
\begin{itemize}

	\item Normally, ctor , destructor and assignment should be public. \textbf{In inheritance context, all the base class desctructor should be virtual. }
	
	\item A constructor shall not be virtual or static. If you need something like this, you can look up the virtual constructor idiom. This idiom uses virtual clone() member function (for copy constructing), or a virtual create() member function (for the default constructor).
	
\begin{lstlisting}
class Shape {
public:
	virtual ~Shape() { }                 
	virtual void draw() = 0;           
	virtual void move() = 0;
	// ...
	virtual Shape* clone()  const = 0;   
	virtual Shape* create() const = 0; 
};

class Circle : public Shape {
public:
	Circle* clone()  const;  
	Circle* create() const;   
};
Circle* Circle::clone()  const{
	 return new Circle(*this); }
	 
Circle* Circle::create() const{
	 return new Circle();      }

Shape* s2 = s.clone();
Shape* s3 = s.create();

delete s2;    // You need a virtual destructor here
delete s3;
\end{lstlisting}
\begin{description}
	\item[Line 13 and 15:] Covariant Return Types; 
\end{description}
	
	\item Avoid calling virtual functions in ctor and dtor. Detail can be found in "C++ Coding Standards" item 49.
	
	\item \textbf{If you define a specific ctor, you also need to define default ctor.} Because system will not produce any default ctor for you. So below statement will produce error when compiling.
\begin{lstlisting}[numbers=none]
class obj; //error
class* obj = new class(); //error
class arra[10] //error
template<class T>
class Array{
	T t;
};
	
Array<class> a; //error
	\end{lstlisting}
	
	\item If no special demand, you can declare you own default ctor and use system implicit generated one. you can use keyword default
\begin{lstlisting}[frame=single, language=c++]
class Empty{
	Empty() = default;
	Empty(int i) ;
}
\end{lstlisting}
\begin{description}
	\item[Line 2:] you don't need to give implementation of default ctor.
\end{description}
	
	\item Make Constructors Protected to prohibit direct Instantiation. Make constructors Private to prohibit Derivation.
	
	\item Use default arguments to reduce the number of ctor.
\begin{lstlisting}[numbers=none]
class Brush{
	Brush();
	Brush(Color c);
	Brush(Texture t);
	Brush(Color c= Black,Texture t=Solid); //better
}
\end{lstlisting}
	
	
	\item From previous example, you can see that default ctor is very important. but when class MUST need another information when create, such as  worker class, You must provide SSN when you create a worker.At this time, if you create default ctor, It's not good idea. A NULL SSN will cause a lot of trouble in the future.  So you have to use Worker pointer, and vector<Worker>.  You also need to use delete to disable default ctor. That is C++ spirit, \textbf{You never have the best answer, only have context answer. }
\begin{lstlisting}[numbers=none]
class Worker{
	char* SSN;
	Worker(const char*);
	Worker(){SSN=nullptr); //bad smell.
}
\end{lstlisting}
	
	\item Normally you will have to explicitly declare your own destructor if:
	\begin{enumerate}
		\item You are declaring a class which is supposed to serve as a base for inheritance involving polymorphism, if you do you'll need a virtual destructor to make sure that the destructor of a Derived class is called upon destroying it through a pointer/reference to Base.
		
		\item You need to release resourced required by the class during its lifetime:
		\begin{enumerate}
			\item Example 1: The class has a handle of a file, this needs to be closed when the object destructs; the destructor is the perfect location.
			
			\item Exempel 2: The class owns an object with dynamic-storage duration, since the lifetime of the object can potentially live on long after the class instance has been destroyed you'll need to explicitly destroy it in the destructor.
		\end{enumerate}
	\end{enumerate}
	
	
	\item A copy constructor is called whenever a new variable is created from an object. This happens:
	
	\begin{enumerate}
		\item When a new object is initialized to an object of the same class.
		\item When an object is passed to a functon by value.
		\item When a function returns an object by value.
		\item When the compiler generates a temporary object.
	\end{enumerate}
	
	\item In previous example, you can see when you pass value of obj, It will call copy ctor, It's not very efficient. So you should use reference or pointer if it's possible, don't pass object directly.
	
	
	\item An Assignment operator examples: \textbf{1) avoid assignment self 2) return *this reference. }
\begin{lstlisting}[numbers=none]
class & class::operator=(class &a){
	if(this == &a)
		return *this;  //avoid assign by himself
	.............  // assignment operation here.
	return *this ; // return *this reference.
}
\end{lstlisting}
	
	\item For reference, once assigned, a reference cannot be re-assigned. So if a class has a reference member, It can be initialized by initializer list in ctor and copy ctor. \textbf{But you can't overload assignment operator any more, If you really need assignment operator, change reference to pointer}
\end{itemize}


\subsubsection{copy and swap idiom}
\begin{itemize}
	\item Any class that manages a resource (a wrapper, like a smart pointer) needs to implement The Big Three. While the goals and implementation of the copy-constructor and destructor are straightforward, the copy-assignment operator is arguably the most nuanced and difficult. How should it be done? What pitfalls need to be avoided?
	
	\item Conceptually, it works by using the copy-constructor's functionality to create a local copy of the data, then takes the copied data with a swap function, swapping the old data with the new data. The temporary copy then destructs, taking the old data with it. We are left with a copy of the new data.
	
	\item The copy-and-swap idiom is the solution, and elegantly assists the assignment operator in achieving two things: avoiding code duplication, and providing a strong exception guarantee.
	
	\item In order to use the copy-and-swap idiom, we need three things: a working copy-constructor, a working destructor (both are the basis of any wrapper, so should be complete anyway), and a swap function.
	
	\item We first notice an important choice: the parameter argument is taken by-value. While one could just as easily do the following (and indeed, many naive implementations of the idiom do): Not only that, but this choice is critical in C++11, which is discussed later. On a general note, a remarkably useful guideline is as follows: if you're going to make a copy of something in a function, let the compiler do it in the parameter list.
	
\begin{lstlisting}[numbers=none]
dumb_array& operator=(const dumb_array& other){
	dumb_array temp(other);//low effeicient,only copy.
	swap(*this, temp);
	return *this;
}
\end{lstlisting}

\item A simple example code:
\begin{lstlisting}[numbers=none]
class dumb_array{
	dumb_array(const dumb_array& other)
		: mSize(other.mSize),
			mArray(mSize ? new int[mSize] : nullptr){
	std::copy(other.mArray, other.mArray + mSize, mArray);
	}
	dumb_array& operator=(dumb_array other){
		swap(*this, other); 
		return *this;
	}

private:
	std::size_t mSize;
	int* mArray;
};

friend void swap(dumb_array& first, dumb_array& second) {
	using std::swap;
	swap(first.mSize, second.mSize);
	swap(first.mArray, second.mArray);
}

\end{lstlisting}
\end{itemize}
	
\subsubsection{Big zero, three and five}
\begin{itemize}
	\item The Rule of the Big Three states that if you have implemented either
	\begin{enumerate}
		\item A destructor
		\item An assignment operator
		\item A copy constructor
	\end{enumerate}
	You should also implement the other two. To implement the Copy-Swap idiom your resource management class must also implement a swap() function to perform a member-by-member swap.\textbf{That is called Rule of big three and half.}
	
	\item Big Five is just like big three, but add move copy ctor and move assignment operator.
	
	\item The Rule of The Big Four (and a half) states that if you implement one of
	\begin{enumerate}
		\item The copy constructor
		\item The assignment operator.\textbf{Don't need move assignment, in assignment operator, we pass only one kind of type--value.} 
		\item The move constructor
		\item The destructor
		\item The swap function(that is half)
	\end{enumerate}
	then you must have a policy about the others.
\begin{lstlisting}[numbers=none]
S(S&& s) : S{} { swap(*this, s); }

S& operator=(S s) { swap(*this, s); }
\end{lstlisting}

	\item "The Rule of The Big Four (and a half)" says if you've written one of the above functions then you must have a policy about the others. It doesn't say you have to write them. In fact, you have to have a resource management policy for every class you create. Your policy can be one of the following:
	\begin{enumerate}
		\item Use the compiler-provided versions of these functions. In other words, you're not doing any resource management in the class.
		
		\item Write your own copy functions to perform deep copy, but don't provide move semantics.(low efficiency)
		
		\item Write your own move functions, but don't support copying.(std::unique\_ptr)
		
		\item Disable copying and move semantics for the class, because it doesn't make sense to allow it.
	\end{enumerate}

	\item Value-like types, such as int or vector<widget>. These represent values, and should naturally be copyable. In C++11, generally you should think of move as an optimization of copy, and so all copyable types should naturally be moveable... moving is just an efficient way of doing a copy in the often-common case that you don't need the original object any more and are just going to destroy it anyway.
	
	\item Reference-like types that exist in inheritance hierarchies, such as base classes and classes with virtual or protected member functions. These are normally held by pointer or reference, often a base* or base\&, and so do not provide copy construction to avoid slicing; if you do want to get another object just like an existing one, you usually call a virtual function like clone. These do not need move construction or assignment for two reasons: They're not copyable, and they already have an even more efficient natural "move" operation -- you just copy/move the pointer to the object and the object itself doesn't have to move to a new memory location at all.
	
	\item Most types fall into one of those two categories, but there are other kinds of types too that are also useful, just rarer. In particular here, types that express unique ownership of a resource, such as std::unique\_ptr, are naturally move-only types, because they are not value-like (it doesn't make sense to copy them) but you do use them directly (not always by pointer or reference) and so want to move objects of this type around from one place to another.
	
	\item What does a typical user defined move constructor do?
\begin{lstlisting}[numbers=none]
class x : public Base{
	Member m_;
	X(X&& x): Base(std::move(x)), m_(std::move(x.m_)){
		x.set_to_resourceless_state();
	}
}
	\end{lstlisting}
	
	\item What does a defaulted move assignment do?
	\begin{lstlisting}[numbers=none]
class x : public Base{
	Member m_;
	X& operator=(X&& x) {
		Base::operator=(static_cast<Base&&>(x));
		m_ = static_cast<Member&&>(x.m_);
		return *this;
	}
}
\end{lstlisting}
	
	
	\item Assuming the only non-static data in the class is a std::string, here's the conventional way (i.e., using std::move) to implement the move constructor:
\begin{lstlisting}[numbers=none]
class Widget {
	Widget(Widget&& rhs)
	: s(std::move(rhs.s)){ ++moveCtorCalls; }
private:
	static std::size_t moveCtorCalls;
	std::string s;
};
\end{lstlisting}
\end{itemize}


\subsection{operator overload}
\begin{itemize}
	\item \textbf{Never overload \&\&, || and comma in C++.  Just remember it!}
	
	\item \textbf{You can declare operator as member function. if it's not member function, declare it as a friend function.}
	
		\item If you want to overload + operator, and support time t; 3+t;   You need to define a friend function. In order to improve a t+3 efficiency, you also can define a member function time operator+(int i) member function.
\begin{lstlisting}[frame=single, language=c++]
time operator+(const time &t) const;

friend time operator+(int,  const time &t)

time operator+(int i)
\end{lstlisting}
\begin{description}
	\item[Line 1:] member function. for t = t1+t2
	\item[Line 3:] nonmember friend function. for 3+t
	\item[Line 5:] member function, for t+3, to avoid implicit conversion from 3 to obj.
\end{description}
	
	\item \textbf{For Binary Arithmetic Operators + - *, implement Compound Assignment Operators += -= *= first, then use these Compound Assignment operators}
	
	\item \textbf{Use += implememnt operator +}. It's very good design. It provides two advantages. 1) give another function, 2) avoid code duplication. 
	
	\item Compound assignment operators should be overloaded as member functions, as they change the left-hand operand. Like all other operators (except basic assignment), compound assignment operators must be explicitly defined, they will not be automatically.A code example. 
\begin{lstlisting}[numbers=none]
Vector2D& Vector2D::operator+=(const Vector2D& right){
	this->x += right.x;
	this->y += right.y;
	return *this;
}
\end{lstlisting}
	
\begin{lstlisting}[numbers=none]
Foo operator+(const Foo& lhs, const Foo& rhs){
	Foo result = lhs;
	result += rhs;
	return result;
}
\end{lstlisting}
	
	\item Why \verb=<<= need to be friend? You need to consider:  Because you need to write cout\verb=<<= obj. If you declare \verb=<<= as a member operator, you have to write obj\verb=<<=cout; it looks weird.
	
	\item ob = ob1+ob2 will changed to:  ob1.operator+(ob2);  The last const make the ob to invoke this operator doesn't change the value in this class. Don't return const value type, It will make "move" not work.
	
	\item assignment operator overload. 1) return a non-const reference, and 2) to avoid assign self. Don't return const reference, somebody said that it can avoid (x=y)=z. But in fact, it's not a normal way to write such code. In STL string, assignment operator just return reference. It give you a clue, \textbf{any time you have questions about interface design, you can see the STL library.}
\begin{lstlisting}[numbers=none]
class A & operator=(const class A& rhs){
	if(this ==&rhs) return *this;
	
	//Do some things other
	return *this;
}
\end{lstlisting}
	
\end{itemize}


\section{inheriantce}
\begin{itemize}
	\item OO just kick in when you use reference and pointer to base class
\begin{lstlisting}[numbers=none]
class A{
		public:
		virtual void fun(){ cout<<"A";}
};
	
class B: public A{
		public:
		void fun(){cout<<"B";}
};
	
int main(){
		B b;
		A a = b;
		a.fun(); //output A
		
		A& ra = b;
		ra.fun(); //output B
		A* pa = &b;
		pa->fun(); //output B
		(*pa).fun(); //output B
		
		A* pa1 = new B;
		(*pa1).fun(); //output B
}
\end{lstlisting}
\end{itemize}

\subsection{special member functions in inheritance}

\subsubsection{ctor}
\begin{itemize}
	
	\item  \textbf{Subclass ctor will always call base class ctor.}
	
	\begin{enumerate}
		\item Constructor should NOT be virtual
		
		\item If subclass doesn't define any ctor, compiler will implicitly define a default ctor, and this ctor will call base class default ctor.
		
		\item If subclass has a ctor, but it doesn't explicitly call base specify ctor, ctor of subclass will call base default ctor.(without any parameter.) If base ctor only has specify ctor, no default ctor, produce compiler error.
		
		\item If you want explicitly call base specify ctor, use initialization list syntax.
	\end{enumerate}
	
\begin{lstlisting}[frame=single, language=c++]
class base{
	public:
	base();  //default ctor
	base(int b); //specify ctor
	private:
	int b;
};
	
class subclass: public base{
	subclass();  //default ctor
	subclass(int s, int b); // specify ctor1
	subclass(int s);     //specify ctor2
	int s;
};
	
subclass::subclass(int s, int b): base(b){
	m_s = s;
}
//////////////////////////////////////////
subclass sc1(2,3);

subclass sc2(2);  // implicit call base default ctor
subclass sc3;   // implicit call base default ctor

}
\end{lstlisting}
\begin{description}
	\item[Line 20:] call specify ctor1, then explicit call base specify ctor.
	\item[Line 22:] if base has not default ctor, sc2 and sc3 will produce error.
\end{description}
	\item If you don't use  explicitly initialization list syntax to call base specify ctor, You will get uninitialized value or you can't initialize base member, Neither are good.
\begin{lstlisting}[frame=single, language=c++]
//method 2:
DeriveClass::DeriveClass(int base_a, b){
	
	Derive_b = b
}	
	/////////////////////
//method 3:
DeriveClass::DeriveClass(int base_a, b) {
	base_a = a  //It can be thought as a bad design.
	Derive_b = b
}
\end{lstlisting}
\begin{description}
	\item[Line 2:] it will call base\_class default constructor. in this case, base\_a is not assigned at all.
	\item[Line 9:] You can't  access private base member data. base\_a need to be public member data,
\end{description}
	\item Idea behind rules: Do best to make sure a obj can be built.	
\end{itemize}



\subsubsection{destructor}
\begin{itemize}
	\item For destructor:
	\begin{enumerate}
		\item If a base class has a destuctor, but sub class doesn't have,  compiler will produce an implicit default destructor, and this implicit default destructor will call base class destuctor.
		
		\item If you define a subclass destructor, It will call base destructor automaticlly, you don't need to call it explicitly.
		
		\item The question is, How can you make sure you sub class destructor will be called if you use a base class pointer or reference, answer is below:
	\end{enumerate}
	
	\item Don't call base desctructor explicitly, It will called automatically in the reverse order of construction.  And you should give a base desctructor a definition, Or linker will report error it even you don't call it in your source code.
	
	\item Make base class destructor public and virtual (polymorphic deletion by base class pointer or reference), or proteced and nonvirtual, base classes need not always allow polymorphic deletion. For example, consider class templates such as std::unary\_function. This time, you should make destructor protected and nonvirtual.
\begin{lstlisting}[numbers=none]
template <class Arg, class Result>
struct unary_function{
	typedef Arg    argument_type;
	typedef Result result_type;
};
	
Illegal code that you can assume will never exist.
void f( std::unary_function* f ){
	delete f; // error, illegal
}
\end{lstlisting}
	
	\item If base class still need to build itself, You can change it back public virtual,  Even without polymorphic deletion by now, you still need to declare it as virtual for the future safety(Even with a little dynamic-binding efficiency penalty. ) At same time, If a base class is not abstract class, usually, it's BAD design.
	
	\item Never throw exception from dtor, if exception A is thrown, then stack-unwindling, when a obj is destructed, then dtor is called, when another exception B is thrown by the dtor, application will call terminat function immediately.  If you have exception, catch it inside of the dtor.
	
\end{itemize}




\subsubsection{copy ctor in inheritance}

\begin{itemize}
	\item copy ctor(assignment ctor) in inheritance will cause slicing problem.  and slicing. Below four are all SLICING.  number 5 and number 4 is not very obvious. They are call base class ctor.  No matter what you input a reference to a derived class or not.
\begin{lstlisting}[numbers=none]
class Base{};
class Derived1 : Base{};
class Derived2 : Base{};
Derived1 d1;
Derived1 d2;
/////////////////////
Base b = d1; //1)
	
Fun(Base b);
Fun(d1);  //2)
	
Base& Bref = d1;
Fun(Bref) //3)
	
Base* bp = new B(Bref); //4)
	
Base* bp1 = new Derived1();  //5) sibling slicing
base* bp2 = new Derived2();
*bp1 = *bp2;  // bp1 just copy Base part in Derived2.
//so bp1 now is MIXTURE of d1 and d2.
\end{lstlisting}
	
\item Think a problem as below: how to make deep copy and avoid slicing in base class copy ctor?
\begin{lstlisting}[numbers=none]
class Base{};
class Derived1 : Base{};
class Derived2 : Base{};
Derived d1;
Derived d2;
	
Base* Copy(Base& Bref){
	//How to avoid slicing and make deep copy.
}
	
Base& Bref = d1
Base* d1p = Copy(Bref)

Base& Bref = d2
Base* d2p = Copy(Bref)
	\end{lstlisting}
	
\item Continue- Think this problem: error method
\begin{lstlisting}[numbers=none]
Base* Copy(Base& Bref){
	Base* p = new Base(Bref)
	//Slicing happen. bad
}
\end{lstlisting}
	\item Continue- Think this problem: TypeID method.
\begin{lstlisting}[numbers=none]
Base* Copy(Base& Bref){
	int typeid;
}
\end{lstlisting}
\begin{description}
	\item[Line 1:] Use tyid and dynamic\_cast. involve a lot of if and switch about type. anytime if you use dynamic\_cast and if, you can think about virtual function
\end{description}
	
\item Continue- Think this problem: Virtual Clone method.
	A function's return type is never considered part of its signature. You can override a member function with any return type as long as the return type could be used wherever the base class return type could be used.
\begin{lstlisting}[numbers=none]
class Base{
	virutal Base* Clone() = 0;
};
	
class Derived1 : Base{
	virutal Derived1* Clone(){return new Derived1(*this);}
}
	
Base* Copy(Base& Bref){
Base* p = Bref.Clone();
}
\end{lstlisting}
	
	\item Continue- Think this problem: Change Design. Base is concrete class,  More Effective C++ Item 33 said"Making Non-leaf class abstract. So maybe you can change the inheritance system.
	
	\item \textbf{Assignment operator and copy ctor in inheritance summary:}
	\begin{enumerate}
		\item \textbf{Default Assignment  operator and  copy constructor in derived class which are implicitly produced by compiler will call default base assignment  operator and  copy constructor.}
		
		\item \textbf{If derived class has no new operation. Don't need to define derived class Assignment  operator and  copy constructor, implicit one will call base one automatically}
		
		\item \textbf{If derived class has new operation. You have to define derived class Assignment  operator and  copy constructor, it will not invoke assignment  operator and  copy constructor in base class any more.  Inside, manually invoke base class Assignment operator and copy ctor } Detail can be found in C++ primer p760. Syntax looks like below: see effective C++ Item 16.
		
		\item For copy ctor, just init list syntaxt. For assignment operator, use two different methods depends on if base class declare its own assignment operator(). Source code is below:
		
\begin{lstlisting}[frame=single, language=c++]
DerivedClass::DerivedClass(const DerivedClass &dc): \
	BaseClass(dc){...}  //init list syntax here.
		
DerivedClass & DerivedClass::operator=(const DerivedClass &dc){
		BaseClass::operator=(dc);
		// base class declare explicitly operator
		
		( (BaseClass&) *this ) = dc
}
	\end{lstlisting}
\begin{description}
	\item[Line 8:] base class no explicitly operator, change *this to BaseClass reference, if you change to BaseClass, It will call copy ctor.
\end{description}
		
	\end{enumerate}

	\item There are three articles, you should read them together.\\
\\
https://herbsutter.com/2013/05/09/gotw-1-solution/
\\
https://stackoverflow.com/questions/21825933/any-difference-between-copy-list-initialization-and-traditional-copy-initializat
\\
https://stackoverflow.com/questions/1051379/is-there-a-difference-between-copy-initialization-and-direct-initialization

\end{itemize}

\subsection{virtual function and override}
\begin{itemize}
	
	\item Only virtual function come into vtbl. Friend can't be virtual function, because it's not a member of class.
	
	\item When a method is declared virtual in a base class, it is automatically virtual in the derived class, but it is a good idea to explicitly declare it by using the keyword virtual in the derived class declarations too.
	
	\item \textbf{Almost all the base class has virtual function, if a class doesn't contain a virtual function, It is an indication that it is not meant to be used as a base class}
	
	\item Don't rewrite non-virtual base member function, see effective c++
	
	\item For overriding to occur, several requirements must be met:
	\begin{enumerate}
		\item The base class function must be virtual.
		\item The base and derived function names must be identical (except in the case of
		destructors).
		\item The parameter types of the base and derived functions must be identical.
		\item The constness of the base and derived functions must be identical.
		\item The return types and exception specifications of the base and derived functions
		must be compatible.
		\item To these constraints, which were also part of C++98, C++11 adds one more: The functions' reference qualifiers must be identical.
	\end{enumerate}
	\item reference qualifier explain:
\begin{lstlisting}[numbers=none]
class Widget {
public:
	void doWork() &; // this version of doWork applies
	// only when *this is an lvalue
	void doWork() &&; // this version of doWork applies
	}; // only when *this is an rvalue
	
	Widget makeWidget(); // factory function (returns rvalue)
	Widget w; // normal object (an lvalue)
	
	w.doWork();
	// calls Widget::doWork for lvalues (i.e., Widget::doWork &)
	makeWidget().doWork();
	// calls Widget::doWork for rvalues (i.e., Widget::doWork &&)
\end{lstlisting}
	
\item Any small error will not real override base virtual function. but creating a new virtual method with a different signature. such as examples below.
\begin{lstlisting}[numbers=none]
class Base {
public:
	virtual void mf1() const;
	virtual void mf2(int x);
	virtual void mf3() &;
	void mf4() const;
};

class Derived: public Base {
public:
	virtual void mf1();
	virtual void mf2(unsigned int x);
	virtual void mf3() &&;
	void mf4() const;
};
\end{lstlisting}
	
	\item override specifier should be used in derived class member function used to check if they are match with member function in base class.
\begin{lstlisting}[numbers=none]
struct A{
	virtual void foo();
	void bar();
};
	
struct B : A{
	void foo() override; // OK: B::foo overrides A::foo
	void bar() override; // Error: A::bar is not virtual
}
	\end{lstlisting}
	
\item Use final in Base class, to stop sub class override.
\begin{lstlisting}[numbers=none]
class Base{
	virtual void method1() final;
}
\end{lstlisting}
	
\end{itemize}



\section{Classes relationship}

\subsection{structure semantic}
\subsubsection{Definition}
\begin{itemize}
	\item OOP has four relationships:
	\begin{description}
		\item[Composition ] exists when a member of a class has a part-of relationship with the class. In a composition relationship, the class manages the existence of the members. To qualify as a composition, an object and a part must have the following relationship:
		\begin{enumerate}
			\item The part (member) is part of the object (class)
			\item The part (member) can only belong to one object (class) at a time
			\item The part (member) has its existence managed by the object (class)
			\item The part (member) does not know about the existence of the object (class)
		\end{enumerate}
	More descriptions: 
	\begin{enumerate}
		\item Compositions are typically implemented via normal member variables, or by pointers where the class manages all the memory allocation and deallocation. If you can implement a class as a composition, you should implement a class as a composition.
		\item  Ownership, same life time,  not change in the middle. Person and Head
	\end{enumerate}
	
	
	\item[Aggregations  ] exists when a class has a has-a relationship with the member. In an aggregation relationship, the class does not manage the existence of the members. To qualify as an aggregation, an object and its parts must have the following relationship:
	
	\begin{enumerate}
		\item The part (member) is part of the object (class)
		\item The part (member) can belong to more than one object (class) at a time
		\item The part (member) does not have its existence managed by the object (class)
		\item The part (member) does not know about the existence of the object (class)
	\end{enumerate}
	More descriptions: 
	\begin{enumerate}
		\item Aggregations are typically implemented via pointer or reference.
		\item Ownership, maybe same life time, may change in the middle,  Container and pointer(same life time, changeable). Airport and airplane and department and teacher.
	\end{enumerate}
	Aggregations are typically implemented via pointer or reference.
	
	\item[Associations  ] are a looser type of relationship, where the class uses-an otherwise unrelated object. To qualify as an association, an object and an associated object must have the following relationship:
	\begin{enumerate}
		\item The associated object (member) is otherwise unrelated to the object (class)
		\item The associated object (member) can belong to more than one object (class) at a time
		\item The associated object (member) does not have its existence managed by the object (class)
		\item The associated object (member) may or may not know about the existence of the object (class)
	\end{enumerate}
	More descriptions:
	\begin{enumerate}
		\item Associations may be implemented via pointer or reference, or by a more indirect means (such as holding the index or key of the associated object). No Ownership, different life time,
		
		\item People and toothbrush(same life time, changeable) Teacher and student( not same life time, changeable), person and father(Not Nullity), person and wife( Nullity)
	\end{enumerate}

	\item[dependency ] exists when a member of a class has a part-of relationship with the class. In a composition relationship, the class manages the existence of the members. To qualify as a composition, an object and a part must have the following relationship:
	
	More descriptions:
	\begin{enumerate}
		\item No Ownership, Not Includes as a member, person and friend.
		
		\item Dependency definition: If class X's member function argument is class Y, X is dependency of Y.
		
		\item Dependency definition extention: For a class X, all functions, including free functions, that both "Mention" X and "supplied with" X are logically part of X, because they form part of the interface of X. Supplied with means that they appear in the same header file.
	\end{enumerate}
	

	\end{description}
	
	\item Summary: \newline
	
	\begin{tabular}{|p{0.25\textwidth}|p{0.12\textwidth}|p{0.12\textwidth}|p{0.12\textwidth}|p{0.15\textwidth}|}
		\tophline 
		 & Composition  & Aggregation  & association & Dependency \\ 
		\tophline 
		Relationship type& Whole/part  & Whole/part  & otherwise unrelated  & otherwise unrelated  \\ 
		\tophline 
		Members can belongs to multi classes& no  & yes & yes & yes  \\ 
		\tophline 
		member existence managed by class& Yes & no & no   & no \\ 
		\tophline 
		Directionality & uni  & uni & uni or bidirectional & uni  \\ 
		\tophline 
		relationship verb& part-of & has-a & uses-a & depends-on 
		\bottomhline 
	\end{tabular} 
	
	\item From Structure perspective, toothbrush and people are association relationship. Although you can say people has a brush, but you can't say brush is part of people.But pay attention, this kind of definition is trick and vague, so\textbf{don't treat it pedantically.} See some examples:
	\begin{enumerate}
		\item Animal class contain name(string):composition.
		
		\item classroom and students: aggregation, but associate if class room is shared. it can be changed in the specific context.
	\end{enumerate}

	\item \textbf{Composition is specific aggregation, and aggregation is specific associate.}

\end{itemize}
	

\subsection{Inheritance semantic}

\subsubsection{private inheritance}
\begin{itemize}
	\item 	Code and example and explanation:
\begin{lstlisting}[frame=single, language=c++]
class B                    { /*...*/ };
class D_priv : private   B { /*...*/ };
class D_prot : protected B { /*...*/ };
class D_publ : public    B { /*...*/ };
class UserClass            { B b; /*...*/ };
\end{lstlisting}
	
	\begin{enumerate}
		\item None of the derived classes can access anything that is private in B.
		
		\item In D\_priv, the public and protected parts of B are private.
		
		\item In D\_prot, the public and protected parts of B are protected. Protect used in three generation inheritance. By protected Inheritance, grandfather member become protected member in father, so Grandson can still use grandfather's members.
		
		\item In D\_publ, the public parts of  B are public and the protected parts of B are protected (D\_publ is-a-kind-of-a B).
		
		\item Class UserClass can access only the public parts of B, which "seals off" UserClass from B.
	\end{enumerate}

	\item To make a public member of B public in D\_priv or D\_prot, state the name of the member with a B:: prefix. E.g., to make member B::f(int,float) public in D\_prot, you would say:
\begin{lstlisting}[numbers=none]
class D_prot : protected B {
public:
	using B::f;  // Note: Not using B::f(int,float)
};
\end{lstlisting}

\item In short, composite uses object names to invoke a method, whereas private Inheritance uses the class name and scope resolution operator Instead. If you need the base class itself, use a type case (const string\&) * this; detail can be seen in C++ primer, P800

\item If you want to reuse string code in class student(also means \textbf{has-a} relationship, student has a string name) you have two options, The first is composition,  the second is private inheritance. See below:
\begin{lstlisting}[numbers=none]
class Student{ // 1) use composition.
	int getNameLen();
private:
	string m_name;
	vector<double> score;
};

int Student::getNameLen(){
	return m_name.length();
}
\end{lstlisting}

\begin{lstlisting}[numbers=none]
class Student: private string, private std::vector<double>{
	int getNameLen();
	// We don't need private memeber data any more
}

int Student::getNameLen(){
	return string::length();
	//use class name and scope-resolution operator
}

const string& Student::getName(){
	return (const string&) *this;
}
\end{lstlisting}
\end{itemize}

\subsubsection{"Has-A" relationship}

\begin{itemize}
	\item You can use \textbf{1)private inheritance, 2)composition and 3)template} three methods to describe has-a relationship.
	
	\item Private and protect inheritances are used to implement has-a relationship. Introduce their access policy in inheritance:

	\item \textbf{Prefer composition, use private inheritance when you have to.} Reusing by private inheritance is weird in syntax and difficult to understand. One exception is you have to access string or vector<T> protect member function, at this time, you MUST use private inheritance.
	
	\item By now, I want to not only reuse class A, I also want to make a class adaptable. or make it possible to select different algorithms from the outside.  An example is  to replace brakes of a car (at runtime) Intend to pass Car around to non-template functions There are three options.
	\begin{enumerate}
		\item Version 1: Abstract base class, In fact, consider \textbf{same life time and composition relationship},  Using Brake obj directly is better. But you want to have runtime polymorphism at the same time, So have to use pointer or reference. Here you can use smart pointer(uniqu\_ptr).
\begin{lstlisting}[numbers=none]
class Brake {
	public: virtual void stopCar() = 0;
};
		
class BrakeWithABS : public Brake {
public: void stopCar() { ... }
};
		
class Car {
	Brake* _brake;
public:
Car(Brake* brake) : _brake(brake) { brake->stopCar(); }
};
\end{lstlisting}
		
		\item Version 2a: Template
		
\begin{lstlisting}[numbers=none]
template<class Brake>
class Car {
		Brake brake;
public:
		Car(){ brake.stopCar(); }
};
		
\end{lstlisting}
		\item Version 2b: Template and private inheritance
\begin{lstlisting}[numbers=none]
template<class Brake>
class Car : private Brake {
		using Brake::stopCar;
public:
		Car(){ Brake::stopCar(); }
};
\end{lstlisting}
	\end{enumerate}
	
	\item I would generally prefer version 1 using the \textbf{runtime polymorphism}, because it is still flexible, and All Car  have the same type. In template implementation,  Car<Opel> is another type than Car<Nissan>. If your goals are great performance while using the brakes frequently, i recommend you to use the templated approach\textbf{static binding}. By the way, this is called \textbf{policy based design.}
	
	\item Another example about policy based design is std::map, you can input a functor type, use to compare two elements inside map. At this time, because your host(std::map) is template, you have to use policy based design.
\end{itemize}

\subsubsection{"Is-A" relationship}

\begin{itemize}
	\item some basic syntactic knowledge:
	\begin{enumerate}
		\item No source code, just header and lib, you also can use inheritance in C++ language.
		
		\item Pure virtual class can't be instance, it just a abstract interface, it's agreement.
		
		\item Both reference and pointer support polymorphism.
	\end{enumerate}
	
	\item Inheritance has three level knowledge.
	\begin{enumerate}
		\item The basic design knowledge, manager is a person, apple is a fruit, and bla bla bla.
		
		\item The basic  pure virtual, virtual, and non virtual syntax knowledge.
		
		\item \textbf{Isolate change between Client and Implement}. That is the highest level in design pattern. How to understand interface? Client<->Interface<->Implement. through Interface, you keep all the change happen implement side, not affect Client at all.
	\end{enumerate}
	
	\item \textbf{Public inheritance is substitutability, not to reuse, but to be reused. } For example, client use class A, and class B inherit class A.  I don't think class B reuse something in class A. we should think that class B could be used by client too, just like client use class A.

	
	\item  A common mistake is inheriting from classes that were not designed to be base class. For example, you want to customize some current class, you have string class, but you want to change some behavior of string. So you write: \texttt{class myString : public string}. But it violate LSP( Liskov Substitution Principle): \textbf{Functions That use pointers or references to base classes must be able to use objects of derived classes without knowing it. }
	\begin{enumerate}
		\item client use string class through base class pointer or reference
		\item base class has virtual function.
		\item derived class redefine base class virtual function.
	\end{enumerate}
	
	\item See previous three points: all requirement are not satisfied. Clients most times use string by value directly, string doesn't has any virtual function, it's a value class, and you didn't design before hand.
	
\item If you want to change find function, You don't need inherit,  Just write non-member function and pass a string object.
\begin{lstlisting}[numbers=none]
myFind(const string& str){
	//you custimized behavior.
}
// use myFind(str) and myStr.find()
//I think only difference is syntax.
\end{lstlisting}
	
\item Even you have specific state, you also can use composition to avoid inheritance.
\begin{lstlisting}[numbers=none]
class MyString{
	size_t length(){return str.length}
	//just need to write forward function here;
	
	myFind(){
		//You customized behavior.
	}
	
	std::string str;
}
	\end{lstlisting}
	
	\item \textbf{Another mistake is public inheritance is work-like-a, not is-a.} For example, circle is a eclipse, and square is a rectangle, but in oop, you can't make circle inherit from eclipse, because, eclipse has two centers.  you can't make squre inherit from rectangle, because setWidth is not work as the same as in rectangle, (setWidth in square will change height at the same time.) It break LSP.  A solution is make an abstract base class(ABC) then make circle and ellipse inherit from ABC
	
	
	\item Previous example also explain, when you design a class, it doesn't need to be a practical object, such as animal, car, people, etc.  It can be abstract conception.  (So desgin pattern is so important conception).
	
	\item Composite VS Inheritance:
	\begin{enumerate}
		\item Does TypeB want to expose the complete interface (all public methods no less) of TypeA such that TypeB can be used where TypeA is expected? Indicates Inheritance. e.g. A Cessna biplane will expose the complete interface of an airplane, if not more. So that makes it fit to derive from Airplane.
		
		\item Does TypeB only want only some/part of the behavior exposed by TypeA? Indicates need for Composition. In this case, it makes sense to extract it out as an interface / class / both and make it a member of both classes.
		
		\item Inheritance must pass Liskov Substitution Principle. Previous example about ellipse and circle fail this test. because ellipse has setLongAxis() and setShortAxis(), but circle doesn't have them at all.
	\end{enumerate}

\begin{lstlisting}[numbers=none]
class Shape{
	virtual draw() = 0 // you have to re
}
	
class Circle: public Shape{
	}
\end{lstlisting}


\end{itemize}

\subsection{Ownership semantic}
\begin{itemize}
	\item \textbf{Owership semantic is different with structure semantic.} Structure semantic care about the whole-part relationship.Ownership semantic. 
	
	\item There is two kinds of Ownership: exclusive ownership and shared ownership. Usually:
	\begin{enumerate}
		\item Composition has exclusive ownership.
		\item Aggrecation has shared ownership.
		\item Ownership semantic is different with structure semantic, Associate can have ownership, such as people and his brush. people and his wife.
	\end{enumerate}
	
	\item Owership semantic has two children policies: life time policy and Nonnullity policy. 
	
	\item Ownership may descripe the relationship between two classes or class and its member.
	
	\item Code example and explanation. 
\begin{lstlisting}
class Man{
	Heart t_   
	unique_ptr<Brush> pb_; 
	shared_ptr<Woman> pwife_; 
	Company* pb_; 
	Woman& mother; 
	void getMoney(const Bank&);
}
\end{lstlisting}
\begin{enumerate}
\item Whole part

	\centering
	\includegraphics[width=0.9\linewidth]{pics/owner.png}

\begin{description}
	\item[Company and Bank] No ownership. Company is a member, It's important for you to have a work and it used by many member functions. so it's a member. For Bank,you just use it when you want to get Money, so use it in the function as parameter. Company is associate relationship and Bank is dependency relationship.
	
	\item[Monther] No ownership. It can not be null, and can not be changed.  so we use reference. 
	
	\item[Heart] Ownership, same life time, (No dynamic life)
	
	\item [toothbrush] Ownership, dynamic life, and exclusive ownership, so we use unique\_ptr
	
	\item [wife] Ownership, dynamic life, and shared ownership, so we use shared\_ptr
\end{description}

\end{enumerate}


	
\end{itemize}
\subsection{Summary}

\subsubsection{Examples}

\begin{itemize}
	\item OOP example 1: If it's a people-head(Composition) relationship, and it's compiler-given(not dynamic), just use \textbf{member obj.}   Pay attention, If Engine has no default ctor, you have to use initialization list in car ctor.  initialization list can be used to call base ctor.
\begin{lstlisting}[frame=single, language=c++]
class Car{
	Engine eng; // member obj, not use pointer here.
	Car(int carArg, int engArg): eng(engArg){}
}
	\end{lstlisting}
	
	\item OOP example 2: 
	
	\item OOP example 2:  If it's an peole-brush(Association) relationship, If has same life time and exclusive ownership, use uniqu\_ptr. If you want to change, use uniqu\_ptr reset function or move semantic from another uniqu\_ptr.   TootuBrush example, use unique\_ptr.
\begin{lstlisting}[frame=single, language=c++]
class Person{
	unique_ptr<Brush> unpbrush;
	
	buyNewBrush(string &name){
		unpbrush.reset(new Brush());
	}
}
\end{lstlisting}
\begin{description}
	\item[Line 5:] you can't use unpbrush= new Brush(), unpbrush assignment only support( unique\_ptr<T> \&\&); use reset, it will make original deleted automatically. don't need destructor any more.
\end{description}
	
	\item OOP example 3: if it's wife-husband(Association) relationship, If you want to express \textbf{Strong Not Nullity}, use reference, such as Mother-Son association, You need to use initialization list to init mother. If Nullity, such as wife, just use raw pointer, weak\_ptr or shared\_ptr. \textbf{Because no ownership involved, don't use uniqu\_ptr at all. }
	
	\item OOP example 3-1: What's different with raw pointer, weak\_ptr or shared\_ptr?
	\begin{lstlisting}[numbers=none]
class Man{
	Woman*  wife; // can be set to nullptr.
	//maybe change or live longer than you.
	
	weak_ptr<> Woman &mother; 
	//must give a mother in initial list
}
\end{lstlisting}
	
	\item OOP example 4: if it's Dependency,  such as friend relationship,  Most of time, we just use pointer or reference as function parameter.
\begin{lstlisting}[numbers=none]
class Man{
	lendMoney(Friend* mike);
}
//just use it in function. not a member of class.
\end{lstlisting}
	
	\item OOP example 5: Suppose Man and Computer(Associate from structure semantic) is has-a relationship(from inheritance semantic) and same life time. Don't use pointer or reference, just copy from a common computer, and maybe later you can customize your computer, and it will not effect common one.  We can copy from commonComputer and init all Worker object.  And this time use initialization list can improve efficiency.
\begin{lstlisting}[numbers=none]
class Worker{
	Computer m_desktop;
	Worker (Computer u): m_desktop(u){}
}
	
Computer commonComputer;
Worker Yan(commonComputer);
Worker Han(commonComputer);
\end{lstlisting}
	
	
	\item OOP example6:  Change a semantic,  Unit may have a Bus, but \textbf{owner policy} tell us that bus can be shared by different unit. and \textbf{life time policy} tell us that bus and unit has separate life time. so here, we should use shared\_ptr.
\begin{lstlisting}[numbers=none]
class Unit{
	shared_ptr<Bus> shr_p_bus;
}
\end{lstlisting}
	
	\item OOP example7: One class provides a container to hold multiple objects of another type. A value container is a composition that stores copies of the objects it is holding. A reference container is an aggregation that stores pointers or references to objects that live outside the container.
	
\end{itemize}




\section{design pattern}

\subsection{Common used principle}
\subsubsection{Three big rules}
\begin{itemize}
	\item There are three basic rules.
\begin{enumerate}
	\item Liskov Substitution Principle----Clients (Functions and Class) that use pointers or references to base classes must be able to use objects of derived classes without knowing it.  So all overrides of virtual member functions must \textbf{require less and provide more}. So you can make substitution successfully.
	
	\item Dependence Inversion Principle. Clients only depends on interface.
	
	\item Interface segregation principle. Make Inferface simple and small.
\end{enumerate}

\item Example, see code below.  1)LSP: Car can use  GasPower or ElePower without know it. 2)DIP: Car only is depends on Power* interface 3)ISP: Interface should be small and separately. An example can be seen in MI section below.

\item There are three points:
\begin{enumerate}
	\item Pointer or refenence to the base class (Power* pow)
	\item Virtual function support dynamic-binding
	\item You need to design the base class and it should include at least one virtual function.
\end{enumerate}

\begin{lstlisting}[numbers=none]
class Car{
....................
Power* pow
};

Car::start(){
...........
pow->ignite();
..........
}

class Power{
virtual ignite();
};

class GasPower : public Power
class ElePower : public Power

Car car(gas);
car.start();
\end{lstlisting}

\end{itemize}

\subsubsection{NFA and NVI}

\begin{itemize}

	\item Inheritance three usage: 1) I want to inherit a interface. (pure virtual, you have to rewrite ) 2) I want to inherit a implement,but I want to change it. (virtual, you may or maynot rewrite) 3) I want to inherit a implement, but I don't want to change it. (Non-virtual, you can't rewrite it at all)
\begin{lstlisting}[numbers=none]
class shape{
public:
	virtual draw() = 0 // you have to re
	virtual error(); // there is default implement.
	// but you may change it.
	int objectID(); // you don't need to rewrite it.
}
\end{lstlisting}

\item NFA can be found in More effective 33 "making non-leaf classes abstract" and C++ coding standards 36 "Prefer providing abstract interfaces." They all said that you should only inherit from an abstract interfaces. It also follow DIP.

\item \textbf{When you found abstract conception appear in more than one context, you need build abstract interface for it. }

\item There are some advantages. use interface will separate client and implement, make addition and modification implement easier. (But it need good design at the beginning). If you inherit from concrete base class, It will cause Slicing problem, Detail can be seen in "ctor in inheritance" section.

\item NVI is making virtual functions nonpublic, and public function nonvirtual. This is similar with Template Method design pattern.  

\item About NVI, more detail can be found in "C++ coding standards Item 39" and "Virtuality herb sutter"

\item A design comparison:
\begin{figure}
	\centering
	\includegraphics[width=0.8\linewidth]{pics/NVI.png}
	\caption{}
	\label{fig:nvi}
\end{figure}

\end{itemize}

\subsection{Resource wrapper and RAII}
\begin{itemize}
	\item Whenever you deal with a resource that needs paired acquire/release function call, encapsulate that resource in an object.  Such as: fopen/fclose, lock/unlock, and new/delete.
	
	\item When implementing RAII, be conscious of copy construction and assignment. the compiler-generated version probably won't be correct. If it's not copyable, use =delete , if it's copyable, duplicate the resource.  You also can use smart\_pointer in this scenario too.
	
	\item The basic idea of RAII  is to represent a resource by a local object, so that the local object's destructor will release the resource.  That is to say: To prevent resource leaks, use RAII objects that acquire resources in their constructors and release them in their destructors.
\begin{lstlisting}[numbers=none]
//C version,
File* fp = fopen("/path/to/file");
// throw exception here, then resource leaking
fclose(fp);
	
//Java version
try {
	File file = new File("/path/to/file");
	// throw exception here, go to finally.
	} finally {
	file.close();
}
	
//c++ version
fun{
	fstream if("path/to/file")
	if.getline
	// you don't need to if.close().
}

//c++ smart version.
std::unique_ptr<FILE,          // the wrapped raw pointer type: FILE*
int(*)(FILE*)>       // the custom deleter type: fclose() prototype
myFile( fopen("myfile", "rb"), // resource (FILE*) is returned by fopen()
fclose );              // the deleter function: fclose()
\end{lstlisting}
	
	\item Another good example RAII is unique\_ptr. The idea of smart pointer is putting *p into a local pointer-like object, then when it go out scope or unwind-stack when exception is thrown, It will call destructor, then delete p.
	
	\item We should consider resource generically, pointer *p pointed to a new object is resource, A handle to a file is a resource to. \textbf{We wrap handle to a file into ifstream, and wrap pointer *p into smart\_pointer}
	
	\item Just like return value,  Exception will skip all the statement below the throw, In C++, It doesn't support finally statement sometimes. At this time, we need to use RAII.
\begin{lstlisting}[numbers=none]
Int *p = new int;
string a   //a is ok, a will be destructed properly
//due to the C++ unwind stack.
throw exception.
delete p; // this will not run.
\end{lstlisting}
	
	\item For this problem, you should use smart pointer to declare a auto object.  If you use string object, It's ok.  So in previous example,  you can use smart pointer, it will help you to avoid memory leakage problem.
\begin{lstlisting}[numbers=none]
unique_ptr<int> aupr (new int(100);
string a   //a is ok, a will be destructed properly
//due to the C++ unwind stack.
throw exception.
// both a and aupr will call their own destructor  function.
\end{lstlisting}
	
	\item In you ctor, If you use new and new failed and throw a exception, the destructor will not be called. You can use auto\_ptr as member data and use init list to initialzie it. see  more effective C++ exception chapter.
	
	\item Don't use C FILE* and char [] as string. Use iofile class and string object, because they are exception safe
	\begin{enumerate}
		\item Any time when you use new, consider if there are c++ container or object.
		\item If not, use smart\_pointer.
	\end{enumerate}
	
	\item Another example is when you make program based on Win API.
\begin{lstlisting}[numbers=none]
class module {
public:
	explicit module(std::wstring const& name)
	: handle { ::LoadLibrary(name.c_str()) } {}
	
	~module{
		::FreeLibrary();
	}
private:
	HMODULE handle;
};
\end{lstlisting}
	
	\item There are three RAII implementation instances in your practical programming:
	\begin{enumerate}
		\item Use auto member; You have to keep m\_str and vc are RAII.  In this way, you don't need to build dtor manually.
\begin{lstlisting}[numbers=none]
class RAII {
		private:
		string m_str;
		vector<int> vc;
};
\end{lstlisting}
		
		\item Use pointer and handle; In this way, You have to use pointer, Maybe you need some customized action in runtime , \textbf{Use handle is only method to use this resource} or any other reason. And this time, you have to write your own dtor.
\begin{lstlisting}[numbers=none]
class RAII {
		private:
		string* m_str;
		vector<int*> vc;
};
\end{lstlisting}
		
		\item Use smart point wrap pointer and handle; When you wrap handle, you can custom this delete behavior. See source code below:
\begin{lstlisting}[numbers=none]
class RAII {
private:
		unique_ptr<string>  m_str;
		vector<unique_ptr<int> > vc;
};
\end{lstlisting}
		
\begin{lstlisting}[frame=single, language=c++]
class module {
public:
		explicit module(std::wstring const& name)
		: handle { ::LoadLibrary(name.c_str()) } {}
		private:
		using module_handle = std::unique_ptr<void, decltype(&::FreeLibrary)>;
		module_handle handle;
};
\end{lstlisting}
	\end{enumerate}
	
	\item Another question is ownership of resource:
	\begin{enumerate}
		\item For auto member resource: \textbf{1)Same life duration(RAII), 2)exclusive ownship to a single obj, but it's copyable(A a1 = a2).  3)move with efficiency(A a1 = A() ) }. If auto member has it's own copy and move special function, You don't need to write any special function in your class. You follow the "Rule of Zero".
		
		\item For raw pointer and handle: \textbf{1) default copy ctor will cause two pointer or handle refer the same resource, It's absolutely BAD SMELL of code 2) So you have to follow "Rule of five" to build your special member function. 3) After you build five special member function, you get RAII and exclusive ownship to a single object, and copyable and efficient move}
\begin{lstlisting}[numbers=none]
Class RawPointer{
		...........
		RawPointer(const RawPointer& rhs){
		pRes = new Resource( *(rhs.pRes));
}
		
RawPointer(RawPointer&& rhs){
		pPes = rhs.pRes;
		rhs.pRes = nullptr;
}
private:
		Resource* pRes;
}
\end{lstlisting}
		
		\item For uniqu\_ptr; \textbf{1) Same life(RAII) 2)exclusive ownship but not copyable 3) uniqu\_ptr support move operation. } You still follow "rule of zero"
		
		\item Even with uniqu\_ptr member, If you follow "rule of zero", that is to say that you don't provide any customized special member function, then the class is not copyable. But if you build copy ctor by youself, get raw pointer from origin side, and build a new uniqu\_ptr member from origin side's raw pointer, you can implement copyable, and code smell better than raw pointer with "Rule of Five". So in this way, \textbf{It's not recommended to use raw pointer in RAII and ownership context}.
		
		\item For shared\_ptr; \textbf{1) Not a RAII 2) shared ownship, 3) copyable and moveable}. When you move a shared\_ptr, origin one is set to nullptr and ref count doesn't increas.  You still follow "rule of zero".
		
	\end{enumerate}
	
	\item \textbf{ Conclusion, If you consider RAII and ownship at the same time, thing will become complex}  so I would like to give you some examples to illustrate them.
	
	\begin{enumerate}
		\item Prefer to use auto member for most of time! It follow "Rule of Five" and support copyable and movable. Such as std::string
		
		\item  For special demand, for example Car class,  people can \textbf{custom} its engine, and buy \textbf{two} at the same time. In this context, you car class should use raw pointer, 1) auto member doesn't support custom 2) uniqu\_ptr doesn't support copyable.  And you have to follow "Rule of Five"
\begin{lstlisting}[numbers=none]
class Car{
		//follow "Rule of Five"
		Engine *pEn;
		~Car(){delete pEn} // assure RAII
}
\end{lstlisting}
		
		\item For special context, It doesn't support object copy: for example 1) Person class in semantic;  2) other  perform consideration, Class Big{int [30000];};  3) Other implementation constrain, such as iostream class.   Under such context, you can use uniqu\_ptr to manage the resource and implement uncopyable.
\begin{lstlisting}[numbers=none]
class Person{
		uniqu_ptr<Resource> pRes;
}
\end{lstlisting}
		
		\item For special context, shared resource, you can use shared\_ptr.  You still can follow "Rule of zero" and resource will be deleted when ref count is 0.
\begin{lstlisting}[numbers=none]
class Student{
		shared_ptr<SchoolBus> pBus
}
\end{lstlisting}
		
		\item To know semantic of two smart pointers. Don't use them just replace raw pointer.
	\end{enumerate}
	
\end{itemize}

\subsection{MI or bridge}
\begin{itemize}
	\item Multiple Inheritance will cause one grandson has two copy of grandfathers. A solution is use virtual key word: When you use this method, you need to follow New Constructor Rules, Detail can be seen in C++ primer P815.  Just look back when you really need MI.
\begin{lstlisting}[numbers=none]
Father 1: virtual public grandfather
Father2: virtual public grandfather
son : public Father1, public Father 2
\end{lstlisting}
	
	\item A design discussion can be seen in "C++ FAQ Inheritance-- Multiple and Virtual Inheritance"
	\item Suppose you have land vehicles, water vehicles, air vehicles, and space vehicles. (Forget the whole concept of amphibious vehicles for this example; pretend they don't exist for this illustration.) Suppose we also have different power sources: gas powered, wind powered, nuclear powered, pedal powered, etc. We could use multiple inheritance to tie everything together, but before we do, we should ask a few tough questions:
	
	\begin{enumerate}
		\item Will the users of LandVehicle need to have a Vehicle\& that refers to a LandVehicle object? In particular, will the users call methods on a Vehicle-reference and expect the actual implementation of those methods to be specific to LandVehicles?
		
		\item Ditto for GasPoweredVehicles: will the users want a Vehicle reference that refers to a GasPoweredVehicle object, and in particular will they want to call methods on that Vehicle reference and expect the implementations to get overridden by GasPoweredVehicle?
	\end{enumerate}
	If both answers are "yes," multiple inheritance is probably the best way to go.
	
	\item There are at least three choices for the overall design: the bridge pattern, nested generalization, and multiple inheritance. Each has its pros/cons:
	
	\includegraphics[scale=0.4]{pics/MI.png}
	
	\item Try especially hard to use ABCs when you use MI. In particular, most classes above the join class (and often the join class itself) should be ABCs. In this context, "ABC" doesn't simply mean "a class with at least one pure virtual function;" it actually means a pure ABC, meaning a class with as little data as possible (often none), and with most (often all) its methods being pure virtual.
	
	\item Where in a hierarchy should I use virtual inheritance?  Just below the top of the diamond, not at the join-class.
	
\end{itemize}

\subsection{factory, bridge and visitor}

\begin{itemize}
	\item These three design pattern share the same UML structure, so I introduce them together. \textbf{Design patter is based on semantic and concrete applicaiton, not based on UML relationship and structure.}
	
	\item This is an example with bicycle and car.  We use abstract factory, bridge and visit Three pattern. 

		\centering
		\includegraphics[width=0.9\linewidth]{pics/visitor.png}
	    
\end{itemize}
     
\chapter{Generic programming}
     
\section{Template Basic}
\begin{itemize}
\item A simple way to simulate template is \verb=typedef int Item=; But when you change the data type, you need to change header file, and you can't have int and double to template class at the same programme. so C++ introduces a better method: \texttt{template<typename T>}.

\item You should use templates if you need functions or container class(act likes) that apply the same algorithm to a variety of types. Templates are frequently used for container classes because the idea of type parameters matches well with the need to apply a common storage plan to a variety of types.

\item A good style in template is: Use typename, not class. At the same time. simple names, such as T.
\begin{lstlisting}[numbers=none]
template<typename T> //better style
//template<class COMPLEX_T> //bad style
swap(T& a, T&b){
	.........
}
\end{lstlisting}

\end{itemize}

\subsection{template parameter}

\begin{itemize}
\item You can have several kinds of template parameters.
\begin{enumerate}
\item  Type Parameters.
  	\begin{enumerate}
   	\item Types
    \item Templates (only classes and alias templates, no functions or variable templates)
	\end{enumerate}

\item Non-type Parameters
   \begin{enumerate}
	\item Pointers
	\item References
	\item Integral constant expressions. (That is why \texttt{constexpr} is so important sometimes.)
	\end{enumerate}
\end{enumerate}

\item You can use more than one type parameter, or default type template parameters.
\begin{lstlisting}[numbers=none]
template <typename T1,  typename T2>
class Pair{ }
Pair<double, int> pair1;

template <typename T1,  typename T2=int>
class Pair{ }
Pair<double> pair2;
\end{lstlisting}

\item You can use Non-Type Argument in a template. But it will cause code bloat problem. 
\begin{lstlisting}[numbers=none]
template <typename T, int n>
	class ArrayTP{
	T ar[n];
	......
}

template <typename T, T n>
class Foo{
}
\end{lstlisting}

\item Type parameter can be another template calss.  It's different with "template template parameter" which is introduced below.
\begin{lstlisting}[numbers=none]
template<typename T> // T is int here
class A

template<typename T> //T is A<int> here
class B

B< A<int> > obj;

vector< vector<int> > matrix // 2D matrix
\end{lstlisting}
\begin{description}
	\item[Line 7:] Two T has no any relationship. you can give them any better description name. You can just think it as placeholder.
\end{description}

\item What is template template parameter? An article is "Correct usage of C++ template template parameters". Another good one is "C++ Common Knowledge: Template Template Parameters". It gives a stack example. Below is bad way to declare stack template.
\begin{lstlisting}[frame=single, language=c++]
template <typename T, typename Cont>
class Stack {
public:
	~Stack();
	void push( const T & );
	//...
private:
	Cont s_;
};

Stack<int, List<int> > aStack1; // OK
Stack<double, List<int> > aStack2; // legal, not OK           
Stack<std::string, Deque<char *> > aStack3; // error!   
\end{lstlisting}
\item We use template template parameter. 

\begin{lstlisting}[frame=single, language=c++]
template <typename T,  template <typename ELEM, 
		typename = std::allocator<ELEM> > 
		class Cont = std::deque>
class Stack {
//...
private:
	Cont<T> s_;
};
//...
Stack<int> aStack1; // use default: Cont is Deque
Stack<std::string,std::list> aStack2; // Cont is List
\end{lstlisting}
\begin{description}
	\item[Line 1:] \textbf{There is another template keyword inside of the out template arrow brackets.} 
	
	\item[Line 2:] Why you need std::allocator here? because std::deque is template calss with two template parameter.
	
	\item[Line 3:] std::deque is default template parameter.
	
	\item[Line 7:] You don't need to specify inside template parameter, because \texttt{Cont<T>} will help to deduct it.
	
	
	
\end{description}

\end{itemize}

\subsection{template instantiation}
\begin{itemize}
\item There are two confusing words in template domain, let's make them clear. What is \textbf{instantiation and specification?}
\begin{enumerate}
	\item C++ uses implicit or explicit instantiation to generate a specialized class or function definition from template. For implicit, you have to declare an variable, but for explicit, you don't need to declare an obj; \textbf{declare an variable or use template keyword}. These two instantiation are all based on existing template implementation.
	
\begin{lstlisting}[frame=single, language=c++]
template<typename T, int n>
class ArrayTP...
	
ArrayTP<int, 100> stuff 
	
template ArrayTP<string, 100>;
\end{lstlisting}
\begin{description}
	\item[Line 4:] implicit instantiation. you have to declare variable \texttt{stuff}.
	\item[Line 6:] generate a specialized class even you don't declare a variable.
\end{description}

	\item explicit specification is define a different template implementation for certain type. For example, For bool type, we can use optimize array storage method
\begin{lstlisting}[frame=single, language=c++]
template<typename T, int n>
class ArrayTP{...common implementation}
	
template<>
ArrayTP<bool, 100>{...specific implementation}
\end{lstlisting}
\begin{description}
	\item[Line 4 and 5:] There is empty<> after template. You should give you own implementation.
\end{description}
	
	\item implicit, explicit instantiation and explicit specification are all \textbf{specializations}. Because it produces a real function definition that uses specific types, The last result is not template at all 
	
	\item partial specification is different with explicit instantiation. Partial specification makes generic template a little narrow, but the result is still template. 
	 
	\item For class template, Explicit specialization includes complete specialization and partial specialization.
\begin{lstlisting}[frame=single, language=c++]
template<> class Pair<int,int>{...}; //complete specialization
template<typename T1> class Pair<T1, int>{...}; //Partial
\end{lstlisting}
	
	\item Non type argument and default type argument only define one template body(only one recipe). But Specialization need to define a generic template body(one recipe), For another type, It need to define a different template body(another recipe), because the code will be different with generic one.
	 
	 \textbf{Instantiation is different with specialization.  For instantiation, it will use template function to produce function body, but for specialization, you have to redefine you own function body }
	 
\begin{lstlisting}[frame=single, language=c++]
Template<typename T>
void sortedArrary (T t) {...};

template void sortedArray<Person>(Person);

template<> void sortedArray<Person>(Person t){
.... //give you own definition of template fun body.
};
.
\end{lstlisting}
\begin{description}
	\item[Line 4:] It is explicit instantiation. you don't need give function parameter name. because it's a function declaration.
	\item[Line 6:] it is specialization. Pay attention, compared with explicit instantiation, there is empty <> after template in specialization.
\end{description}

	\item For function template, there is no partial specialization, So explicit specialization is complete specialization.
\end{enumerate}


\item Instantiation happen in compiling time, not running time. When you declare a variable, It will instantiation. (It will make compiling time longer). So all the template definition must be put in head file. 
	
\item \textbf{compiler will parse the template definition before it instantiation.} Why? It's a compiler, not a macro processor. Errors in the template itself won't be detected as long as it is only instantiated with 'friendly' types that don't trigger the errors: for example, if the template assumes that the type always has such-and-such a method.

\item C++ Coding standards 65 states customization of point. In order to understand it. You need to understand two basic conceptions: \textbf{"two phases lookup"} and \textbf{"dependent name"}.  

\item two phases lookup can see "Dependent name lookup for C++ templates" in the ref and "Two-Phase or Not Two-Phase: The Story of Dependent Names in Templates" in the ref.
\end{itemize}


\subsection{template specialization}
\begin{itemize}
	\item Class templates can be partially specialized, and the resulting class is still a template. Partial specialization allows template code to be partially customized for specific types in situations, such as:

	\begin{enumerate}
		\item A template has multiple types and only some of them need to be specialized. The result is a template parameterized on the remaining types.

		\item A template has only one type, but a specialization is needed for pointer, reference, pointer to member, or function pointer types. The specialization itself is still a template on the type pointed to or referenced.


		\item You can see that there is three level, It become narrower and narrower: 1) base template, 2)partial specialization 3) complete spcialization of member.
\begin{lstlisting}[frame=single, language=c++]
template <class T>
class Storage{
	T m_value;
public:
	Storage(T value){
	m_value = value;
}

template <class T>
class Storage<T*>{
	T* m_value;
public:
Storage(T* value){
	m_value = new T(*value);  //To make deep copy
}

template <>
Storage<char*>::Storage(char* value){
	// Figure out how long the string in value is
	int length = 0;
	while (value[length] != '\0')
		++length;
}
\end{lstlisting}
\begin{description}
	\item[Source code:] Line 1 is base template, line 9 is partial specialization and line 17 is Full specialization of constructor for type char* 
\end{description}

\end{enumerate}

	\item For function, there is no template partial specifization. Difference between template function overload and partial specializations:
\begin{enumerate}
	\item Partial specializations is just use in template class.
	\item Partial specializations need put another <type> after class name
	\item If you want to have custom implementation of function with same name, use overload function, if you need  custom implementation of class with same name, use partial specialization.
\begin{lstlisting}[frame=single, language=c++]
template <typename T1, typename T2>
class Pair{}  //general one

template <typename T1>
class Pair<T1, T1>  // partial specializations

template <typename T1>
class Pair<T1, int > // partial specializations
\end{lstlisting}

\item Keep the design of a template in mind and not use it blindly. When you input pointer as typename, you should be on high alert. If common template can't deal with pointer type very well, you can define a partial specializations.
\begin{lstlisting}[frame=single, language=c++]
template <typename T>
class Foo //general one

template <typename T>
class Foo<T*> //partial specializations.
\end{lstlisting}

\end{enumerate}

\item Explicit specification usually need define all the implementation in it. If there is a lot of repetition. There are two helpful options: 
\begin{enumerate}
	\item Add a special function just suitable for certain type. 
\begin{lstlisting}[frame=single, language=c++]
template <typename T>
class A{
public:
void onlyForInts(T t){
	static_assert(std::is_same<T, int>::value, "Only ints!");
}

protected:
	std::vector<T> myVector;
};

A<int> i;
i.onlyForInts(1); // works !

A<float> f;
//f.onlyForInts(3.14f); // does not compile !
\end{lstlisting}

\item Use type trait and overload, select at the compile time. See enable\_if example below.

\end{enumerate}

\item A very good article about specialization is chapter 12 in "C++ template: The complete guide". Remember, you should read each sentence in this chapter.
\begin{enumerate}
	\item You can complete(full) specialization of template class. 
	\item You also can complete(full) specialization of template function. 
	\item You can complete(full) specialization of member in template class. 
\begin{lstlisting}
template<> int f(int)
template<> 
class S<void>
// full specialization must have a empty template<>
\end{lstlisting}
	\item You can partial specialization template class.
\begin{lstlisting}
template<T> //1)has template<T>
class S<T*>  //2)after class name has another <>
\end{lstlisting}
	\item Pay attention the specialization of declaration. it should be after the basic template.
	\item \textbf{For template function, there is overload and full specialization, for template class, there is full and partial specialization. Template function doesn't support partrial specialization, because it can use overload to reach the same result.} 
\end{enumerate}

		\item pointer sometimes need to be deal with differently, at that time we need partial specialization of template class. A very good article is:\\ https://www.learncpp.com/cpp-tutorial/13-8-partial-template-specialization-for-pointers/. 
\end{itemize}


\subsection{template and friend}
\begin{itemize}
	\item You can have:
	\begin{enumerate}
		\item friend class.
		\item friend function.
		\item friend template.
	\end{enumerate}

	At the same time, they can be bound or non-bound. If it's bound, you can find host class parameter T in the friend declaration. 
	
	\item  There are three different kinds for a template class:
	\begin{enumerate}
		\item Non-template friend.
		\item Bound-template.
		\item Unbound-template.
	\end{enumerate}

\begin{lstlisting}
template<typename T>
class HasFriend{
	friend void counts();
}
\end{lstlisting}
\begin{description}
	\item[Line 3:] Non-template friend function counts(), The counts is not invoked by an HasFriend obj and has not object parameters.  If counts want to access a HasFriend object, It can access a global one, and use a global pointer to access non-global object.
\end{description}
	
	\item Bound-template friend function. You need to define explicit specialization for the friends you plan to use. Why, because \textbf{1)reports is not template function. 2) reports is not function defintion, 3) report is just function declaration.}
	
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
class HasFriend{
	friend void reports(HasFriend<T> &);
}
	
void reports(HasFriend<int> &hf){
	cout <<hf.item<<endl;
}
void reports(HasFriend<short> &hf){..}
\end{lstlisting}
\begin{description}
	\item[Line 6 to 9:] explicit specialization for the type you plan to use.
\end{description}
	
	\item A better bound-template, reports has <> after it.  and you don't need redefine reports many time like previous codes.\textbf{reports is a template function here. You can think that is a implicit instantiations. }
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
void reports(T &hf){
	cout <<hf.item<<endl;
}

template<typename TT>
class HasFriend{
	friend void reports<>(HasFriend<TT> &);
}
\end{lstlisting}
\begin{description}
	\item[Line 8:] It has <> after reports function name. that is a implicit instantiations.
\end{description}

	\item Non-bound friend template.
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
class ManyFriend{
	template<typename C, typename D>
	friend void show(C& , D&);
};
	
template <typename C, typename D> void show2(c& c, D& d){
	cout<<c.item<<d.item<<endl;
}
	
ManyFriend<int> mi;
ManyFriend<double>md;
show2(mi,md);
\end{lstlisting}
	
	\item Difference between bound and non-bound:
	
	\begin{enumerate}
		\item bound friend is specialization of template function, so It has <> after the function name.
		
		\item non-bound template use different typename, such as C and D in previous example, and it also use template keyword
		
		\item bound template will produce more function implementation , but non-bound template will only produce ONE function implementation.
	\end{enumerate}
\end{itemize}

\subsection{member function templates}

\begin{itemize}
	\item Use member function templates to accept
	"all compatible types." detail can be found in effective c++ item 45. An example can be found below, we define a template copy ctor member function, for a generalized copy ctor.
	
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
class SmartPtr {
public:
	template<typename U> // member template
	SmartPtr(const SmartPtr<U>& other); 
...
}
\end{lstlisting}
	
	\item When writing a class template that offers functions related to the template that support implicit type conversions on all parameters, define those functions as friends inside the class template. Detail can be found in effective c++ item 46.
	
	\item  Implicit type conversion functions are never considered
	during template argument deduction. Never. Such conversions are
	used during function calls, yes, but before you can call a function, you have to know which functions exist. 
	
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
class Rational {
public:
	...
	friend const Rational operator*(const Rational& lhs, 
	const Rational& rhs){
		return Rational(lhs.numerator() * rhs.numerator(), 
	lhs.denominator() * rhs.denominator());  
	} 
};
\end{lstlisting}

\end{itemize}



\section{Type Inference}

\subsection{template type deduction}

Given below code, We will introduce the basic type deduction rules.
\begin{lstlisting}[numbers=none]
template<typename T>
void f(ParamType param);

f(expr); // deduce T and ParamType from expr
\end{lstlisting}

\begin{enumerate}
	
	\item ParamType is a Reference or Pointer, but not a Universal Reference. If expr's type is a reference, \textbf{ignore the reference part}. Then pattern-match expr's type against ParamType to determine T.
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
void f(T& param); // param is a reference
	
int x = 27; // x is an int
const int cx = x; // cx is a const int
const int& rx = x; // rx is a reference to x as a const int
	
f(x); 
f(cx);  
f(rx); 
\end{lstlisting}
\begin{description}
	\item[Line 8:]  T is int, param's type is int\&
	\item[Line 9:]  T is const int, param's type is const int\&
	\item[Line 10:] T is const int, param's type is const int\&
\end{description}
	
	\item ParamType is a Universal Reference
	
	\begin{enumerate}
		\item If expr is an lvalue, both T and ParamType are deduced to be lvalue references.
		\textbf{although ParamType is declared using the syntax for an rvalue reference, its deduced type is an lvalue reference.}
		
		\item If expr is an rvalue, the "normal" (i.e., Case 1) rules apply.
		
		\item \textbf{Only universal reference deduction distinguishs lvalue and rvalue}
	\end{enumerate}
	
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
void f(T&& param); // param is now a universal reference
int x = 27; // as before
const int cx = x; // as before
const int& rx = x; // as before
	
f(x); 
f(cx); 
f(rx); 
f(27); 
\end{lstlisting}
\begin{description}
	\item[Line 7:]  x is lvalue, so T is int\&, param's type is also int\&.
	\item[Line 8:]  cx is lvalue, so T  and param's type are const int\&.
	\item[Line 9:] rx is lvalue, so T  and param's type are const int\&.
	\item[Line 10:] 27 is rvalue, so T is int, param's is therefore int\&\&.
\end{description}
	
	\item ParamType is Neither a Pointer nor a Reference. As before, if expr's type is a reference, \textbf{ignore the reference part}. If, after ignoring expr's reference-ness, expr is const, \textbf{ignore const too}. If it's volatile, also ignore that.
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
void f(T param); // param is now passed by value
	
int x = 27; // as before
const int cx = x; // as before
const int& rx = x; // as before
f(x); 
f(cx); 
f(rx); 
\end{lstlisting}
\begin{description}
	\item[Line 7 to 9:] T's and param's types are both int
\end{description}
	
	\item We only drop const and volatile qualifiers for by-value parameters. For parameters that are rererences-to-const pointer or pointers-to-const pointer, we don't skip const. Why?
\begin{lstlisting}
const int ci = 2;
int& ncr = ci; //compile error
const int& cr = ci; //compile ok
int v = ci; //compile OK, v is int, not const int
\end{lstlisting}
	
	\item We only skip top const. 
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
void f(T param); // param is now passed by value
	
const int* const p1 = &x;
f(p1)  
	
const int*& rp = p1;
f(p1)  
\end{lstlisting}
\begin{description}
	\item[Line 5:] param is const int*, top const has been skipped. 
	\item[Line 8:] //param is const int*, top const is default for reference. 
\end{description}
	
	\item \textbf{Conclusion:  Take four steps to decide:}
	\begin{enumerate}
		\item array or function decay to pointer, if they are not used to reference ParamType
		\item universal reference for lvaue, T is lvalue reference. (keep const)
		\item reference is ignored
		\item for value-type ParamType, const and volatile are ignored.
	\end{enumerate}
	
	\item The last method is manually specify the type.  
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
void f(T param); 
	
int &x = a;
f(x)  //T is int
   f<int&>(x) //T is int&
\end{lstlisting}
	
\end{enumerate}


\subsection{auto type deduction}
\begin{itemize}
	\item Just like a template type, auto follow the same deduction rule. template type deduction happens when you call a function or build a customize type. \textbf{auto deduction happen when you initialize using assignment. Here just think the auto is T in the template deduction.}
	
\begin{lstlisting}[frame=single, language=c++]
auto x = 27; // x is neither ptr nor reference
const auto& rx = x; //  rx is a non-universal ref.
auto && ax = 27; // ax is universal(forwarding) ref
\end{lstlisting}
	
	\item \textbf{When combine auto and brace init in assignment, it means std::initializer\_list<T>}
	
\begin{lstlisting}[frame=single, language=c++]
auto x = { 11, 23, 9 }; 

template<typename T> 
void f(T x);
f({ 11, 23, 9 }); 
	
void f(std::initializer_list<T> initList);//OK
\end{lstlisting}
\begin{description}
	\item[Line 1:] x's type is  \texttt{std::initializer\_list<int>}
	\item[Line 5:] error! can't deduce type for T
\end{description}
	
	\item auto in a function return type or a lambda parameter implies template type deduction, not auto type deduction.
\begin{lstlisting}[frame=single, language=c++]
auto createInitList(){
	return { 1, 2, 3 }; 
}
	
std::vector<int> v;
auto resetV =
[&v](const auto& newValue) { v = newValue; }; // C++14
	
resetV({ 1, 2, 3 }); 
\end{lstlisting}
\begin{description}
	\item[Line 2 and 9:] error! can't deduce type for { 1, 2, 3 }
\end{description}
	
	\item When use with auto, you need to be careful. The only situation where = is preferred over \verb={}= is when using auto keyword to get the type determined by the initializer.
\begin{lstlisting}[frame=single, language=c++]
auto z1 {99}; // z1 is an initializer_list<int>
auto z2 = 99; // z2 is an int

auto d = {1.23};
// d is a std::initializer_list<double>
auto d = double{1.23};
auto d = 1.23
\end{lstlisting}
\begin{description}
	\item[Line 7:] Good -- d is a double, not a std::initializer\_list.
\end{description}

	
	\item \texttt{auto\&\&} is a kind of forwarding reference.
\begin{lstlisting}[frame=single, language=c++]
auto&& uref1 = x; 
auto&& uref2 = cx; 
auto&& uref3 = 27; 
\end{lstlisting}
\begin{description}
	\item[Line 1:] x is int and lvalue, so uref1's type is int\&
	\item[Line 2:] cx is const int and lvalue, so uref2's type is const int\&
	\item[Line 3:] 27 is int and rvalue, so uref3's type is int\&\&
\end{description}

\end{itemize}



\subsection{decltype deduction}
\subsubsection{basice knowledge}
\begin{itemize}
	\item decltype has two different deduct rules when facing different kinds of expression.
	
	\begin{enumerate}
		\item Expression whose type is to be determined is a plain variable or function parameter, like x, or a class member access, like p->m\_x. In that case, decltype lives up to its name: it determines the type of the expression to be the declared type,
\begin{lstlisting}[frame=single, language=c++]
vector<int> v; // decltype(v) is vector<int>
struct S {
	int m_x;
};

int x;
const int cx = 42;
const int& crx = x;
const S* p = new S();

decltype(x) a;  // a is int, as auto a =x

decltype(cx) b; // b is const int
auto b = cx;  //auto ignore const, b is int

decltype(crx) c;  // c is const int&.
auto c = crx; //ignore reference and const, c is int

decltype(p->m_x) d; // d is int
auto d = p->m_x; //auto ignore const, d is int
\end{lstlisting}
\begin{description}
	\item[Line 19:] p is a pointer to const S. But decltype goes by the declared type, which is int.
\end{description}
		
		\item If expr is not case 1, then three different rules:
		\begin{enumerate}
			\item If expr is an lvalue, then decltype(expr) is T\&. 
			\item If expr is an xvalue, then decltype(expr) is T\&\&. 
			\item Otherwise, expr is a prvalue, and decltype(expr) is T.
		\end{enumerate}
	\end{enumerate}

	\item For the case 2, give more examples:
\begin{lstlisting}[frame=single, language=c++]
struct S {
	int m_x;
};
int x;
const int cx = 42;
const int& crx = x;
const S* p = new S();

typedef decltype((x)) x_with_parens_type;
typedef decltype((cx)) cx_with_parens_type;
typedef decltype((crx)) crx_with_parens_type;
typedef decltype((p->m_x)) m_x_with_parens_type;
\end{lstlisting}
	\begin{enumerate}
		\item  (x) has type int, and decltype adds references to lvalues. Therefore, x\_with\_parens\_type is int\&.
		
		\item The type of (cx) is const int. Since (cx) is an lvalue, decltype adds a reference to that: cx\_with\_parens\_type is const int\&.
		
		\item  The type of (crx) is const int\&, and it is an lvalue, decltype adds a reference. By the C++11 reference collapsing rules, that makes no difference. Hence, crx\_with\_parens\_type is const int\&.
		
		\item S::m\_x is declared as int. Since p is a pointer to const, the type of (p->m\_x) is const int. Since (p->m\_x) is an lvalue, decltype adds a reference to that. Therefore, m\_x\_with\_parens\_type is const int\&.
	\end{enumerate}

\item For some complex expression examples:
\begin{lstlisting}[frame=single, language=c++]
const S foo();
const int& foobar();
std::vector<int> vect = {42, 43};

typedef decltype(foo()) foo_type;
typedef decltype(foobar()) foobar_type;
decltype(vect[0]) first_element = vect[0];
double d1, d2;
typedef decltype(d1 < d2 ? d1 : d2) cond_type;
int x = 0;
typedef decltype(x < d2 ? x : d2) cond_type_mixed;
\end{lstlisting}

	\begin{enumerate}
		\item foo() is declared as returning const S. The type of foo()
is const S. Since foo() is a prvalue, decltype does not
add a reference. Therefore, \textbf{foo\_type is const S}.
		
		\item The type of foobar() is const int\&, and it is an lvalue. Therefore, decltype adds a reference. By the C++11 reference collapsing rules, that makes no difference. Therefore, \textbf{foobar\_type is const int\&.}
		
		\item std::vector<int>'s operator[] is declared to have return type int\&. Therefore, the type of the expression vect[0] is int\&. Since vect[0] is an lvalue, decltype adds a reference. By the C++11 reference collapsing rules, that makes no difference. Therefore, \textbf{first\_element has type int\&.}  
		
		\item  The type of the expresson is double, and the expression is an lvalue. Therefore, a reference is added, and \textbf{cond\_type is double\&.}
		
		\item The type of the expresson is double. The expressionis a prvalue, because in order to accomodate the promotion of x to a double, a temporary has to be created. Therefore, no reference is added, and \textbf{cond\_type\_mixed is double.}
	\end{enumerate}

\end{itemize}

\subsubsection{decltype usage}
\begin{itemize}
	
	\item \textbf{decltype can be used in deducting template function return value.}
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
template<typename T, typename U>
auto eff(T t U u) -> decltype(T*U){
....
}
\end{lstlisting}
	\item When the function return a lvalue reference, auto will not work here(skip reference), only decltype can success keep reference.
\begin{lstlisting}
template<typename Container, typename Index>
auto authAndAccess(Container& c, Index i) -> decltype(c[i]){
	authenticateUser();
	return c[i];
}

template<typename Container, typename Index> // C++14; works,
decltype(auto) authAndAccess(Container& c, Index i) {
	authenticateUser();
	return c[i];
}
\end{lstlisting}
\begin{description}
	\item[Line 8:] Pay attention to decltype(auto), it deduct template\_type\&, not only template\_type.
\end{description}
	
	\item make template function support universal reference.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
template<typename Container, typename Index> // final c++14
decltype(auto) authAndAccess(Container&& c, Index i) {
	authenticateUser();
	return std::forward<Container>(c)[i];
}
	
template<typename Container, typename Index> // final c++11
auto authAndAccess(Container&& c, Index i)
	-> decltype(std::forward<Container>(c)[i]){
		authenticateUser();
		return std::forward<Container>(c)[i];
	}

auto s = authAndAccess(queue,5);
auto s = authAndAccess(std::move(queue),5); 
\end{lstlisting}
\begin{description}
	\item[Line 14 and 15:] Both work here. For the firs,t it returns a lvalue reference and for the second, it returns a rvalue reference.
\end{description}
	
	\item The use of decltype(auto) is not limited to function return types. It can also be convenient for declaring variables when you want to apply the decltype type deduction rules to the initializing expression.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
Widget w;
const Widget& cw = w;

auto myWidget1 = cw; 
decltype(auto) myWidget2 = cw;
\end{lstlisting}
\begin{description}
	\item[Line 4:] auto type deduction: myWidget1's type is Widget.
	\item[Line 5:] myWidget2's type is  const Widget\&
\end{description}
	
	\item An important property of decltype is that its operand never gets evaluated. For example, you can use an out-of-bounds element access to a vector as the operand of decltype with impunity:
	
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
std::vector<int> vect;
assert(vect.empty());
typedef decltype(vect[0]) integer; 
//vect is empty now, but we use vect[0] in decltype.
\end{lstlisting}
	
	\item Another property of decltype that is worth pointing out is that when decltype(expr) is the name of a plain user defined type (not a reference or pointer, not a basic or function type), then decltype(expr) is also a class name. This means that you can access nested types directly:
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
template<typename R>
class SomeFunctor {
public:
	typedef R result_type;
	result_type operator()() {
		return R();
	}
SomeFunctor(){}
};

SomeFunctor<int> func;
typedef decltype(func)::result_type integer; // access nested type
\end{lstlisting}
	
	\item  \textbf{If you're declaring variables inside a class.} Instead of typing out the full name of the type of the iterator, you can use decltype:, you can't use auto.  This works because decltype doesn't actually execute the expression given as its argument-- it is only used by the type checker to determine a type.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
class A {
	std::vector<std::pair<int, std::string>> array;
	decltype(array.begin()) iter; 
};
\end{lstlisting}
\begin{description}
	\item[Line 3:] You don't need init expression here. you can't use auto here, because auto need init expression
\end{description}
	
	\item We could have also done the above example with declval. allows you to use decltype without constructing the object. The type doesn't even need a default constructor, and in fact, it can be used with an incomplete type. The above example could be rewritten as:
	
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
template <typename C>
decltype(std::declval<const C>().begin())
foo(const C& c){
	return one iterator of c
}
\end{lstlisting}
	
	\item declval is commonly used in templates where acceptable template parameters may have no constructor in common, but have the same member function whose return type is needed.
	
\begin{lstlisting}[frame=single, language=c++]
struct Default { int foo() const { return 1; } };

struct NonDefault{
NonDefault(const NonDefault&) { }
int foo() const { return 1; }
};
	
decltype(Default().foo()) n1 = 1;   
decltype(std::declval<NonDefault>().foo()) n2 = n1;
//ok now,  n2 is int
\end{lstlisting}
\begin{description}
	\item[Line 8 and 9:]  type of n1 is int, decltype(NonDefault().foo()) n2 = n1;  error: no default ctor
\end{description}
	
	\item result\_of usage. result\_of was introduced in Boost, and then included in TR1, and finally in C++0x. Therefore result\_of has an advantage that is backward-compatible (with a suitable library). decltype is an entirely new thing in C++, does not restrict only to return type of a function, and is a language feature.
\begin{lstlisting}[frame=single, language=c++]
struct foo {
double operator()(char, int);
};
//same
std::result_of<foo(char, int)>::type d1 = 10.0;
decltype(foo()('c', 1)) d2 = 10.0;
\end{lstlisting}

\item Basic knowledge of decltype detail can be found "How decltype Deduces the Type of an Expression: Case 1"
\end{itemize}

\subsection{check type}

\begin{itemize}
	\item There are three ways to view deducted type
	\begin{enumerate}
		\item use IDE
		\item use Compiler
\begin{lstlisting}[frame=single, language=c++]
template<typename T> // declaration only for TD;
class TD; // TD == "Type Displayer"

TD<decltype(x)> xType; 
TD<decltype(y)> yType; 
//elicit errors containing x's and y's types
\end{lstlisting}

	\item use typeid and std::type\_info::name
	
\begin{lstlisting}[frame=single, language=c++]
std::cout << typeid(x).name() << '\n'; 
\end{lstlisting}
		
	\end{enumerate}
	
\end{itemize}

\subsection{summary}
\begin{itemize}
	\item \texttt{auto}, template T and decltype are three kinds of type deduction context. auto and template T are almost same, beside when we meet initilizaer\_list. but decltype are quite different with the other two. 
	
	\item When you use decltype(auto), \textbf{auto tell compiler to automaticly type deduction, but please use decltype rules.} They are most used when we deal with some expression which return back lvalue, such as a[0], in this way, if you use auto, it will ignore reference. but decltype will keep it. 
	
	\item \texttt{auto} can be used to set the type of a newly declared variable from its initializing expression. It removes the reference, if any, from the expression's type, then removes top-most const and volatile qualifiers.
	
	\item decltype can be used in a wider variety of contexts, such as typedefs, function return types, and even in places where a class name is expected. There are two different ways in which decltype(expr) can work, depending on the nature of expr
	
	
	\item Basic idea can be illustrated below: \newline
	\includegraphics[scale=0.7]{pics/type_deduct.png}
\end{itemize}

\section{type traits and policy}
\subsection{implementation}
\begin{itemize}
	\item \textbf{The most common way of implementation is template class specification.}
	\begin{enumerate}
		\item most common usage of trait is member constants, such as \texttt{is\_integer<T>::value}
		
		\item You use a templated structure, usually named with the type trait you are after. Eg) \texttt{is\_integer, is\_pointer, is\_void}. The structure contains a static const bool named value which defaults to a sensible state. You use a type trait by querying its value, like: \texttt{my\_type\_trait<T>::value}
		
		\item Make default template return default value, then make template specification return what you expect. 
\begin{lstlisting}[frame=single, language=c++]
template <typename T>
struct is_swapable {
	static const bool value = false;
};
		
template <>
struct is_swapable<short> {
	static const bool value = true;
};
		
template <>
struct is_swapable<int> {
	static const bool value = true;
};
\end{lstlisting}
		\item A good article is "A simple introduction to type traits"
	\end{enumerate}
	
	\item Another way is to build new trait based on existing trait.
\begin{lstlisting}[numbers=none]
template <typename T>
struct is_swapable {
	static const bool value = 
	std::is_integral< T >::value && sizeof(T)>=2;
};
\end{lstlisting}
	
\item Type trait implementation trick, use \texttt{sizeof} and \texttt{static\_cast}, these two can be executed at compile time. For example, we want to test if a class derived from another class.
\begin{lstlisting}[frame=single, language=c++]
template<typename D, typename B>
class IsDerivedFromHelper{
	class No { };
	class Yes { No no[3]; };
	
	static Yes Test( B* );
	static No Test( ... );
	public:
	enum {Is = sizeof(Test(static_cast<D*>(0)))
	                             == sizeof(Yes) };
	
};
	
template <class C, class P> 
bool IsDerivedFrom() {
	return IsDerivedFromHelper<C, P>::Is;
}
\end{lstlisting}
	
	\item In C++11, you can use constexpr instead of sizeof, and \textbf{decltype and declval also get type in the compiling time.}. 
	\begin{enumerate}
		\item two overload template test functions. One return true, default return false.
		
		\item In the funciton which return true, use decltype and declval to simulate call some functions you want to judge. make these type used in function parameter or return 
		
		\item Pay attention to the usage of \texttt{static constexpr bool}. Use test function to initialized \textbf{constexpr value} 
		
	\end{enumerate}
\
\item Examples1, one is judge if T has member function.

\begin{lstlisting}[frame=single, language=c++]
template <class T>
struct IsFunction{
	// int (*p)[1]  pointer to arry(int [1])
	// int *p[1], that is array of pointer .
	template <typename C> 
	static constexpr bool test(C (*)[1] ){
		return true;
	}
	
	template <typename C> 
	static constexpr bool test(...){
		return false;
	}
	//use 0 as pretend pointer.
	static constexpr bool value = test<T>(0);
};

int f();
IsFunction<decltype(f)>::value; //value is true 
\end{lstlisting}


\item  Another example is to test if T is function. We test if the type has serialize using decltype and declval.

\begin{lstlisting}[frame=single, language=c++]
template <class T> 
struct hasSerialize{
	template <typename C>
	static constexpr 
	     decltype(std::declval<C>().serialize(), bool())
	     
	test(int /* unused */){
		return true;
	}
	
	template <typename C>
	static constexpr bool test(...){
		return false;
	}
	
	// int is used to give the precedence!
	static constexpr bool value = test<T>(int());
};
\end{lstlisting}
	
\item last kind of implementation is use category. An example can be found in iterator.
	
\begin{lstlisting}[frame=single, language=c++]
struct input_iterator_tag {};
struct output_iterator_tag {};
struct forward_iterator_tag: 
          public input_iterator_tag {};
          
struct bidirectional_iterator_tag: 
          public forward_iterator_tag {};
          
struct random_access_iterator_tag: 
          public bidirectional_iterator_tag {};
	
template < ... > // template params elided
class deque {
	class iterator {
	public:
		typedef random_access_iterator_tag 
		                   iterator_category;
	};
	
template<typename IterT>
struct iterator_traits {
	typedef typename IterT::iterator_category 
	                      iterator_category;
};
	
template<typename T> // partial template specialization
struct iterator_traits<T*>{ // for built-in pointer types
	typedef random_access_iterator_tag iterator_category;
};
\end{lstlisting}

\begin{enumerate}
	\item what is function type?
\begin{lstlisting}
typedef int FT(); //FT is type

int f();  //f is variable
FT* fp= f; 

FT fv; 
void fv(){...} 
\end{lstlisting}
	\begin{description}
		\item[Line 4:] usage of FT : fp is variable and type is function pointer
		\item[Line 6:] just like int fv(); declare a function. How to define this varaible make it linkable? Just like common funciton definition.
	\end{description}
	
	\item You can not define function type array.
\begin{lstlisting}
typedef int FT(); //FT is type
FT fa[3]; 
\end{lstlisting}
	\begin{description}
		\item[Line 2:] compile error, error: declaration of 'fa' as array of functions
	\end{description}
\end{enumerate}

	\item How to deal with member function pointer? Given an example code below, if you want to have member function pointer, its type should be: \texttt{int (A::*)() const \&} 
\begin{lstlisting}[frame=single, language=c++]
struct A {
	int fun() const&;
};
typedef int FunSignature() const&;
FunSignature A::*p = &A::fun;
\end{lstlisting}
\item When we want to use template class to deduct it, it can be used in \textbf{\texttt{U T::*}}.
\begin{lstlisting}[frame=single, language=c++]
struct A {
	int fun() const&;
};

template<class T, class U>
struct PM_traits<U T::*> {
	using member_type = U;
};

int main() {
	using T = PM_traits<decltype(&A::fun)>::member_type; 
	// T is int() const&
}
\end{lstlisting}
	
	\item Based on previous knowledge, we can implement 
\begin{lstlisting}[frame=single, language=c++]
template< class T >
struct is_member_function_pointer_helper : std::false_type {};
	
template< class T, class U>
struct is_member_function_pointer_helper<T U::*> :
                               std::is_function<T> {};
	
template< class T >
struct is_member_function_pointer : 
    is_member_function_pointer_helper<
    		 std::remove_cv_t<T>  {};
	
class A {
public:
	void member() { }
};
// output 0 if A::member is a data member and not a function
cout<<std::is_member_function_pointer<
			decltype(&A::member)>::value
\end{lstlisting}
	
	\item summary: Common type traits implementation methods
	\begin{enumerate}
		\item template specification: is\_integer
		\item use basic trait: is\_swap
		\item use template paramter deduciton : std::is\_function and
		is\_member\_function, is\_array, is\_class(T::*)
		\item define trait in existing class : iterator\_trait.
		\item overload template function, deduct return or function parameter based on template parameter T's expression:  has\_serialize, isIsFunction
	\end{enumerate}

	\item There are two articles which are good.
"An introduction to C++'s SFINAE concept: compile-time introspection of a class member" and "checking expression validity in-place with C++17"
\end{itemize}


\subsection{Usage}
\begin{itemize}
	\item A type trait is a way for you to get information about the types passed in as template arguments, at compile time, so you can make more intelligent decisions. 
	
	\item A type trait can return any information or customization about a type. A simple example is is\_integer, it just return bool value information. A complex example is char\_trait. it can return a few functions. In this way, you also can think that char\_trait is a policy. 
	
\end{itemize}


\section{Template function}
\begin{itemize}
	\item When you use template function with real argument, compiler will deduct type from real argument, then generate real function code for you.  So it will make compiling longer.
	
\begin{lstlisting}[numbers=none]
swap(i1, i2);
swap(f1, f2);
\end{lstlisting}
\begin{description}
	\item[Source code:] compiler can extract type information from i1. compiler will produce two swap functions bodies.
\end{description}

	\item Why we need a overload template function? Because not all type support the same operation. For example, in your template function, you use = operator, but when you use array for this template function type, compiler will report error.
\begin{lstlisting}[numbers=none]
template <typename T>
void swap(T a[], T b[], int n)

template <typename T>
void swap(T &a, T &b )
\end{lstlisting}

\item Overload is different with Specializations, Overload means that you have different function signatures. Specialization have the same function signature.

\item Some good articles:\newline
"Why Not Specialize Function Templates?" .
\newline
"Why Argument Dependent Lookup doesn't work with function template dynamic\_pointer\_cast". 
\newline
"C++ template function taking template class as parameter".
\end{itemize}


\subsection{overload resolution}
\begin{itemize}
	\item Given a function name, you can have regular, template and explicit specialization temple. When pick a function, regular> specialization> template. function picking ranking from best to worst is:
	\begin{enumerate}
		\item Exact math, regular function.
		\item Template if you have define the same template function name.
		\item Conversion by promotion.
		\item Conversion by standard conversion.
		\item user-defined conversion.
	\end{enumerate}

\item What is exact match. There are table below:

\begin{tabular}{|c|c|}
\tophline
Actual argument & Formal argument \\
\tophline
type-name & type-name \& \\
\tophline
type-name \& & type-name \\ \tophline
type-name [ ] &  type-name* \\ \tophline
type-name ( argument-list ) & ( *type-name ) ( argument-list ) \\ \tophline
type-name  & const type-name \\ \tophline
type-name  &  volatile  type-name \\ \tophline
type-name*  & const type-name*  \\ \tophline
type-name*  & volatile  type-name*  \bottomhline
\end{tabular}

	\item About exact match, there are three result:
	\begin{enumerate}
		\item If there are two exact matches, compiler can't distinguish them, then it will report error.
		
		\item If reference and pointer, even there are two exact match, It will pick up first according to const.
\begin{lstlisting}[frame=single, language=c++]
int i = 2;

f(const int& j); //#1
f(int& j);  //#2, 
\end{lstlisting}
\begin{description}
	\item[Source code:] \#2 will be selected, because i isn't const.
\end{description}
		\item If there are exact match, it will pick up before template, even template has EXACT specification.
\end{enumerate}

	\item For template, order is:
	\begin{enumerate}
		\item specialized argument template
		\item specialization version inside this specialized argument template.
	\end{enumerate}
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
f(T t);  //#1

template< >f<int*>(int* t) #2

template<typename T>
f(T* t); //#3

template<> f<int> f( int* t) //#4

int * p;
f(p) // #4>#3>#2>#1
\end{lstlisting}

\item For above example, If you omit type inside <> after function name f, It will depends on location.
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
f(T t);  //#1

template< >f<>(int* t) //#2 is specialization of #1

template<typename T>
f(T* t); //#3

template< >f<>(int* t) //#4 here is specialization of #3

int *p; 
f( p ); 
\end{lstlisting}
\begin{description}
	\item[Line 12:] If put specialization at \#2, it will call \#3,wrong! If put specialization at \#4, it will call \#4,right!.
\end{description}

\item You can tell compiler that you prefer template function over overload one.

\begin{lstlisting}[frame=single, language=c++]
template<typename T>
void f(T t);  //#1

void f(int t) //#2

f<>(2) //tell compiler use #1, not #2.
\end{lstlisting}

\end{itemize}



\subsection{template function specification}
\begin{itemize}

	\item Explicit Specialization: Because for char *, you can't use > , but use strcmp.  So you need to build explicit Specialization Version. The prototype and definition of an explicit spcialization should be preceded by template<> and should mention the specialized type by name.
\begin{lstlisting}[numbers=none]
Template<typename T>
      void sortedArrary(T) {...};

template<> void sortedArray<const char *>(){...}
\end{lstlisting}

\item Some explicit specification syntax.
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
void foo(T param);

void foo(int param);

void foo<int>(int param);

template <> void foo<int>(int param);

template <> void foo(int param); 

template void foo(int param);  
template void foo<int>(int param); 
template void foo<>(int param); 
\end{lstlisting}
\begin{description}
	\item[Line 4:] syntax 1: not a specialization, it is an overload
	\item[Line 6:] syntax 2: ill-formed, not recommend
	\item[Line 8:] syntax 3: normal explicit specialization, specify T directly
	\item[Line 10:] explicit specialization. syntax4: same as above, but use template argument deduction
	\item[Line 12:] explicit instantiation syntax5: but works only if template argument deduction is possible!
	\item[Line 13 and 14:] both explicit instantiation
	
\end{description}
\item There seems to be (a lot) of confusion regarding explicit instantiation and specialization. The code I posted above deals with explicit instantiation. The syntax for specialization is different. Here is syntax for specialization: Note that angle brackets after template!

\begin{lstlisting}[numbers=none]
template <typename T> void func(T param) {} // definition

template void func<int>(int param); 
// explicit instantiation.

template <> void func<int>(int param) {} 
// specialization
\end{lstlisting}

	\item  If you want to customize a function base template and want that customization to participate in overload resolution (or, to always be used in the case of exact match), make it a plain old function, not a specialization. And, if you do provide overloads, avoid also providing specializations. Detail you can google" Why Not Specialize Function Templates?" \textbf{prefer to use overload than template function specification.}

\end{itemize}

\subsection{summary}
\begin{itemize}
\item A good article is "Overload resolution" in Andrzej's C++ blog. \textbf{It taught you 1) name kookup and 2)overload and 3)instanition three conception very well.}


\includegraphics[scale=0.8]{pics/template.png}

\item More explanation about previous figure.
\begin{enumerate}
\item p1 and p2, 
\begin{lstlisting}[frame=single, language=c++]
template <typename T> struct Base {
	typedef int MyType;
};

template <typename T> struct Derived : Base<T> {
	void g() {
		// MyType k = 2;
		// Base<T>::MyType k = 2;
		
		// C. works!
		typename Base<T>::MyType k = 2;
	}
};
\end{lstlisting}
\begin{description}
	\item[Line 7:]  error: 'MyType' was not declared in this scope
	
	\item[Line 8:] error: need 'typename' before 'Base<T>::MyType' because 'Base<T>' is a dependent scope.
\end{description}

\begin{lstlisting}[frame=single, language=c++]
struct Foo {
	template<typename U>
	static void foo_method(){
	}
};

template<typename T> void func(T* p) {
	// T::foo_method<T>();
	
	//  works!
	T::template foo_method<T>();
}
\end{lstlisting}
\begin{description}
	\item[Line 8:] error: expected primary-expression before '>' token
\end{description}

\item p3
\begin{lstlisting}[numbers=none]
template <typename T> struct Base {
   void f() {...}
};

template <typename T> struct Derived : Base<T> {
   void g() {
       //f(); error happen here. 
       this->f() will resolve problem.
   }
};
\end{lstlisting}


\item p4 name look up has two stages. 1) from process function, then it found a) current namespace, b)using namespace and c)all previous declaration.  At these time only f(T) is visible, Then add it into overload options.  2) When T is knowing, It will search all options in the boost namespace, \textbf{At this time, it will not search framework namespace again}

\begin{lstlisting}[numbers=none]
namespace framework { // library 1
	template <typename T>
	void f(T) { puts("master");}
 
	template <typename T>
	void process(T v) { f(v); }
}
 
namespace boost {     // library 2
	template <typename T>
	struct optional {};
}
 
namespace framework  {     
	template <typename T>
	void f(boost::optional<T>) { puts("optional<T>"); }
    
	inline void f(boost::optional<bool>) 
	                { puts("optional<bool>"); }
}
 
int main(){
	int i = 0;
	boost::optional<int>  oi;
	boost::optional<bool> ob;
  
	framework::process(i); //output three "master"
	framework::process(oi);
	framework::process(ob);
}
\end{lstlisting}


\item p5, In instaniation, with help of ADL, boost namespace is searched and two other functions are added into overload options.

\begin{lstlisting}[numbers=none]
namespace framework{  // library 1
  template <typename T>
  void f(T) { puts("master"); }
 
  template <typename T>
  void process(T v) { f(v); } 
}
 
namespace boost{      // library 2
  template <typename T>
  struct optional {};
}
 
namespace boost {      // some glue between 1 and 2
  template <typename T>
  void f(optional<T>) { puts("optional<T>"); }
    
  inline
  void f(optional<bool>) { puts("optional<bool>"); }
}
 
int main(){
  int i = 0;
  boost::optional<int>  oi;
  boost::optional<bool> ob;
  
  framework::process(i);
  framework::process(oi);
  framework::process(ob);
}
\end{lstlisting}

\item p6 template specification happen in the end and after overload. 
\begin{lstlisting}[numbers=none]
namespace framework  // library 1
{
  template <typename T>
  void f(T) { puts("master"); }
 
  template <typename T>
  void process(T v) { f(v); } 
}
 
namespace boost{      // library 2
  template <typename T>
  struct optional {};
}
 
namespace framework{  // some glue between 1 and 2
  template <>
  void f<boost::optional<bool>>(boost::optional<bool>)
  { puts("optional<bool>"); }
}
 
int main() {
  int i = 0;
  boost::optional<bool> ob;
  
  framework::process(i);
  framework::process(ob);
}
\end{lstlisting}

\item Another interesting example:
\begin{lstlisting}[frame=single, language=c++, numbers=left,
stepnumber=1,]
template<typename T>
void f(T i){
	cout<<"template "<<i<<endl;
}

//template<> void f<short>(short s);
void g(void){
	//int s = 5; //output template
	short s = 5; 
	//uncomment above specification, call specification version.

	//"Specification after initialzation.
	f(s);
}

template<> void f<short>(short s){
	cout<<"specification" <<s <<endl;
}
void f(short s){
	cout<<"short " <<s<<endl;
}

int main(){
	g();
}
\end{lstlisting}


\begin{enumerate}
	\item put line 19 and line 16 two  functions before function g, it will call regular exact mathch funciton void f(short). 
	
	\item put void f(short) after function g, it will can full specification version
	
	\item comment line 6(specification decalaration). report error:\\
	error: specialization of 'void f(T) [with T = short int]' after instantiation.
	Because it has instantiation f(short) version from generic template, you can't specialize it any more.
	 
	\item \textbf{Although exact match and specification have higher order, but you you mush make it visible by declaring them before the caller.}
\end{enumerate}

\end{enumerate}

\end{itemize}


\section{template class and inheritance}

\begin{itemize}
	
	\item Non-Template class Derived from Template Base class specification

\begin{lstlisting}[numbers=none]
class u8toU16 : public 
           std::codecvt<wchar_t, char, std::mbstate_t>{
	...
};
\end{lstlisting}

	\item Template class Deriving from the non-template class
\begin{lstlisting}[numbers=none]
class Base
	
template<typename T>
class Derived: public Base
\end{lstlisting}	
	
	\item template class can be used as base class and used as a component class. So we can inehrite from a template class
\begin{enumerate}
	\item A basic example
\begin{lstlisting}[numbers=none]
template< typename Type>
class SpecialStack: public Stack<Type>{
	Array<Type> array;
}
\end{lstlisting}	
	
	\item If an enum is used by several member functions of the std::codecvt template class, and does not relate to the template parameters. Hence it can exist in a separate base class.
	
\begin{lstlisting}[numbers=none]
template<typename T>
class codecvt_base{
public:
	enum result {ok, partial, error, noconv};
};
\end{lstlisting}
	
	\item You also can extending the derived class
\begin{lstlisting}[numbers=none]
template< typename T>
class Base
	
template<typename T, typename U>
class Derived: public Base<T>
\end{lstlisting}
	
	
	\item Factor parameter-independent code out of templates. detail can be found in effective item 44. That is to avoid code bloating.
\begin{lstlisting}[frame=single, language=c++]
template<typename T> // size-independent base class for
class SquareMatrixBase { // square matrices
protected:
	...
	void invert(std::size_t matrixSize); 
	...
};
	
template<typename T, std::size_t n>
class SquareMatrix: private SquareMatrixBase<T> {
private:
	using SquareMatrixBase<T>::invert; 
public:
	...
	void invert() { invert(n); } 
	}; // version of invert
\end{lstlisting}
\begin{description}
	\item[Line 5:] invert matrix of the given size.
	\item[Line 12:] make base class version of invert visible in this class; see Items 33 and 43
	\item[Line 15:] make inline call to base class
\end{description}

	
	\item Specializing the base class
\begin{lstlisting}[numbers=none]
template< typename T>
class Base
	
template<typename T>
class Derived: public Base<int>
\end{lstlisting}
\end{enumerate}

\item Parameterised inheritance
	\begin{enumerate}
	\item Basic example 
\begin{lstlisting}[numbers=none]
template<typename T>
class Derived: public T
\end{lstlisting}
	
	\item \textbf{Two famous idioms are Mixin and Policy, can be found below sections. In this chapter, we only focuse syntaxtic level, not semantic level.}

	\end{enumerate}

\item It can be used as private inheritance. An example can be found in policy section. 

\item public inheritance. A good introduction can be found in "modern c++ design" first chapter, about creator template class.\textbf{public inheritance means the derived class want to expose the public interface in base class}

\item public inheritance will expose interface to outside, just like Create() function. private inheritance just implement it. 

\begin{lstlisting}[numbers=none]
template <class T>
struct OpNewCreator{
	static T* Create(){
		return new T;
	}
};
template <class T>
struct MallocCreator{
	static T* Create(){
		void* buf = std::malloc(sizeof(T));
		if (!buf) return 0;
		return new(buf) T;
	}
}; 
// Library code
template <class CreationPolicy>
class WidgetManager : public CreationPolicy{
...
}; 
// Application code
typedef WidgetManager< OpNewCreator<Widget> > MyWidgetMgr; 
\end{lstlisting}

\item \textbf{private inheritance is not the first choice, but the last choice For above example, you don't need private inheritance, you can use previous section "Templates Parameterized by independent class". It's much clear. If policy class has protect member function which we want to use, at this time. private inheritance is our last choice. }
\end{itemize}

\section{template common idiom}
\begin{itemize}
	\item Some common used idioms in std:
	\begin{enumerate}
		\item concept
		\item traits
		\item tag dispatching
		\item adaptors
		\item type generators
		\item object generators
		\item policy classes
	\end{enumerate}

	
\end{itemize}

\subsection{policy, mixin and CRTP}
These three patterns are associated, so I put them together. 

\subsubsection{policy}
\begin{itemize}
	
	\item The Policy class can be thought as an optional of multi-inheritance. 
	
\begin{lstlisting}[numbers=none]
template <typename OutputPolicy, typename LanguagePolicy>
class HelloWorld : private 
          OutputPolicy, private LanguagePolicy{
public:
	void run() const{
		// Two policy methods
		print(message());
	}
};
	
class OutputPolicyWriteToCout{
protected:
	template<typename MessageType>
	void print(MessageType const &message) const{
		std::cout << message << std::endl;
	}
};
	
class LanguagePolicyEnglish{
protected:
	std::string message() const{
		return "Hello, World!";
	}
};
	
class LanguagePolicyGerman{
protected:
	std::string message() const{
		return "Hallo Welt!";
	}
};
\end{lstlisting}
\item Client code is below:
\begin{lstlisting}[numbers=none]
int main(){
	/* Example 1 */
	typedef HelloWorld<OutputPolicyWriteToCout, 
	     LanguagePolicyEnglish> HelloWorldEnglish;
	
	HelloWorldEnglish hello_world;
	hello_world.run(); // prints "Hello, World!"
	
	/* uses another language policy */
	typedef HelloWorld<OutputPolicyWriteToCout, 
	     LanguagePolicyGerman> HelloWorldGerman;
	
	HelloWorldGerman hello_world2;
	hello_world2.run(); // prints "Hallo Welt!"
}
\end{lstlisting}
	

		\item If this polymorphism can be known at compile time, we can use "static polymorphism". Use template parameter inject a class with static method. They can be inline and without any runtime overhead. 
\begin{lstlisting}[frame=single, language=c++]
// char_traits::eq
#include <iostream>   // std::cout
#include <string>     // std::char_traits
#include <cctype>     // std::tolower
#include <cstddef>    // std::size_t
	
// traits with case-insensitive eq:
struct custom_traits: std::char_traits<char> {
	static bool eq (char c, char d) { 
	return std::tolower(c)==std::tolower(d); 
}
	
static const char* find (const char* s, std::size_t n, char c)
	{ while( n-- && (!eq(*s,c)) ) ++s; return s; }
};
	
std::basic_string<char,custom_traits> str ("Test");
std::cout<< "found at position" <<str.find('t') ;
\end{lstlisting}
\begin{description}
	\item[Line 13:] some (non-conforming) implementations of basic\_string::find call this instead of eq:
\end{description}

	
	\item This kind of examples can be found a lot in the STL, most of time by a kind of functor. Basic idea is the same.
	
	\item All above technologies are part of generic programming. A good and more example about generic programming examples can be found in "Modern C++ desing" a book. The first chapter introduce policy pattern. The second chapter introduce a lot of ways to manage Type information at compile time. 
	
\end{itemize}

\subsubsection{Mixin}
\begin{itemize}
	\item \textbf{Mixin refers to the following idiom - a template class that is parameterized on its base class.} Here Mixin classes are template classes that define a generic behaviour, and are designed to inherit from the type you wish to plug their functionality onto.
	
	\item For example, \texttt{RepeatPrint} is Mixin class, T is the type you wish to plug their functionality onto.
\begin{lstlisting}[numbers=none]
template<typename T>
class RepeatPrint : T{
	explicit RepeatPrint(T const& printable) : T(printable) {}
	void repeat(unsigned int n) const{
		while (n-- > 0){
			this->print(); 
			//Make sure printable has print method
		}
	}
};
\end{lstlisting}
	
	\item Supposing that we have an existing type which has print method.
\begin{lstlisting}[numbers=none]
class Name{
public:
	Name(std::string firstName, std::string lastName)
	: firstName_(std::move(firstName))
	, lastName_(std::move(lastName)) {}
	
	void print() const{
		std::cout << lastName_ << ", " << firstName_ << '\n';
	}
	
private:
	std::string firstName_, lastname;
};
\end{lstlisting}
	
	\item We can use it two ways:
\begin{lstlisting}[numbers=none]
//method 1, we use object generator pattern
template<typename T>
RepeatPrint<T> rpGen(T const& printable){
	return RepeatPrint<T>(printable);
}
Name ned("Eddard", "Stark");    
rpGen(ned).repeat(10);

\\method 2, we need to specify type explicitly
RepeatPrint<Name> rp(ned);
rp.repeat(10)
\end{lstlisting}

\end{itemize}


\subsubsection{CRTP}
\begin{itemize}
	\item The basic syntax is Templates Parameterised by a Derived Class.
	
\begin{lstlisting}[numbers=none]
template <class T> 
struct Base{
	void interface(){
		// ...
		static_cast<T*>(this)->implementation();
		// ...
	}
	
	static void static_func(){
		// ...
		T::static_sub_func();
		// ...
	}
};
	
struct Derived : Base<Derived>{
	void implementation();
	static void static_sub_func();
};
\end{lstlisting}
	
	\item A easy way of "call back" is function pointer, but it can't be used inline. so There is efficiency problem. 
	
	\item You can use inheritance, It's runtime polymorphism, and has some runtime overhead. 
	
	\item There are two common usages from CRTP:
	\begin{enumerate}
		\item Static polymorphism. It avoids runtime polymorphism cost. 
\begin{lstlisting}[numbers=none]
template <typename T>
class Amount{
	public:
	double getValue() const {
		return static_cast<T const&>(*this).getValue();
	}
};

class Constant42 : public Amount<Constant42>{
public:
	double getValue() const {return 42;}
};

template<typename T>
void print(Amount<T> const& amount){
	//use base class reference
	std::cout << amount.getValue() << '\n';
}

Constant42 c42;
print(c42);
\end{lstlisting}
\item Adding Functionality
\begin{lstlisting}[numbers=none]
template <typename T>
struct counter{
	static int objects_created;
	counter(){ ++objects_created;}
};

template <typename T> int counter<T>::objects_created(0);

class X : counter<X>{
	// ...
};

X x;
cout<<X::objects_created<<endl;
\end{lstlisting}
	\end{enumerate}
\end{itemize}

\subsubsection{A practical example}
\begin{itemize}
	\item  Consider that there is a Task Manager framework. It is expected that there will be some common bits of functionality that should be reused across task implementations. I have selected task execution timing and logging of start and completion messages to serve as examples. We use six different ways to implement it.
	
	\item method 1, use Mixin
	\begin{enumerate}
		
		\item The function name (Execute) can be different. Here, we use the same name because we can recursive use it. such as: \texttt{LoggingTask< TimingTask< MyTask > > Task;}
		
		\item A detail can be found "C++ Mixins - Reuse through inheritance is good... when done the right way" and "Mixin Classes: The Yang of the CRTP"
		
\begin{lstlisting}[numbers=none]
class MyTask{
public:
void Execute(){
	std::cout << "task is executed" << std::endl;
	}
};
		
template< class T >
class LoggingTask : public T{
public:
	explicit LoggingTask(T const& t) : T(t) {}
			
	void Execute(){
		std::cout << "LOG: The task is starting - " ;
		T::Execute(); 
		std::cout << "LOG: The task has completed - " ;
	}
};
		
LoggingTask<  MyTask  > t;
t.Execute();
\end{lstlisting}
		
		\item if you have a MyTask value, you can build a helper function to build Mixin class 
\begin{lstlisting}[numbers=none]
template<typename Task>
LogTask<Task> getLogTask(Task const& task){
	//Call the below explicit ctor in LogTask class
	return LogTask<Task>(task);
}
		
getLogTask(task).Execute //with log funcitons
\end{lstlisting}
		
	\end{enumerate}
	
	\item method 2, use CRTP
	\begin{enumerate}
		\item Use base class extend and reuse function(Execute\_imp)
		\item Expose Execute interface to client by base class 
		\item Client can directly use MyTask.
	\end{enumerate}
\begin{lstlisting}[numbers=none]
template< class Task >
class LoggingTask {
public:
	void Execute(){
		std::cout << "LOG: The task is starting - " ;
		static_cast<Task const&>(*this).Execute_imp();
		std::cout << "LOG: The task has completed - " ;
	}
};
	
class MyTask:public LoggingTask<MyTask> {
public:
	void Execute_imp(){
		std::cout << ".task is executed..." ;
	}
};
	
MyTask t;
t.Execute();
\end{lstlisting}
	
	\item method 3, template Method
	\begin{enumerate}
		\item No template, just use run time polymorphism
		\item Base class define a basic flow of action, some part of action is override in the Child class, That is Template Method pattern in design pattern.
	\end{enumerate}
\begin{lstlisting}[numbers=none]
class BaseLoggingTask{
public:
	void Execute(){
		std::cout << "LOG: The task is starting - " ;
		OnExecute();
		std::cout << "LOG: The task has completed - ";
	}
	virtual void OnExecute() = 0;
};
	
// Concrete Task implementation that 
//reuses the logging code of the BaseLoggingTask
class MyTask : public BaseLoggingTask{
public:
	virtual void OnExecute(){
		std::cout << "task is executed..." << std::endl;
	}
};
	\end{lstlisting}
	
	\item method 4, command pattern
	\begin{enumerate}
		\item That is command pattern.
		\item For Logging Task, you can see the class \textbf{includes and derived from ITask at the same time}. 
		\item Command pattern is illustrated by below figure:
		\newline
		\includegraphics[scale=1.1]{pics/command.png}
	\end{enumerate}
\begin{lstlisting}[numbers=none]
class LoggingTask : public ITask{
	ITask* task_;
public:
	LoggingTask( ITask* task ) : task_( task ){ }
	
	~LoggingTask(){
	delete task_;
}
	
	virtual void Execute(){
		std::cout << "LOG: The task is starting - " 
		          << GetName().c_str() << std::endl;
		if( task_ ) task_->Execute();
		std::cout << "LOG: The task has completed - " 
		         << GetName().c_str() << std::endl;
	}
};
	
class MyTask : public ITask{
public:
	virtual void Execute(){
		std::cout << ".task is executed..." ;
	}
};
	
ITask* t = new LoggingTask(new MyTask()) ;
t->Execute();
\end{lstlisting}
	
	
	\item method 5, mixin many mixin

\begin{lstlisting}[numbers=none]
template< class T >
class LoggingTask : public T{
	public:
	void Execute(){
		std::cout << "LOG: The task is starting - " 
		         << GetName().c_str() << std::endl;
		T::Execute();
		std::cout << "LOG: The task has completed - " 
		         << GetName().c_str() << std::endl;
	}
};
	
template< class T >
class TimingTask : public T{
	Timer timer_;
public:
	void Execute(){
		timer_.Reset();
		T::Execute();
		double t = timer_.GetElapsedTimeSecs();
		std::cout << "Task Duration: " << t <<;
	}
};
	
class MyTask{
	public:
	void Execute(){
		std::cout << "task is executed..." ;
	}
};
	
tyedef LoggingTask< TimingTask< MyTask > > Task;
Task t4;
t4.Execute();
\end{lstlisting}

		\item method 6, policy base
\begin{lstlisting}[numbers=none]
class coutLog{
	void beginLog(){
		cout<< "LOG: The task is starting - " <<endl
	}
	
	void endLog(){
		cout << "LOG: The task has completed - "
	}
}
	
template<typename LogPolicy, typename TimePolicy>
class Task: private LogPolicy, TimePolicy{
	void Execute(){
		beginLog();
		beginTime();
		std::cout << "This is where the task is executed";
		endTime();
		endLog();}
\end{lstlisting}
	
	\item summary:
	\begin{enumerate}
		\item Policy can be used when you log and time funciton change a lot
		\item Mixin and command can be compose the multi-actions
		\item template is more effeicent than inheritance. 
		\item Command pattern can also be thought as composite pattern.
		\item Mixin will not change current class, but CRTP change the current class interface.
	\end{enumerate}
	
\end{itemize}

\subsubsection{summary}
\begin{itemize}
	\item Basic idea is illustrated below:

		\includegraphics[width=0.9\linewidth]{pics/mixin.png}

	
	\item For Contain pattern, we can use template template parameter.

		\includegraphics[width=0.9\linewidth]{pics/mixin_tt.png}

	
	\item For CRTP pattern, we can use template template parameter.

		\includegraphics[width=0.9\linewidth]{pics/crtp_tt.png}

\end{itemize}

\subsection{tag dispatch}
\begin{itemize}
	\item A famous usage of tag dispatch is iterator 
	\begin{enumerate}
		\item Pay attention to iterator\_traits. Why do we use it here? It's also a template. With specialization, it also support common pointer type.
		
		\item Client side may or may not be template. For advance, it should be template, because it need template parameter Inputiterator.
		
		\item There is some tag type which need to be defined. And you should use these tags in the functions which you want to dispatched by overload resolve in compiling time. 
	\end{enumerate}
\begin{lstlisting}[numbers=none]
struct input_iterator_tag { };
struct random_access_iterator_tag { };
	
namespace detail {
	template <class InputIterator, class Distance>
	void advance_dispatch(InputIterator& i, 
	           Distance n, input_iterator_tag) {
		while (n--) ++i;
	}
		
	template <class RandomAccessIterator, class Distance>
	void advance_dispatch(RandomAccessIterator& i,
	 Distance n, random_access_iterator_tag) {
		i += n;
	}
}
	
template <class InputIterator, class Distance>
void advance(InputIterator& i, Distance n) {
	typename iterator_traits<InputIterator>
	           ::iterator_category category;
	                   
	detail::advance_dispatch(i, n, category);
}
\end{lstlisting}
	
	\item The second implementation of tag dispatch is use integral\_constant
	\begin{enumerate}
		\item \textbf{std::true\_type use inegral\_constant(type generator)to define a new type. is\_arithmetic derived form true\_type or false\_type}
\begin{lstlisting}[numbers=none]
std::integral_constant<bool, true>
		
template< class T >
struct is_arithmetic : std::integral_constant<bool,
std::is_integral<T>::value ||
std::is_floating_point<T>::value> { };
\end{lstlisting}
		
		\item client side is also template
		\item is\_arithmetic is a kind of trait, When you input T, it return a unnamed type,but it inheriated from ture\_type, Then use overload resolving.
		\item overload funciton can return different types. foo's return type is `int` if it calls the `std::true\_type` overload and `double` if it calls the `std::false\_type` overload. So here we use auto as function return type.
	\end{enumerate}
\begin{lstlisting}[numbers=none]
template <typename T>
int foo_impl(T value, std::true_type) {
	// Implementation for arithmetic values
}
	
template <typename T>
double foo_impl(T value, std::false_type) {
	// Implementation for non-arithmetic values
}
	
template <typename T>
auto foo(T value) {
	// Calls the correct implementation function, 
	return foo_impl(value, std::is_arithmetic<T>{});
}
	\end{lstlisting}
	
	\item The third method: build your own trait, it define a value
	\begin{enumerate}
		\item build you own trait has\_serialize, it includes a bool memeber ::value
		
		\item You can use decltype, declval and constexpr to build this trait. 
		\item From this trait, it return value, not a type. So you need use enable\_if template in the client code. change the value to a type, then use the type to overload resolving.
		
		\item For false, enable\_if is empty define.
\begin{lstlisting}[numbers=none]
template <bool, typename T = void>
struct enable_if
{};
		
template <typename T>
struct enable_if<true, T> {
		typedef T type;
};
\end{lstlisting}

\item an example which use enalbe\_if. has\_serialize trait has been introduced in the type trait section, you can see the detail there. 

\begin{lstlisting}[numbers=none]
template <class T>
enable_if<has_serialize<T>::value, std::string>::type
serialize(const T& obj){
	return obj.serialize();
}

	// Contra-SFINAE to avoid ambiguity
template <class T>
enable_if<!has_serialize<T>::value, std::string>::type 
serialize(const T& obj){
	return to_string(obj);
}
\end{lstlisting}

	\end{enumerate}
	\item summary:
	
	\includegraphics[scale=0.9]{pics/tag_dispatch.png}
	
\end{itemize}

\subsubsection{enable\_if}
\begin{itemize}
	
	\item Note SFINAE. When we make the call do\_stuff(25), the compiler selects the first overload: since the condition std::is\_integral<int> is true, the specialization of struct enable\_if for true is used, and its internal type is set to int. The second overload is omitted because without the true specialization (std::is\_class<int> is false) the general form of struct enable\_if is selected, and it doesn't have a type, so the type of the argument results in a substitution failure.
	
\begin{lstlisting}[numbers=none]
template <typename T>
void do(typename enable_if<std::is_integral<T>::value, T>::type &t){
	// an implementation for integral types (int, char, unsigned, etc.)
}
	
template <typename T>
void do(typename enable_if<std::is_class<T>::value, T>::type &t) {
	// an implementation for class types
}
\end{lstlisting}
	
	\item This technology has been used widely inside of vector.
\begin{lstlisting}[frame=single, language=c++]
template <typename T>
class vector {
	vector(size_type n, const T val);
	
	template <class InputIterator>
	vector(InputIterator first, InputIterator last);
	...
}
	
	template <class _InputIterator>
	vector(_InputIterator __first,
	typename enable_if<__is_input_iterator<_InputIterator>::value &&
	!__is_forward_iterator<_InputIterator>::value &&
	... more conditions ...
	_InputIterator>::type __last);
\end{lstlisting}
	

	\item \textbf{use a few ways to implement type trait, then use enable\_if to use type trait to get generic programming(static polymorphism); That is generic programming basic idea.}


\begin{enumerate}
	\item use true\_type or flase\_type tag.
\begin{lstlisting}[numbers=none]
template <typename T>
auto get_value(T t, std::true_type) {
	return *t;
}

template <typename T>
auto get_value(T t, std::false_type) {
return t;
}

template <typename T>
auto get_value(T t) {
return get_value(t, std::is_pointer<T>{}); 
}
\end{lstlisting}
\item use SFINAE 

\begin{lstlisting}[numbers=none]
template <typename T, 
		std::enable_if_t<std::is_pointer_v<T>, int> = 0>
auto get_value(T t) {
	return *t;
}

template <typename T, 
typename std::enable_if_t<!std::is_pointer_v<T>, int> = 0>
auto get_value(T t) {
	return t;
}
\end{lstlisting}
\item use constexpr if: 

\begin{lstlisting}[numbers=none]
template <typename T>
auto get_value(T t){
	if constexpr (std::is_pointer_v<T>) {
		return *t;
	} else {
		return t;
	}
}
\end{lstlisting}
\end{enumerate}

\item A good article is "SFINAE and enable\_if"
\end{itemize}


\subsection{type erasure and concept}
\subsubsection{function}

\begin{itemize}
	\item function template support \textbf{copyable and callable.}
\begin{lstlisting}[numbers=none]
double add(double a, double b){
	return a + b;
}
	
struct Sub{
	double operator()(double a, double b){
		return a - b;
	}
};
	
double multThree(double a, double b, double c){
	return a * b * c;
}
	
using namespace std::placeholders;
map<const char,std::function<double(double, double){
{'+', add },                                         
{'-', Sub() },                                      
{'*', std::bind(multThree, 1, _1, _2) },             
{'/',[](double a, double b){ return a / b; }}};      

cout<<dispTable['+'](3.5, 4.5) <<dispTable['-'](3.5, 4.5) 
<< dispTable['*'](3.5, 4.5) << dispTable['/'](3.5, 4.5);
\end{lstlisting}
	
	\item If you want to check if a variable of type std::function is currently holding a valid function, you can always treat it like a boolean:
\begin{lstlisting}[numbers=none]
std::function<int ()> func;
	.......
if ( func ) { // if we did have a function, call it
	func();
}
\end{lstlisting}
	
	\item function can be used \textbf{CALL BACK} as a function argument. At this time, you can use reference, but you'd better pay attention reference dangling problem. 
	
\begin{lstlisting}[numbers=none]
void run_within_for_each(std::function<void (int)> func){
	vector<int> numbers{ 1, 2, 3, 4, 5, 10, 15, 20, 25 };
	for_each(numbers.begin(), numbers.end(), func);
}
	
void fun(int x){   //1) function pointer
	cout<<x<<endl;
};
	
auto lambda1 = [](int y){  //4) lamba
	cout << y <<endl;
};
	
run_within_for_each(fun);
run_within_for_each(lambda1);
\end{lstlisting}
	
	\item One big advantage of std::function over templates is that if you write a template, you need to put the whole function in the header file, whereas std::function does not. This can really help if you're working on code that will change a lot and is included by many source files.
	
	\item A good article: google "Should I use std::function or a function pointer in C++?" another is "How is std::function implemented?"
	
	
	\item In this way you can write a type-erased wrapper for any Whatever callbacks, counters, output streams, input generators.
	
\end{itemize}

\subsubsection{type erasure}
\begin{itemize}
\item When you implement type erasure, it always starts with making a list of the things you want to be able to do with your type-erased object - call it, destroy it, copy it, and so on. For example, A std::function affords copying and calling. A std::any affords copying, but not calling. A unique\_function affords calling and moving, but not copying.

\item Each affordance in your list turns into a virtual member function of AbstractWhatever, which will be overridden by WrappingWhatever<T> appropriately for T. Finally, the top-level Whatever will store a unique\_ptr<AbstractWhatever> ptr\_ (and/or an SBO buffer), and provide a clean non-virtual interface implemented completely in terms of calling virtual member functions on *ptr\_.

\item A \textbf{concept} is a set of requirements consisting of valid expressions, associated types, invariants, and complexity guarantees. A type that satisfies the requirements is said to \textbf{model} the concept. A concept can extend the requirements of another concept, which is called \textbf{refinement}.
\begin{enumerate}
	\item Valid Expressions are C++ expressions which must compile successfully for the objects involved in the expression to be considered models of the concept. For example, an \texttt{Iterator x} is expected to support the expressions \texttt{++x} and \texttt{*x}.

	\item Associated Types are types that are related to the modeling type in that they participate in one or more of the valid expressions. Typically associated types can be accessed either through typedefs nested within a class definition for the modeling type, or they are accessed through a traits class. For example, an iterator's value type is associated with the iterator through \texttt{std::iterator\_traits}

	\item Invariants are run-time characteristics of the objects that must always be true, that is, the functions involving the objects must preserve these characteristics. The invariants often take the form of pre-conditions and post-conditions. For example, Forard iterator is copied, the copy and original must comare equal.
	
	\item Complexity Guarantees are maximum limits on how long the execution of one of the valid expressions will take, or how much of various resources its computation will use.
\end{enumerate}


\item An implementation is below:

\includegraphics[scale=0.9]{pics/function1.png}

\item An implementation code is below:
\begin{lstlisting}[frame=single, language=c++]
struct Plus1 {
	int call(int x) const { return x+1; }
};

struct AbstractCallback {
	virtual int call(int) const = 0;
	virtual ~AbstractCallback() = default;
};

template<class T>
struct WrappingCallback : AbstractCallback {
	T cb_;
	explicit WrappingCallback(T &&cb) 
	                : cb_(std::move(cb)) {}
	                
	int call(int x) const override 
	          { return cb_(x); }
};

struct Callback {
std::unique_ptr<AbstractCallback> ptr_;

template<class T>
Callback(T t) {
	ptr_ = std::make_unique<WrappingCallback<T>>
	                            (std::move(t));
}
int operator()(int x) const {
	return ptr_->call(x);
}
};

int run_twice(const Callback& callback) {
	return callback(1) + callback(1);
}

int y = run_twice([](int x) { return x+1; });
assert(y == 4);
\end{lstlisting}
\item A good article is "What is Type Erasure" A detail implementation can be found in:\\ \verb|http://blog.bitfoc.us/p/525|
\end{itemize}



\chapter{STL}
\section{Basic}
\begin{itemize}
\item Effective STL item 48. Always include the proper headers.
\begin{enumerate}
\item Include corresponding header when you use container.
\item All but four algorithms are declared in <algorithm>. inner\_product, adjacent\_differene, partial\_sum and accumulate are in the <numeric>.
\item Special kinds of iterators , including istream\_iterators are in the <iterator>
\item Standard functors, eg less<T> and functor adapter not1, bind2nd are declared in <functional>. They are not recommended to use in C++11. Because C++ 11 introduce \textbf{function} and \textbf{bind} template.
\end{enumerate}


\item Containers, iterators, functions objects, and algorithms four parts. \textbf{Use functor customize algorithms, then apply algorithm on Containers by iterators.} Such as algorithm find, you can input two Iterators into the it.  Find don't care what container which he will look for a value in it.  Find() in fact is a template function, it doesn't use inheritance to make generic programming, but use template.   All the idea is explained here:\newline
http://www.cplusplus.com/reference/algorithm/for\_each/

\begin{lstlisting}[frame=single, language=c++]
struct Sum{
    Sum(): sum{0} { }
    void operator()(int n) { sum += n; }
    int sum;
};

 std::vector<int> nums{3, 4, 2, 8, 15, 267};

 std::for_each(nums.begin(), nums.end(), [](int &n){ n++; })
 
 Sum s = std::for_each(nums.begin(), nums.end(), Sum());
 cout<<s.sum<<endl;
\end{lstlisting}
\begin{description}
	\item[Line 9:]  g++ -std=c++11 compile lambda syntax.
	\item[Line 11:] It return a Sum struct.
\end{description}

\end{itemize}


\section{Container}

\subsection{Basic knowledge}
\begin{itemize}

\item For all container, \textbf{Copy in, Copy out}. In C++11, you can use emplace\_back to build object directly on the vector to avoid copy.
\begin{lstlisting}[numbers=none]
int j = 10;
vector<int> vc;
vc.push_back(j); // not j, but copy of j to vc

int i = vc.pop_back(); 
i = -99 // when you modify i, not effect on vc
\end{lstlisting}

\item Even copy in, copy out. vector is better than array in C language.Because it use heap memory, if you want to use stack memory, you can use std::array.
\begin{lstlisting}[numbers=none]
Foo farray[50]; //default ctor has been called 50 times.
Foo *parray = new Foo[50]; 
//Same, ctor will be called 50 times.

vector<Foo> fvc; // no default ctor has been called.
fvc.reserve(50);
\end{lstlisting}

\item \textbf{Anytime you want to write new [..] just for allocate dynamic array, using a vector or string instead, and using reserve() to allocate enough space.}


\item Copy in and copy out can cause efficient problem. Furthermore, It brings  another problem. when you inserting a derived class object into a container of base class objects is always error(slicing error). In order to fight this problem, you can use container of pointer. But it will cause resource leaking problem if you forget or an exception is thrown. So a better choice is use smart pointer. But don't use auto\_ptr in any container, It's prohibited in c++, and produce a compiler error, see effective stl item 8.

\item All container is not thread-safe. It's your duty to make thread-safe, and thread-safe is OS depended. Detail can be seen effective STL item 12
\begin{lstlisting}[numbers=none]
getMutexFor(v);
// do something on v.
releaseMutexFor(v);
\end{lstlisting}

\item There are three kinds of for-loop container syntax;
\begin{lstlisting}[numbers=none]
for(auto it = con.begin(), itend != con.end()
         it !=itend ; ++it){
   foo(*it);
}

for_each(con.begin(), con.end(), [](Element& e){
   foo(e);
});

for(auto & e : con){
   foo(e);
}
\end{lstlisting}

\end{itemize}


\subsection{Basic classifications}
\subsubsection{structure classification}
\begin{itemize}

\item STL container: sequence container, associative container and containter adapter:
\begin{enumerate}
\item sequence: vector, list, string,  deque
\item associative: map , multiset , set and multimap
\item adapter: stack, queue and priority\_queue.
\end{enumerate}

\includegraphics[scale=0.6]{pics/container.png}

\begin{enumerate}
\item  If you can find same name member functions in container, prefer to use member function than generic algorithm. Such as \textbf{sort, merge, remove, reverse, unique in list, and find, count, low\_bound in set and map. }


\item all container support empty(), size(), max\_size(), and swap(). max\_size() is just theoretic value. (4  functions)
\item First class container includes begin(), end(), rbegin(), rend(). insert() and erase(). (6 functions)
\item sequence container support pop\_back(), push\_back(),front() and back() (4 functions)
 while associative don't.
\item vector support operator[], list support push\_front and pop\_front. and deque support both. (3 function.)  By now deque support (4+6+4+3 = 17 functons)\textbf{container(4)--> first container(6)-->sequence container(4)-->deque(3)}
\item vector support reserve, list has reverse(\textbf{not reserve}) and splice().  deque support nothing.
\item list support it's own  version sort(), remove(), merge(),unique(). For other container, you can use the generic algorithm, Why list has its own? For sort(), list doesn't support random access iterator. For merge(), remove() and unique(). generic algorithm just use copy method, but list has high efficient pointer implementation, So list offer its own version merge(), remove(),sort(), unique().

\item All first class container support begin() and end(). Only sequence containers support push\_front() or push\_back(). \textbf{begin is not equal front, begin can be used for all first class container, but front only be used for sequence container.}

\begin{enumerate}
\item begin() and end() return iterator, and all first container support them.
\item front() and back() return reference, and all sequenced container support them.
\item push\_front() and push\_back() add element, and vector only support push\_back. deque and list support both.
\end{enumerate}


\item Associative container support It's own find(), count(),  lower\_bound(), upper\_bound() , equal\_range(). They share the same name with generic algorithm, Don't confuse them. When you deal with associative container, just use container member function, don't use generic algorithm. \textbf{Associative offer log-time lower\_bound, upper\_bound and equal\_range, but generic algorithm just linear time.}


\item deque is the data structure of choice when most insertions and deletions take place at the beginning or at the end of the sequence. It doesn't not guarantee continuity within memory, and higher constant factor cost than vector. Although both offer random access to elements and linear-time insertion and removal from middle of a sequence, the vector is faster.  In my evernote, you can see a implementation of deque.

\item difference between vector and deque:
\begin{enumerate}
\item vector has relocation problem,If vector has 1000, It probably need log(1000) = 10 times relocation. that is a little costly. On the contrary, deque just allocate a new place then insert pointer of new place to pointer map. It's relatively cheap.


\item Elements in a deque are not contiguous in memory; vector elements are guaranteed to be. So if you need to interact with a plain C library that needs contiguous arrays, or if you care (a lot) about spatial locality, then you might prefer vector.

\item For stack and queue default use deque as container inside. Why, because for a large amount of element, vector has relocation problem,
\end{enumerate}


\item All the container adapter support push(), pop(). and stack and priority\_queue support top(). They don't have any iterator.

\item If you want strongly error-safe code, such as transnational semantics for inserting and erasing, or need to minimize iterator invalidation, prefer a node-based container.

\item Using a vector for small list is almost always superior to using list. Even though inseriton in the middle of the sequence is a linear-time operation for vector and a constant-time operation for list. Vector usually outperforms list because of its better constant factor. \textbf{list's Big-Oh advantage doesn't kick in until data sizes get larger}

\item Store only values and smart pointers(unique\_ptr or shared\_ptr) in container.
\begin{enumerate}
\item To contain objects even though they are
not copyable or otherwise not value-like (e.g., DatabaseLocks and
TcpConnections), prefer containing them indirectly via smart pointers (e.g.,
container<shared\_ptr<DatabaseLock>> and \\
container<shared\_ptr<TcpConnection> >).

\item Optional values. When you want a map<Thing, Widget>, but some
Things have no associated Widget, prefer map<Thing, shared\_ptr<Widget> >.
\item Index containers. To have a main container hold the objects and access them using different sort orders without resorting the main container, you can set up secondary containers that "point into" the main one and sort the secondary containers in different ways using dereferenced compare predicates. But prefer a container of MainContainer::iterators (which are value-like) instead of a container of pointers.

\item To have a container store and own objects of different but related types, such as types derived from a common Base class, prefer container< shared\_ptr<Base> >. An alternative is to store proxy objects whose nonvirtual functions pass through to corresponding virtual functions of the actual object.
\end{enumerate}

\end{enumerate}

\end{itemize}


\subsubsection{memory classification}

\begin{itemize}
\item Another classification of containter : contiguous-base and node-base.
\begin{enumerate}
\item vector, string, and deque
\item list and slist(linked list), set and map(balanced trees)
\end{enumerate}

\item Why we have this point of view.
\begin{enumerate}
\item \textbf{Because all the contiguous-base container has invalidation of iterator(pointer, reference) problem. }
\item \textbf{All the node-base container only support bidirectional iterators. }
\item \textbf{All the node-base container don't have reserve() function and need NOT to worry allocation problem. deque doesn't have reserve() function either }
\end{enumerate}

\item About the iterator invalidation problem,  First, you need to know the invalidation rules below:
\begin{description}
\item[Insertion]
\begin{itemize}
\item Sequence containers
		\begin{enumerate}
		\item vector: all iterators and references before the point of insertion are unaffected, unless the new container size is greater than the previous capacity (in which case all iterators and references are invalidated)
		\item deque: all iterators and references are invalidated, unless the inserted member is at an end (front or back) of the deque (in which case all iterators are invalidated, but references to elements are unaffected)
		\item list: all iterators and references unaffected
		\end{enumerate}

\item Associative containers: [multi]{set,map} all iterators and references unaffected

\item Container adaptors:  stack, queue and priority\_queue: inherited from underlying container.(Usually, we don't use iterator in stack, queue and priority\_queue. Maybe you don't need to worry about it. )
\end{itemize}

\begin{lstlisting}[frame=single, language=c++, mathescape=true]	
vecArr.insert ( it + 2, 1 , 200 );
it = vecArr.begin();
\end{lstlisting}
\begin{description}
	\item[Line 2:] Reinitialize the invalidated iterator to the begining.
\end{description}

\item[Erasure]
	\begin{itemize}
			\item Sequence containers
					\begin{enumerate}
					\item vector: every iterator and reference after the point of erase is invalidated
					\item deque: all iterators and references are invalidated, unless the erased members are at an end (front or back) of the deque (in which case only iterators and references to the erased members are invalidated)
					\item list: only the iterators and references to the erased element is invalidated
					\end{enumerate}
			
			\item Associative containers: [multi]{set,map}: only iterators and references to the erased elements are invalidated
			
			\item Container adaptors: stack, queue and priority\_queue: inherited from underlying container
	\end{itemize}

\begin{lstlisting}[]
auto it = std::find(vecArr.begin(), vecArr.end(), 5);
if(it != vecArr.end())
        vecArr.erase(it);
       it = vecArr.erase(it);

for(; it != vecArr.end(); it++)//Unpredicted Behavior
 std::cout<<(*it)<<"  "; //Unpredicted Behavior
\end{lstlisting}
\begin{description}
	\item[Line 6:]  Now iterator 'it' is invalidated because it still points to old location, which has been deleted.
\end{description}

\item[swap]
no swap() function invalidates any references, pointers, or iterators referring to the elements of the containers being swapped.

\item[Resizing]
vector, deque and list  as per insert/erase
\end{description}

\end{itemize}

\subsection{Usage}
\subsubsection{Search in Container}
\begin{itemize}
\item Distinguish among count, find, binary\_search, lower\_bound, upper\_bound, and equal\_range.

\includegraphics[scale=0.6]{pics/distinguish.png}

\begin{enumerate}
\item \textbf{For unsorted range, just generic find() or find\_if() algorithm or  count. return last if no find element.}
\item \textbf{For sorted range, Only four binary\_search, lower\_bound, upper\_bound, and equal\_range. are used on a sorted range.}
\item \textbf{For set or map, It has own version, find(),count() and lower\_bound, upper\_bound, and equal\_range}
\item Don't use generic find() algorithm on a sorted range,  use binary\_search(). binary\_search just return bool, not position.

\item  find() will return match iterator, if no match, it will return end()(for map or set). or last iterator(for generic algorithm). but Lower\_bound  will return a position anyway, match position or insert position(no match).

\item Lower bound: first element that is greater-or-equal. Upper bound: first element that is strictly greater. equal\_range return a pair of (lower\_bound, Upper\_bound).

\includegraphics[scale=0.5]{pics/lowerupper.png}

\item equal\_range  if two iterators equal, (no found,). if two iterators distance >=1, (find one or more match, can replace find() or count() function.) .
\begin{lstlisting}[frame=single, language=c++]
  std::sort (v.begin(), v.end());
  // 10 10 10 20 20 20 30 30
 auto p =std::equal_range (v.begin(), v.end(), 20);
 for ( auto i = p.first; i != p.second; ++i )
        std::cout << i->name << ' ';

  //or code below:
  if(distance(p.first, p.second)  >=1){
       cout<<" found match"<<endl;
  }
\end{lstlisting}

\end{enumerate}
\end{itemize}


\subsubsection{Range}

\begin{itemize}

\item Copy algorithm usage: 1) copy v2 to v1.  2) it use loop inside.  \textbf{Almost all uses of copy where the destination range is specified using an insert iterator should be replaced with calls to range member function.}

\begin{lstlisting}[frame=single, language=c++]
v1.clear();
copy(v2.begin(), v2.end(), back_inserter(v1) );

v1.insert(v1.end(), v2.begin(),v2.end() );  //better than copy
v1.assign(v2.begin(), v2.end() )
vector<int> v1( v2.begin(), v2.end() );
v1.erase( v1.begin(), v1.begin()+5);
\end{lstlisting}
\begin{description}
	\item[Line 4 and 5:] //prefer to use below three range memeber function, if want to replace all value in v1.
	
	\item[Line 6:] build from sractch.
	
	\item[Line 7:]erase range.
\end{description}

\item A good example to explain why use range member function is below: When you use insert, inside of insert,  STL will get distance(n elements) of v2,begin() and v2.end(). Then , It will reserve and move the all element in v1 just once according to the distance.  If you use copy, it use loop insert one by one, It will move all element in v1 n times. if no space, it will reallocate and copy old element, just like common vector do. So use range member function, can save you a lot of time in this example.

\begin{lstlisting}[frame=single, language=c++]
//don't use front_inserter() here,
//because vector don't support push_front()
copy(v2,begin() , v2.end(),
          inserter(v, v.begin() ) );

// a better method is here.
v1.insert(v1.begin(),  v2,begin() , v2.end());
\end{lstlisting}

\item effective STL Item 5: Prefer range member functions to their single-element counterparts.
\begin{enumerate}
\item Range construction:
\item Range insertion:
\item Range erasure:
\item Range assignment:
\end{enumerate}

\begin{lstlisting}[numbers=none]
container::container(inputIterator1, inputIterator2);
container::insert(insertPosition, inputIt1, inputIt2);
container::erase(inputIterator1, inputIterator2);
container::assign(inputIterator1, inputIterator2);
\end{lstlisting}


\item The main reason for using assign is to copy data from one type of container to another.
\begin{enumerate}
\item For example, if you want to migrate the contents of an std::set<int> to an std::vector<int>, you can't use the assignment operator, but you can use vector.assign(set.begin(), set.end()).

\item Another example would be copying the contents of two containers holding different types that are convertible to one or the other; If you try to assign std::vector<Derived*> to an std::vector<Base*>, the assignment operator is insufficient.
\item different part from one container to another.
\end{enumerate}



\end{itemize}

\subsubsection{Erasure}
\begin{itemize}


\item So, in short: generally speaking, you should not delete the items from the list while iterating through it, because the deletion may invalidate the iterator (and the program will possibly crash). If you are however completely sure that the items which you delete are not the values referenced by any of the iterators which you use at the moment of deletion, you may delete.

\item Beware that for the other STL containers (e.g. vectors) the constraint is even more strict: deleting from the container invalidates not only iterators pointing to the deleted item, but possibly other iterators, too! So deleting from that containers while iterating through them is even more problematic.

\item Choose carefully among erasing options:  To eliminate all objects in a container that have a particular value.
\begin{enumerate}
\item For vector, string or deque, use erase-remove. \textbf{Don't use for loop, it will invalid the iterator.}
\item For a list, use it's own remove or remove\_if.
\item For associative container, use its erase member function.
\end{enumerate}

\begin{lstlisting}[numbers=none]
vect.erase(remove(vect.begin(), vect.end(),1963), vect.end());
list.remove(1963);
map.erase(1963);
\end{lstlisting}

\item  To eliminate all objects in a container that satisfy a particular predicate, 1)for vector, string or deque, use erase-remove. 2) for a list, use remove\_if, 3) for associative container, write loop being sure to postincrement your iterator. detail can be sen in effective STL item 9;
\begin{lstlisting}[numbers=none]
bool badValue(int x);
vc.erase(
	remove(vc.begin(), vc.end(), badValue), vc.end());

lsit.remove_if(badValue);
for(auto i = map.begin();i!=map.end(); /* no ++i here*/) {
	if(badVaue(*i)) map.erase(i++);
	// or i = map.erase(i);
	else  ++i;
}
\end{lstlisting}

\item  To do something inside the loop (in addition to erasing objects);  You can't use remove, just write a loop,
\begin{lstlisting}[numbers=none]
bool badValue(int x);
for(vect<int>::iterator i = vect.begin();i!=vect.end(); ){
	if(badVaue(*i)) {
		i = vect.erase(i);
		...do something else
	}
	else  ++i;
}
\end{lstlisting}

\end{itemize}
\subsubsection{type definition in container}
\begin{itemize}
\item value\_type in container.
\begin{lstlisting}[numbers=none]
vector<uint> vecs;
cout << sizeof(vecs.value_type)  //error usage
cout<<sizeof(vector<uint>::value_type);
//Pay attention to :: because it's static class member.
\end{lstlisting}

\item Having the commonly-used types available as a type on the container is useful when the container's type itself is unknown. For example, someone may want to write library code that works equally well with std::map and std::unordered\_map:
\begin{lstlisting}[numbers=none]
template<typename TMap>
void insert_default_pair(TMap& map)
{
    map.emplace(typename TMap::key_type(),
                       typename TMap::mapped_type());
}
\end{lstlisting}

\item Inside templated code, prefix value\_type with the keyword typename. Why, It depending on whether some identifier designates a type or a variable, e.g.T * p may be a multiplication or a pointer declaration. Not explicitly marked as type by prefixing it with typename is considered a variable.

\begin{lstlisting}[numbers=none]
template <typename T>
class TSContainer {
private:
        T container;
public:
        void push(typename T::value_type& item){
                container.push_back(item);
        }
\end{lstlisting}


\item summary of type in container
\begin{enumerate}
\item complex type, save typing
\item change a lot, good maintain
\item Inside of a function
\item previous two example, unknow container in template class or support two container at the same time, to reach generic purpose.
\end{enumerate}
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
//1)it will save a lot of typing.
 typedef vector< pair<int, string> > ComVec;
ComVec::value_type aaa;

//2)int to float, but below code don't need change at all.
typedef vector< pair<float, string> > ComVec;

//3) inside of funciton.
typedef std::vector< std::pair<int,std::string> > Record_t;
typedef is your good friend, reuse it below
Record_t k1;

int find_it(std::string value, Record_t const& stuff){
  auto fit = std::find_if(stuff.begin(), stuff.end(),
            [value](Record_t::value_type const& vt) -> bool
                 { return vt.second == value; });
\end{lstlisting}

\end{itemize}


\subsubsection{Sizes}
\begin{itemize}
\item For container, Call empty() instead of of checking size() against zero. it's very easy to understand it.

\item for vector, size(), capacity() and max\_size() can be seen below: capacity is equal or bigger than size. So if you want to avoid allocate the unnecessary space.  LLVM give a SmallVecotr<type, N> example, you can use N to specify a smaller vector to avoid waste.
\begin{lstlisting}[frame=single, language=c++]
std::vector<int> myvector;
for (int i=0; i<100; i++) myvector.push_back(i);

std::cout << (int) myvector.size() << '\n'; // 100
std::cout  << (int) myvector.capacity() << '\n';//128
std::cout << (int) myvector.max_size() << '\n';//1073741823
\end{lstlisting}


\item Four confused conceptions:
\begin{lstlisting}[frame=single, language=c++]
capacity() //how many CAN hold
size()   //how many are in NOW
resize(n) 

reserve(n) //cause the container's capacity() to at lease n.
\end{lstlisting}
\begin{description}
	\item[Line 3:] forces the container to change to n, if n <size(),  object in the end will be lost. if n>size(),  default ctor of element will be called. after resize(n), size will return n. but resize don't change capacity
\end{description}

\item You want to avoid allocation, 1), if you know the number, then use reserve, 2) if you don't know the number, you can reserve maximum space, then you can trim off any excess capaciy.  you can use shrink\_to\_fit() function too. Just remember \textbf{string(s).swap(s)}
\begin{lstlisting}[frame=single, language=c++]
vector<class> v1;
v1.reserve(1000); v1.size(); // only 5

vector<class>(v1).swap(v1);

string(s).swap(s) // the same idea behind.
\end{lstlisting}
\begin{description}
	\item[Line 4:] vector<class>(v1) copy ctor create a temp vector. temp just copy real object, so it's capacity (maybe 8)is small. temp.swap(v1) then temp has 1000 space,  v1 capacity is 8 now. in the end of statment, temp destory.
\end{description}

\item Worthwhile note about vector: It will avoid allocate new space many times.
\begin{lstlisting}[numbers=none]
std::vector<int> v
for(){ ...
 v.clear
}  //good smell.

for(){vector<int> v ...} //bad smell
\end{lstlisting}
\item resize and reserve difference.
\begin{lstlisting}[frame=single, language=c++]
vector<Foo> vcFoo;
vcFoo.reserve(10);
vcFoo.resize(10); 
vcFoo[2] = foo; 
\end{lstlisting}
\begin{description}
	\item[Line 3:] will call Foo ctor 10 times.
	\item[Line 4:] will call Foo ctor and assignment 1 times. if no reserve or resize. vcFoo[2] = foo will fail.
\end{description}


\end{itemize}

\subsubsection{Usages Tips}
\begin{itemize}

\item \textbf{When you use STL Container, you should realize that typedef are your best friends.}
\begin{lstlisting}[numbers=none]
typedef vector<Foo, SpecialAllocator<Foo> > FooContainer;
typedef FooContainer::iterator FooIt;

FooContainer fc1; // make you programming more clearly,
FooContainer fc2;  // you should use typedef more
FooIt it1;
\end{lstlisting}


\item Never try to expect all the container has the same interface. Even a generic erase(), for sequence, It return next iterator,(because it will invalid the iterator).   But for associative, it return void(c++ 98) and return next iterator(C++ 11). If you just want to change a container in the future, you should put a container into a class: CustomCollection. then hide it from the class client. The detail can be seen in Effective STL item 2.

\item The standard associative container are implemented as balanced binary search trees.  It's optimized for a mixed combination of insertions, erasures and lookup.  But if that is dictionary, It can be fall into three distinct phases. setup, lookup, modify. and modify is not happen very often. lookup is very often. At this time, associative container is not best option. sorted vector also support log search time.  1) It use less space. 2) more space cause page fault in memory, then the same log search complex, but sorted vector is faster than associate container.\textbf{ For dictionary, please use sorted vector.}


\item Avoid using vector<bool>, use deque<bool> or bitset


\item item 22 Avoid in-place key modification in set and multiset
\begin{enumerate}
   \item you can't change key in map because it's const default.
\begin{lstlisting}[numbers=none]
map.begin()->fist = 10 //compile error
\end{lstlisting}

   \item For set or map, you can modify non-key part.
\begin{lstlisting}[frame=single, language=c++]
iterator i = set.find(employee);
if( i != set.end())
   i->setTitle("manager")  // it's also ok or
   const_cast<Employee &> (*i).setTitle("manager")
\end{lstlisting}
\begin{description}
	\item[Source Code:]  you must change it to a reference, then you can modify it. if you just use const\_cast<Employee >. this is not right. it will create a temporary obj and then modify a temporary obj.
\end{description}

\item If you want to modify the key part in set or map.
\begin{lstlisting}[frame=single, language=c++]
iterator i = se.find(employee); 
if(i ! = se.end())   // 1) find the one
	Employee e(*i);    //2) create temp one.
	e.setKey("new key") //3) modify
	se.erase(i++);  4) delete the old one and keep ;
	se.insert(i,e); //5) insert new one
\end{lstlisting}
 \end{enumerate}

\item Item19 effective STL, Understand the difference between equality and equivalence in associative Containers.
  \begin{enumerate}
  \item equality is based on operator ==. equivalence is based on operator<. Because associate container, set, map, they must sort their elements, so they must use operator<. Then it use !if(a<b)\&\&!if(b<a) to define equivalence, and associate container use equivalence to decide if a object exist in container.
  \item if you don't have custom compare funciton, most of time equivalence is equal to equality, but if you define you specific compare function, you need to know below:
  \item It will cause container.find and generic algorithm find has different result
\begin{lstlisting}[frame=single, language=c++]
 set<string,  case_insensitive_compare> ss;
 //ss has "AA";
 ss.find("aa"); //return true;
 find(ss.begin(),ss.end(),"aa") //return false
 //find algorithm use operator == .
\end{lstlisting}
  \item It will lead to item 21 in effective STL. Always have comparison functions return false for equal values. (strict weak ordering )
  \item It will lead to item 20 in effective STL. For associative container of pointers, You need to specify comaprsion types, You want to order by pointers or want to order by objects pointed by pointer.(Most of time, the second option is what we want)
\begin{lstlisting}[frame=single, language=c++]
struct stringLess: binary_fucntion<const string* ,const string * , bool>{
   bool operator()(const string* s1 , const string * s2){
        return *s1<*s2;
	}
}
 set<*string,  stringLess> ss;
\end{lstlisting}


  \end{enumerate}

\end{itemize}


\subsection{string}
\begin{itemize}
	\item String::npos is the maximum possible length of the string. Equal the maximum value of an unsigned int.
	\item String is template specialization basic\_string<char> , from this point of view, you will know how to construct a w\_char string.
	\item There are a lot of ways that can be used construct a string object, you can see the reference , such as:
\begin{lstlisting}[numbers=none]
string(const char* s);
string(const char*, size_type n);
string(const string& str, size_type pos, size_type n = npos)
......
\end{lstlisting}
	
	\item The standard containers define size\_type as a typedef to Allocator::size\_type (Allocator is a template parameter), which for std::allocator is defined to be size\_t. So for the standard case, they are the same. However, if you use a custom allocator a different underlying type could be used. So container::size\_type is preferable for maximum portability.
	
	\item In C++, we encourage you to use string more, to replace char[] and char *p = new.  Because it offer you more functions, such as\textbf{ compare, find,erase, replace,insert}.
	
	\item About real size of string, string usually manage it's memory by itself, but you can use two functions string::capacity() and string::reserve() to do some simple work. If the size of string is not enough, string will allocates a new block twice the size and copy the old content. You can use capacity to know the real block size. And use reserve to tell string at least you need minimum size of bloc. For example, str.reserve(50),  str.capacity will return 63. 63 = 64-1; string need the last char to store \verb='\n'= and end of symbol.
	
	\item When you use string with some legacy c function, use string.c\_str() function for read only function, string.c\_str() return a const char *. so You can't modify it. If you Legacy C function want to fill in a string. you need do below:
	
\begin{lstlisting}[frame=single, language=c++]
Old_c(const char* p); string str;
Old_c(str.c_str());  // legacy C function read a string
	
// legacy C write
size_t Old_c(char *pArray, size_t arraySize);
	
vector<char> vc(maxNumChars);
size_t charsWritten = Old_c(&vc[0], vc.size());
string s(vc.begin(), vc.begin()+charsWritten);
\end{lstlisting}
\begin{description}
	\item[Line 7:] create a vector whose size is maxNumChars
	\item[Line 8:] have fillString write into vc
	\item[Line 9:] copy data from vc to s via range constructor
\end{description}
	
	\item string method lists:
	
	\begin{tabular}{| p{0.2\textwidth} |p{0.7\textwidth}|}
		\tophline
		capacity(), reserve() & Returns the largest number of elements that could be stored in a string without increasing the memory allocation of the string.\\
		\tophline
		empty(),  size()& \\
		\tophline
		max\_size() & maximum number of characters \\
		resize() & Specifies a new size for a string, appending or erasing elements as required.\\
		\tophline
		length() & Returns the current number of elements in a string.\bottomhline
		
	\end{tabular}
	
	\begin{tabular}{| p{0.2\textwidth} |p{0.7\textwidth}|}
		\tophline
		find(), rfind() & Searches a string in a forward/backward direction for the first occurrence of a substring that matches a specified sequence of characters.\\
		\tophline
		substr() & Copies a substring of at most some number of characters from a string beginning from a specified position. \\
		
		\tophline
		find\_first\_not\_of() & Searches through a string for the first character that is not any element of a specified string.\\
		\tophline
		find\_first\_of() & \\
		\tophline
		find\_last\_not\_of() & \\
		\tophline
		find\_last\_of() & .\bottomhline
	\end{tabular}
	
	\item find function in the string return position. Vector doesn't have find member function, you can use find function in  algorithm category.
	
\begin{lstlisting}[frame=single, language=c++]
size_t found;
found=str.find("haystack");
// or found=str.find('.');
if (found!=std::string::npos)
std::cout << "'haystack' also found at: " << found << '\n';
	
vector<int> myints = { 10, 20, 30, 40 };
auto  it = std::find (myints.begin(), myints.end(), 30);
if(it!=myints.end())
cout<< "find 30"<<endl;
\end{lstlisting}
	
	
	\begin{tabular}{| p{0.2\textwidth} |p{0.7\textwidth}|}
		\tophline
		begin(),end() & Returns an iterator addressing the first element in the string.\\
		\tophline
		rbegin(), rend() & \bottomhline
		
	\end{tabular}
	
	
	\begin{tabular}{| p{0.2\textwidth} |p{0.7\textwidth}|}
		\tophline
		clear()& Erases all elements of a string.\\
		\tophline
		insert(), erase() & Inserts an element or a number of elements or a range of elements into the string at a specified position.\\
		\tophline
		append(), push\_back() & Adds characters to the end of a string.\\
		\tophline
		assign() &Assigns new character values to the contents of a string.\\
		\tophline
		replace() & \bottomhline
	\end{tabular}
	
	\begin{tabular}{| p{0.2\textwidth} |p{0.7\textwidth}|}
		
		\tophline
		at() & a reference to the element at a specified location \\
		\tophline
		c\_str(), data() & \\
		\tophline
		compare()& \\
		\tophline
		copy() & Copies at most a specified number of characters from an indexed position in a source string to a target character array.The function does not append a null character at the end of the copied content.
		\\
		\tophline
		get\_allocator() & Returns a copy of the allocator object used to construct the string.\\
		
		\tophline
		swap() & Exchange the contents of two strings. \bottomhline
	\end{tabular}
	
	\item clear will delete all the characers, and erase will remove character in certain position.
	
	\item position in find method can be used in loop
\begin{lstlisting}[numbers=none]
std::string str ("Please, replace the vowels with asterisks.");
std::size_t found = str.find_first_of("aeiou");
while (found!=std::string::npos){
	str[found]='*';
	found=str.find_first_of("aeiou",found+1);
}
\end{lstlisting}
	
	
\end{itemize}


\section{Iterator}

\begin{itemize}
\item There are 5 classification iterators: input, output, forward, bi-direction, random. You need to know these five are not real class, they are just conception, not real implementation.

\item As mentioned earlier, each container class defines a class scope typedef name called iterator. So the vector<int> class has iterators of type vector<int>::iterator.  The document will tell you vector iterators is  random access iterators.

 \item In practical point of view: There are four points you need to know:
\begin{enumerate}
\item Five classification and associated supported operation.
\item Common container's iterator classification.
\item Common algorithm can accept what kind of iterator. (See next chapter)
\item Use typedef simply define container iterator.(typedef is good friend when you use stl more and more);
\end{enumerate}

\item Now, five classification iterators play important role here: From this figure, you can know what operation each iterator supports.  \newline

  \includegraphics[scale=0.48]{pics/iterator.png}

\item Basic container iterator is below: \newline

  \includegraphics[scale=0.56]{pics/container_it.png}

\item In each container, iterator of container is implemented by itself. There is no iterator class inheritance hierarchical structure.  I means that in vector, there is vectIter: Iterator (vectIter inheriate from base iterator class) , then you define ++ operator in class vectIter class. It's totally wrong. In fact, In vector, Maybe iterator is defined by:
\begin{lstlisting}[frame=single, language=c++]
template<type T>
vector{
	....
	typedef T* iterator;
};

vector<int>::iterator ip; //use it outside.
// ++ and -- is done by pointer automatically.
\end{lstlisting}

and All the member function of vector know the iterator very well, inside, it will use T* directly,
\begin{lstlisting}[frame=single, language=c++]
push_back(T x){
*end++ = x;
}  
\end{lstlisting}
\begin{description}
	\item[Source code:] you can see there is no iterator when you implement container implementation.
\end{description}


\item When you see the algorithm,  you will see the algorithm is based on template, not inheritance. (You don't need to make type can be cast or not. ). \textbf{Algorithm don't care what iterator really is, It just make sure each iterator can support what operation. }
\begin{lstlisting}[frame=single, language=c++]
template <class InputIterator, class OutputIterator>
  OutputIterator copy (InputIterator first, InputIterator last,
            OutputIterator result);
\end{lstlisting}


\item Common four iterator errors.
\begin{enumerate}
\item Valid values: Is the iterator dereferenceable? For example, writing "*e.end()" is always a programming error.
\item Valid lifetimes: Is the iterator still valid when it's being used? Or has it been invalidated by some
operation since we obtained it?

\item Valid ranges: Is a pair of iterators a valid range? Is first really before (or equal to) last? Do
both really point into the same container?
\item Illegal builtin manipulation: For example, is the code trying to modify a temporary of builtin
type, as in "--e.end()" above? (Fortunately, the compiler can often catch this kind of mistake
for you, and for iterators of class type, the library author will often choose to allow this sort of
thing for syntactic convenience.)


\end{enumerate}


\begin{lstlisting}[frame=single, language=c++]
int main(){
vector<Date> e;
copy( istream_iterator<Date>( cin ), 
              istream_iterator<Date>(), back_inserter( e ) );
vector<Date>::iterator first = find( e.begin(), e.end(), "01/01/95" );
vector<Date>::iterator last = find( e.begin(), e.end(), "12/31/95" );
*last = "12/30/95";
copy( first, last, ostream_iterator<Date>( cout, "\n" ) );
e.insert( --e.end(), TodaysDate() );
copy( first, last, ostream_iterator<Date>( cout, "\n" ) );
}
\end{lstlisting}


\item You can inheriate you own iterator from std::iterator: yes, that's what it's for.If you mean anything else: no, because none of the STL iterators have virtual destructors. They're not meant for inheritance and a class inheriting from them might not clean up properly. A Good example can be seen link: \\ http://www.cplusplus.com/reference/iterator/iterator/

\item two common iterator operation:  advance() and distance().
\begin{lstlisting}[frame=single, language=c++]
std::list<int>::iterator first = mylist.begin();
std::list<int>::iterator last = mylist.end();

std::advance(first, 3) //
std::cout  << std::distance(first,last)
\end{lstlisting}


\item istream\_iterator and istreambuf\_iterator topic:
\begin{lstlisting}[frame=single, language=c++]
 std::ostream_iterator<int> out_it (std::cout,", ");
 std::copy ( myvector.begin(), myvector.end(), out_it );

 ifstream inputFile("aa.txt");
 string fileData((istreambuf_iterator<char>(inputFile)) ,
	istreambuf_iterator<char>());

 ifstream inputFile("aa.dat");
 list<int> data((istreambuf_iterator<char>(inputFile)) ,
	istreambuf_iterator<char>());
\end{lstlisting}
\begin{description}
	\item[Line 5:] It will just read all the character.(including white character) I don't need format data,
	\item[Line 9:] It wil  read format data, and use white space as delimiter.
\end{description}

\end{itemize}

\subsection{Insert iterator}
\begin{itemize}
\item Three common iterator generator: inserter(), back\_inserter(), front\_inserter();  They will produces three insert\_iterator:
\begin{enumerate}
	\item insert\_iterator
	\item back\_insert\_iterator
	\item front\_insert\_iterator
\end{enumerate}

\item When you use insert\_iterator in an assignment, insert\_iterator will call insert() function.  \newline 
back\_insert\_iterator will call push\_back() and front\_insert\_iterator will call push\_front(). insert\_iterator++ has no any operator inside.

\item  std::inserter is commonly used with sets

\item Why do we need it. in some algorithm, such as copy and generator, if you read sth from a container, you can use regular iterator, but when you want to write into a container.  You must keep regular iterator is valid. so a method is to use reverse before you write to a container.

\begin{lstlisting}[numbers=none]
list<State> res2( src.size() );
copy( src.begin(), src.end(),
    res2.begin() ); // often works...
\end{lstlisting}

\item Another way is to use back\_insert\_iterator.
\begin{lstlisting}[frame=single, language=c++]
std::vector<int> foo;
for (int i=1; i<=5; i++)
  { foo.push_back(i); bar.push_back(i*10); }
  std::copy (bar.begin(),bar.end(),back_inserter(foo));
  //foo support push_back

  std::deque<int> foo;
  // deque or list
  for (int i=1; i<=5; i++)
  { foo.push_back(i); bar.push_back(i*10); }
  std::copy (bar.begin(),bar.end(),front_inserter(foo));
  //foo support push_front
\end{lstlisting}

\item Of course, you can use the random access iterators (or any output iterator) in algorithms like std::copy, as third argument, but that assumes the iterator is referencing to existing range â€” *it and ++it are well-defined for the value you passed. You pass them to overwrite the existing elements of the range, whereas std::back\_insert\_iterator adds new elements to the container.

\item For copy algorithm, pass vect.end() is not meanful, because It's not a valid iterator to support *it = new\_obj.

\end{itemize}


\subsection{Reverse iterator}
\begin{itemize}
\item reverse\_iterator topic:
You need a front-to-back traversal or a back-to-front traversal. The reason for reverse iterators is that the standard algorithms do not know how to iterate over a collection backwards. For example:
\begin{lstlisting}[frame=single, language=c++]
std::find(foo.begin(), foo.end(), L'a');

std::find(foo.rbegin(), foo.rend(), L'a').base()-1;

std::find(foo.end(), foo.begin(), L'a');
\end{lstlisting}
\begin{description}
	\item[Line 1:] Returns an iterator pointing to the first a character.
	\item[Line 3:] Returns an iterator pointing to the last A.
	\item[Line 5:] WRONG!! (Buffer overrun)
\end{description}
\item reverse\_iterator can use base() to change a normal iterator, because all the contain member function just receive normal iterator. such as insert and erase.
why ri.base() and ri will have step 1 advance. detail can be seen effective stl item 28.
\begin{lstlisting}[frame=single, language=c++]
reverse_iterator ri =
    find(foo.rbegin(), foo.rend(), L'a');
foo.insert(ri.base()); 
                          
foo.erase((++ri).base()); 
      ri
1 2 3 4 5
        i = ri.base()
\end{lstlisting}
\begin{description}
	\item[Line 3:] you can use ri.base() directly. when you want to insert.
	\item[Line 5:] you can't use ri.base() directly. when you erase what you want.
\end{description}

\end{itemize}

\section{Algorithms}

\subsection{Basic}

\begin{itemize}

\item Effective STL item 43, \textbf{Prefer algorithm calls to hand-written loops}.
\begin{enumerate}
\item  Handing writing is prone to bug

\begin{lstlisting}[numbers=none]
for( size_t i = 0; i < max; ++i )
d.insert( current++, data[i] + 41 ); 
// do you see the bug?
\end{lstlisting}
\item You can fix it bu with careful design
\begin{lstlisting}
for( size_t i = 0; i < max; ++i ) {
	current = d.insert( current, data[i] + 41 ); 
	++current;    
}
\end{lstlisting}
\begin{description}
	\item[Line 2 and 3:] be careful to keep current valid, then increment it when it's safe
\end{description}
\item but a better way is
\begin{lstlisting}[numbers=none]
transform( data, data + max, // copy elements from data
inserter(d, d.begin()), // to the front of
\end{lstlisting}

\item With a complex algorithem, just use STL alogrithem+lambda
\item but a better way is
\begin{lstlisting}[numbers=none]
for( vector<int>::iterator i = v.begin(); i != v.end(); ++i )
if( *i > x && *i < y ) break;

// This is better version now.
vector<int>::iterator i = find_if( v.begin(), v.end(),
                              [x, y](int &i){i>x && i<y} );
\end{lstlisting}



\end{enumerate}
But if you need a loop that dees something fairly simpler, but would require a confusing tangle of binders and adapters, just use loop.
\begin{lstlisting}[numbers=none]
list<Widget> lw;
type list<Widget>::iterator WI;
for_each(lw.begin(),lw.end(),
                mem_fun_ref(&Widget::redraw) );

transform(data, data+10, inserter(deque, deque.begin()),
        bind2nd(plus<double>(), 41));
\end{lstlisting}

\item There are four groups: non modifying sequence , mutating sequence, sorting, generalized numeric operations. Detail can be see c++ primer p1286.

\item Note which algorithm expect sorted ranges:
\begin{lstlisting}[numbers=none]
binary_search lower_bound upper_bound equal_range
set_union set_intersection set_difference
merge  inplace_merge  includes
unique  unique_copy
\end{lstlisting}



\item Make sure destination ranges are big enough effective stl item 30
\begin{lstlisting}[frame=single, language=c++]
vector<int> values, result;
int doSth(int x); // function
// make destination range big enough
result.reserve(result.size()+values.size() );

transform(values.begin(), values,end(), result.end(),doSth );

transform(values.begin(), values,end(),
  back_inserter(result), doSth)  //insert end

transform(values.rbegin(), values,rend(),
  front_insert(result), doSth)
\end{lstlisting}
\begin{description}
	\item[Line 6:] It's error. transform writes its result by making assignment. result.end() has no object at all.
	\item[Line 11:]  result must be a list, use rbegin make insert in front right order
\end{description}



\item Know you sorting options: It makes no sense to sort elements in standard associative containers, because such containers use their comparison functions to remain sorted all the time.

\item For other sequence container, sorting options is below: (1-3) need random iterator. 4 only need bidirection iterator.(list)
  \begin{enumerate}
  \item full sort on vector, string, deque, or array.  use sort or stable\_sort
  \item put only the top n elements in order, partial\_sort
  \item Identify the elements at position n , you need nth\_element
  \item spearate the elements of a standard sequence container, do satisfy some criterion, you use partition or stable\_partition.
  \item for list, you should use list.sort() in place of common sort.
  \end{enumerate}
\begin{lstlisting}[numbers=none]
vector<Foo> vf;
bool compare(const Foo& f1, constFoo& f2);
partial_sort(vf.begin(),vf.begin()+20, vf.end(),  compare);
sort(vf.begin(),vf.end(), compare);
nth_element(vf.begin(),vf.begin()+20,vf.end(), compare);

bool good(const Foo &f1)
partition(vf.begin(), vf.end(), good);
\end{lstlisting}

\item Be wary of remove-like algorithm on container of pointers
\begin{lstlisting}[numbers=none]
void delAndNULL(Foo*& pf){ // use pointer reference here.
if(!pf->isCertified(){ delete pf; pf = nullptr}
}
for_each(v.begin(),v.end(), delAndNULL);
v.erase(remove(v.begin(),v.end(),
                 static_cast<Foo *>(0) ), v.end());
\end{lstlisting}


\item \textbf{For a algorithms, you need to know three points: 1) what's function  for 2) what iterator it accept, 3) what functor it will accept.  So please see below summary. }
\end{itemize}

\subsection{STL algorithms}
\subsubsection{basic notation}



Iterator:  \\
\begin{tabular}{| p{0.2\textwidth} |p{0.8\textwidth}|}
\tophline b, f &	a bidirectional, forward iterator \\
\tophline i,o,a 	&an input, output, random iterator  \\
\tophline(?, ?)	&a pair of iterators as a return value, as in (f,f) \bottomhline
\end{tabular}

functor:  \\
\begin{tabular}{| p{0.2\textwidth} |p{0.8\textwidth}|}
\tophline upred, bpred	& a unary or binary predicate (boolean function or function object)
(generally used to test a single value from a container) \\

\tophline ufunc, bfunc	&  a unary or binary  (value-returning) function or functor \\
\tophline pfunc	& a "parameterless" (value-returning) function (or function object)
(often used to "generate" a value of some kind) \\
\tophline uproc, bproc	& a unary or binary  procedure (void function or function object) \\
\tophline pproc	&  a "parameterless" procedure (void function or functor) \bottomhline
\end{tabular}

Parameter:  \\
\begin{tabular}{| p{0.2\textwidth} |p{0.8\textwidth}|}
\tophline n, v, \&  & 	a quantity (or size). A value. reference to a value \bottomhline
\end{tabular}

\subsubsection{Applying}
\begin{tabular}{| p{0.35\textwidth} |p{0.45\textwidth}|p{0.2\textwidth}|}
\tophline ufunc for\_each(i,i,ufunc) &Apply a function to every item in a range and return the function. &  ufunc may not return value. 
\bottomhline
\end{tabular}

\begin{lstlisting}[numbers=none]
void fun(int n){
    cout<<" "<<n;
} //all function definition end no semicolon

struct Sum{
    Sum(): sumEven{0} { }  //no semicolon here
    void operator()(int n) {if(n%2 ==0) ; sumEven += n;}
    int sumEven;
}; // type definition need semicolon

vector<int> nums{3, 4, 2, 8, 15, 267};
for_each(nums.begin(), nums.end(), fun);
Sum s = for_each(nums.begin(), nums.end(), Sum());
for_each(nums.begin(), nums.end(), [sumEven](int n){
                           if(n%2==0) sumEven+=n;
                            });
\end{lstlisting}

\begin{itemize}
\item for\_each need a functor, So when to use for\_each eaual another question, when use functor.
\begin{enumerate}
\item For fun example, a better way is for(auto e: nums)\{cout<<e<<" ";\}. Here just demonstrate that  you can input fun.
\item For struct Sum just use once, lambda function is better, because it is cleaner.
\item If functor need to be 1)customized state and 2)reuse many time, then functor is better.
\begin{lstlisting}[numbers=none]
struct GreatThanX{
    GreatThanX(int x): cutoff{x} { } 
    bool operator()(int n) { if(n>x) ; 
                    return true; return false; }
    int cutoff;
};

vector<int> nums{3, 4, 2, 8, 15, 267};
find_if(nums.begin(), nums.end(),GreatThanX(3));
copy_if(nums.begin(), nums.end(),GreatThanX(7));
..........
\end{lstlisting}
\item \textbf{Only functor can be use a argument input to map or set container set}. See below examples.

\begin{lstlisting}[numbers=none]
struct lex_compare {
    bool operator() (const int64_t& lhs, const int64_t& rhs) const{
        stringstream s1,s2;        s1 << lhs;  s2 << rhs;
        return s1.str() < s2.str();
    }
};
set<int64_t, lex_compare> s;
\end{lstlisting}


\item Lambdas aren't useful for more complex scenarios because they weren't made for them. They provide a short and concise way of creating simple function objects for correspondingly simple situations.

\item with function, bind and name lambda, You can reach above requirement.  but it's not as good as functor
\begin{lstlisting}[numbers=none]
auto f = [](int x, int y){if(y>x) return true; return false;} ;
auto f1 = bind(f, 3, placeholders::_1) // GreatThanX(3);
if(f1(8)) cout<<"8>3"<<endl;
\end{lstlisting}

\end{enumerate}

\end{itemize}


\textbf{Transforming}  \\
\begin{tabular}{| p{0.4\textwidth} |p{0.35\textwidth}|p{0.25\textwidth}|}
\tophline \specialcell[t]{ o transform(i1,i1end,o,ufunc) \\o transform(i1,i1end,i2, o, bfunc) }
         &Transform one range of values into another.
         & Ret of ufunc or bfunc writed to o. 

\bottomhline
\end{tabular}

\begin{itemize}
\item If output is associate container, you need use inserter( ) function to get inserter iterator.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
std::transform(a.begin(), a.end(),
        std::inserter(set, set.begin()), modify);

std::transform(a.begin(), a.end(), b.begin(),
        a.begin(), plus<int>() );
\end{lstlisting}
\begin{description}
	\item[Source code:] 1) you can make in place modification. 2) plus minus, multiplies, divides, modulus, negate, equal\_to are often used in transform algorithms.
\end{description}

\item
\end{itemize}


\subsubsection{Bounding}

\begin{tabular}{| p{0.4\textwidth} |p{0.4\textwidth}|p{0.2\textwidth}|}
\tophline \specialcell[t]{(f,f) equal\_range(f,f,\&) \\
(f,f) equal\_range(f,f,\&,bpred) }& Find the lower bound and upper bound of a value within a range and return a pair of iterators  .
& \multirow{3}{*}{ \parbox{0.2\textwidth}{1)container should be sorted firstly,  2) order by default < or bpred. 3) Sorted by bpred, find by bpred. } } \\

\ifdefined\pdfbook \cline{1-2} \fi  \specialcell[t]{f lower\_bound(f,f,\&) \\
f lower\_bound(f,f,\&,bpred)} & Find the lower bound of a value within a range and return an iterator pointing to it.
 &  \\

\ifdefined\pdfbook  \cline{1-2} \fi \specialcell[t]{f upper\_bound(f,f,\&) \\ f upper\_bound(f,f,\&,bpred) }
& Find the upper bound of a value within a range and return an iterator pointing to it.
&  \bottomhline
\end{tabular}

\subsubsection{Comparing}
\begin{tabular}{| p{0.4\textwidth} |p{0.6\textwidth}|}
\tophline \specialcell[t]{bool equal(i1,i1last, i2) \\
bool equal(i1,i1last,i2,bpred) } &  Check if the values in two ranges match.\\

\tophline
bool lexicographical\_compare (i1,i1last,i2,i2last)
bool lexicographical\_compare (i1,i1last,i2,i2last,bpred)  & Compare two ranges lexicographically, and return true if the first range is less than the second; otherwise return false.
  \\


\tophline
 (i1,i2) mismatch(i1,i1last,i2)  (i1,i2) mismatch(i1,i1last,i2, bpred)
& Search two ranges for the first two items in corresponding positions that don't match, and return a pair of iterators pointing to those two items.
  \bottomhline
\end{tabular}
\begin{itemize}
\item An example to use equal:
\begin{lstlisting}[numbers=none]
bool is_palindrome(const std::string& s){
    return std::equal(s.begin(), s.begin() + s.size()/2,
                      s.rbegin());
}
\end{lstlisting}
\end{itemize}


\subsubsection{copy}

\begin{tabular}{| p{0.4\textwidth} |p{0.6\textwidth}|}
\tophline o copy(i,i,o) & Copy a range of items to a destination and return an iterator pointing to the end of the copied range.   \\
\tophline b2 copy\_backward(b1,b1last, b2)  & Copy a range of items backwards to a destination and return an iterator pointing to the end of the copied range.    \bottomhline
\end{tabular}
Example:
\begin{lstlisting}[frame=single, language=c++]
for (int i=1; i<=5; i++)
    myvector.push_back(i*10);

copy(myvector.begin(), myvector.end(),
	 myvector.begin()+3)

copy_backward(myvector.begin(), myvector.end(), 
	myvector.begin()+4)
\end{lstlisting}
\begin{description}
	\item[Line 4:] error, when source and targe is overlap, you have to use backward copy
	\item[Line 7:]pay attention, copy\_backward, *(--last) = if you want copy to position 3, you need to input position 4. or you can input vector.end() as target, but for copy, you can't input vector.end()
\end{description} 

\begin{itemize}
\item Copy.  Inside Copy, It use assignment operator =. o should be insert iterator or target should be use reserve() to allocate space for assignment operator =.
\end{itemize}



\subsubsection{Count}
\begin{tabular}{| p{0.3\textwidth} |p{0.5\textwidth}|p{0.2\textwidth}|}
\tophline n count(i,i,\& ) & Count the items in a range that match a value and return that count.& \multirow{2}{*}{ \parbox{0.2\textwidth}{count will not stop when it find match. } }    \\
\ifdefined\pdfbook  \cline{1-2} \fi n count\_if(i,i,upred)  & Count the items in a range that satisfy a predicate and return that count. & \bottomhline
\end{tabular}


\subsubsection{Filling and Generating}
\textbf{Filling} \\
\begin{tabular}{| p{0.3\textwidth} |p{0.7\textwidth}|}
\tophline fill(f,f,\& ) & Set every item in a range to a particular value.  \\
\tophline fill\_n(o,n,\& )  & Set n items to a particular value.   \bottomhline
\end{tabular}


\textbf{Generating} \\
\begin{tabular}{| p{0.4\textwidth} |p{0.6\textwidth}|}
\tophline generate(f,f,pfunc)  & Fill a range with generated values.   \\
\tophline generate\_n(o,n,pfunc)  & Generate a specified number of values.   \bottomhline
\end{tabular}

\begin{itemize}
\item examples:
\begin{lstlisting}[numbers=none]
std::vector<int> v(5);
std::generate(v.begin(), v.end(), std::rand);
                   // Using the C function rand()

int n = {0};
std::generate(v.begin(), v.end(), [&n]{ return n++; });
//1, 2, 3, 4, 5
\end{lstlisting}

\end{itemize}



\textbf{Filtering , should used on sorted container} \\
\begin{tabular}{| p{0.35\textwidth} |p{0.65\textwidth}|}
\tophline \specialcell[t]{f unique(f,f) \\
f unique(f,f,bpred) }&  Collapse each group of consecutive duplicate values to a single value, and return an iterator pointing to the end of the modified range.
\\

\tophline \specialcell[t]{
o unique\_copy(i,i,o)  \\
o unique\_copy(i,i,o,bpred)  } & Copy a range of values, performing the same action as unique above, and return an iterator pointing to the end of the new range.   \bottomhline

\end{tabular}

\begin{lstlisting}[numbers=none]
int myints[] = {10,20,20,20,30,30,20,20,10};
  std::vector<int> myvector (myints,myints+9);

  // using default comparison:
  std::vector<int>::iterator it;
  it = std::unique (myvector.begin(), myvector.end());
  // 10 20 30 20 10 ?  ?  ?  ?
\end{lstlisting}

\textbf{Heap} \\
\begin{tabular}{| p{0.3\textwidth} |p{0.5\textwidth}|p{0.2\textwidth}|}
\tophline \specialcell[t]{make\_heap(r,r)  \\
make\_heap(r,r,bpred) }&  Make a range of values into a heap.
& \multirow{4}{*}{ \parbox{0.2\textwidth}{It nees random iterator. priority\_queue use them inside. You don't use them directly } } \\

\ifdefined\pdfbook  \cline{1-2} \fi  \specialcell[t]{
o pop\_heap(r,r) \\
o pop\_heap(r,r,bpred)   } & Delete the first value from a heap.  &  \\

\ifdefined\pdfbook  \cline{1-2} \fi  \specialcell[t]{
push\_heap(r,r) \\
push\_heap(r,r,bpred)  } & Insert the last value of a range into a heap. &  \\

\ifdefined\pdfbook  \cline{1-2} \fi  \specialcell[t]{
sort\_heap(r,r) \\
sort\_heap(r,r,bpred)   } & Sort a heap.  &  \\
\tophline
\end{tabular}

\subsubsection{Math}
\begin{tabular}{| p{0.4\textwidth} |p{0.6\textwidth}|}
\tophline \specialcell[t]{v accumulate(i,i,v) \\
v accumulate(i,i,v,bfunc)  }&  Add an initial value and the values in a range, return sum.
\\

\tophline \specialcell[t]{
o adjacent\_difference (i,i,o) \\
o adjacent\_difference \\ (i,i, o, bfunc)   } & Calculate the difference between adjacent pairs of values, write the differences to an o, and return the end of that output range.    \\

\tophline
v inner\_product (i1,i1last,i2,vInitial)
v inner\_product (i1,i1last,i2,v,bfunc1,bfunc2)  & Calculate the inner product of two ranges and return that value plus vInitial.  \\

\tophline  \specialcell[t]{
o partial\_sum(i,i,o)  \\
o partial\_sum(i,i,o, bfunc)   } & Fill a range with running totals and return an iterator pointing to.   \bottomhline
\end{tabular} \\
\begin{itemize}

\item An example about partial\_sum

\begin{lstlisting}[numbers=none]
std::vector<int>v(10, 2); // new initialize method
std::partial_sum(v.begin(), v.end(),
          std::ostream_iterator<int>(std::cout, " "));
    //2 4 6 8 10 12

std::partial_sum(v.begin(), v.end(), v.begin(),
                            std::multiplies<int>());
std::cout << "The first 10 powers of 2 are: ";
 for (auto n : v) {
      //2 4 8 16 32
    }
\end{lstlisting}
\item An example about accumulate

\begin{lstlisting}[numbers=none]
std::vector<int> v{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int sum = std::accumulate(v.begin(), v.end(), 0);
int product = std::accumulate(v.begin(), v.end(), 1,
                              multiplies<int>());

string s=accumulate(v.begin(), v.end(),std::string{},
    [](const std::string& a, int b) {
    return a.empty() ? to_string(b): 
    a + '-' + to_string(b); });
\end{lstlisting}

\item An example about adjacency\_difference. produces fibonacci.
\begin{lstlisting}[numbers=none]
 v = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
    std::adjacent_difference(v.begin(), v.end() - 1,
           v.begin() + 1, std::plus<int>());

\end{lstlisting}

\item difference some algorithms
\begin{enumerate}
\item For accumulate, input a init, -->calculate(init, element)-->return it to init.
\item For adjacent\_difference:   first -> dfirst,  f(first+1, first)-->dfirst+1; Pay attention, for first element, assign it directly.
\item For partial\_sum function, you can think it as accumulate, \textbf{accumulate just return one value, but partial\_sum return many value, and write them back to target iterators one by one.  }
\item accumulate and inner\_product return one value, partial\_sum and adjacent\_difference return a list of value.
\end{enumerate}

\end{itemize}

\subsubsection{Merging}
\begin{tabular}{| p{0.4\textwidth} |p{0.6\textwidth}|}
\tophline \specialcell[t]{inplace\_merge(b,b,b) \\
inplace\_merge(b,b,b,bpred)   }&  Merge two sorted ranges, in place, into a single sorted range.
\\

\tophline  \specialcell[t]{
o merge(i1,i1,i2,i2,o)  \\
o merge(i1,i1,i2,i2,o,bpred)    } & Merge two sorted ranges into a single sorted range.   \\
\tophline
\end{tabular}

\textbf{Min/Max} \\
\begin{tabular}{| p{0.4\textwidth} |p{0.6\textwidth}|}
\tophline \specialcell[t]{\& min(\&,\&)  \\
\& min(\&,\&,bpred)   }&  Find the minimum of two values and return a reference to that value.
\\

\tophline  \specialcell[t]{
\& max(\&,\&) \\
\& max(\&,\&,bpred)     } & Find the maximum of two values and return a reference to that value.    \\

\tophline \specialcell[t]{
f min\_element(f,f)  \\
f min\_element(f,f,bpred)  } & Find the minimum value in a range and return an iterator pointing to that value.   \\

\tophline  \specialcell[t]{
f max\_element(f,f)  \\
f max\_element(f,f,bpred)   } & Find the maximum value in a range and return an iterator pointing to that value.   \bottomhline
\end{tabular}



\subsubsection{Partitioning}
\begin{tabular}{| p{0.4\textwidth} |p{0.6\textwidth}|}
\tophline \specialcell[t]{nth\_element(r,r,r) \\
nth\_element(r,r,r,bpred)   }&  Partition a range of values so that the value pointed to by the middle r in the parameter list is in its correct sorted position, and no element to its left is greater than any element to its right. \\

\tophline  \specialcell[t]{
b partition(b,b,upred)    } & Partition a range of values using a predicate, and return an iterator pointing to the first value for which upred returns false.   \\

\tophline  \specialcell[t]{
b stable\_partition(b,b,upred)     } & Partition a range using a predicate without altering the relative order of the values, and return an iterator pointing to the first value for which upred returns false.  \bottomhline
\end{tabular}


\begin{itemize}
\item  An example of partition:
\begin{lstlisting}[numbers=none]
std::vector<int> v = {0,1,2,3,4,5,6,7,8,9};
auto it = std::partition(v.begin(), v.end(),
                     [](int i){return i % 2 == 0;});
                     
std::copy(std::begin(v), it,
         std::ostream_iterator<int>(std::cout, " "));
         
std::copy(it, std::end(v),
         std::ostream_iterator<int>(std::cout, " "));
\\output: 0 8 2 6 4   5 3 7 1 9
\end{lstlisting}

\item \textbf{Partition return: Iterator to the first element of the second group.}

\item All of the elements before this new nth element are less than or equal to the elements after the new nth element. Who are my top 20 salespeople?" For example, nth\_element( s.begin(),
s.begin()+19, s.end(), SalesRating ); puts the 20 best elements at
the front.
\item If you use nth\_element on most of the range, It may be slower than a full sort.
\end{itemize}




\subsubsection{Permuting}
\begin{tabular}{| p{0.4\textwidth} |p{0.6\textwidth}|}
\tophline \specialcell[t]{bool next\_permutation(b,b) \\
bool next\_permutation\\ (b,b,bpred)    }&  Change a range of values to the next lexicographic permutation of those values, and return true, or false if no next permuation exists.
 \\

\tophline  \specialcell[t]{
bool prev\_permutation (b,b)  \\
bool prev\_permutation \\ (b,b, bpred)     } & Change a range of values to the previous lexicographic permutation of those values, and return true, or return false if no previous permuation exists.  \bottomhline
\end{tabular}
A example:
\begin{lstlisting}[numbers=none]
int a[] = {1,2,3};
do {
    cout << a[0] << ' ' << a[1] << ' ' << a[2] << '\n';
} while ( std::next_permutation(a,a+3) );
1 2 3 // 1 3 2 //2 1 3
2 3 1 //3 1 2  //3 2 1
\end{lstlisting}


\subsubsection{Random/shuffing}
\begin{tabular}{| p{0.4\textwidth} |p{0.6\textwidth}|}
\tophline \specialcell[t]{random\_shuffle(r,r)  \\
random\_shuffle(r,r,ranGen)    }&  Randomize a range of values, and use the random generator function ranGen, if supplied, rather than an internal random generator. \bottomhline
\end{tabular}




\subsubsection{Removing}
\begin{tabular}{| p{0.4\textwidth} |p{0.6\textwidth}|}
\tophline \specialcell[t]{remove(f,f,\&)  \\
remove\_if(f,f,upred)    } &  Remove from a range of values all values that match a give value or satisfy a predicate \\

\tophline \specialcell[t]{ remove\_copy(i,i,o,\&) \\
remove\_copy\_if(i,i,o,upred)}  & Copy a range of values, removing all values that match a given value. \bottomhline

\end{tabular}

\begin{itemize}
\item These algorithms cannot be used with associative containers such as std::set and std::map because ForwardIt does not dereference to a MoveAssignable type (the keys in these containers are not modifiable)
\item list has its own remove
\item Then, remove only can be used in erase remove idiom in vector and string.
\end{itemize}


\subsubsection{Replacing}
\begin{tabular}{| p{0.4\textwidth} |p{0.6\textwidth}|}
\tophline \specialcell[t]{  replace(f,f,\&,\&) \\
 replace\_if(f,f,upred,\&) } &
Replace, within a range of values, one specified value(satisfies a predicate) with another value.  \\

\tophline \specialcell[t]{ replace\_copy(i,i,o,\&,\&)  \\
 replace\_copy\_if(i,i,o,upred,\&)} &
Copy  replacing one specified value with another specified value.  \\
\tophline
\end{tabular}


\subsubsection{Reverse}
\begin{tabular}{| p{0.3\textwidth} |p{0.7\textwidth}|}
\tophline reverse(b,b) &  Reverse the order of all values in a range of values. \\
\tophline reverse\_copy(b,b,o) &  Reverse and copy  \\ \tophline
\end{tabular}

\subsubsection{Rotating}
\begin{tabular}{| p{0.4\textwidth} |p{0.6\textwidth}|}
\tophline rotate(f,f,f)  & Rotate a range of values by n positions.  \\
\tophline rotate\_copy(f,f,f,o) &   Copy and rotating it by n position.  \bottomhline
\end{tabular}

\begin{itemize}
\item Rotates the order of the elements in the range [first,last), in such a way that the element pointed by middle becomes the new first element.

\begin{lstlisting}[numbers=none]
for (int i=1; i<10; ++i) myvector.push_back(i);
// 1 2 3 4 5 6 7 8 9
rotate(myvector.begin(),
			myvector.begin()+3,myvector.end());
// 4 5 6 7 8 9 1 2 3
\end{lstlisting}

\end{itemize}




\subsubsection{Searching}

\textbf{1:Sorted range Searching}  \\
\begin{tabular}{| p{0.4\textwidth} |p{0.6\textwidth}|}

\tophline bool binary\_search(f,f,\&)&  sorted range of values and return bool.
\bottomhline
\end{tabular}


\textbf{2: linear time Searching} \\
\begin{tabular}{| p{0.4\textwidth} |p{0.6\textwidth}|}
\tophline \specialcell[t]{f adjacent\_find(f,f) \\
f adjacent\_find(f,f, bpred)
   }&  the first pair of equal adjacent values in a range and return an iterator pointing to the first value of the pair.  \\

\tophline i find(i,i,\&)  &
return an iterator pointing to the value or end  \\

\tophline i find\_if(i,i,upred)  &
satisfies a predicate and return an iterator pointing to the first such value, or to the end  \bottomhline
\end{tabular}


\textbf{3: Searches for a single element from a range} \\
\begin{tabular}{| p{0.45\textwidth} |p{0.55\textwidth}|}

\tophline \specialcell[t]{ f1 find\_first\_of(f1,f1,f2,f2) \\
f1 find\_first\_of(f1,f1,f2,f2,bpred) } & std::find\_first\_of searches for a single element from a range within another range.
\bottomhline
\end{tabular}

\textbf{4: Below 3 algorithms searche for a whole range of elements within another range }\\
\begin{tabular}{| p{0.4\textwidth} |p{0.6\textwidth}|}
\tophline \specialcell[t]{f1 search(f1,f1,f2,f2) \\
f1 search(f1,f1,f2,f2) } &
first occurrence of a second range of values within a first range . return an iterator pointing to the first value of that first match. or end of the first range  \\

\tophline \specialcell[t]{ f1 find\_end(f1,f1,f2,f2) \\
f1 find\_end(f1,f1,f2,f2,bpred) } &
the last occurrence of a second range of values in a first range of values and return an iterator pointing to the first value of that last match within the first range, or pointing to the end of the first range(not find) \\

\tophline  \specialcell[t]{f search\_n(f,f,n,\&) \\
f search\_n(f,f,n,\&,bpred) }  &
For a contiguous sequence of n values each equal to \&, return iterator to the first of those values, or  the end of the range \bottomhline
\end{tabular}


\subsubsection{set}.
\begin{tabular}{| p{0.4\textwidth} |p{0.6\textwidth}|}
\tophline \specialcell[t]{ bool includes(i1,i1,i2,i2) \\
bool includes(i1,i1,i2,i2,bpred) }  &
Search for \textbf{all values from the second range in the first range} and return true if found, or false  \\
\tophline \specialcell[t]{o set\_difference(i1,i1,i2,i2,o) \\
o set\_difference \\ (i1,i1,i2,i2,o,bpred) } &
in the first range but not in the second range and return the end of that output range. \\

\tophline \specialcell[t]{o set\_intersection(i1,i1,i2,i2,o)  \\
o set\_intersection \\(i1,i1,i2,i2,o,bpred) } &
 in the first range and also in the second range and return the end of that output range. \\

\tophline \specialcell[t]{o set\_union(i1,i1,i2,i2,o) \\
o set\_union(i1,i1,i2,i2,o,bpred) } &
either in the first range or in the second range and return the end of that output range. \\

\tophline \specialcell[t]{o set\_symmetric\_difference \\ (i1,i1,i2,i2,o)  \\
o set\_symmetric\_difference \\ (i1,i1,i2,i2,o,bpred) } &
 not common to both ranges and return the end of that output range.  \bottomhline

\end{tabular}
\begin{itemize}
\item All algorithm need two ranges should be sorted.
\end{itemize}


\subsubsection{swapping}
\begin{tabular}{| p{0.4\textwidth} |p{0.6\textwidth}|}
\tophline iter\_swap(f,f) &
Swap the values pointed to by the two iterators.  \\
\tophline swap(\&,\&) &
Swap the two values.  \\
\tophline f2 swap\_ranges(f1,f1end,f2) &
Swap two ranges of values and return an iterator pointing to the end of the second range.  \bottomhline
\end{tabular}

\subsubsection{sort}
\begin{tabular}{| p{0.38\textwidth} |p{0.64\textwidth}|}
\tophline \specialcell[t]{partial\_sort(r,r,r) \\
partial\_sort(r,r,r,bpred) } &
Sort all values till first part of range is in sorted order. \\

\tophline \specialcell[t]{r partial\_sort\_copy(i,i,r,r) \\
r partial\_sort\_copy \\ (i,i,r,r,bpred) } &
Partially sort a range of values (as above) and copy \textbf{as many values as will fit into an output range.}\\

\tophline \specialcell[t]{sort(r,r) \\
sort(r,r,bpred) } &
Sort a range of values.\\

\tophline \specialcell[t]{ stable\_sort(r,r) \\
stable\_sort(r,r,bpred) } &
Sort and maintaining the same relative order of duplicate values.\bottomhline
\end{tabular}

\section{Function object}
\subsection{Basic}

\begin{enumerate}
\item  In C language, we use function pointer.
\begin{lstlisting}[numbers=none]
int(*pf)(int, int); //declare a pointer function
int fun1(int i,int j);
pf = fun1 // or pf=&fun1; we usually skip &.
(*pf)(1,2) //or pf(1,2);
\end{lstlisting}

\item In C++, Some generic algorithms can also accept function by template.
\begin{lstlisting}[numbers=none]
void fun(int i) {
	//do stuff
}

for_each(a.begin(), a.end(), fun);
\end{lstlisting}
\begin{description}
	\item[Line 5:] here just input fun name, it's function pointer usage. function pointer is variable.
\end{description}

\item But passing function has shortcomings:
\begin{enumerate}
	\item Can't be inline.
	\item Sometimes It can't be compile due to different compiler implementation.
	\item You can't adapt or custom it.
\end{enumerate}
So STL invented a functor(function object). It is class or structure objects for which the () operator is overloaded.

\begin{lstlisting}[numbers=none]
class functor { // also call function objects
public:
  void operator()(int i);
};

for_each(a.begin(), a.end(), functor());
\end{lstlisting}
\begin{description}
	\item[Line 1:] here, use functor, (class object); overload operator();
	\item[Line 6:] function accept variable, not type. You must use functor() to produce a temporary functor obj.
\end{description}

\item  You can use struct or class. If you want to have a private customized  value, you have to use class to build a functor.  Such as cutoff value in below code.
\begin{lstlisting}[frame=single, language=c++]
struct less_than_7 : std::unary_function<int, bool>{
    bool operator()(int i) const { return i < 7; }
};

class less_than_value : std::unary_function<int, bool>{
    less_than_value(int x) :value(x) {};
    bool operator()(int i) const { return i < value; }
    private:
    int value;
};

count_if(v.begin(),v.end(), std::not1(less_than_7()));
count_if(v.begin(),v.end(),std::not1(less_than_value(7)));
\end{lstlisting}
\begin{description}
	\item[Line 1:] you can use class instead struct, but you need to make operator() public, in struct, default is public, so struct is better!
\end{description}


   \item In previous example, you can see advantage of usage less\_than\_value.
   \begin{enumerate}
   \item You can inherit from  template unary\_function when you declare a functor, then you functor is adaptable by std::not1.

   \item you can change value when you build a less\_than\_value functor.

   \item set or map are template class. So it only accept type, not function, If you want to give set or map a customized compare function,  you have to use functor to define a type.
\begin{lstlisting}[frame=single, language=c++]
class yanCompare{
    bool operator()(string &s1, string &s2){....;}
};

set<string, yanCompare> setDic;
remove_if(...yanComare() );
\end{lstlisting}
\begin{description}
	\item[Line 5:] just yanCompare, no() follow it. pass into a type, not obj
	\item[Line 6:] yanCompare(), to pass a function obj.
\end{description}
 
\end{enumerate}

\item Based on previous example, I would like to say something about \textbf{type, variable, expression, value}.
\begin{enumerate}
\item type is build-in type, custom type(class, struct), and pointer, reference type.
\item variable has a name, value and type.
\item expression has no name but has value and type.
\item value can be divided by three categories.
\end{enumerate}
\item template function is a function, we have to input value, so we pass variable or expression. in previous example, yanCompare() produce a obj variable.
\item template container need type. so we have to input type, so we input yanCompare, It's a class type.
\item Given a variable or expression, we need to know its type, we can use auto, T in template and decltype. detail can be seen "type inference" section.
\item Given a container, we can get value\_type by predefined type information in container.

\item given a type, we need to define an variable, we can use typedef or using alias to replace complex type in C++(such as: vect<pair<string, int> >). In template,
\item In template class, If you define depended type, use using alias, detail can be seen in using alias part in the last chapter.

\item Sometimes, you don't want to reuse this functor which will cause you write clutter code, so C++14 introduce lambda.  Detail can be seen in C++ 11 New features.
\begin{lstlisting}[frame=single, language=c++]
 []->bool(int){return x<7};

std::count_if(v.begin(), v.end(), [](int x){return x<7;} );
\end{lstlisting}
\begin{description}
	\item[Line 1:]  if only return, you can omit ->bool (return type);
\end{description}

\item Why you use  unary\_funciton and binary\_function template, then inherit from it.  It can make you functor adaptable, see below section:
\end{enumerate}

\subsection{Adaptable}
\subsubsection{Before c++11}
\begin{itemize}
\item Four adapter is not1, not2, bind1st and bind2nd. It can change you current functor. An example is below: equal\_to is binary function, but count\_if only need unary function.  bind1st or bind2nd can change binary function to unary function.  another function is not1, used for unary function, not2 used for binary function.
\begin{lstlisting}[numbers=none]
int array[] = {10,20,30,40,50,10}; int cx;
cx = count_if (array, array+6, bind1st(equal_to<int>(),10));
\end{lstlisting}

\item In order to use these four adapters. You functor should be inheriated from unary\_funciton or binary\_function. It make you function object has typedef information, which not1 or not2 will use them.

\item Usage of ptr\_fun, If you want to adapter a current function, (not function object), because function doesn't have any typedef information, so you have to use ptr\_fun firstly.
\begin{lstlisting}[frame=single, language=c++]
bool IsBad(Foo& f);

find_if(vect.begin(), vect.end(),not1(IsBad);  

find_if(vect.begin(), vect.end(), not1(ptr_fun(IsBad )); 
//recommend to use c++11 new feature
std::not1(std::cref(isvowel)));
std::not1(std::function<bool(char)>(isvowel)));
\end{lstlisting}




\item Usage of mem\_fun, mem\_fun\_ref
\begin{lstlisting}[numbers=none]
list<Foo*> lpf
for_each(lpf.begin(),lpf.end(),mem_fun_ref(&Foo::testFun) );

list<Foo> lf
for_each(lf.begin(),lf.end(),mem_fun(&Foo::testFun) );
\end{lstlisting}

\item With variadic templates, a lot of general function composing can be expressed much more simply and consistently, so all of the old cruft is no longer necessary: depracated in C++ 11. (but support)
\textbf{Do use: std::function, std::bind, std::mem\_fn, std::result\_of, lambdas }.  \textbf{Don't use: std::unary\_function, std::binary\_function
std::mem\_fun , std::bind1st, std::bind2nd}

\end{itemize}

\subsubsection{After c++11}
\begin{itemize}
	\item std::mem\_fun is deprecated. std::mem\_fn can do everything it does, and it does it more conveniently. The relation between the two is the same as the relation between std::bind1st/std::bind2nd and the C++11 std::bind. 
	
	\item std::bind use variadic template parameter.
	
\begin{lstlisting}
struct Foo {
	void display_greeting() {
		std::cout << "Hello, world.\n";
	}
	void display_number(int i) {
		std::cout << "number: " << i << '\n';
	}
	int data = 7;
};

Foo f;   //use & here to get address
auto greet = std::mem_fn(&Foo::display_greeting);
greet(f); // have to input a object f

auto print_num = std::mem_fn(&Foo::display_number);
print_num(f, 42);

auto access_data = std::mem_fn(&Foo::data);
std::cout << "data: " << access_data(f) << '\n';
\end{lstlisting}

\end{itemize}

\subsubsection{member function}
\begin{itemize}
	If you called for\_each() with \texttt{\&Item::Foo}, the code try to call \texttt{(\&Item::Foo)(x)}, which is ill-formed since for pointers to members you have to write \texttt{(x.*\&Item::Foo)()}. It's that syntactical difference that mem\_fn is meant to solve: mem\_fn deals with the invocation syntax of pointers to members so that you can use all the algorithms with pointers to members as well as functions and function objects. You cannot have \texttt{for\_each(v.begin(), v.end(), \&Item::Foo)} but you can have \texttt{for\_each(v.begin(), v.end(), mem\_fn(\&Item::Foo))}.
\begin{lstlisting}
template<class InputIt, class UnaryFunction>
UnaryFunction for_each(InputIt first, 
	InputIt last, UnaryFunction f){
		
	for (; first != last; ++first) {
		f(*first); // <== N.B. f(*first)
	}
}
\end{lstlisting}
	\item In order to resolve this problem.Three ways to use member function:
	\begin{enumerate}
		\item use std::function:
\begin{lstlisting}[numbers=none]
struct Foo {
	Foo(int num) : num_(num) {}
	void print_add(int i) const{
		std::cout << num_+i << '\n'; }
	int num_;
};

std::function<void(const Foo&, int)> 
			f_add_display = &Foo::print_add;
			
const Foo foo(3);
f_add_display(foo, 1); 
\end{lstlisting}

	\item use mem\_fn:
\begin{lstlisting}[numbers=none]
struct Foo {
	void display_number(int i) {
		std::cout << "number: " << i << '\n';
	}
	int data = 7;
};

Foo f;
auto print_num = std::mem_fn(&Foo::display_number);
print_num(f, 42);
auto access_data = std::mem_fn(&Foo::data);
std::cout << "data: " << access_data(f) << '\n';
\end{lstlisting}

	\item use lambda:
\begin{lstlisting}[numbers=none]
typedef std::function<void(int)> fp;

void test(fp my_func){
my_func(5);
}

Foo foo;
test([&foo](int i){ foo.print_add(i); });
\end{lstlisting}
	
	\end{enumerate}

	\item \textbf{Prefer mem\_fn than bind because it's verbose, Perfer mem\_fn  than std::function, because it lightweight.}
	
	\item You can't really compare std::function with std::mem\_fn. The former is a class template whose type you specify, and the latter is a function template with unspecified return type. There really isn't a situation in which you'd actually consider one versus the other.
	
	A better comparison might be between mem\_fn and std::bind. There, for the specific use-case of a pointer-to-member, mem\_fn is going to a lot less verbose if all you want to do is pass-through all the arguments. Given this simple type:
\begin{lstlisting}[frame=single, language=c++]
struct A { 
	int x;
	int add(int y) { return x+y; }
};
	
A a{2};
auto add1 = std::mem_fn(&A::add);
auto add2 = std::bind(&A::add, _1, _2);
add1(a, 5); // yields 7
add2(a, 5); // same
	\end{lstlisting}
	
	\item mem\_fn(C++11) and mem\_fun. \textbf{mem\_fn is new, don't use mem\_fun any longer}
	
	\begin{enumerate}
		\item mem\_fn is faster than std::bind.  so prefer mem\_fn first.
		
		\item std::mem\_fun can only deal with member functions that take one or no argument. std::mem\_fn is variadic and can deal with members that take any number of arguments.
		
		\item You also need to pick between std::mem\_fun and std::mem\_fun\_ref depending on whether you want to deal with pointers or references for the class object (respectively). std::mem\_fn alone can deal with either, and even provides support for smart pointers.
	\end{enumerate}

	\item \textbf{bind is deprecated in C++11, and will be given up in C++14. perfer to use lambda than bind, detail can be found in effective modern c++ item }
\end{itemize}


\subsection{functor tips}

\begin{itemize}

	\item prefer to use lambda than std::bind, detail can be found in "Effective modern C++" item 34.

\item Functor can be template.
\begin{lstlisting}[numbers=none]
template<typename Type>
class TooBig{
	Type cutoff;
	bool operator()(const T&v){ return v>cutoff};
}
\end{lstlisting}

\item For template functor, You can get value type from iterator\_traits
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
struct Average{
	T operator()(T t1, T t2){t1+t2/2;}
};

transform(beg1, end1, beg1,
Average<typename iterator_traits<beg1>::value_type> () );
\end{lstlisting}
\begin{description}
	\item[Source code:] I also can extract value\_type information from container.This information can be used in template function object. \textbf{This source code is very interesting, it combines container, algorithm and template function together. and almost support "Generic type"}
\end{description}



\item Make predicates pure function, see effective STL item 39. That means that there is no side effect in side the fucntion. 1) no I/O, 2) no change any state.
\begin{lstlisting}[numbers=none]
class Predicate: public unary_function<Foo, bool>{
public:
	bool operator()(const Foo& f) const{ // two const
		cutoff++; // this statment will not compile.
}
private:
	int cutoff;
\end{lstlisting}


\item More effective STL item 42. Make sure less<T> means \texttt{operator<} . Don't specialization of std::less. If you need to another compare, just define your own compare function.
\end{itemize}

\subsubsection{when to use std::function}
\begin{itemize}
	\item About std::function and template? In general, if you are facing a design situation that gives you a choice, use templates. I stressed the word design because I think what you need to focus on is the distinction between the use cases of std::function and templates, which are pretty different.
	
	\item In general, the choice of templates is just an instance of a wider principle: try to specify as many constraints as possible at compile-time. The rationale is simple: if you can catch an error, or a type mismatch, even before your program is generated, you won't ship a buggy program to your customer.
	
	\item Moreover, as you correctly pointed out, calls to template functions are resolved statically (i.e. at compile time), so the compiler has all the necessary information to optimize and possibly inline the code (which would not be possible if the call were performed through a vtable).
	
	
	\item When use std::function? One such use case arises when you need to resolve a call at run-time by invoking a callable object that adheres to a specific signature, but whose concrete type is unknown at compile-time. This is typically the case when you have a collection of callbacks of potentially different types, but which you need to invoke uniformly; the type and number of the registered callbacks is determined at run-time based on the state of your program and the application logic. Some of those callbacks could be functors, some could be plain functions, some could be the result of binding other functions to certain arguments.
	
	\includegraphics[scale=0.9]{pics/function.png} 
\end{itemize}



\chapter{Exception and error}

\section{End application}
\begin{itemize}
	\item In C language, You can call \texttt{abort()}, \texttt{exit()}, \texttt{quick\_exit} and  \texttt{\_exit} to end you problem anytime. they are both declared in <cstdlib> head file.
	
	\item exit( status ) terminates the process normally.
	a status value of 0 or EXIT\_SUCCESS indicates success, and any other value or the constant EXIT\_FAILURE is used to indicate an error. exit() performs following operations:
	\begin{enumerate}
		\item Flushes unwritten buffered data.
		\item Closes all open files.
		\item Removes temporary files.
	\end{enumerate}
	
	\item \texttt{atexit()} Registers the function pointed to by func to be called on normal program termination (via std::exit() or returning from the main function)
\begin{lstlisting}[numbers=none]
void myProgramIsTerminating1(void){
	cout<<"exit function 1"<<endl;
}
	
int main(int argc, char**argv){
	atexit (myProgramIsTerminating1);
	//abort(); if you uncomment it, myProgramIsTerm will not be called.
	return 0;
}
\end{lstlisting}
	
	\item C++11 introduce \texttt{quick\_exit}. It was added to specifically deal with the difficulty of ending a program cleanly when you use threads. \texttt{std::quick\_exit()} is similar to \texttt{\_exit()} but with still the option to execute some code, whatever was registered with \verb=at\_quick\_exit=.
	
	\item \_exit() is called without performing any of the regular cleanup tasks for terminating processes
	
	\item abort() is called without destroying any object and without calling any of the functions passed to atexit or at\_quick\_exit. But It will dump core, if the user has core dumps enabled. Using abort to debug by analysing a core dump.
	
	\item \textbf{When you use gdb, abort can list stack frame information for you.} It's very helpful for you debug information.  Exit just end the application. When you use gdb, it show nothing.
	
	
	\item assert just call abort. You can use assert in this way.
\begin{lstlisting}[numbers=none]
assert(! "You should not reach here");
\end{lstlisting}
	
	\item \texttt{std::terminate} is what is automatically called in a C++ program when there is an unhandled C++ exception. \textbf{This is essentially the C++ equivalent to abort.} This calls a handler that is set by the std::set\_terminate function, which by default simply calls abort.
	
	\item Don't use exit in main, It will not destroy local object in main function. Catch the exceptions you can't handle in main() and simply return from there. This means that you are guaranteed that stack unwinding happens correctly and all destructors are called.
\begin{lstlisting}[numbers=none]
int main() {
	try {
		// your stuff
	}
	catch( ... ) { // catch all exceptions.
		return EXIT_FAILURE;
	}
}
	\end{lstlisting}
	
	\item according to previous main, if you want to end applicaiton in the other fun, you need to throw a exception, then leave it un-handle or re-throw it until it reach main, in this way, stack unwinding will make sure all the destrcutor will be called. \textbf{Don't use exit, it's C-style function and will not perform any stack unwinding}
\begin{lstlisting}[frame=single, language=c++]
try{
	fun(){
		throw end_exception();
	}
}
catch(end_exception& ex){
	//do something here
	throw;
}
\end{lstlisting}
\begin{description}
	\item[Source code:] or just skip the whole catch, end\_exception will reach main function all clean all the local object, when it return from main, it will do the same work as exit();
\end{description}
	
\end{itemize}


\section{Bug and assert}
\subsection{Use assert}
\begin{itemize}
	\item \textbf{Bugs should be found as early as possible}. There are two basic methods to find bugs early: assert and unit test.
	
	\item Idea of assert is to make "an unnormal" can be spotted immediately, or this "an nunormal" will cause error in other place, then It's a little difficult to trace back source.
\begin{lstlisting}[frame=single, language=c++]
fun(char* p){
	assert(p!=nullptr);
	...... // a lot of codes here
	strcpy(p) 
	fun1(p); It will cause error in other place.
}
\end{lstlisting}
\begin{description}
	\item[Line 4:] error happen here, but You don't know the source is the beginning of fun.
\end{description}
	
	\item Although when to use assert depends on context, Use assert to its fullest. \textbf{precondition assertion} to test the validity of the arguments passed to a method. and use \textbf{postcondition assertion} to test the validity of the results produced by the method.  In my whirl2llvm project, I have used them a lot. It really gave me a lot of benefits.
\begin{lstlisting}[frame=single, language=c++]
#include <cassert>
assert(I<5 && "I is more than 5");
\end{lstlisting}
\begin{description}
	\item[Line 2:] string literal is always true; when I<5 is false, the whole condition will be printed out.
\end{description}
	
	
	\item Assert is just if()+abort(): Difference of assert and return error(throw exception)  lies in two sides: 
	\begin{enumerate}
		\item It will abort you application, and you can use GDB to trace back source easily.
		\item \textbf{Do you think that is a bug or  exceptions(error) ?} Detail can be seen conclusion section.
	\end{enumerate}
	
	\item A practical example is dead battery in cell phone, It's a exception. But if you have diarrhea, It's a unnormal, It's not exception. For example, opening file failure is exception, You should (throw exception). but age<0 is a indication of a bug.
\begin{lstlisting}[numbers=none]
	FILE *f = fopen("hr.dat".....);
if(f==nullptr){  // It's an exception, so don't use assert here.
	return -1;
	throw runtime_error();
}
	
assert(age>=0); //Here use assert.
fprintf(f, %d, age);
\end{lstlisting}
	
\end{itemize}

\subsection{Trace}
\begin{itemize}
	\item you can implement trace, such as it in the MFC
\begin{lstlisting}[numbers=none]
#if defined NDEBUG
	#define TRACE( format, ... )
#else
	#define TRACE( format, ... )   printf( "%s::%s(%d)"
	format, __FILE__, __FUNCTION__,  __LINE__, __VA_ARGS__ )
#endif
	\end{lstlisting}
	
\end{itemize}

\section{Handling exceptions}

\subsection{errno in C}
\begin{itemize}
	
	\item There are three common error methods:
	\begin{enumerate}
		\item global error code(C) or error state(C++).
		\item return value.
		\item Exception.
	\end{enumerate}
\begin{lstlisting}[frame=single, language=c++]
//C language
errno(), strerror()
//C++ language
cin.fail()
\end{lstlisting}

	
	\item errno() and strerror() is a typical C language style.
	
	
	\item Besides above, you can use some custom function pointer to do some custom error handling behavior, such as \texttt{set\_new\_handler} function for new operator
	
	\begin{enumerate}
		\item In general, you should detect errors by checking return values, and use errno or perror() only to distinguish among the various causes of an error, such as "File not found" or "Permission denied."
		
\begin{lstlisting}[numbers=none]
FILE * pFile = fopen ("unexist.ent","rb");
if (pFile==NULL)
perror ("The following error occurred");
\end{lstlisting}
		
		\item It's only necessary to detect errors with errno when a function does not have a unique, unambiguous, out-of-band error return (that is, because all of its possible return values are valid; one example is atoi()). In these cases (and in these cases only; check the documentation to be sure whether a function allows this),
\begin{lstlisting}[numbers=none]
#include <cerrno>
errno = 0
// set it zero before call any math library function.
double not_a_number = std::log(-1.0);
if (errno == EDOM) {
		std::cout << "log(-1) failed: " <<
		std::strerror(errno) << '\n';
\end{lstlisting}
		\item You can detect errors by setting errno to 0, calling the function, and then testing errno. (Setting errno to 0 first is important, as no library function ever does that for you.)
	\end{enumerate}
	
\item C11 provide fenv.h file to expand errno
\begin{lstlisting}[frame=single, language=c++]
#include <math.h>       /* math_errhandling */
#include <errno.h>      /* errno, EDOM */
#include <fenv.h>
/* feclearexcept, fetestexcept, FE_ALL_EXCEPT, FE_INVALID */
	
#pragma STDC FENV_ACCESS on
errno = 0;
if (math_errhandling & MATH_ERREXCEPT)
feclearexcept(FE_ALL_EXCEPT);
	
sqrt (-1);
if (math_errhandling & MATH_ERRNO) {
	if (errno==EDOM) 
		printf("errno set to EDOM\n");
}
	
if (math_errhandling  &MATH_ERREXCEPT) {
	if (fetestexcept(FE_INVALID)) 
		printf("FE_INVALID raised\n");
}
\end{lstlisting}
	
\end{itemize}

\subsection{exceptions in C++}
\begin{itemize}
	\item Exception mainly deal with runtime error: At the same time , these potentially recoverable error.  Such as open an unavailable file re request more memory than is available, they can be exceptions.
	
	\begin{enumerate}
		\item A file write operation failed or file access operation because failed file change or non-exist.
		
		\item No enough memory
		
		\item invalid value, which come from user input, not come from you error code logic.
		
		\item System communication software invalid protocol, format, or no response.
	\end{enumerate}
	
	\item unwinding the stack has cost problems, it make progamme 10\% larger and slowlier. So you can use \texttt{-fno-exceptions} to stop it.
	
	\item Exception specification is add throw in the end of function, no throw means that it will throw any exceptions, and throw() means it will not throw any exceptions. Throw( e1, e1) means that it will throw two kinds of exceptions. In C++, this feature has been unsupported and only one left is use throw() to indicates that it will not throw any exceptions.  At the same time, exception specification doesn't use very well with template.
	
	\item A simple exception can be a char string, than use "const char* c" to catch it. A more complicate example is exception class, and you can define the exception class, and throw exception\_class, than use exception\_class \& ec to catch it.  You don't need explicit define exception\_class object and throw this object; throw exception\_class(); will call constructor and throw this unnamed object, it is ok.
	
	\item You can build exception class inside the C++ standard exception system. It need to derive you class from exception, and redefine function what();  if you exception class has very tight relationship with you real class, it can be declared as nested class.
	
\begin{lstlisting}[numbers=none]
Class my_ex :public std::exception{
	const char* what(){return "my_ex reason is here"}
}
\end{lstlisting}
	
	\item Arranging the catch blocks in inverse order of derivation.
	
	\item Standard exception includes \textbf{logic\_error, domain\_error,  runtime\_error.  Invalid\_argument, out\_of\_bounds, range\_error, overflow\_error.}
	
	\item \textbf{Catch use reference, 1) It will support polymorphic exception, and catch exception from specify to generic.2) It will avoid extra coping}
	
\item Empty throw means that you throw present exception again.
	\begin{lstlisting}[frame=single, language=c++]
catch(my_base_ex &me){
	......
	throw;
}
\end{lstlisting}
\begin{description}
	\item[Line 3:] 	Don't use throw me, because maybe me is child class of my\_base\_ex;
\end{description}
	
	\item In you destructor, don't throw any exception, or catch all the exception in side of it. Or it will call stop the application. see more effective C++ exception chapter.
	
	\item Compared with return error code, exception has advatnage:
	\begin{enumerate}
		\item  Can catch deeper called function exceptions. If you want to use return value, deeper called function is hard to deal with.
		
		\item Difficult to return value, 1) no return value, such as class constructor, 2) all return value is normal value, such as atoi().
		
		\item Make happy path and error-handle path clearly.
		
		\item You can't omit exception, Any unhandle exception will can terminate in the end.
	\end{enumerate}
	
\end{itemize}

\section{Conclusion}
\begin{itemize}
	\item  Consciously specify, and conscientiously apply, what so many projects leave to adhoc
	(mis)judgment: Develop a practical, consistent, and rational error handling
	policy early in design, and then stick to it. Ensure that it includes:
	
	\begin{enumerate}
		\item Identification: What conditions are errors.
		\item Severity: How important or urgent each error is.
		\item Detection: Which code is responsible for detecting the error.
		\item Propagation: What mechanisms are used to report and propagate error
		notifications in each module.
		\item Handling: What code is responsible for doing something about the error.
		\item Reporting: How the error will be logged or users notified
	\end{enumerate}
	
	
	\item For different runtime errors, you can take different actions. And It's depends on you context of application.
	\begin{enumerate}
		\item error is just warning, log or show it to user, then continue;
		\item error can be resolved inside a function, the whole appliation can be continue after you reslove or retry, such as input error.
		\item error is serious, application can't continue, stop (call exit).  please debug me (call abort)
		\item set global error code or return error code or throw exception. then caller decide what to do (return a error code or use exception)
	\end{enumerate}
	
	\item Pay attention, exception and return a error code has the same philosophy. \textbf{let caller decide what to do next}.
	
	\item Exception handling is highly dependent on your application context. So it should be designed into a program rather than just added on.
	
	\item Confusing logical error with runtime error. \textbf{For logical error, you need to rewrite code to fix it. For runtime error, you need to throw it and catch it to responds. } logical error should use assert  or unit tesst to find the as early as possible. For example, in f(Foo* p), p is nullptr. There are two possibilities:
	\begin{enumerate}
		\item they are passing nullptr because they got bad data from an external user (for example, the user forgot to fill in a field and database connection fail) you should throw an exception since it is a runtime situation \textbf{(i.e., something you can't detect by a careful code-review; it is not a bug)}.
		\item they just plain made a mistake in their own code. you should definitely fix the bug in the caller's code. but you must not merely change the code within f(Foo* p); you must, must, MUST fix the code in the caller(s) of f(Foo* p).
	\end{enumerate}
	\item \textbf{ In previous example, You can use assert first, after you code-review, found that It's not bug, but cause by an exception, such as net disconnect. so you can change assert to throw. THAT IS  A GOOD STRATEGY!}
	
\begin{lstlisting}[frame=single, language=c++]
fun(int* pi, int j){
	assert(j< 10);
	if (pi == nullptr)
	
	if(file.open())
		throw runtime_error();
}
\end{lstlisting}
\begin{description}
	\item[Line 2 and 3:] don't throw it, It's logical error. you need to check  caller of fun why pass a nullptr into fun.
	\item[Line 5:] file maybe deleted. It's not your logic error but runtime error.
\end{description}

	\item Use all throw and catch to replace return-code. For a simple function, just return one error code and user will not forget to test return code. this time, return-code method maybe is better.
	
	\item For object constructor, always use exception and try block.
	
	\item When to use assert ?
	\begin{enumerate}
		\item your problem comes from your own bad code, it's better to use ASSERTs.  Including you coding error or addition overflow.
		\item bugs in your program are not something the user can handle, User can do nothing when he face "age should be not negative" unless age is inputted by himself(at this time, you should use return error code)
		\item you have to stop your application. If you write negative age back to database, It may cause futuristic error for other user later, and It's very difficult to trace back.
	\end{enumerate}
	
	
	\item When to throw a exception( or return error code)?
	\begin{enumerate}
		\item As a general rule of thumb, throw an exception when your program can identify an \textbf{external problem} that prevents execution.
		\item identify problems that program cannot handle and tell them about the user, because user can handle them.
		\item For example, no memory space, no file exit, no net connection , no object construct and get invalid data from sever etc.
	\end{enumerate}
	
	\item When to use try... catch block?
	\begin{enumerate}
		\item Catch an exception where you can do something useful with it.
		\begin{enumerate}
			\item You can actually handle the exception. your catch clause deals with the error and continues execution without throwing any additional exceptions. My caller never knows that the exception occurred.
			\item So I can have a catch clause that does blah blah blah, after which I will rethrow the exception. In this case, consider changing the try block into an object whose destructor does blah blah blah. For instance, if you have a try block whose catch clause closes a file then rethrows the exception, consider replacing the whole thing with a File object whose destructor closes the file. This is commonly called RAII
			\item Show some message or log exception, or give user a list options to select.  then rethrow.
		\end{enumerate}
		
		\item For an atomic operation, there is only one try block. That is to say, inside one function, just include one try block
\begin{lstlisting}[numbers=none]
atomic_fun(){
	try{
		//complex operation.
	}
	catch(...){
		cout<<"I can't do it"<<endl;
		throw;
	}
\end{lstlisting}
	\end{enumerate}
	
	\item Exception in C++ is a tool; use it properly and it will help you; \textbf{but don't blame the tool if you use it improperly.} "Wrong exception-handling mindsets" in c++ FAQ website section 17 is good topic. You need to read it again if you have time.
	
\end{itemize}


\chapter{I/O}
\section{I/O basic}
\subsection{I/O basic knowledge}
\begin{itemize}
	\item Neither C++ nor C has built input and output in the language. They use functions(C) or other I/O obje
	cts(C++) in language library.
	
	\item C++ I/O class and head file \\
	\includegraphics[scale=0.45]{pics/io.png}
	\begin{enumerate}
		
		\item \textbf{iofs} stand for three head files <iostream> <fstream> and <sstream>. <iostream> includes <ios> automatically. They are three main header file you should includes in your C++ application.
		
		\item three classes: iostream(streambuf), fstream(filebuf), stringstream(stringbuf) and four pre-defined object: \texttt{cin, cout, clog and cerr} 
		
		\item clog is just like cerr, but it buffer it output.
		
		\item C++ normally flushes the input buffer when you press enter. For output to the display, C++ program normally flushes the output buffer when you transmit a newline character, or reaches an input statement.
		
		\item \verb=>>= and \verb=<<= don't need to format string,  C++ will automatically,  convert it, it's better than printf and scanf in C language.
		
		\item through inheritance, fstream and cin(cout) share the same usage. \textbf{All the knowledge can be used directly in fstream.} I like it the most.
	\end{enumerate}
	
\end{itemize}



\section{Input}

\subsection{Input basic knowledge}

\begin{itemize}
	\item For Input, you need to master \textbf{One basic idea, Two languages, Three data type.}
	\item One basic idea: In order to make continuously input, you need to use while(inputMethod), When two things happens:
	\begin{enumerate}
		\item user want to end input(ctrl+D) or read the end of File;
		\item read fail (for example,  \verb|cin>> int|, but input letter 'a'),
	\end{enumerate}
	
	InputMethod will return false.  Then you need use some flag or status to tell the difference between EOF or error inside of while loop.
	
	\item Two languages is c and c++, they use the different inputMethod. three data types are: number and word(no space in middle), character(white), and string(include space in middle)
	
	\item two languages common used input method \\
	\begin{tabular}{|p{0.08\textwidth}|p{0.25\textwidth}|p{0.25\textwidth}|p{0.25\textwidth}|}
		\tophline
		& Number and non-white  character word & Character (including white-character) & string(line)\\
		\tophline
		C &scanf("\%d \%f \%c \%s",\&i, \&f,\&c);  & int a = getchar(); & fgets(stdin, char*p, n ) \\
		\tophline
		C++ & \verb|cin>>i>>f>>c>>w;| & cin.get(char \& c); \newline  Ch = cin.get(); & cin.get( char *p, n); \newline cin.getline(char *p, n); \newline getline(cin, string);
		\bottomhline
	\end{tabular}
	
	
	\item In scanf, You need to specify exact data type when you read.
	\begin{enumerate}
		\item h:  short int or short unsigned. Example: \%hd or \%hu.
		
		\item l:  a long int or long unsigned, or double (for \%f conversions.) Example: \%ld, \%lu, or \%lf.
		
		\item L: The value to be parsed is a long long for integer types or long double for float types. Example: \%Ld, \%Lu, or \%Lf.
		
		\item *: Tells scanf() do to the conversion specified, but not store it anywhere. This is what you use if you want scanf() to eat some data but you don't want to store it anywhere; you don't give scanf() an argument for this conversion. Example: \%*d.
	\end{enumerate}
	
	
	\item scanf("\%c" \&c) will read any character, including whitespace character. If you want to scanf skip any whitespace, you can use space before \%c.
	
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
while(true){
	scanf("%c",&c);
	//scanf(" %c",&c);
	printf("you input: %d" c);
}
\end{lstlisting}
\begin{description}
	\item[Output:] When you input a(enter), output will be like
	you input: 97(a value)
	you input: 10(enter value)
\end{description}
	
	\item \verb=cin>>c= will not read white character(tab, space , newline), If you want to read them from input buffer, You should use getchar() or cin.get(); If you want the user to input his or her name
\begin{lstlisting}
while(true){
	cin>>c;
	cout<<"you input:"<<c<<endl;
}
	\end{lstlisting}
	\begin{description}
		\item[Output:] When you input  "    a(enter)"
		output will be like:you input:  a. then cursor wait for here.
	\end{description}
	
	\item Using \verb=cin>>= or scanf will terminate the string after it reads the first space. The best way to handle this situation is to use the function to read a line;
	
	\item Read word and line:
\begin{lstlisting}[frame=single, language=c++]
scanf(%s,char_array) //c
cin>>char_array or ; //c++
cin>> str;
	
//line	
gets(char_array)  //c
fgets(char_array, n , FILE *) 
	
cin.getline(char * ,int n) 
cin.get(char * ,int n) 
std::getline(istream&  is, string& str)
	\end{lstlisting}
\begin{description}
	\item[Line 1:] read a word until reach white character.
	\item[Line 7:] recommend to use this for safety.
	\item[Line 9:] c++ read and discard newline
	\item[Line 1:] not read newline
\end{description}
	
	\item cin.read function has the same interface with cin.get, but it doesn't append a null character to input, It's not intend for keyboard input, but for binary format of file
	
	\item \textbf{For C++, three get, two getline, other use} \verb|>>|;
	
	\item Difference between cin.get(char) and int = cin.get()
\begin{lstlisting}[frame=single, language=c++]
while(cin.get(c))
// use cin.get(char) in reading loop

cin.get() != '\n'
//use cin.get() return character to test sth.
	
cin.get()!= EOF
\end{lstlisting}
\begin{description}
	\item[Line 7:] When used in EOF, you have to use int. because EOF may not be expressed by char tyep
\end{description}
	
	\item Three confused functions: cin.get and cin.getline are almost the same thing.
\begin{lstlisting}[numbers=none]
cin.get ( char* s, streamsize n, char delim );
cin.getline (char* s, streamsize n, char delim );
istream& getline (istream&  is, string& str);
\end{lstlisting}
	
	\begin{enumerate}
		
		\item For each line, if you don't know the max length, juse use getline(cin, string). You don't need to input any length.(you can reserve lengh of string if you want to avoid allocation of memory)
		
		\item cin.get() doesn't discard delim from input stream. However, cin.getline() will read and discard newline.  (It's easy for you to remember, because, \textbf{line} is defined by newline character)
		
		\item In cin.getline(char* s, int n)The failbit flag is set if the function extracts no characters(newline is a character), Or if the delimiting character is not found once (n-1) characters have already been written to s. Note that if the character that follows those (n-1) characters in the input sequence is precisely the delimiting character, it is also extracted and the failbit flag is not set.
		
		\item In cin.get(char* s ,  int n). The failbit flag is set only if the function extracts no characters.
		
		\item If you are talking about the newline character from a console input,it makes perfectly sense to discard it, So use cin.getline(). Or you don't want to customized flexible reading method, just read a line from a file. please use cin.getline().
		
		\item cin.get(char* s, n) is more flexible than cin.getline. Because when it read to the array is full, It doesn't set failbit. At this time you can use gcount() or peek() to see if next character is new line. It's more customized than  cin.getline();
	\end{enumerate}
	
\end{itemize}

\subsection{Input error}

\begin{itemize}
	\item \textbf{For the error of input: Just remember C language return EOF and NULL, and C++ return all false. }
	
	\begin{tabular}{|c|c|c|c|}
		\tophline
		& Number, non-white & character, white  & string \\
		\tophline
		C & scanf return EOF & getchar return EOF & fgets return NULL \\
		\tophline
		c++ & cin return false & cin return false & cin.getline return false \bottomhline
	\end{tabular}
	
	\item When you can't continue input, you need to know if it's end of file or fail. In C language, you can use feof and ferror function, in C++, you can use cin.eof(), cin.fail() or cin.bad() three functions. cin.bad() means serious system error happens, and input buffer can't be consistent and can't be recoveried anymore.
	
	\item When failbit or badbit are set. fail() return false, So you need to judge it by bad() again if this information is important for you.  Usually, bad() is not use very often.
	
	\item eofbit is interesting topic. when you reach(not read) the "logical end-of-file", it will not be set, \textbf{It's set by a read function, not by position}   Instead,  You can use std::ifstream::peek() to check for the "logical end-of-file".
	
	\item \textbf{eof is set by last read EOF position} When you read EOF position, failbit is set and eof is set too. So If EOF is set, failbit must set too.  If only failbit is set, it means that input error happen.  Under these two conditions, istream will return false by operator bool.
	
	\item In http://en.cppreference.com/w/cpp/io/basic\_ios/operator\_bool . You can see eofbit are true and failbit are false, operator bool return true. I don't' know when it will happen. \textbf{ eof() function returns "true" after the program attempts to read past the end of the file.}  But when read action set eofbit, it will set failbit at the sametime, so bool operator will return false because failbit are set.
	
	\item How do you know if you read an incorrect input word, or if you are at the end of the file? This is when you use cin.eof() or feof() in C language.
	
	
	\item you can use clear() and setstate() to set the states, Why? It's just depends on what the program is trying to accomplish.  It provides a means for you to change the state. setstate() is different with clear(), clear() clear all the status bit. but setstate just set specific bit.
	
	\item You can use exceptions() method to control if exceptions will throw, when the eofbit, failbit and badbit is set.
	
	\item setstate() is to provide a means for input and output functions to change the state. For end user, we don't use it very often. We just use clear() more.
	
	\item for rdstate() it will return all the bit value, then you can use \& to certain bit( such as failbit) to check if the bit has been set. But here, you can use fail() directly, so we don't use this function very often.
\begin{lstlisting}[frame=single, language=c++]
std::ifstream is;
is.open ("test.txt");
if ( (is.rdstate() & std::ifstream::failbit ) != 0 )
std::cerr << "Error opening 'test.txt'\n";
\end{lstlisting}
	
	
	\item \textbf{clear() function is very important, when cin.fail() return true, you have to use clear(), otherwise all he below cin operation will not work.} See below example.
	
\begin{lstlisting}[numbers=none]
char ch, str[20];
cin.getline(str, 5);
cout<<"flag1:"<<cin.good()<<endl;    // check good bit
cin.clear();   //without, cin>>ch below will not work at all
cout<<"flag1:"<<cin.good()<<endl;    // check good bit again
cin>>ch;
cout<<"str:"<<str<< " ch:" <<ch<<endl;
	

\end{lstlisting}
\begin{description}
	\item[Output:] 
	\begin{verbatim}
	input:
	12345[Enter]
	output:
	flag1:0 // good()return false
	flag2:1 // good()return true after clear().
	str:1234 ch:5
	\end{verbatim}
\end{description}
	
\end{itemize}

\subsection{Input Pattern}

\begin{itemize}
	\item It is bad idea to test the stream on the outside and then read/write to it inside the body of the conditional/loop statement. This is because the act of reading may make the stream bad. It is usually better to do the read as part of the test.
	
\begin{lstlisting}[numbers=none]
while(!cin.fail()){  // that is bad programming style
	cin>>i;  //here may make stream fail().
	.....      //then i is not valid value
}
	\end{lstlisting}
	
	\item If you just want to input, You don't want to know eof or deal with failbit. You can use below: \\
	
\begin{lstlisting}[numbers=none]
while(scanf("%d",&i) != 1)
while((int c = getchar())!=EOF)
while( fgets(line, sizeof(line), fp) != NULL )
//in c language, use these to exit loop!
	
while(cin>>input)
while(cin.get(p, 20) )
while(getline(ifstream, string)) {
	//in C++ language, use bool operator to exit loop.
	//do some useful things.  //input is right.
}
\end{lstlisting}
	
	\item If you want to know eof or deal with error. You can use below code. When you press enter, the read will end. When you input letter, it will get rid of these letter until you input number. 
\begin{lstlisting}[frame=single, language=c++]
While(true)  // use break to exit loop;
{
	cin>>i // or getline(ifstream, string);
	if(cin.eof()){   //If it's EOF
		cout<<"EOF encountered"<<endl
		//break;
	}
	
	if(cin.fail())    //deal with Invalide input
	{
		cin.clear(); //Important. clear state and buffer
		while(cin.get()!='\n')  //get rid rest of line,
			continue ;
		cout<<"please input a number"<<endl;
		continue;
	}
	...  // input is right.do some useful things.
}
\end{lstlisting}
	
	\item In the previous example, Why do we need to distinguish eof and fail? When fail happen, maybe there are invalid character in buffer. After clean the buffer, I can continue to read input from input buffer. Three methods to clean invalid character in the buffer
\begin{lstlisting}[numbers=none]
cin.clear();    //Important. clear state and buffer
while(cin.get()!='\n')
	continue ;      // method 1
	
while(!issapce(cin.get()))
	continue;  //method 2
	
basic_istream& ignore(streamsize _Count = 1, \
int_type _Delim = traits_type::eof());  //method 3
cin.ignore(5, 'a');
cin.ignore(numeric_limits<streamsize>::max(), '\n');
\end{lstlisting}
	
	\item You can use istream\_iterator, It can save you some trouble to judge EOF.
	
\begin{lstlisting}[frame=single, language=c++]
class A{
private:
	int x,y;
	friend istream& operator>>(istream& in, A&);
	friend ostream& operator<<(ostream& in, const A&);
};
	
istream& operator>>(istream& in, A& a){
	in>>a.x>>a.y;
	return in;
}
	
ostream& operator<<(ostream& out, const A& a){
	out<<a.x<< " " <<a.y;
	return out;
}
	
	vector<A> v;
	copy(istream_iterator<A>(cin), istream_iterator<A>(),
	back_inserter(v));
	copy(v.begin(), v.end(),ostream_iterator<A>(cout, "\n"));
\end{lstlisting}
	
	
	\item \textbf{In summary, It's better just use judgment to exit end loop.  If you need to different specific action to take to deal with EOF or error. Use while(true), then use eof() of feof() fail() or clear() functions in c++ and c to deal with and break the loop; }
\end{itemize}

\section{output}

\begin{itemize}
	\item For cout, It can recognize type automatically, and It is extensible, You can redefine \verb=<<= operator so that cout can recognize you data type.
\begin{lstlisting}[frame=single, language=c++]
class Foo{
	friend ostream & operator<<(ostream& s,const Foo &r);
}
	
ostream & operator<<(ostream& s, const Foo &r){
	s<<Foo.a<<Foo.b<<endl;
}
\end{lstlisting}
	
	\item  How to print pointer address in C and C++?
\begin{lstlisting}[numbers=none]
char* amount = "dozen";
cout<< amount  ; //print "dozen" string
	
cout<<(void*) amount;//prints the address of pointer
printf("%p", (void*) p);
\end{lstlisting}
	
	
	\item Format is key point for Output. you need to know the common manipulator to control the output format.
	\item Number base manipulators:  hex, oct  and dec; Field widths: Width,  fill, precision Setf()
	\item You don't need to know the details, just name of them. When you want to use them go to reference website to look.A detail format manipulators can be seen on C++ primer P1090. You need to include <iomanip>
	
	\item \verb=<<= is a bitwise left-shift operator in C language, but in C++, we overloaded it in ostream class, cout is a object of ostream,
	
	\item You can use \verb=cout<<flush= to force flushing the output buffer
	\item cout.write can be used to output a string, It will output certain length string, even reach the end of string.
	
	
\end{itemize}

\section{other stream}

\subsection{file}
\begin{itemize}
	\item When you studied cin and cout very well, you will find that file operation is so easy. just change cin or cout to your ifstream , ofstream or fstream object.
	
\begin{lstlisting}[numbers=none]
std::fstream ifs;
ifs.open ("test.txt", ios_base::in| ios_base::binary);
if(!ifs.is_open())
	exit(1);
char c = ifs.get();
// use all previous input methods
ifs.close();
\end{lstlisting}
	\item Only read ifsteam;  Only write ofsteam; write and read fstream.
	
	\item For ios\_base::binary mode, use write() and read() funciton.
	
	\item For writing, pay attention to the difference between ios\_base::trunc and ios\_base::app
	
	\item Random access is used mostly on binary file. Because the position can be pinpointed exactly. For seekg() for input, and seekp() for output.(p is put, g is get) It move the pointer. tellp() and tellg() function.  It tell the position of pointer.
	
\end{itemize}

\subsection{buffer and string buffer}

\begin{itemize}
	\item stringstream is a convenient way to manipulate strings like an independent I/O device. Sometimes it is very convenient to use stringstream to convert bettween strings and other numerical types. The usage of stringstream are much the same with iostream, so it is not a burden to learn.  
	
	\item \textbf{You need to build a stringstream from a string, or convert a stringstream back to a string.}
	
\begin{lstlisting}[frame=single, language=c++]
stringstream outstr;
outstr<<"salary value"<<123333.00<<endl;
string str = outstr.str() //change to string
	
istringstream Instr(str);
while(instr>>number)
	cout<<number<<endl
	
char sentence []="Yan is 41 years old";
char str [20];
int i;
sscanf (sentence,"%s %*s %d", str, &i);
sprintf(.....);
\end{lstlisting}
\begin{description}
	\item[Line 1 to 3:] change number to a text.
	\item[Line 5 to 7:] change text to a number.
	\item[Line 9 to end:] C language method. In line 12, you can see "*s", it means input will be ignored. So str = Yan, i = 41.
\end{description}
	
\end{itemize}

\section{manipulate stream}
\begin{enumerate}
	\item \textbf{peek} return the next character from input without extracting from the input stream. For example, you want to read input up to the first newline or period.
\begin{lstlisting}[numbers=none]
char input[80];
int i = 0;
while( (ch=cin.peek()) != '.' && ch != '\n')
	cin.get(input[i++];)
input[i] = '\0';
\end{lstlisting}
	
	\item \textbf{gcount()} method returns the number of characters read by the last unfromatted extraction method. That means character read by the a get(), getline(), ignore(), or read(), but not extraction operator.
	
	\item \textbf{putback()} function inserts a character back in the input buffer.
\end{enumerate}


\chapter{New Feature in moder C++}

\section{New Type}

\subsection{New int}

\begin{itemize}
\item Add three new data types " long long", "char16\_t"  and "char32\_t". standard define:
\begin{enumerate}
\item int must be at least 16 bits
\item long must be at least 32 bits
\item long long must be at least 64 bits
\end{enumerate}

\item If you need a specific integer size for a particular application, rather than trusting the compiler to pick the size you want, \#include <stdint.h> (or <cstdint>) so you can use these types:\textbf{All these types have \_t in the end.}
\begin{lstlisting}[numbers=none]
int8_t and uint8_t
int16_t and uint16_t
int32_t and uint32_t
int64_t and uint64_t
\end{lstlisting}

\item The fixed-width integers have two downsides: First, they may not be supported on architectures where those types can't be represented. They may also be less performant than the built-in types on some architectures.To help address the above downsides, C++11 also defines two alternative sets of integers. They are int\_least and int\_fast  

\item The 8-bit fixed-width integer types.
Any compiler-specific fixed width integers -- for example, Visual Studio defines \_\_int8, \_\_int16, etcâ€¦


\item integer best practices:
\begin{enumerate}
	\item int should be preferred when the size of the integer doesn't matter (e.g. the number will always fit within the range of a 2 byte signed integer). For example, if you're asking the user to enter their age, or counting from 1 to 10, it doesn't matter whether int is 16 or 32 bits (the numbers will fit either way). This will cover the vast majority of the cases you're likely to run across.
	
	\item If you need a variable guaranteed to be a particular size and want to favor performance, use std::int\_fast\_t.
	
	\item If you need a variable guaranteed to be a particular size and want to favor memory conservation over performance, use std::int\_least\_t. This is used most often when allocating lots of variables.
	Avoid the following if possible:
	
	\item Don't use unsigned types, unless you have a compelling reason.
\end{enumerate}


\item nullptr is always a pointer type, Don't use NULL any more. NULL is just 0 In C language, but in strong type C++ language, NULL can be ambiguity in f(int); and f(foo *);

\item Syntactic improvement of C++ 14:
\begin{enumerate}
\item Prefix 0b and are followed by binary digits.
\item To use the single quote character, making the million dollar value render in C++ as: 1'000'000.00.
\end{enumerate}

\begin{lstlisting}[numbers=none]
int val = 0b11110000;
std::cout << 0b1000'0001'1000'0000;
std::cout<<300'000.00;
\end{lstlisting}

\item Note that the syntax of C++ attribute-tokens might seem a bit unfamiliar. The list of attributes, including [[deprecated]], comes after keywords like class or enum, and before the entity name. A good article can be found if you google "Marking as deprecated in C++14". This feature is useful for a large and long term project. You can't just delete class \texttt{flaky}, because other people maybe is using it in their code. 

\begin{lstlisting}[frame=single, language=c++]
class [[deprecated]] flaky {
};
[[deprecated("Consider using something other than cranky")]]
int cranky(){
   return 0;
}

  flaky f;
  return cranky();
\end{lstlisting}
\begin{description}
	\item[Line 8 and 9:] below two statements produce compiler warning.
\end{description}

\end{itemize}

\subsection{new container}
\begin{itemize}

\item New container: forward\_list, unordered\_map unordered\_set.  The latter two support implementing hash tables. std library provide basic hash function for some basic type, such as int and string. If you have you own class, you can use boost::hash\_combine. 

\item To support user-defined key types in std::unordered\_set<Key> and std::unordered\_map<Key, Value> one has to provide operator==(Key, Key) and a hash functor
\begin{lstlisting}[numbers=none]
struct X { int id; /* ... */ };
bool operator==(X a, X b) { return a.id == b.id; }

struct MyHash {
size_t operator()(const X& x) const { 
	return std::hash<int>()(x.id); }
};

std::unordered_set<X, MyHash> s;
\end{lstlisting}

\item You are expressly allowed and encouraged to add specializations to namespace std*. The correct (and basically only) way to add a hash function is this:
\begin{lstlisting}[frame=single, language=c++]
namespace std {
	template <> struct hash<Foo>{
		size_t operator()(const Foo & x) const{
			//your code here
		}
	};
}
std::unordered_set<Foo> s;
\end{lstlisting}
\begin{description}
	\item[Line 4] your code here, e.g. return hash<int>()(x.value);
\end{description}
\item A good std::hash example can be found in cppreference.com 

\item std::array is just a class version of the classic C array. \textbf{Its size is fixed at compile time and it will be allocated  on the stack}.

\item std::vector is a small class containing pointers into the heap. (So when you allocate a std::vector, it always calls new.) They are slightly slower to access because those pointers have to be chased to get to the arrayed data... But in exchange for that, they can be resized and they only take a trivial amount of stack space no matter how large they are.


\item Because it does bounds checking, at() is slower (but safer) than operator [].

\item array support copy and assignment between the same size.
\begin{lstlisting}[numbers=none]
auto a3 = a2; //Making a new array via copy
auto a4(a2); //same
a5 = a2 // a2 and a5 must have the same size.
\end{lstlisting}


\item Fixed arrays decay into pointers, losing the array length information when you pass it to a function.

\item Like std::vector, std::array doesn't implicitly decay into a raw pointer. If you want to use the underlying std::array pointer, you must use the data() member function.For example, let's assume you are using an API with a C-style buffer interface: For other new function, you can use std::array\& as a function parameter. 

\begin{lstlisting}[numbers=none]
void carr_func(int * arr, size_t size){
    std::cout << "carr_func - arr: " << arr << std::endl;
}

carr_func(a2, a2.size()); //Error:
carr_func(a2.data(), a2.size()); //OK
\end{lstlisting}

\item Use std::vector unless (a) your profiler tells you that you have a problem and (b) the array is tiny.
\begin{lstlisting}[numbers=none]
#include <iostream>
#include <array>
void printLength(const std::array<double, 5> &myarray){
    myarray.sort();
    std::cout << "length: " << myarray.size();
}

std::array<double, 5> myarray { 9.0, 7.2, 5.4, 3.6, 1.8 };
printLength(myarray);
\end{lstlisting}


\item \textbf{For most of time, you should use std::array and std::forward\_list firstly if you don't have any strong reason against using them.} 
\end{itemize}


\section{range base}
\begin{itemize}
	
	\item A range-based for loop is introduced in C++11. Use \texttt{auto\&} to aoid copying each element. Below are highly recommended when yo use STL container.
	
	\begin{enumerate}
		\item For observing the elements, use the following syntax. For observing the elements in generic code. since we can't make assumptions about generic type T being cheap to copy, it's safe to always use for (const auto\& elem : container).
		(This won't trigger potentially expensive useless copies, will work just fine also for cheap-to-copy types like int, and also for containers using proxy-iterators, like std::vector<bool>.)
\begin{lstlisting}[numbers=none]
for (const auto& elem : container)    
// capture by const reference
\end{lstlisting}	
		
		
		\item If the objects are cheap to copy (like ints, doubles, etc.), it's possible to use a slightly simplified form. 
		
\begin{lstlisting}[numbers=none]
for (const auto elem : container)   
// capture by value
\end{lstlisting}            
		
		\item Of course, if there is a need to make a local copy of the element inside the loop body, capturing by value (for (auto elem : container)) is a good choice.
		
		\item For modifying the elements in place, use:
\begin{lstlisting}[numbers=none]
for (auto& elem : container)    
// capture by (non-const) reference
\end{lstlisting}
		
		
		
		\item If there are pointer inside the container. You don't need star symbol explicitly, but it give more information to the variable, so I reccommend using it.
\begin{lstlisting}[numbers=none]
//make sure Container contain pointer
for(auto *ptr: Container){ ptr->change();}
for(const auto *ptr: Container){ ptr->read();}
\end{lstlisting}
		
	\end{enumerate}
	
	
	\item For vector<bool>, below code doesn't work, because std::vector template is specialized for bool, with an implementation that packs the bools to optimize space (each boolean value is stored in one bit, eight "boolean" bits in a byte). Because of that (since it's not possible to return a reference to a single bit), vector<bool> uses a so called "proxy iterator" pattern. A "proxy iterator" is an iterator that, \textbf{when dereferenced, does not yield an ordinary bool \&, but instead returns (by value) a temporary object}, which is a proxy class convertible to bool. 
\begin{lstlisting}[numbers=none]
vector<bool> v = {true, false, false, true};
for (auto& x : v)
x = !x;
\end{lstlisting}

	
	\item If you want to read, you can use two below methods:
\begin{lstlisting}[numbers=none]
for(auto i: bv)

for(auto const & i: bv)
	cout<<i<<endl;
\end{lstlisting}
	
	\item If we want generic code to work also in case of proxy-iterators, the best option is for (auto\&\& elem : container).This will work just fine also for containers using ordinary non-proxy-iterators, like std::vector<int> or std::vector<string>.It also can modify vector<bool> 
\begin{lstlisting}[numbers=none]
for (auto&& elem : container)
\end{lstlisting}
	
	\item The range-based version is for: You want to do something with every element in the container, without mutating the container(insert or erase). If you want to mutate the container, Follow idea introduced in Container--Erasure section below.
	
	\begin{enumerate}
		\item For any container, you can \textbf{NOT} mutating container by calling insert or erase inside loop.
		\item If you really want to change a container, for a sequential container, you can use range-based function to change elements. 
		\item For any associate container, only visit each element. If you want to change a key, delete it first, then modify, in the end insert new key again. 
	\end{enumerate}
	
\end{itemize}

\section{lambda}

\begin{itemize}
\item lambda basic syntax and an example.
\begin{lstlisting}[numbers=none]
[ captures ] (parameters) -> returnTypesDeclaration { ..; }
int sum = 0, divisor = 3;
vector<int> vc { 1, 2, 3, 4, 5, 10, 15, 20, 25, 35, 45 };
for_each(vc.begin(), vc.end(), [divisor, &sum] (int y){
		if (y % divisor == 0){
			cout << y << endl;
			sum += y;
		}
	});
 cout << sum << endl;
\end{lstlisting}

\item Lambda is used on complex type container. You can use typedef.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
typedef std::vector< std::pair<int,std::string> > Record_t;
Record_t k1;

int find_it(std::string value, Record_t const& stuff){
  auto fit = std::find_if(stuff.begin(), stuff.end(),
            [value](Record_t::value_type const& vt) -> bool
                 { return vt.second == value; });
  if (fit != stuff.end())
           return fit->first;
}
\end{lstlisting}
\begin{description}
	\item[Line 1:] typedef is your good friend, reuse it on line 4 and line 6.
	\item[Line 6 to 7:] we define a lambda function.
\end{description}
\item This auto-declaration defines a closure type named factorial that you can call later instead of typing the entire lambda expression (a closure type is in fact a compiler-generated function class):
\begin{lstlisting}[numbers=none]
auto factorial = [](int i, int j) {return i * j;};

int arr{1,2,3,4,5,6,7,8,9,10,11,12};
long res = std::accumulate(arr, arr+12, 1, factorial);
cout<<"12!="<<res<<endl; // 479001600
\end{lstlisting}

\item Under the final C++11 spec, if you have a lambda with an empty capture specification, then it can be treated like a regular function and assigned to a function pointer. Here's an example of using a function pointer with a capture-less lambda:
\begin{lstlisting}[numbers=none]
typedef int (*func)();
func f = [] () -> int { return 2; };
f();
\end{lstlisting}

\item A delegate. When you call a normal function, all you need is the function itself. When you call a method on an object, you need two things: the function and the object itself. It's the difference between func() and obj.method(). Starting with some code that again expects a function as an argument, into which we'll pass a delegate. \textbf{lambda is like a glue to combine for\_each and class MessageSizeStore.}

\begin{lstlisting}[numbers=none]
class MessageSizeStore{
public:
    MessageSizeStore () : _max_size( 0 ) {}
    void checkMaxMessage (const std::string& message ) {...}
    int getSize (){...}
private:
    int _max_size;
};

MessageSizeStore size_store;
for_each(s.begin(),s.end(), [&] (const std::string& message){
	size_store.checkMessage( message );
});
\end{lstlisting}

\item Why functor is better than function pointer? because functor can be inline. 

\item Why lambda is bettern than functor? 
\begin{enumerate}
\item lambda will produce a unnamed functor class. Not pollute name space.Frequently (not in this example, though) the name of the functor class is much less expressive than its actual code.
\item It can be inline too.
\item It can access all the automatic variable.
\item It's much less verbose.
\item Placing the code closer to where it's called improves code clarity.
\begin{lstlisting}[numbers=none]
int count3 = 0;
std::count_if(v.begin(), v.end(), 
        [&count3](int x){count3 += (x%3 == 0)} 
           );
\end{lstlisting}
\end{enumerate}
\end{itemize}


\section{Other New Feature}
\subsection{delctype}
\begin{itemize}

\item decltype and  Trailing Return type(C++11 new feature)
\begin{lstlisting}[frame=single, language=c++]
template<typename T1, typename T2>
void f(T1 x, T2 y){
	decltype(x+y) xpy = x+y;
}

template<typename T1, typename T2>
auto f(T1 x, T2 y) ->decltype(x+y){
	x+y;
}
\end{lstlisting}
\begin{description}
	\item[Line 1 to 4:] It can be used inside a function to declare variable.
	\item[Line 6 to 9:] It also can be used in function return.
\end{description}

\item How to make your template class has more generic use for client, "exceptional C++" item 5 introduces more idea in this topics.

\end{itemize}


\subsection{alias declaration}

\begin{itemize}
\item Alias declaration is better than typedef when you declare a function pointer, It's more verbose.
\begin{lstlisting}[frame=single, language=c++]
typedef void (*FP)(int, const std::string&);

using FP = void (*)(int, const std::string&);
\end{lstlisting}
\begin{description}
	\item[Line 1:] FP is a synonym for a pointer to a function taking an int and a const std::string\& and returning nothing
	\item[Line 3:] Alias declaration looks clean and simple.
\end{description}

\item C++98 doesn't support typedef template directly, only can be put inside a struct.
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
struct MyAllocList {
	typedef std::list<T, MyAlloc<T>> type;
};
MyAllocList<Widget>::type lw; // client code

template<typename T>
class Widget { 
private:
	typename MyAllocList<T>::type list; 
};
\end{lstlisting}
\begin{description}
	\item[Line 1 to 5:] C++98 style. You have to use ::type to declare a variable.
	\item[Line 10:] MyAllocList<T>::type is thus a dependent type, and one of C++'s many endearing rules is that the names of dependent types must be preceded by typename.
\end{description}


\item In C++14, A better way is to use Alias name
\begin{lstlisting}[frame=single, language=c++]
template<typename T> 
using MyAllocList = std::list<T, MyAlloc<T>>;
MyAllocList<Widget> lw; // client code

template<typename T>
class Widget {
private:
	MyAllocList<T> list; 
};
\end{lstlisting}


\begin{description}
	\item[Line 1 to 3:] C++14 style. You can use this template alias directly.
	\item[Line 8:] no "typename" and no "::type"
\end{description}

\item Another advantage of Alias Name is below.The first source code uses typedef inside a struct; The second source code uses "using alias".

\begin{lstlisting}[frame=single, language=c++]
template<typename T>
struct type{ typedef std::vector<T> sometype; }
template<typename TT>
void someFunction(typename type<TT>::sometype& myArg);

std::vector<int> a;
someFunction(a); // error, cannot deduce int
someFunction<int>(a); //have to expilict do it 
\end{lstlisting}
\begin{description}
	\item[Line 4:] You need typename here, because sometype is depended T. \newline typename indicates type<TT>::sometype is a type.
\end{description}

\begin{lstlisting}[numbers=none]
template<typename T>
using sometype = std::vector<T>;
template<typename T>
void someFunction(sometype<T> &myArg );

std::vector<int> a;
someFunction(a); //OK, can deduce int
\end{lstlisting}


\item C++14 offers alias templates for all the C++11 type traits transformations.
\begin{lstlisting}[numbers=none]
template <class T>
using remove_const_t = typename remove_const<T>::type;

template <class T>
using remove_reference_t = 
               typename remove_reference<T>::type;

template <class T>
using add_lvalue_reference_t = 
            typename add_lvalue_reference<T>::type;
\end{lstlisting}

\end{itemize}

\subsection{scoped enums}
\begin{enumerate}
\item C++98-style enums are now known as unscoped enums.
\begin{lstlisting}[frame=single, language=c++]
enum Color { black, white, red };
auto white = false; // error! 

enum class Color { black, white, red };
auto white = false; // fine, 

Color c = white; // error!
Color c = Color::white; // fine
auto c = Color::white; //fine
\end{lstlisting}
\begin{description}
	\item[Line 1:] black, white, red are in same scope as Color, That is why when you define the duplicated varaible name "white" again in line 2, compiler report error.
	
	\item[Line 4:]black, white, red are scoped to Color
\end{description}

\item Enumerators of scoped enums are visible only within the enum. They convert
to other types only with a cast.
\begin{lstlisting}[frame=single, language=c++]
enum class Color { black, white, red }; 
Color c = Color::red; 
if (c < 14.5) { 
\end{lstlisting}
\begin{description}
	\item[Line 1:] enum is now scoped.
	\item[Line 2:] as before, but with scope qualifier.
	\item[Line 3:] error! can't compare Color type and double type.
\end{description}
\item Both scoped and unscoped enums support specification of the underlying type.
The default underlying type for scoped enums is int. Unscoped enums have no
default underlying type.

\item Scoped enums may always be forward-declared. Unscoped enums may be
forward-declared only if their declaration specifies an underlying type.

\item Prefer deleted functions to private undefined ones. because Any function may be deleted, including non-member functions and template instantiations.
\end{enumerate}


\begin{lstlisting}[frame=single, language=c++]
template <class charT, class traits = char_traits<charT> >
class basic_ios : public ios_base {
public:
	basic_ios(const basic_ios& ) = delete;
	basic_ios& operator=(const basic_ios&) = delete;
};

bool isLucky(int number); // original function
bool isLucky(char) = delete; // reject chars
bool isLucky(bool) = delete; // reject bools

template<typename T>
void processPointer(T* ptr);

template<>
void processPointer<void>(void*) = delete;
\end{lstlisting} 
\begin{description}
	\item[Line 16:] You can't not use void to instantiate
\end{description}

\subsection{noexcept}

\begin{enumerate}

\item  When an exception is thrown from an noexcept function, std::terminate gets triggered. compiler will not check it for you.

\item noexcept is part of a function's interface, and that means that callers may
depend on it.

\item noexcept functions are more optimizable than non-noexcept functions.

\item noexcept is particularly valuable for the move operations, swap, memory deallocation functions, and destructors.

\item Most functions are exception-neutral rather than noexcept.

\end{enumerate}

\subsection{Variadic Templates}
\begin{itemize}
\item Finally, there's a way to write functions that take an arbitrary number of arguments in a type-safe way and have all the argument handling logic resolved at compile-time, rather than run-time.

\begin{lstlisting}[frame=single, language=c++]
template<typename T> //Basic condition
T adder(T v) {
	return v;
}

template<typename T, typename... Args>
T adder(T first, Args... args) {
	return first + adder(args...);
}
////////////////////////////
template<typename T>
show_list(const T& value){cout<<value<<endl;}

template<typename T, typename... Args>
show_list(const T& value, const Args&... args){
	cout<<value<<endl;
	show_list(args...);
}
\end{lstlisting}
\begin{description}
	\item[Line 1 to 4:] it is base condition case, you can see there is only one parameter here.
	\item[Source cdoe:] The whole idea is like the recursive function.
\end{description}
\end{itemize}



\chapter{Style and Guideline}
\section{efficiency}
\begin{itemize}
	\item  lazy evaluation includes:
	\begin{enumerate}
		\item reference counting (to avoid extra copy).
		\item distinguish read from write.
		\item lazy fetching.
		\item lazy expression evaluation.
	\end{enumerate}
	\item Detail see in "More Effective C++". Usually, implementation will be  more complex with lazy evaluation.
\end{itemize}



\section{Style}
\subsection{Basic Principles}
\begin{itemize}
	\item \textbf{Keep consistent with your style!} Don't change it very often.
	
	\item \textbf{Don't sweat on the small stuff.} Such as how many spaces to indent? space or tab? Or must have comment etc. In any interview, style is not an important question.
	
	\item \textbf{Use descriptive function and variable name. Even it's a little longer.} Most code is read a lot more than typed. With good function and variable name, comment is unnecessary.
	
	\item \textbf{Don't use abbreviation name unless it's very common, such as CPU and TCP/IP.}
	
	\item \textbf{Don't need to use type indicator for all variable.} Hungarian notation offer no benefit for object-oriented language, especially it's impossible to use in generic programming. But for some generic concept, such as reference, pointer and STL container, you can use it such as: "ptr\_map\_dic". Modern IDE(such as Visual Studio and Understand) support pop up message when you hover your mouse over a variable.
\end{itemize}


\subsection{Naming}
\begin{itemize}
	
	\item For global scope, use g\_ prefix;
	
	\item For member variable in class, use tailing underscore. Why? 
	\begin{enumerate}
		\item Prefix underscore uses for reserved word mostly.
		\item When you use trailing underscore, you can use auto completion better. For example for variable name \texttt{test\_}, When you type t, the name will appear, but for \texttt{\_test}, you have to type \_t two characters, and options are much more than \texttt{test\_}.
	\end{enumerate}
	
	\item For member variable in struct, just like an ordinary variable name. 
	
	\item For constant name, use k\_ prefix and upperCamelCase;
	
	\item Using upper-case and underscores for pre-processor Macro;
	
	\item \textbf{Using upperCamelCase for Classes, Structures, Enumerations, Typedef and  Constants;}
	
	\item \textbf{Using lowerCamelCase and verb for function. Such as \texttt{getSth} and \texttt{doSth}}
	
	\item \textbf{Using lowercase and underscore  and noun for variable and parameter name. Because for long variable name, It's easier to read. Such as \texttt{sth\_for\_dinner}}
	
	\item Using \texttt{other} or \texttt{rhs} as name for copy ctor and assignment operator.
	
	\item The prefix \texttt{is} should be used for boolean variables and methods which return bool.
	
	\item Below is code example demonstrates the above rules. 
\begin{lstlisting}[numbers=none]
#define ARRAY_NUM 10
bool isVisible;

struct Student{
	name;
};
enum BackgroundColor{
	Red,  //constant
	Green
};
class Teacher{
	name_;  // not m_strName;  
};

typedef struct Student StuStruct ;
StuStruct g_global_varaible;
const int k_DaysInWeek = 7;
main(){
	string teacher_name;  //meaning variable name
}

printTeacherName(const string& name){...}
\end{lstlisting}
\end{itemize}
\subsection{Comment and Document}

\begin{itemize}
	\item There are five levels of comment: \\
	\begin{tabular}{|c|c|c|}
		\tophline 
		type & tool & user \\ 
		\tophline 
		good name convention & no & developer  \\ 
		\tophline 
		source code comment & with source code &  developer \\ 
		\tophline 
		API & source code+ doxgen  & developer + user  \\ 
		\tophline 
		developer document & latex &  developer \\ 
		\tophline 
		End user & Word, power point & end users 
		\bottomhline 
	\end{tabular} 
	
	\item Only use comment when it's very necessary. If you give function and variable good name, don't need to comment them at all. 
	
	\item source code comment are most inside of a function. API comments are most before function, class. You can use doxygen to produce a html from it. 
	
	\item Use C++ and doxygen style comment more, use C style comment less.
	
\begin{lstlisting}[numbers=none]
/// \brief fooFun does ...
///
///if \p flag is true, when happen
///\param [out] result will be filled
///\return 0 on success.
bool fooFun(bool flag, int& result);
\end{lstlisting}
	
	\item When you want to comment a large block of code out, use \texttt{\#if 0} ...  \texttt{\#endif}, It's better than using /* ... */. 
	
	\item Don't duplicate the function or class name in comment. Maybe you will change name later, this inconsistency will confuse comment readers in the future.
	
	\item Install Doxygen in linux, then run \linuxcommand{doxygen -g} in the terminal to produce configure file, the name is Doxyfile.  In Doxyfile, modify two items:
\begin{verbatim}[numbers=none]
GENERATE_LATEX = NO
INPUT = ./src
\end{verbatim}
	then run \linuxcommand{doxygen Doxyfile}, A html directory will be built.
	
	\item Install doxygen on Windows, you can run doxywizard application, or you can use GUI to set Doxyfile configuration file.
	
	\item Usually you have a standard tree structure of project, that is to say every .cpp has .h file.  Under this circumstance, you should put comment command in .h file. Because .h file is an interface to customer.
	
	\item If a .cpp file include a .h file,  doxygen will not parse the .cpp file automatically, It only parse all .h file in certain directory and extract all types, such as class and struct information. \textbf{No function and global variable information is extracted.} 
	
	\item For class and struct which are declared inside a .h file, Doxygen will show them under Classes tab in the index.html. Even you don't have any comment on it.
	
	\item If you want global functions, variables, enums, typedefs, and defines to be documented, you should document the file in which these contents are located using a comment block containing a $\backslash$file (or @file) command. Even this global function is inside of .h file. With $\backslash$file in .h file, You'd better to use HIDE\_UNDOC\_MEMBERS to ignore all the other global function members without comment inside this .h file. It will make last result looks clean. 
	
	\item In order to make Doxygen to parse a .cpp file , you need to put Doxygen command\textbf{$\backslash$file} in a separate line in the .cpp file, then Doxygen will parse this .cpp file and produce the corresponding html page.
	
	\item Given a C++ source code section, Doxygen will produce below html page.  \textbf{References} and \textbf{Referenced} can be turn on in the configure files.
	
\begin{lstlisting}[numbers=none]
/// \brief Return the function this instruction belongs to.
///
/// Note: it is undefined behavior to call this on an
/// instruction not currently inserted into a function.
const Function *getFunction() const;
	\end{lstlisting}
	
	\item Doxygen produce html pages looks like this:
	
	\includegraphics[scale=0.45]{pics/dox1.png}  \medskip
	
	\includegraphics[scale=0.45]{pics/dox2.png} 
	
\end{itemize}


\subsection{Code Convention}
\begin{itemize}
	
	\item Pointer and reference symbol is near to data type, not near to a variable name.
	
	
	\item Declare variables as locally as possible and minimize usage of global variables.
	
	\item Avoid macro, use inline function;  Avoid magic numbers, instead of using \texttt{const} and \texttt{enum}
	
	\item Format lambdas like blocks of code.
\begin{lstlisting}[frame=single, language=c++]
int cutoff = 7;
std::find(foo.begin(),foo.end(),[&](const Foo &a ) ->bool{
		return a.blah<cutoff //use reference to get local var
		});
\end{lstlisting}
	
	
	\item Use \texttt{\_FILE\_} and \texttt{\_LINE\_} to capture the current file name and line number.  \texttt{assert} just uses this kind of macro inside.
	
	\item Use \texttt{const} replace \texttt{\#define} to define global constants. \texttt{static const} can be used to define constant class member. (\texttt{const} means that it will not change, so I don't need keep multi copy in multi objs, so I use static.)
	
	\item Use more \texttt{typedef} or \texttt{alias} to simplify Complicated Type Expressions, It's helpful especially in STL. 
\begin{lstlisting}[frame=single, language=c++]
typedef std::map< int, int > IntMap;
typedef IntMap::const_iterator IntMapConstIter;
for( IntMapConstIter it = layout.begin();
it != layout.end(); ++it ) {

typedef int(*CB)(int, const char*); 
CB callBack;  //decare a functions pointer.
int sort(int, const char*){..}
callBack = sort; // &operator is optional here!
\end{lstlisting}
\begin{description}
	\item[Line 6:] Use typedef when you want to define a function pointer type. It make easier for you to define a funciton pointer variable in line 7.
\end{description}
	
	\item Using alias(C++11) is better than typedef. 
	\begin{enumerate}
		\item First word is \texttt{using}, \textbf{There are no sharp symbol before \texttt{using} .} 
		\item Second is TypeName. 
		\item Third is assignment \texttt{=}.  
	\end{enumerate}
	
\begin{lstlisting}[numbers=none]
using UPtrMapSS =
std::unique_ptr<std::unordered_map<std::string, int>>;

using CB = int(*)(int, const char*);
\end{lstlisting}
	
	\item Create a zero-valued enumerator to indicate an invalid or default state and make it the first item.
	
	\item \textbf{Declare all member variables private, then use getter and setter functions to access them.}
	\begin{enumerate}
		\item Declare all member variables private firstly.
		
		\item If Outside need to access it's member variables, just build a public interface function. There are two advantages: 1) Inside set-function, You can test valid range. 2) Inside get-function, even type of member variable change, you just need to change get-function, and get all customer code unmodified. In this way, It's de-coupling.
		
		\item If child want to access its parent member, declare it as protected.
		
	\end{enumerate}
	
	\item Don't use multi-thread unless you really need it. Simultaneously respond to many events. Just remember, synchronization has some overhead. Below are some typical scenarios.
	\begin{enumerate}
		\item A web server.
		\item Interface and working thread.
		\item Take advantage of with multiple processor.
	\end{enumerate}
	
	\item \textbf{Uses early exits to simplify code.}
	
\begin{lstlisting}[numbers=none]
if(IsValid){   //bad style
	do something;
} else{
	return;
}
	
if(!IsValid) // A better style is
return;
..do something here.
	\end{lstlisting}
	
	\item Turn Predicate Loop into Predicate Function. It makes you code clean and easy to understand.
	
\begin{lstlisting}[frame=single, language=c++]
for(v.begin....){   /bad style
	if(it->IsSth){
		flag = true; break;
	}
}
if(flag){...}
	
if(isHasSth()){...}
\end{lstlisting}
\begin{description}
	\item[Line 8:] Put line 1 to Line 5 into a function \texttt{isHasSth().} That is good style.
\end{description}
	
	\item Use \texttt{static\_assert} to test some compile-time boolean conditions. It supports a message parameter. It doesn't need to build execution application. It will stop when you are compiling your code. 
\begin{lstlisting}[numbers=none]
static_assert(sizeof(int) > 4, "int is too small");
\end{lstlisting}
	
	\item Use assert more in your project. You don't need to include file name and line number in the string. assert will output these hint messages.
\begin{lstlisting}[numbers=none]
#include<cassert>
assert(index>=0 && " index is negative");
\end{lstlisting}
\begin{description}
	\item[Line 2:] Assertion failed: expression, file name, line num
\end{description}

	
	\item \textbf{If you don't modify container inside loop}, don't need to evaluate end() every time through for loop. Please remember below code block. \textbf{Just remember auto i,e ++i}

\begin{lstlisting}[numbers=none]
vector<int> con={1,2,3}; //list initializer
for(auto i = con.begin, e = con.end();i!=e; ++i){
	...........
}
\end{lstlisting}
	
	\item The C++11 standard (23.2.1) mandates that end has O(1) complexity, so previous item has no efficiency meaning in C++11.
	
	
	\item \textbf{Prefer Preincrement (++i), especially in a for loop.}  When you use ++i or i++ inside expression, there are differences. Otherwise, there is no differences.
	
\begin{lstlisting}[numbers=none]
for(int i = 0;i<10; ++i)
j=++i; // j = i+1;
j=i++; //j = i;  i=i+1;
++*p;  //++(*p) ;
*++p; //*(++p);
\end{lstlisting}
	
	\item How to understand \texttt{*p++} ?
	
	\begin{enumerate}
		\item Precedence of prefix ++ and * is same. Associativity of both is right to left.
		\item Precedence of postfix ++ is higher than both * and prefix ++. Associativity of postfix ++ is left to right.
		\item Prefix and postfix are both syntax sugar, in order to reduce typing.   But prefix represents \textbf{one statement}, postfix means \textbf{two statements};
	\end{enumerate}
	
\begin{lstlisting}[frame=single, language=c++]
++i;  //just like i = i+1 or  i+=1;
*p++; // *(p++);  *p ; p=p+1;

while(*p != '\0'){
	p= p+1;
}
//can be written to
while(*p++ != '\0')
\end{lstlisting}
\begin{description}
	\item[Line 2:] When i++ used in expression, treated as two statements.
\end{description}
	
	\item Always turn on all warning options in your compiler with -Wall. Once you get warning, Eliminate warning before you go further.
	
	\item Sometimes, this warning is what you have to, or if warning comes from a header file you can't change. You can use \#pragma warning compile directive to temporary disable it, then restore it later.
\begin{lstlisting}[numbers=none]
#pragma warning(push)
#pragma warning(disable:4512);
#include<not_change.h>
#pragma warning(pop)
\end{lstlisting}
\begin{description}
	\item[Line 2 and 4:] disable warning on line 2 and restore original warning level on line 4.
\end{description}
	
\end{itemize}


%\end{CJK*}
\end{document}

