% !Mode:: "TeX:UTF-8:Hard"
\documentclass[a4paper,11pt,twoside]{book}
%\documentclass[paper=8.5in:11in,pagesize=pdftex]{book}
%\usepackage{CJKutf8}
\usepackage[T1]{fontenc}
\usepackage{pifont}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{longtable}
\usepackage{capt-of}
\usepackage{color}  
\usepackage{enumitem}

\setitemize[1]{itemsep=0pt,partopsep=0pt,parsep=3pt,topsep=0pt}
\setenumerate[1]{itemsep=0pt,partopsep=0pt,parsep=3pt,topsep=0pt}
\setdescription{itemsep=0pt,partopsep=0pt,parsep=3pt,topsep=0pt}

%\usepackage[paperwidth=8.5in, paperheight=11in]{geometry}

%\usepackage[margin=1.1in]{geometry}
\usepackage[a4paper,left=2cm,right=2cm,top=3cm,bottom=3cm,]{geometry}
%\usepackage[pass]{geometry}

\newcommand{\linuxcommand}[1]{\texttt{\textcolor{blue}{\$ #1 \Pisymbol{psy}{191}}}}
\newcommand{\op}[1]{\textcolor{blue}{-#1}}
\newcommand{\hotkey}[1]{\framebox{#1}}
\newenvironment{screen}{\sffamily}{\rmfamily}
% for C/C++ frame box
\usepackage{listings}
\definecolor{mygray}{rgb}{0.96,0.96,0.96}

\lstset{ 
	backgroundcolor=\color{mygray},
	mathescape=true,
	frame=single,
	frameround=tttt,
	language=c++,
	basicstyle=\footnotesize,
	%literate={\ \ }{{\ }}1
	tabsize=2,
	numbersep=6pt,
	breaklines=true,
	%framextopmargin=0.5em,
	%framexbottommargin=0.5em,
	morecomment=[s][\color{red}]{/*-}{*/},
	%escapeinside={//*}{*//},
	numberstyle=\tiny\textit,
	stepnumber=1,
	numbers=left
}



\def\numdot{}
\ifdefined\numdot % false so skip to matching 
	\usepackage{totcount}
	\newcounter{maxlstnumber}
	\regtotcounter{maxlstnumber}
	\def\updatemaxlstnumber{%
		\ifnum\value{lstnumber}>\value{maxlstnumber}%
		\setcounter{maxlstnumber}{\the\value{lstnumber}}%
		\fi%
	}
	\newlength{\MaxSizeOfLineNumbers}%
	\makeatletter
	% The following command allows you to customize line number style, without affecting \ref{}.
	% Here, the style is "\thelstnumber." (with a dot at the end)
	\def\renderlstnumber{\normalfont\lst@numberstyle{\thelstnumber.}\kern\lst@numbersep}
	\def\lst@PlaceNumber{\updatemaxlstnumber\makebox[\MaxSizeOfLineNumbers][r]{\renderlstnumber}}
	\makeatother
\fi


\def\pdfbook{}
\ifdefined\pdfbook
	\newcommand{\Hilight}[1]{\makebox[0pt][l]{\color{yellow}\rule[-3pt]{#1em}{11pt}}}
	\newcommand{\HilightLine}[2][yellow]{\makebox[0pt][l]{\color{#1}\rule[-4pt]{#2em}{13.9pt}}}
	\newcommand{\tophline}{\hline }
	\newcommand{\bottomhline}{\\ \hline }
	\newcommand{\ecline}{\cline }
\else
	\newcommand{\Hilight}[1]{}
	\newcommand{\HilightLine}[2][yellow]{}
	\newcommand{\tophline}{ }
	\newcommand{\bottomhline}{ }
	\newcommand{ \ecline }{}
\fi


\newcommand{\specialcell}[2][c]{%
  \begin{tabular}[#1]{@{}l@{}}#2\end{tabular}}

%\addtolength{\oddsidemargin}{-.375in}
%	\addtolength{\evensidemargin}{-.375in}
%	\addtolength{\textwidth}{1.25in}

%	\addtolength{\topmargin}{-.375in}
%	\addtolength{\textheight}{1.75in} 


%\renewcommand{\begin{itemize}}[1]{}
%\renewcommand{\end{itemize}}[1]{}	
%\renewcommand{\itemize}}[1]{}	

\usepackage{etoolbox}
\makeatletter
\preto{\@verbatim}{\topsep=0pt \partopsep=0pt }
\makeatother



\begin{document}
%\begin{CJK*}{UTF8}{song}
\title{Drops of knowledge of C++}
\author{Yan Zhao}
\date{}\maketitle

\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}
\tableofcontents
%\thispagestyle{empty}
\setcounter{page}{1}


\setlength\parindent{0pt}
\setlength{\parskip}{5pt}

\chapter*{Preface}
\addcontentsline{toc}{chapter}{Preface}

I publish a new edition every year, and the seventh edition, which I have just released, now has almost 500 pages. In comparison, the first edition had only about 100 pages. This book is like my child; I watch it grow slowly every year.

\par Bjarne Stroustrup, the creator of C++ language, stated that modern C++  "feels like a new language". I totally agree with him. By now, modern C++ is quicker, safer and easier to use, but it can be challenging to learn and teach. I love this language, I also like to recommend and teach more people to use it. That is precisely why I have written this book. The book has three characteristics:
\begin{itemize}
	\item \textbf{"Talk is cheap, show me the code"}. OK, There are a lot of code with short, concise description with each code block. You can even think that this is a book of source code, with some explanation around it. At the same time, each piece of code is not ordinary. They are all very classic and highly representative, excellently demonstrating some issues to avoid or some very practical techniques.
	
	\item \textbf{"A graph is worth 1000 Words"}. The book provides numerous graphs to help illustrate complex concepts. You can even see a figure on the cover of this book. With the help of these diagrams, readers will find it very easy to understand some difficult or complex concepts. For example, the diagram below clearly illustrates the relationships among all elements in multithreading, allowing readers to quickly develop a comprehensive view of multithreaded programming, which is known as 'grasping the essentials.' Without such excellent diagrams and merely listing details, readers would quickly lose direction and interest, a phenomenon referred to as 'missing the forest for the trees.'
	
	\begin{center}
		\includegraphics[width=0.69\linewidth]{pics/concurrent.drawio.png}
	\end{center}
	
	
	\item \textbf{"Design is not how it looks, but how it works"}. The four chapters "pointer and smart pointer", "reference and rvalue reference", "OOP" and "Generic programming" introduce quite a lot deep semantic knowledge in these fields. By studying these topics, you can gain a deeper understanding of both language features and design patterns.
\end{itemize}



\par	This book can be divided into six main parts:

\begin{enumerate}
	\item The first part includes the first four chapters, primarily introducing the basic language features of C++.
	\item The second part comprises chapters 5 to 7, focusing mainly on memory-related knowledge.
	\item The third part is chapter 8, which mainly introduces OOP programming.
	\item The fourth part covers generic programming, including chapters 10 to 12.
	\item The fifth part deals with engineering practices, primarily discussing concurrency and multithreading (chapter 13), networking (chapter 14), and testing (chapter 15).
	\item The sixth part is chapter 16, which introduces some key features of C++14/17/20.
\end{enumerate}

\par This book is \textbf{NOT} for beginners. It is just about 500 pages but covers all the key points in C++. It does not introduce the basic knowledge of each topic. However, for each topic, I introduces some important techniques and practical considerations in real-world projects. This knowledge will greatly enhance and expand your understanding of the fundamentals. There is also a small tip for using this book: each small item in the book is an \textbf{excellent prompt}. By using these excellent prompts, you can fully interact with the current mainstream AI platforms. AI is powerful, but it needs good prompts. If you only input 'void', AI can only return 'void'. :)

\par In seventh edition, I greatly improved the quality of the book by removing some obscure and difficult parts and adding well-described charts, summaries, and easy-to-remember mnemonics. Compared to the sixth edition, although the number of chapters has not increased, the page count has gone from 410 to 450. Particularly for some more abstract topics like multithreaded programming, ranges, and views, more introductions have been provided, along with very reader-friendly summaries and analyses. The other existing chapters have also been improved both in terms of content and format. \medskip  

\par I am a software developer, and have worked with C/C++ family language for almost 25 years. I have published a very famous C language book "Drop of knowledge of C", and the link is:\\ \verb|http://product.dangdang.com/23340055.html.| I am able to provide C/C++ tutorial and training, either online or onsite. Please contact me if you need some consulting services.\par \par \medskip

I would like to express my gratitude to my two daughters, Millie and Ivy. I promise that the C++ language will continue to thrive and prosper as they grow up. \par \par \medskip


Any suggestions and error reports are appreciated. You can contact me by: \\
Email          : \textbf{zhaoyan.hrb@gmail.com}  \\ 
Homepage       : http://zhaoyan.website  \\ 
Wechat account : zhaoyan\_rock   \\ 

I also have a blog: http://zhaoyan.website/blog/. You can find some interesting Chinese blogs about C++ there. 

\chapter*{How to?}
\addcontentsline{toc}{chapter}{How to}
	 \textbf{How to read this book in eReader?}
	\begin{itemize}
		\item Due to the large amount of source code in the book, it is recommended to read it in landscape mode. If you are using a Kindle, you can easily find instructions online on how to switch to landscape mode for e-books. 
		
		\item In some E-readers, such as kindle and ipad, the display in source code block sometimes get crowded together. You can resolve this problems by doing:
		\begin{enumerate}
			\item Use landscape mode to get wider screen.
			\item Decrease font size, until the whole source code can be displayed probably.
		\end{enumerate}
		
		\item If a table does not display properly on your Kindle, you can click on the small icon below the table. This will extract the entire table and display it on a separate page. 
		
		\item You can search keyword in the source code block.
		
		\item You can purchase the printed book from Amazon.com. Simply search for 'Drops of Knowledge of C++' on Amazon.com. I strongly recommend a printed book for any computer programming book, because we spend so much time looking at screens.
		
	\end{itemize}

	\par \textbf{How to run the source code?}

		\par Most of the source code in this book can be run directly. However, in order to save space, I have omitted some of the header files. Please make sure to add the required header files and a \texttt{main} function when you want to run the source code from the book.
		
		\par Most of the source code in this book illustrates basic ideas, so they are not intended to be long or production-ready. To run the code, you can use an online C++ compiler. These lightweight tools are very suitable for the code in the book. Just search for "online C++ compiler" online. \textbf{Make sure to select one with a black background, as light backgrounds can attract bugs.} My personal favorite is the \textbf{Compiler Explorer}.
		 

	\par \textbf{Why some source code has line number on left side?}

		\par If the source code has line numbers, below the source code block you might see some explanations which refer to the line number and make you understand it more clearly. An example of source code is illustrated below: 
		
\begin{lstlisting}
#include<iostream>
using namespace std:
int main(void){
	cout<<"hello world"<<endl;
	typedef HelloWorld<OutputPolicyWriteToCout, 
		LanguagePolicyEnglish> HelloWorldEnglish;
}
\end{lstlisting}

\begin{description}
	\item[Line 1:] Add more explanation about source code in line 1.
	\item[Line 4:] All the code has proper intent.
	\item[Line 5 and Line 6:] If one line is long, will add line break in the middle. 
	\item[Source code:] Tell the purpose of the whole code snippet.
	\item[Output:] The output of the code snippet if you run it.
\end{description}

		\par If the source code does not have line numbers, then it usually does not require further descriptions based on line numbers. 


	\par \textbf{Do I need to read this book in order?}

        \par You don't need to read orderly, it's not a textbook. It's unnecessary for you to read the current chapter before you finish the previous one. If you are a beginner of C++, you should read some other textbooks before read this book.

        \par You can select any favorite topic to dig into. Each chapter covers sub-topic of C++ language. For example, I/O and exceptions are almost independent chapters by themselves.

\chapter{C++ Introduction}

\section{Multi-paradigm support and three constraints}

	 C++ offers both high-level abstractions and low-level memory manipulation, making it suitable for both system-level programming and application development. C++ is also known for its high performance, making it ideal for low-level system programming, embedded systems, game development. Developers can optimize code by:
	\begin{itemize}
		\item Reducing memory overhead by manual memory manipulation ability.
		
		\item Minimizing unnecessary copies by move and copy control.
		
		\item Leveraging concurrency and parallelism. 
	\end{itemize}
	
	\par C++ is a multi-paradigm language that supports various programming paradigms. 
	\begin{itemize}
		\item Procedural programming. (Traditional C programming: function, struct, pointer, etc.)
		
		\item Object-base programming. (Class and object, access control, operator overload, etc.)
		
		\item Object-oriented programming. (Inheritance and polymorphism, design pattern, etc.)
		
		\item Generic programming. (Template, STL, Metaprogramming, etc.)
		
		\item Functional programming. (Function object, lambda, etc.)
	\end{itemize}
	
\begin{center}
	\includegraphics[width=0.95\linewidth]{pics/whole.png}
\end{center}
		
	
	\par About object-base programming (also call data abstraction), C++ provides below supports:
	\begin{itemize}
		\item Member function, private member data, and copy and assignment control.
		\item Global function overload, such as \texttt{sin(const complex\& x)} and operator overload, such as \texttt{operator +}, \texttt{operator *}, etc..
		
		\item Template container, such as \texttt{std::vector}, \texttt{std::complex}, \texttt{std::pair}.
	\end{itemize}
	
	A notable point is that, in the object-base programming domain, compared to C language, C++ offers greater abstraction, encapsulation, and expressive capabilities, while maintaining nearly the same runtime speed as C language, they almost generate identical machine code.
	
    \par There are three constraints in C++ language: 1) compatible with C; 2) zero overhead abstraction; 3)static type. Some people also think the third constraint is value semantic. If you want to follow value semantic, you need to know and check the type information when you compile. So static type and value semantic are the two sides of one coin. These three constraints give C++ unique characteristics compared to other languages like Java and Python. The combination of static typing and value semantics ensures type safety and efficiency, distinguishing C++ from dynamically-typed languages.
    
    \par In C++ language, value semantics refer to the way that values (i.e., objects) are passed between functions or copied from one object to another. When a value is passed to a function or copied to another object, a new copy of the value is created. Any modifications made to the copy will not affect the original value. This is in contrast to reference semantics, where a reference (i.e., pointer) to the original value is passed or copied, and any modifications made to the reference will affect the original value. In the C++ Standard Template Library (STL), containers like \texttt{std::complex, std::pair, std::vector, std::string,} etc. are based on value semantics. They are a kind of data and support copying directly. 
    
    \par At first glance, value semantics appear less efficient than reference semantics when performing copies. However, programs typically perform read and write operations more frequently than they create or copy objects. When reading or writing an object with reference semantics, you must dereference a pointer or reference. This adds an instruction to the generated code and may result in two memory locations that are not in cache. As a result, reference semantics can be less efficient for read and write operations due to the additional dereferencing and potential cache misses. In one word, C++ uses value semantics to increase efficiency at the cost of additional copies. C++ gains type safety while losing the dynamic type ability possessed by languages like Python. C++ is a fast, strong type (type safe) language. 
    
    On the other hand, for large objects or arrays, C++ also supports references and pointers when you want to avoid copying, although this is not the default assignment behavior.
    
    
    
    
    \par C++ is a cross-platform language, meaning programs written in C++ can run on various operating systems like Windows, Linux, macOS, and various embedded devices, with little or no modification. Tools like CMake, docker and cross-platform libraries help facilitate this.
    
    \par C++ offers manual memory management by using \texttt{new} and \texttt{delete} operator. It also provides modern features such as:
    \begin{itemize}
    	\item Smart pointer for automatic memory management and garbage collection (GC). 
    	
    	\item Resource Acquisition Is Initialization (RAII): A principle that ensures resources are acquired and released automatically through object lifetime.
    \end{itemize}
    
    \par The C++ Standard Template Library (STL) provides a rich set of generic containers, algorithms, and iterators, which are crucial for efficient and flexible tasks:
    \begin{itemize}
    	\item Containers: \texttt{std::vector, std::list, std::map}, and others for data storage.
    	
    	\item Algorithms: \texttt{std::sort}, \texttt{std::accumulate} etc. for performing operations on containers.
    	
    	\item Iterators: Generalized pointers used to traverse containers, mainly used by the previous algorithms in STL.
    \end{itemize}
    
    


\section{Compilation and link}

\subsection{Separate compilation and header file}
	 C++ employs separate compilation, where each source file is compiled independently and subsequently linked to form the final one executable. This modular approach facilitates breaking down large programs into smaller, more manageable units. Each unit can be developed and tested independently, and modifications to one unit typically do not necessitate recompiling others. Moreover, separate compilation enhances compilation speed and aids in handling complexity in extensive codebases.
	
	\par When you write a single source file (.cpp, .cxx, etc.), a C++ compiler creates a translation unit. Essentially, each .cpp file becomes a \textbf{translation unit}. A translation unit represents a source file after it has been processed by the \texttt{preprocessor}, which means that included header files specified in \texttt{\#include} directives are directly incorporated, sections of code within \texttt{\#ifdef} may be included based on conditions, and macros defined using \texttt{\#define} have been expanded.
	
	\par Since a C++ file is compiled \textbf{independently}, when the compiler processes a.cpp and encounters a function or type defined in other C++ files, it requires information about those functions or types. This is why declarations, typically found in header files, are necessary.
	
	\par While you can technically declare a variable, function, or class multiple times across different .cpp files, it's generally not advisable due to the potential for duplication, which can lead to maintenance issues. If you modify a declaration, you would need to update all instances across many .cpp files. Instead, for functions or variables used in multiple files, it's best to place them in a header file. For instance, you might create an \texttt{export\_to.h} file for specific cpp source files, or a \texttt{global.h} file for the entire system. When searching for function or variable declarations across a project, encountering the same declaration more than twice suggests it's time to relocate them into a global header file.

	
	\par If you want a function or variable to be visible only within the current translation unit, you can declare it as \texttt{static}, a better way is to enclose it within an unnamed namespace in modern C++. In such cases, you don't necessarily need to place it in a header file. Please note here, it's crucial in C++ to declare a function or variable before its first use. This differs from C, where the compiler infers a function prototype from its usage—a practice generally discouraged in C++ for maintaining good coding style.
	
	\par A more effective approach would be to create a single \texttt{global.h} file for a complex system. This file should include common types, defined types, constants, and global functions. This strategy helps minimize duplication across different .cpp files in the project. Suggestions for writing a header file:
	\begin{itemize}
		\item Include everything that should be exported (i.e., used in other files), but avoid including anything that causes the compiler to generate code immediately.
		
		\item Use \texttt{\#pragma once} to add an include guard. \texttt{\#pragma} is a preprocessor directive in C and C++ used to provide special instructions to the compiler. While it's not standard, it is supported by mainstream compilers such as g++, Clang, and MSVC.
		
		\item Constants, templates, and inline functions have internal linkage unless marked as external with the \texttt{extern} keyword. Therefore, template and inline function definitions should go in the header file. It's also good practice to end the header file with a semicolon because class declarations require it. In the .cpp file, semicolons are not needed after function definitions.
		
		\item Include the minimal set of \texttt{\#include} statements necessary to make the header file compilable. Use forward declarations instead of including entire header files, or employ techniques like the PIMPL idiom to reduce dependencies.
		
		\item Typically, each class definition should reside in its own header file, If two classes are closely related or very short, they may be placed in the same header file.
		
		\item \textbf{Avoid} using "using directives" (\texttt{using namespace}) in header files.
		
	\end{itemize}
	
	

	\par Include header file in the following order. \textbf{Put your local/private header file in front of system header file, in another word, prioritize local and specific headers before more general and standard ones.} 
	\begin{enumerate}
		\item The prototype/interface header for this implementation (ie, the .h/.hh file that corresponds to this .cpp/.cc file).
		\item Other headers from the same project, as needed.
		\item Headers from other non-standard, non-system libraries (for example, Qt, Eigen, etc).
		\item Headers from other "almost-standard" libraries (for example, Boost)
		\item Standard C++ headers (for example, iostream, functional, etc.)
		\item Standard C headers (for example, cstdint.h, dirent.h, etc.)
	\end{enumerate}
	
    \par Why do we need to follow previous order?  This order makes some potential fault can be found as early as possible. Please see the below examples, it demonstrates an important rule we should follow: \textbf{explicit error is better than implicit false success.}
	
	\begin{enumerate}

			\item It's crucial to include local or private headers first to ensure that each header file is self-sufficient and avoids hidden dependencies. 
			
%			\item We should include \texttt{Boo.h} the first place, because it makes compiling fail. If we include \texttt{Foo.h} first, although compile successively, it makes hidden dependency to \texttt{Foo} invisible, that is bad code smell. 
%
%\begin{lstlisting}[numbers=none]
%Foo foo;  //hidden dependency here //Boo.h
%class Boo{
%  ...
%}
%
%#include Foo.h //Boo.cpp
%#include Boo.h 
%\end{lstlisting}
			
			\item Sometimes, if you have your own function with same name as system or library, compiler will report error if you put your header file before the system one; Below example will give you a compiler error. The reason behind of this failure comes from \texttt{extern "c"}.
\begin{lstlisting}
#include "myHead.h"  // myHead.h declares "double acos(double);"
#include <cmath>   // cmath declares "extern "C" double acos(double);"
main{
	acos(0.5);
}

double acos(double);   // compiler report error if it sees this order.
extern "C" double acos(double);
\end{lstlisting}			
			
			\item On the contrary, if you put \texttt{<cmath>} before \texttt{myHead.h}, then \texttt{main()} function will use \texttt{acos()} in \texttt{<cmath>}, and your \texttt{acos()} will be hidden, and I think that it is not what you want and you don't get any useful prompt, that is an "implicit false success".   
		
\begin{lstlisting}[numbers=none]
#include <cmath>   // cmath declares "extern "C" double acos(double);"
#include "myHead.h"  // myHead.h declares "double acos(double);"
main{
	acos(0.5);
}

extern "C" double acos(double); // compiler accept this order declaration.
double acos(double); 
\end{lstlisting}
    	\item The code above clearly shows that a potential issue with header files occurs when multiple definitions of the same function or variable arise from multiple inclusions. When including header files, it’s important to pay close attention to the inclusion order and to guard against multiple inclusions, as this can lead to slow compilation, errors, and even undefined behavior.
    
	\end{enumerate}

			
	\par You can google "Advanced Software Engineering with C++ Templates". The first half part introduces separate compilation very well.

\subsection{Declaration and definition}



	 A declaration introduces an identifier and specifies its type, whether it denotes a type, object, or function. It is required by the compiler to enable references to the identifier.
	
\begin{lstlisting}
extern int bar;  //extern keyword before variable name, it's declaration.
extern int g(int, int); //function declaration.
double f(int, double); //extern can be omitted for function declarations.
class Foo; //Type declaration, no "extern" is allowed for type declarations.
\end{lstlisting}
	
	\par A definition instantiates or implements an identifier. It provides the actual entity that the linker needs to resolve references to that identifier. Below are examples of definitions corresponding to the declarations above:

\begin{lstlisting}[numbers=none]
int bar;
int g(int lhs, int rhs) {return lhs*rhs;} //has function body {...}
Foo foo{}; //put {}; after foo, that is a value initialization.
\end{lstlisting}
	
	\par The difference between declaring a symbol and defining a symbol:
	\begin{itemize}
		
		\item A declaration informs the compiler about the existence of a symbol, allowing it to be referenced without specifying its memory address or storage requirements. In contrast, a definition provides details about the symbol's implementation, such as the function's body or the memory allocation for a variable.
		
		\item While a symbol can be declared multiple times across different translation units, it must be defined exactly once in one translation unit. This principle is known as the \textbf{One Definition Rule}. For instance, you can forward declare a function or class as many times as needed, but its definition should appear exactly once in one translation unit.
		
	\end{itemize}


\subsubsection{One Definition Rule}
	 For C language, there is tentative definition rule. You can define the same variable in two different .c file. The result will be undefined behavior. 
	
\begin{lstlisting}[numbers=none]
int g_i = 100;  //a.c file
//--------------------
int g_i;   //b.c file
fun(){
	printf("%d",g_i) //will print 100
}	
\end{lstlisting}	
	\begin{description}
		\item[gcc:] (gcc a.c b.c) report no error. in b.c, if you write \texttt{int g\_i= 2}; gcc also reports error.
		\item[g++:] (g++ a.c b.c) reports error.
	\end{description}
	
	
	\par In C++, only one definition of any variable, function, class type, enumeration type, concept(since C++20) or template is allowed in any one translation unit (some of these may have multiple declarations, but only one definition is allowed). Tentative variable definitions are not allowed any more. 
	
	\par For function definition and class type definition (not class variable definition), there are two points to note:
	
	\begin{itemize}
		\item Multiple definitions of a function is prohibited, as they result in a linkage error. 
		
		\item In the same translation unit, you can't define the same class \texttt{Foo} again, but if you put two classes \texttt{Foo} in two different .cpp file. compiler doesn't complain at all. When you run the application, it probably crashes and it's dangerous. It's a little different with function and global variable, because function and global variable all need allocate memory.
\begin{lstlisting}
class Foo{  //in a.cpp file.
	int i;
};

class Foo{  //in b.cpp file
	double f;
};  
//compiler will not complain and it may lead to Undefined Behavior.
\end{lstlisting}
	\end{itemize}
	
	
	\par In order to avoid previous undefined behavior, you need to follow this principle: \textbf{Either a name is for everyone (declared in a header file) or is translation-unit-local in an anonymous namespace}. For class type definition, put it into a header file, when you need this class type definition, include it by using \texttt{\#include "Foo.h"}. More detail can be found in "The One-Definition Rule  Andrzej's C++ blog".

\subsubsection{Forward declaration}
	 In C++, we can declare a symbol, which involves declaring its type and name, so we can use it in places where its definition is not necessary. There are three common use cases for this feature, as outlined below:
	\begin{itemize}
		\item It will reduce compile-time dependencies.
		\item Hide all the implementation detail--PIMPL (Pointer to Implementation) idiom. 
		\item Break cyclic references.
	\end{itemize}
	
\begin{lstlisting}[numbers=none]
class C1; //That is a forward declaration.
class C2{
...
	C1* pc1; //A pointer, so we don't need to know the memory layout here.
}
\end{lstlisting}
	
	\par Forward declaration is insufficient when you need to access the members of a class or instantiate an object of that class directly. In such cases, you must include the header file (\texttt{\#include "Foo.h"}) to provide the compiler with complete information about the class \texttt{Foo}, including its size and memory layout, this allows the compiler to correctly compile code that accesses \texttt{Foo}'s members or constructs \texttt{Foo} object directly.
\begin{lstlisting}[frame=single, language=c++]
class Foo; // forward declaration here
Foo* f1 = new Foo; //error, need allocate memory for f1, but how big Foo is? 
	
fun(Foo* f1){
	f1->a;   //error, Compiler need to know if there is member a inside of Foo.
}
fun(Foo f1)       //error, f1 not a pointer or reference type.
\end{lstlisting}
	
	\par About cyclic reference, please see code below:
	\begin{itemize}
		\item You can't write the code below, because it has cyclic dependent of \texttt{a.h} and \texttt{b.h}.
\begin{lstlisting}[numbers=none]
#include "b.h" //a.h file
class A{
	B b;
};

#include "a.h" //b.h file
class B{
	A a;
};
\end{lstlisting}

		\item How to fix? you can use forward declaration to remove \texttt{\#include} statement in one header file. But at this time, you have to use pointer or reference in that header file.
\begin{lstlisting}[numbers=none]
//a.h file, Don't need to #include "b.h" here. 
class B;  //instead, just forward declaration class B.
class A{
	B* b; //have to use pointer or reference here.
}
\end{lstlisting}
	\end{itemize}
	
	\par About PIMPL, you need to know:
	\begin{itemize}
		\item When you implement PIMPL, you also need to use forward declaration and pointer/reference here.
\begin{lstlisting}[numbers=none]
class Widget { // "widget.h" file
private:
	struct Impl; // forward declaration here.
	Impl* pImpl; // have to use pointer for any forward declaration.
};
		
#include "Foo.h"  // widget.cpp file, include Foo.h
struct Widget::Impl { //definition of Impl is here
	Foo f1;
	...other detail.
};
\end{lstlisting}
		
		\item PIMPL idiom is one of \texttt{std::unique\_ptr} most common use case. But just like using raw pointer, you should define destructor even you have used \texttt{std::unique\_ptr} here. 
		
\begin{lstlisting}
class Widget {     // widget.h file
	Widget::~Widget(); //declare Widget destructor. 
	
private:
	struct Impl; // Forward declaration.
	std::unique_ptr<Impl> pImpl;
};
		
#include "Foo.h"    //widget.cpp file
struct Wideget::Impl{ //definition of Impl is here
	Foo foo;
};
Widget::~Widget() = default; //define Widget destructor
\end{lstlisting}
\begin{description}
	\item[Line 2:] If you don't declare destructor here, compiler will produce default destructor in line 7 by itself, In the end, it will call \texttt{delete pointer\_to\_Impl} inside the \texttt{std::unique\_ptr} destructor. At this time, \texttt{struct Impl;} is just forward declaration and a uncompleted type (definition is still invisible here).
	
	\item[Line 13:] Here, \texttt{Widget}'s destructor can see the whole \texttt{Impl} definition(line 10-12), so \texttt{delete pointer\_to\_Impl} is legal now. You don't need to define \texttt{Widget} destructor by youself, using \texttt{=default} is enough.
	
	\item[Source code:] The entire idea is to control when the compiler generates the destructor for class \texttt{Widget}; It should not be generated too early. Instead, we should wait until we have seen the complete definition of \texttt{struct Impl}. This program reflects an important \textbf{principle}: the compiler has its own processes and restraints. As a programmer, you should understand these processes and restraints, work well with the compiler, and achieve your objectives.
\end{description}

\end{itemize}


\subsection{Linkage}

\subsubsection{Duration, Scope and Linkage}
	 \textbf{Storage duration} and \textbf{scope} are two different conceptions in C++. 
	
	\par Storage duration in C++ refers to the lifetime or extent of existence of an object or variable within a program. There are four kinds of storage duration: 
\begin{itemize}
	\item automatic: Local variables declared inside functions or blocks.
	
	\item static: Objects with static storage duration are allocated once when the program starts and persist throughout the entire execution. They are destroyed when the program terminates. 
	
	\item thread storage duration: Introduced in C++11, objects with thread storage duration are created when their thread begins and destroyed when their thread ends.
\begin{lstlisting}
thread_local int counter = 0;
void incrementCounter() {
	++counter;
	std::cout << "Thread ID: " << std::this_thread::get_id() << ", Counter: " << counter << std::endl;
}

std::thread t1(incrementCounter); //Each thread has its own counter variable.
std::thread t2(incrementCounter);
t1.join(); t2.join();
\end{lstlisting}
	
	\item dynamic: Allocated and deallocated manually by the programmer using dynamic memory allocation operators like \texttt{new} operator and \texttt{delete} operator. The lifetime of dynamically allocated objects is not tied to any specific scope or function.
\end{itemize}
	
        \par There are mainly three kinds of \textbf{scopes}:
	\begin{itemize}
		\item global: In C++, we can use namespace to add more scopes to divide global scope.
		\item translation unit: Contents of a single source file (such as a.cpp), plus the contents of any header files directly or indirectly included by it.
		\item local: function local and class local. 
	\end{itemize}

	\par Scope is a property handled by compiler, whereas linkage is a property handled by linker. \textbf{Only global scope variable or function definition has external or internal linkage}. There are two linkages: internal linkage and external linkage. Internal linkage refers to everything only in scope of a translation unit. External linkage refers to things that exist beyond a particular translation unit. In other words, accessible through the whole program, which is the combination of all translation units. Linkage refers only to elements that have addresses at link/load time; thus, class declarations and local variables have no linkage. Some internal and external linkage examples are:
	
\begin{itemize}
	\item non-const global variable has external linkage. Use \texttt{static} to make it internal linkage. Please note here: \texttt{static} has two usages, in file scope, it says that a variable has \textbf{internal linkage}, in function or class scope, it says that this variable has \textbf{static storage duration}, don't mix it up.
	
	\item Const global variables have internal linkage by default.
	
	\item Functions have external linkage by default. Static function has internal linkage. Inline function will be introduced in the next section. 
\end{itemize}

	\par When you declare a variable as \texttt{const} at the global or namespace scope in C++, it has internal linkage by default.
	 
	\begin{itemize}
		\item Internal linkage means the variable is only accessible within the translation unit (typically a single source file and its included headers) where it is defined. So you can define two same name \texttt{const} variable in two different .cpp file, and they will not conflict each other. 
\begin{lstlisting}[]
//a.cpp
const Buffer_Size = 10;
int a[Buffer_Size] // a[10] in a.cpp

//b.cpp
const Buffer_Size = 20;
int b[Buffer_size] // b[20] in b.cpp, no multiple definition error.
\end{lstlisting}
		
		
		\item You can put \texttt{const int num\_month = 12;} into a header file or global.h file. Then when you need \texttt{num\_month}, just include this header file into you .cpp and it will not cause "multiple definition" linkage error. 
		
		\item You also can put \texttt{const int g\_num = 10;} in one .cpp file. then declare \texttt{extern const int g\_num ;} in global.h file. Once you use \texttt{extern} to declare const, you change it to external linkage. I recommend this style because it's a kind of "explicit". 
		
\begin{lstlisting}[numbers=none]
//file.h:
extern const int a_global_var; 

//file.c:
#include "file.h"
const int a_global_var = /*const expression */;
\end{lstlisting}

	\end{itemize}
	
	\par When a definition has internal linkage, it means that:
\begin{itemize}
		\item You can put two same static variable name (\texttt{static} indicates internal linkage) in two different .cpp file, no linkage error (Each definition will has his own memory).
		
		\item You can't access internal linkage definition from another .cpp file. 
		
		\item You can't use \texttt{extern} with \texttt{static}, but you can use \texttt{extern} with \texttt{const}.
\end{itemize}



\subsubsection{Inline function}
	 All the functions defined inside the class are implicitly or automatically considered as inline except virtual functions. Note that inline is a request to the compiler and its compilers choice to do inlining or not.
	
\begin{itemize}
	\item For non member function, put inline function into a header file, and when you need to use this function, include the header file.
	
	\item For member function, you have two options.
\begin{lstlisting}[numbers=none]
class Foo {  
	public:
	void method(){...};  //option 1, give definition in the class body.
};

class Foo {  
public:
	void method(); //Don't put inline keyword here, no function body.
};

//option 2, inline keyword here, still in the header file.          
inline void Foo::method(){       
  ...// if the function body is very long.
}	
\end{lstlisting}	

\end{itemize}	
	
	
	\par When defining inline functions, adhere to a straightforward rule: \textbf{Whether for member or non-member inline functions, always place them in a header file}. Why? 
\begin{itemize}
	
	\item No matter how you designate a function as inline, it is a request that the compiler is allowed to ignore: the compiler might inline-expand some, all, or none of the places where you call a function designated as inline. (Don’t get discouraged if that seems hopelessly vague. The flexibility of the above is actually a huge advantage: it lets the compiler treat large functions differently from small ones, plus it lets the compiler generate code that is easy to debug if you select the right compiler options.)
	
	\item When the compiler wants to inline a function, it needs to see the definition so it can expand and insert it directly into the source code. Placing the definition in one header file ensures consistent inline expansion across the whole codebase.
	
	
	\item If the compiler chooses not to inline a function marked with inline, the inline keyword serves to suppress multiple definition errors. In modern C++, inline informs the linker that if it encounters multiple definitions (not just declarations) of the same inline function in different translation units, they are identical. Therefore, the linker can retain one definition and discard the others without issues. It is crucial for the programmer to ensure that all inline function definitions with the same name are identical across translation units. Placing inline function definitions in a single location, typically a header file, ensures this consistency.
\end{itemize}

		
	
%	\item Does an inline function have internal linkage? No! The explanation is a little complex, so if you don't want to go deeper, you can skip the contents below. If you are confident and like facing a challenge, read on. In fact, an inline function has \textbf{external} linkage, but inlining suppresses the multi-definition error. The linker will simply pick one and discard the others, which can be dangerous. That's why we should ensure that we have only one definition and put the inline function in a header file. Then, when we want to use it, we can simply include it. We can demonstrate that an inline function has external linkage using the code below, which involves two files: a.cpp and b.cpp.
%\begin{lstlisting}
%inline int foo() { //File a.cpp
%	return 6;
%}
%void g() {
%	printf("foo called from g: return value = %d, address = %p\n", foo(), &foo);
%}
%
%inline int foo() { //File b.cpp
%	return 12;
%}
%void g();
%int main(){
%	printf("foo called from main: return value = %d, address = %p\n", foo(), &foo);
%	g();
%}
%\end{lstlisting} 
%\begin{description}
%	\item[Line 1 and 8 without inline:] it will trigger multi-definition linkage error
%	\item[Line 1 and 8 one inline:] Only on inline, because inline has external linkage, so it will trigger multi-definition linkage error too.
%	\item[Line 1 and 8 two inline:] Redefining an inline function with the same name but with a different function body is illegal; however, the compiler does not flag this as an error, but simply generates a function body for the version defined in the first file entered on the compilation command line, and discards the others. Therefore, may not produce the expected results.
%	\item[Delete line 8 to 10:] Compiling error, identifier doesn't found.	
%\end{description}

		


\subsection{Combine C and C++}
	
	 C++ inherits basic data types, variable names, statements, expressions, operators, control flow structures, functions, files, header files, libraries, arrays, pointers, and structures from the C language. As a superset of C, C++ compiler can compile C program too. \textbf{Most of time, you want your C++ application to call some existing C functions, but not reverse}. The C++ compiler must be used to compile \texttt{main()}, and must be used to direct the linking process. 
	
	\par When compiling C and C++ files together, there are three key considerations to understand:
	\begin{itemize}
		\item What is \texttt{\_\_cplusplus}? 
		\item How to understand \texttt{extern "C"}? 
		\item Learn how to pass a class between C and C++, and how to call member function in C? 
	\end{itemize}
	
	 
		
	\par When you use g++,  \texttt{\_\_cplusplus} will be defined automatically and implicitly, you can't undef it in fact. When you use C compiler, such as gcc, \texttt{\_\_cplusplus} is not defined. At the same time, When you use C++ compiler, such as g++ to compile a C file, although file extension is .c, but g++ still compile the C file with \texttt{\_\_cplusplus} defined and use name mangling to change function name. Whether \texttt{\_\_cplusplus} is defined or not depends on the compiler you are using (like g++ or gcc on a Linux system), not on the file name extension of your source file.
	
	
	\par The key idea of this section is: \textbf{\texttt{extern "C"} will disable name mangling in C++ compiler.} 
\begin{itemize}
	

	
	\item If you have all .c and .cpp source files and you can control them, you can just use g++ compile them all. You don't need any \texttt{extern "C"} syntax.  g++ compiles all files using name mangling. 
	
	\item If your C++ file want to use a c function. You don't have C function source code (It is in a lib or obj file) or you don't want to recompile it( it's a very big C library). At this time, you have two methods:
	
\begin{lstlisting}
extern "C"{  // method 1, Only be used by a C++ compiler.
	c_function(int);
	#include "old_C_header.h"
}

#ifdef __cplusplus //method 2, can be used by both C and C++ compiler
extern "C" {
#endif
	Foo (int a, int b);
#ifdef __cplusplus
}
#endif	
\end{lstlisting}
	
	\begin{description}
		\item[Line 6 to line 12:] If you can control the header file, you can use \texttt{\_\_cplusplus + extern "C"}. This header file can be used both in C and C++ compiler. In fact, all c lib header file, such as \texttt{math.h} follow this pattern.
	\end{description}
\begin{center}
\includegraphics[width=0.85\linewidth]{pics/extern.drawio.png}
\end{center}

\end{itemize}

		\par There are two occasions which you have to use \texttt{extern "C"} in your header file to avoid name mangling. 
	\begin{itemize}
		\item When you want to produce a DLL or SO from C compiler. Why? because maybe your DLL or SO will be used in both C language and C++ language or different compiler which uses different name mangling rule.
		
		\item When the code will be used by java, python or legacy C code. 
	\end{itemize}
	 
        

	
	

%	\item If you define a function in .cpp file(You have to use g++ to compile it), and this function will be used in legacy C system, you need to use \texttt{\_\_cplusplus + extern "C".} to disable name mangling.  You can give lib and head file to C system,  and then the C system can include head file and linked to lib.
	
%	\item \textbf{In one word, if you have obj code produced by C or C++, When you want to linked it to different language, you should consider using \_\_cplusplus + extern "C" }
	
	\par Can a C function directly access data in an object(lib or so) of a C++ class? Yes, but with some restriction. C++ class has no virtual base and virtual function and no access control. If you just want to pass a object from or to C function, you can refer a article in "C++ FAQ, 36.05". It demonstrate how to pass object from main to cppCallingC (C++ to C), then call cCallingC++ (C to C++). You need to pass the class pointer and use the same header file, but use \texttt{\#ifdef \_\_cplusplus} to defines one class (used by C++) and one struct (used by C), and they have the same name. Sometimes, you also need to write a C++ wrapper function, which include C++ member function syntax, then C call this C++ wrapper function. 
	
\section{Deployment and ABI}

You can directly distribute your source code, allowing users to download and compile it locally with their toolchain to generate an executable. This ensures absolute ABI (Application Binary Interface)  compatibility during deployment. Another option is to distribute a statically linked version, enabling users to run your program directly. Both approaches require certain assumptions and restrictions on the user's operating system. While this is relatively straightforward on Windows, it poses some challenges on Linux. (A better approach for Linux is to distribute a docker container.) 

\par Assume you are maintaining a shared library. If the header files and library files are upgraded separately and you want to avoid affecting existing executables, you must carefully manage ABI compatibility. C/C++ exposes the usage of dynamic libraries through header files, which serve primarily as a reference for the compiler to generate binary code. At runtime, the loader links the executable with the dynamic library. To ensure binary compatibility, the key is to verify whether the "usage specification" defined in the header file remains consistent with the actual implementation in the new version of the library. While a new library version comes with updated headers, existing binary executables still interact with the dynamic library based on the old headers.

\par The following changes in your new shared library break ABI compatibility:
\begin{itemize}
	\item Adding a default parameter to a function prevents existing executables from passing the extra argument.
	
	\item Adding a virtual function alters the vtable layout. (Ignoring the "only add at the end" workaround, as the class may already be inherited.)
	
	\item In both struct and class in C++, memory layout is determined by the order and alignment of data members. Data members are accessed using their offsets from the object's base address.
	
	\item Adding a default template type parameter, such as changing vector<T> to vector<T, Alloc=alloc<T>>, modifies name mangling.
\end{itemize}


\par If ABI compatibility is a primary concern, you should avoid using virtual functions as the interface in your class.
\begin{lstlisting}
class Graphics{
	virtual void drawLine(int x0, int y0, int x1, int y1);
	virtual void drawLine(Point p0, Point p1) //this addition will break ABI
	...
}
\end{lstlisting}

\par We can use the PIMP (Pointer to Implementation) idiom to avoid exposing virtual functions in the public interface. Instead, forward calls within the library implementation to Graphics::Impl, which resides in the .so/.dll and is updated alongside the library. When adding new functionality, avoid extending through inheritance. Instead, modify the implementation in place while maintaining binary compatibility. Start by updating the header file, then add the forwarding in the implementation file. This approach preserves binary compatibility since adding non-virtual functions does not affect existing executables.

\begin{lstlisting}
class Graphics{
	void drawLine(int x0, int y0, int x1, int y1){
		impl->drawLine(x0, y0, x1, y1);
	}
	void drawLine(Point p0, Point p1) //this addition doesn't break ABI
	
	class Impl;
	boost::unique_ptr<Impl> impl;
}	
\end{lstlisting}


% This part is very important. The other two places where virtual functions can be avoided are in the call and callback areas. In both cases, we can use std::function. The advantage is that, for calls, we can customize the behavior based on different objects, and for callbacks, we can avoid inheriting from platform-specific classes.

%\begin{lstlisting}
%//The first usage of std::function
%class Graphics{
%	fuction<void (Point, Point) drawLine;
%
%Graphics g1(lam) //different behaviour base on different obj
%Graphics g2(fun)
%
%//The second usage of std::function.
%class NetServer : boost :: nocopyable{
%	typedef boost::function( void (Connection*)); ConnectionCallback;
%	void registerConnectionCallback(const ConnectionCallback &);
%}
%
%NetServer server;
%server.registerConnectionCallback(boost::bind(&amp;EchoService::onConnection,&amp;echo, _1));
%\end{lstlisting}




\chapter{Type, operator and expression}
\section{Type}
\subsection{Type cast in c++}
\subsubsection{Implicit conversions}
	 There are two kinds of conversion, one is \textbf{implicit}, and the other is \textbf{explicit}. Implicit conversions are performed whenever an expression of a type \texttt{T1} is used in context that does not accept \texttt{T1}, but accepts another type \texttt{T2}; in particular:
	\begin{itemize}
		\item When the expression is used as the argument when calling a function that is declared with \texttt{T2} as parameter;
		
		\item When the expression is used as an operand with an operator that expects \texttt{T2};
		
		\item When initializing a new object of type \texttt{T2}, including a function returning \texttt{T2};
		
		\item When the expression is used in a switch statement (\texttt{T2} is integral type) or when the expression is used in an if statement or a loop (\texttt{T2} is bool).
	\end{itemize}
	
	\par Implicit conversion sequence consists of the following, in this order:
	\begin{enumerate}
		\item zero or one standard conversion sequence.
		\item zero or one user-defined conversion.
		\item zero or one standard conversion sequence.
	\end{enumerate}

	\par A user-defined conversion is a conversion defined by the user, consisting of zero or one non-explicit single-argument converting constructor or non-explicit conversion operator call. You can think of the conversion operator as the opposite of a one-argument conversion constructor. For type \texttt{Foo}, single-argument converting constructor is \textbf{from}, and conversion operator is \textbf{to}.

\begin{itemize}
	\item Single-argument constructor, it means that a class \texttt{Foo} can be produced \textbf{from something.}
	
	\item Conversion operator, it means that a class \texttt{Foo} can be converted \textbf{to something}. No argument, and must be a member function.

\begin{lstlisting}
class Foo {
	Foo(int i); // Foo can be built FROM int
	operator const char*(); //Foo can be converted TO char*
};

Foo f1, f2;
f2 = f1*2;   // implicitly convert 2 to temp A obj.
f2 = 2;   //implicitly convert 2 to temp A obj, then call operator =;
const char* p = f2; //use conversion operator here. 
\end{lstlisting}	
	
\end{itemize}


%	\item Implicit conversion can be called by compiler implicitly, (means that you don't know at all). It sometimes will lead to potential ambiguity problem and result which you don't expect. more detail can be seen effective c++ item 26.
%\begin{lstlisting}[frame=single, language=c++]
%class A{
%	A(class B&); // one method converting from A to B
%};
%class B{
%	operator A() //Another method converting From A to B
%};
%
%void g(const A&);
%B b;
%g(b) // Ambiguity here. two possibilities from A to B. 	
%\end{lstlisting}

	\par Implicit conversions performed by the compiler can occur automatically, often leading to potential ambiguity and unexpected results. It's crucial to \textbf{avoid} implicit conversions whenever possible, following two key rules:
	
\begin{itemize}
	\item Use explicit before single parameter constructor. In the code below, with explicit keyword before constructor,  you have to use \texttt{Foo(2)} or \texttt{(Foo)2} to explicitly build a a temporary obj in \texttt{f1*Foo(2)} expression. It's a good habit and you should follow. 
	
	\item Use name convert function instead of conversion operator. In STL, \texttt{std::string} class has a function \texttt{c\_str()} instead \texttt{operator const char*()}. 
\end{itemize}
\begin{lstlisting}[numbers=none]
class Foo {
	explicit Foo(int i);     // good style, explicit
	const char* getInternalPoint(); //good,a name function.
};	

Foo f1;
f2 = f1*Foo(2) // f2 = f1*2 will fail. 	
\end{lstlisting}	


		\par If you still want to use a conversion operator, it is generally recommended to make conversion operators explicit. This prevents implicit conversions that can lead to unexpected behavior and errors in your code. An explicit conversion operator requires explicit syntax to perform the conversion, rather than allowing the compiler to automatically handle it. This approach makes the code clearer and easier to understand, especially for those unfamiliar with the codebase.
\begin{lstlisting}[numbers=none]	
struct X {
	operator int() const { return 7; } 	//implicit conversion
	explicit operator int*() const { return nullptr; } // explicit conversion
	
};
X x;
int i = x; //implicit conversion, compiler convert it automatically, bad style. 
int* p = x; //fail, operator int* is explicit.
int* p = static_cast<int*>(x); //work, explicit call operator, good style.
\end{lstlisting}	

		
%\begin{lstlisting}[numbers=none]	
%struct X {
%	operator int() const { return 7; } 	//implicit conversion
%	explicit operator int*() const { return nullptr; } // explicit conversion
%	
%	int* p = static_cast<int*>(x); // OK: sets p to null
%	//  int* q = x;  //Error: no implicit conversion	
%	//   Error: array operator not allowed in conversion-type-id
%	//   operator int(*)[3]() const { return nullptr; }
%	
%	using arr_t = int[3];
%	operator arr_t*() const { return nullptr; } // OK if done through using
%	//operator arr_t () const; // Error: conversion to array not allowed
%};
%\end{lstlisting}	
	
	\par A practical usage of conversion operator can be seen in the below code. 
	\begin{enumerate}
		\item In line 8, \texttt{ref(a)} return a \texttt{reference\_wrapper} type object, so in line 3, when we use \texttt{++a}, it becomes \texttt{++reference\_wrapper}.
		
		\item Because \texttt{reference\_wrapper} doesn't support \texttt{++ operator}, as a result \texttt{a} (\texttt{reference\_wrapper} type) is "used as an operand with an operator that expects \texttt{T2}", compiler try to perform implicit conversion here to convert \texttt{a} to another type which supports \texttt{++ operator}.
		
		\item Then it try a "zero or one non-explicit single-argument converting constructor or non-explicit conversion function call" in the \texttt{reference\_wrapper} class, STL has defined \texttt{operator T\& () const} conversion operator inside \texttt{reference\_wrapper} class, which can converts the \texttt{reference\_wrapper} type to an \texttt{int\&} type. \texttt{int\&} supports the (\texttt{++ operator}), so compiler convert \texttt{reference\_wrapper} to \texttt{int\&} implicitly in line 3.
	\end{enumerate}
	  
\begin{lstlisting}[]
template<typename T>
void functest(T a){
	++a; //convert reference_wrapper to int& implicitly here. 
}

int g_i = 1;
functest(g_i);  //g_i is still 1
functest(ref(g_i)); // g_i is 2 now.	 
\end{lstlisting}		

\subsubsection{Type cast operator}
	  In C language, there exists two casts for explicit type-casting: functional and C-style cast.  \textbf{Prefer C-style cast in C language}.
	
\begin{lstlisting}[]
double x = 10.3;
int y;
unsigned int n2 = unsigned(f);     // functional cast: type(variable)
unsigned int n1 = (unsigned int)f; // C-style cast: (type)variable
\end{lstlisting}
\begin{description}
	\item[Line 4:] functional cast only be used in one word type. \texttt{unsigned int (f)} is not right, \texttt{int *(p)} is not right either. That is why we prefer C-style cast in C language.
\end{description}	
	
	\par Unrestricted explicit type-casting allows to convert any pointer type into any other pointer type, regardless of the types they point to. While the syntax and compiling may be correct, this can lead to run-time error. In order to overcome this problem, C++ introduces cast operator, There are five cast operators, \texttt{dynamic\_cast}, \texttt{const\_cast}, \texttt{static\_cast}, \texttt{reinterpret\_cast} and \texttt{bit\_cast}. The latter two are not used very often, it mainly used in some specific contexts, such as compiler development.
	
\begin{lstlisting}[frame=single, language=c++]
char c = 10;    
int *p = (int *)&c;  //compile succeed here
*p = 5;             //but run time error later and cause stack corruption.
	
int *p = static_cast<int*>(&c); //compile fail here, more safe. 
\end{lstlisting}
		
	\par \texttt{void*} type can be converted to any other type implicitly. You don't need any cast operator when you change any type pointer to \texttt{void*}, but when you want to use dereference \texttt{void} pointer , you'd better use \texttt{static\_cast }to change it back to a certain type pointer.
\begin{lstlisting}[frame=single, language=c++]
int* p = malloc(sizeof(int)); //malloc return void*, can assign to int* in C
int* p = static_cast<int*>(malloc(sizeof(int)));//In C++, must use cast or new operator
\end{lstlisting}		
	

	\par Changing the value of an const object through \texttt{const\_cast} pointers leads to  "undefined behavior". For const static data -- the compiler may put such variables in a read-only region, the program will crash if you try to modify it. 

\begin{lstlisting}[numbers = none]
const int a = 12;
int* p = const_cast<int*>(&a); //Bad style
*p = 66;  //UB	
\end{lstlisting}


	\par Using \texttt{const\_cast} is not good design. Sometimes for a const member function, you have to use \texttt{const\_cast} to change the "\texttt{this}" pointer to modify a class member. If compiler support, always use \texttt{mutable} keyword. Only use \texttt{const\_cast} if your compiler doesn't support \texttt{mutable}. Additionally, there may be cases where you need to pass a const object to a function that takes a non-const parameter, but you know that the parameter will not be modified inside the function. The second condition is important, because it is always safe to cast away the constness of an object that will only be read and not modified. In these cases, you can use \texttt{const\_cast}. In one word, don't use \texttt{const\_cast} unless you know it's safe. 

\begin{lstlisting}[numbers = none]
strlen( char* p);
const char* cp = "hello";
strlen(const_cast<char*>(cp));	
\end{lstlisting}

	\par \texttt{static\_cast<type-name>} is a valid expression only if two types are convertible. It will stop you from changing a bird class to an unrelated apple class. Even when converting from \texttt{int} to \texttt{double}, it is recommended to use \texttt{static\_cast<double>(i)}.  This type of cast can make it easier to find casting operations in your source code by searching for instances of \texttt{static\_cast}.
\begin{lstlisting}[numbers = none]
int i = 11111600;
char c = i; //give warning, conversion from big type to small type. 
char c = (char)i; //no warning, because you have told compiler explicitly.
char c = static_cast<char>(i); //no warning, just like previous statement.

int *p = (int* p)i //no warning, but crash when running
int *p = static_cast<int *>i //compile error,  int and int* are not convertible
                         //That is why static_cast is better then C style const.
\end{lstlisting}

%	\item  \texttt{static\_cast} can't deal with inheritance well in C++. 
%\begin{lstlisting}[numbers = none]
%struct V {
%	virtual void f() {};
%};
%struct A : V {};
%struct B : V {};
%
%A a;
%V& v = a;
%B& b = static_cast<B&>(v); //compile OK, but it's UB.
%\end{lstlisting}
%\begin{description}
%	\item[Source code] From \texttt{V} to \texttt{B}, it's possible to downcast, so \texttt{static\_cast} succeed. But if \texttt{A} is behind reference \texttt{V}, then you will have undefined behaviour. That is why we need \texttt{dynamic\_cast}.
%\end{description}	
	
	\par A \texttt{Derived} class pointer can always be directly assigned to a \texttt{Base} class pointer, which is known as an \textbf{up-cast} conversion and is a key aspect of polymorphic implementation. However,  \textbf{down-cast} is not allowed without an explicit type cast. The reason for this restriction is that the is-a relationship is not, in most of the cases, symmetric. A derived class could add new data members, and the class member functions that used these data members wouldn't apply to the base class.
\begin{lstlisting}
Base* pb = new Derived{}; //Ok, it's up-cast 

Derived* pd = pb;  //down-cast, can't compile, even it's Derived class behind pb.
Derived* pd = static_cast<Derived*>(pb);//OK, with explicit type cast.
\end{lstlisting}
	
	
	\par Both \texttt{static\_cast} and \texttt{dynamic\_cast} operator can be used to perform a \textbf{down-cast} of a base pointer to a \texttt{Derived} pointer. \texttt{static\_cast} just check on compile time and doesn't use run time information, so sometimes it makes mistake. On the contrary, \texttt{dynamic\_cast} ensures that the down-cast is valid in the run time.
	
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
class Base {
public:
	virtual void fun(){cout<<"base"<<endl;}
};

class Derived : public Base {
public:
	virtual void fun(){cout<<"child"<<endl;}
};

Base* pa = new Derived();
Derived* pb = dynamic_cast<Derived*>(pa); //OK, Derived is behind pa,
Derived* pb = static_cast<Derived*>(pa);  //OK, 	

Base* pa = new Base();
Derived* pb = dynamic_cast<Derived*>(pa); //return nullptr, Base is behind pa, 
Derived* pb = static_cast<Derived*>(pa);  //compile OK, but UB in runtime.	
\end{lstlisting}
\begin{description}
	\item[Line 15 to 17]  when \texttt{Base} is behind \texttt{pa} pointer and you downcast to \texttt{Derived*}, \texttt{dynamic\_cast} give you \texttt{nullptr}(warning), but \texttt{static\_cast} has UB problem.	
\end{description}

	 \par \texttt{dynamic\_cast} can also be used with reference types. If the cast fails, \texttt{dynamic\_cast} will not return \texttt{nullptr} (because it's a reference), but throw a \texttt{bad\_cast} exception instead.

	
\begin{lstlisting}
struct Base {};
struct Derived : public Base {};

Derived d; // a derived object
Base& b = d; // That is up-cast, dynamic_cast may be used, but unnecessary
Derived& new_d = dynamic_cast<Derived&>(b); // downcast, have to use dynamic_cast 
\end{lstlisting}	
	
	\par \texttt{dynamic\_cast} should only be used down-cast public inherited relationship. You can't use \texttt{dynamic\_cast} when it is private or protected inherited relationship. If a class doesn't have virtual function, you can't use \texttt{dynamic\_cast} on this object either. If you frequently use \texttt{dynamic\_cast}, it can be a sign that your base class offer too little functionality, you'd better to re-design you base class API (moving member functions from \texttt{Derived} class to \texttt{Base} class).
	
	\par \texttt{dynamic\_cast} can also be used in \textbf{side-cast in multi inheritance. }
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
struct V {
	virtual void f() {}; // must have virtual function
};                            V
struct A : virtual V {};     / \
struct B : virtual V {};    A-->B (From A to B is side cast)
struct D : A, B {};          \ /
                              D                    
D d; // the most derived object
A& a = d; // upcast 
B& b = dynamic_cast<B&>(a); //side cast from A to B, it's valid here. 
\end{lstlisting}

\begin{description}	
	\item[Line10:] That is side cast. Change \texttt{d} to \texttt{a} first(from child D to parent A), then \texttt{a} to \texttt{b}, (from child D to parent B, always succeed because \texttt{d} is behind \texttt{a}, and \texttt{d} can be converted to \texttt{b}.)
\end{description}
	


	\par \texttt{static\_cast} can not be use in virtual base. virtual base is mainly used to avoid "diamond" problem in the multiple inheritance. 
\begin{lstlisting}[numbers = none]
struct Parent {
	virtual void f() {};
};
struct Child : virtual Parent {}; //virtual keyword here.

Child child;
Parent& parent = child;
Child& other = static_cast<Child&>(parent); //compile fail, 
\end{lstlisting}

	\par About \texttt{dynamic\_cast}, "exceptional C++" item 44 give a good question and answer.
	

	\par RTTI makes \texttt{dynamic\_cast} work correctly in run time. RTTI is a relatively new conception in C++, you should avoid using it on old C++ compiler. It has two methods: \texttt{typeid} and \texttt{dynamic\_cast}. There are two kinds of types (for the purposes of RTTI): polymorphic types and non-polymorphic types. A polymorphic type is a type that has a virtual function, in itself or inherited from a base class. A non-polymorphic type is everything else; this includes POD types and many other types too.
		
	\par \texttt{typeid} operator will return a \texttt{type\_info} class. You need to include typeinfo.h header file. \texttt{typeid} operator also receive pointer or class name. \texttt{name()} is member function of \texttt{type\_info} class, you can call this member function to get type name information. 
		
\begin{lstlisting}
int myint = 50;
std::string mystr = "string";
double *mydoubleptr = nullptr;
	
cout << "myint has type: " << typeid(myint).name(); //typeid is operator
cout<< "mystr has type: " << typeid(mystr).name();  // it returns type_info
const type_info& ti = typeid(mydoubleptr);
\end{lstlisting}		
			
		
	\par RTTI (Run-Time Type Information) has legitimate uses but is also prone to abuse, so it's important to use it carefully. Like exceptions, it can cause some loss in performance, so you can turn it off by using the "-fno-rtti" compiler flag. You may use RTTI freely in unit tests, but try to avoid it in other production code whenever possible. Consider using one of the following alternatives to querying the type:
		\begin{itemize}
			\item Virtual methods are the preferred way of executing different code paths depending on a specific subclass type. This puts the work within the object itself.
			
			\item If the work belongs outside the object and instead in some processing code, consider a double-dispatch solution, such as the Visitor design pattern. This allows a facility outside the object itself to determine the type of class using the built-in type system. Visitor design pattern can be seen in the later section.
			
			\item Use static polymorphism (compile-time polymorphism), it can be achieved through function overloading and template metaprogramming.
		\end{itemize}		
	
	
	\par \texttt{reinterpret\_cast} can convert any pointer type to any other pointer type, even if they are unrelated classes. The operation results in a simple binary copy of the value from one pointer to the other. All pointer conversions are allowed: neither the content pointed to nor the pointer type itself is checked. It can even cast pointers to or from integer types. There is no any type safe here, so \textbf{DON'T USE IT UNLESS YOU HAVE NO OTHER CHOICE}. When you use \texttt{reinterpret\_cast} to change one pointer type to another, it violates the "strict alias rule" and can lead to undefined behavior.
	
	
	\par "strict alias rule" explanation. Under strict aliasing, the compiler writer is free to optimize the function \texttt{foo} below because incompatible types, \texttt{double} and \texttt{int}, can't alias. That means that if you do call \texttt{foo} as \texttt{foo((double *)\&anint)} something will go quickly wrong, but you get what you deserve.
\begin{lstlisting}
int anint;

void foo(double *dblptr){
	anint = 1;  //compiler developer can optimize this line.
	*dblptr = 3.14159;
	bar(anint);
}

foo((double *) &anint) // violate "strict alias rule"
\end{lstlisting}
	
	\par Below code also has undefined behavior because there is no \texttt{SomePod} object within the buffer. Objects do not spontaneously come into existence just because you want them; The compiler determines that the store to the \texttt{x} subobject cannot possibly alias the object buffer, because buffer does not contain an x subobject, and no other object for which buffer might provide storage has been created since buffer was created. Therefore the compiler reasons that it can reorder the store to before its internal marker for the start of the lifetime of buffer. The store can now be deleted, because it is immediately followed by the start of the lifetime of an object in the same region of storage.
	
	% YanReview here
	
\begin{lstlisting}
struct SomePod { 
	int x; 
};
alignas(SomePod) char buffer[sizeof(SomePod)];
reinterpret_cast<SomePod*>(buffer)->x = 42;
\end{lstlisting}
	
	\par To avoid previous undefined behavior with \texttt{reinterpret\_cast}, we can use \texttt{memcpy} to ensure that there are no UB issues. You don't need to worry about efficiency problems because the \texttt{memcpy} below will produce the same assembly code as the previous code while avoiding UB.
	
\begin{lstlisting}
struct SomePod { int x; };
alignas(SomePod) char buffer[sizeof(SomePod)];
SomePod temp;
memcpy(&temp, buffer, sizeof(SomePod));
temp.x = 42
memcpy(buffer, &temp, sizeof(SomePod));	
\end{lstlisting}
	
	\par If you understand previous \texttt{reinterpret\_cast} and memcpy, you can understand \texttt{std::bit\_cast} intent. \texttt{std::bit\_cast} also use \texttt{memcpy} inside, it also can be used in constexpr context and is a new feature of C++ 20.
	
	\par There are two kinds of casts: implicit cast and explicit cast. You should try to use \texttt{explicit} keyword more in C++ class to avoid implicit cast. There are two kinds of explicit cast methods:
	\begin{itemize}
		
	\item C type cast, you should avoid using them in your new code. 
	
	\item C++ type cast operators should be used more because they are more restricted and safer. \texttt{const\_cast} should be used when calling legacy or old functions that do not have \texttt{const} parameters. \texttt{static\_cast} will suppress warnings and prevent conversions like \texttt{int} to \texttt{int *}. This is why we should always use \texttt{static\_cast}. \texttt{static\_cast} always allows down casting (because it's theoretically valid, but not correct in practice), which is why we need to use \texttt{dynamic\_cast} to avoid illegal down-casting. \texttt{dynamic\_cast} can only be used with public inheritance classes that include virtual functions. \texttt{reinterpret\_cast} only be used in specific context, \texttt{std::bit\_cast} is an improvement of \texttt{reinterpret\_cast} to satisfy "strict alias rule".
\end{itemize}
	

\subsection{Arithmetic types}

\subsubsection{Numerical conversions}
	 Numerical conversions happen in three contexts:
	\begin{enumerate}
		\item Assign a value of one \textbf{arithmetic type} to a variable of another arithmetic type.
		
		\item Combine mixed types in expressions.(Most of time, implicit promotion conversion happens)
		
		\item Pass arguments to or return from a function with different types.
	\end{enumerate}
	
	\par Converting short type to long type is \textbf{promotion}, it happens when we need hardware bit alignment optimization. Most of time, we don't need to worry about it. In an expression, C++ makes three kinds of automatic promotion conversion.
	\begin{enumerate}
		\item Some types are automatically converted whenever they occur. For example, when you add \texttt{char} to \texttt{char}. C++ converts \texttt{bool}, \texttt{char}, \texttt{unsigned char}, \texttt{signed char} and \texttt{short} to \texttt{int}. Because \texttt{int} type is generally chosen to be the computer's most natural type. It does calculations faster for that type. It's called \textbf{integer promotions}.
		
		\item Some type are converted when they are combined with other types in an expression. When an operation involves two types, the smaller is converted to the larger. For example, when you add an \texttt{int} to a \texttt{float}, \texttt{int} is converted to \texttt{float} type. (You have to do it, because two types have the different inside binary representations).
		
		\item \texttt{unsigned short} convert to \texttt{int} if \texttt{short} is shorter than \texttt{int}, if they have the same size. \texttt{unsigned short} convert to \texttt{unsigned int}.  So no data loss in type promotion.
	\end{enumerate}
	
\begin{lstlisting}
char c1, c2, c //c1 and c2 convert to int first.
c = c1+c2;  // then change int result back to char.

store i8 97, i8* %c1, align 1  //LLVM IR code below
store i8 2, i8* %c2, align 1
%0 = load i8, i8* %c1, align 1
%conv = sext i8 %0 to i32  //promote to integer
%1 = load i8, i8* %c2, align 1
%conv1 = sext i8 %1 to i32
%add = add nsw i32 %conv, %conv1 //add two integers
%conv2 = trunc i32 %add to i8  //convert result back to char.

i+f // integer will promoted to float
float f1, f2, f; //Whether float promote to double depends on compiler, 
f = f1+f2; // Clang++ has fadd in LLVM IR, so don't change float to double here.
\end{lstlisting}	
	
	
	
	\par A implicit conversion will happen when you assign non bool value to a bool, zero converts to false, and nonzero converts to true.
	
	\par When a implicit conversion happen, assigning a value to a type with a greater range (promotion conversion) usually poses no problem. If shorter range or different type, maybe there are some problems. For example, when conversion \texttt{double -> float, long long ->float} happens, it maybe lose precision. When \texttt{float -> i} happens, it loses fragment. Be careful with implicit narrowing standard conversion. 
	
\begin{lstlisting}
int i, float f = 3.99;
i=f;  //i will be 3(not rounding), UB if f is too big

f = i; //will lost precision if i is big.	
int i = 666;
char c = i; //this will lead to undefined behavior. 
\end{lstlisting}	
	
	\par A implicit conversion also happen when you call a function.(Just like you use assignment operator=). Below code compile successfully. Compile with "-Wconversion" flag, note that it is not included in "-Wall" in g++; It only gives warning when standard conversion occurs, not for promotion conversion.
	
\begin{lstlisting}[numbers=none]
bool isLucky(int number);

isLucky('a') // promotion ,NO warning
isLucky(false) // promotion, NO warning
isLucky(1.2f) // narrowing standard conversion.  Warning	
\end{lstlisting}	
	
	\par C++ 11 introduces braces initialization \{\}, It will not allow narrowing happen (In g++, it just show a -Wnarrowing message). we should use more braces initialization \{\} in our new code. 
\begin{lstlisting}[numbers=none]
int x = 66;  char c1 = {x}; //ok	
int x = 666; char c2 = {x};// not allowed;
int fun(){
	return 1.2f; //OK, no warning
	return {1.2f}; //ERROR, -Wnarrowing
}	
\end{lstlisting}	
	


\subsubsection{Numerical Overflow}

	 How to understand integer overflow? \texttt{int x;} is a position in the below figure, \texttt{x+3} means walk 3 step clockwise from \texttt{x}. \texttt{x-3} means walk 3 step anti-clockwise from \texttt{x} position. The overflow (or underflow) only happens in the -8 position. Anytime you walk pass the -8 position, the overflow happens, no matter clockwise and anti-clockwise direction. For example, 5+4 = -7 (not 9); -6-3 = 7 (not -9).

	
\begin{figure}[!htb]
	\begin{minipage}{0.48\textwidth}
		\centering
		\includegraphics[width=.9\linewidth]{pics/integer.png}
	\end{minipage}\hfill
	\begin{minipage}{0.48\textwidth}
		\centering
		\includegraphics[width=.9\linewidth]{pics/integer1.png}
	\end{minipage}
\end{figure}


%		\includegraphics[width=0.5\linewidth]{pics/integer.png}		
%		\includegraphics[width=0.5\linewidth]{pics/integer1.png}

	
	
	
	\par In C and C++, you can use limits.h or <limit> to get all the type limit information.
	
\begin{lstlisting}[numbers=none]
INT_MAX INT_MIN  //use in C
std::numeric_limits<int>::lowest() //use in C++
std::numeric_limits<int>::max()
\end{lstlisting}
	
	\par There are three ways to deal with overflow and underflow problem:
	
	\begin{enumerate}
		\item Build your own template function.
\begin{lstlisting}[numbers=none]
template <class T>
void increment_without_wraparound(T& value) {
	if ( value < numeric_limits<T>::max() )
		value++;
}
\end{lstlisting}
		
		\item  Judge if overflow happens before calculation. \texttt{INT\_MAX} is like "-8" position in the previous figure, it's help you to understand below code. 
		
\begin{lstlisting}
if ((x > 0) && (a > INT_MAX - x)) // a + x would overflow 
if ((x < 0) && (a < INT_MIN - x)) // a + x would underflow
if ((x < 0) && (a > INT_MAX + x)) //a - x would overflow  (1-(-10))
if ((x > 0) && (a < INT_MIN + x)) //a - x would underflow (1-10)
if (a > INT_MAX / x)  // a * x would overflow 
if ((a < INT_MIN / x)) // a * x would underflow 
\end{lstlisting}
		
		
		\item Judge it after calculation, we can use this method for unsigned integer.
\begin{lstlisting}[numbers = none]
uint32 a,b;  //must be unsigned integer
uint32 result = a + b;
if (result < a) //overflow
\end{lstlisting}
	\end{enumerate}
	
	\par There is no simple, general, portable way to avoid integer overflow. You can't check whether a signed integer addition or subtraction has overflowed after the fact. Typically, the result wraps around, but in principle, your program could cause undefined behavior or crash before you have a chance to examine the result. Clang 3.4+ and GCC 5+ offer checked arithmetic built-ins that provide a very fast solution to this problem, especially when compared to bit-testing safety checks.
\begin{lstlisting}[frame=single, language=c++]
unsigned long b, c, c_test;
if (__builtin_umull_overflow(b, c, &c_test)){
	// returned non-zero: there has been an overflow
}
\end{lstlisting}
	
	\par Integer type has \textbf{overflow} problem, and float has \textbf{precision} problem. So prefer to use \texttt{long long} and \texttt{double} as your numerical type. In modern hardware, memory usage is not big concern, and using types with enough width can save you a lot of trouble in the future. There are also some tricks to avoid overflow. If you  want to know the last three digits of \texttt{n!}. You need use \texttt{mod} to keep last two digits in each calculation.
\begin{lstlisting}[numbers = none]
(a+b)/2  //a+b maybe overflow
a/2+b/2 +(a&b&1); //will not overflow
\end{lstlisting}
	


\subsection{size\_t and ptrdiff\_t}

\subsubsection{Be careful with unsigned int}

     When an \texttt{unsigned int} and an \texttt{int} are added together, the \texttt{int} is first converted to \texttt{unsigned int} before the addition takes place and the result is also an \texttt{unsigned int}. In another word, For integer addition or subtraction, It is just a trip around clock. When you reach a position in the clock, how to understanding depends on its context and type.
\begin{lstlisting}[numbers=none]
unsigned int ui = 1;
int i = -2;
printf("%d", ui+i);//print -1, ui+i is 0xffffffff in memory, interpret as signed int.
printf("%u", ui+i);//print UINT_MAX, interpret as unsigned int.
cout<<ui+i<<endl; //output 4294967260.
(ui+i)<6  //false here, interpret (ui+i) as unsigned int.
\end{lstlisting}
    
	\par You can see llvm reference. 1) has only i32, no ui32 2) has only add and mul, no uadd or umul.  3) but has uge, zext or sext, udiv. That is to say, these three operations 1)comparison, 2)promotion, 3)divid  need interpret signed or unsigned semantic differently. In order to understand why we need udiv and sdiv two different operation, just like why we need logical shift right and arithmetic shift right, because for signed and unsigned number, we need to take different action. Detail can be see \verb|https://llvm.org/docs/LangRef.html| to get more detail.
	 
\begin{lstlisting}[frame=single, language=c++]
unsigned int ui = 1 
int i = -2;
(ui+i)/4  //a big positive number
int* p;
p+(ui+i);  //OK on 32 bits platform, but crash on 64 platform.
\end{lstlisting}

	\par In above code, why does it crash on 64 bits? \texttt{ui+i} will be promote to 64 bits first and it will be promoted according to \texttt{unsigned int}. In order to avoid \texttt{p+(ui+i)} portable problem, we should use \texttt{size\_t} and \texttt{ptrdiff\_t} type. 
\begin{lstlisting}
0xffffffff //ui+i in memory, it's 32 bit representation.
//when we want to promote(expand) it to 64 bit, we have two possibilities:
0xffffffff -> 0x00000000ffffffff //1) promote as a unsigned int, a big positive number
0xffffffff -> 0xffffffffffffffff //2) promote as a signed int, still -1 semantic
//p+(ui+i) will crash if ui+i is promoted as unsigned int. 
//(ui+i) is interpreted as a big positive number and p+big_number will be out of range. 
\end{lstlisting}
	

%YanReview
	
    \par In summary, \texttt{ui+i} result type is \texttt{unsigned int},  when you use \texttt{ui+i} in 1) compare with other, 2) promote 3) divid, it will interpret according to its unsigned semantic(non negative). Maybe it's not what you expect.  In one word, Don't use unsigned type just for big range, if \texttt{int} is not big, just use \texttt{long} instead \texttt{unsigned int}. Don't combine unsigned and signed integer together in your expression.

\subsubsection{size\_t and ptrdiff\_t}
	 \texttt{size\_t} is commonly used for array indexing and loop counting. Programs that use other types, such as \texttt{unsigned int}, for array indexing may fail on, e.g. 64-bit systems. \texttt{ptrdiff\_t} is used for pointer arithmetic and array indexing, if negative values are possible. Programs that use other types, such as \texttt{int}, may fail on, e.g. 64-bit systems. The main reason for using \texttt{size\_t} is that the size of something depends on a pointer, but on different systems, the size of a pointer is not the same as the size of an \texttt{int}. The size of \texttt{size\_t} and \texttt{ptrdiff\_t} always coincide with the pointer's size. Because of this, these types should be used as indexes for large arrays, for storing pointers, for pointer arithmetic, loop counters, array indexing, and address arithmetic. 
	
	\par Type \texttt{size\_t} is a typedef that's an alias for some unsigned integer type, typically \texttt{unsigned int} or \texttt{unsigned long}, but possibly even \texttt{unsigned long long}. Each Standard C implementation is supposed to choose the unsigned integer that's big enough--but no bigger than needed--to represent the size of the largest possible object on the target platform.
	
	\par \texttt{size\_t} can resolve portable problem. Supposed \texttt{unsigned int} is 16 bit, the first function work well in 16 bit OS, but in 32 bit OS, it can't copy big object(bigger than 16 bit.) The second function works well in 32 bit OS, but in 16 bit OS, it's not high efficient. The \texttt{size\_t} version can work well in both 16 and 32 bit system, because it's adjustable to 16 bit or 32 bit according to the platform. 
	
\begin{lstlisting}
//suppose that int is 16 bit and long is 32 bit
void *memcpy(void *s1, void const *s2, unsigned int  n); 
void *memcpy(void *s1, void const *s2, unsigned long  n);
void *memcpy(void *s1, void const *s2, size_t n);
\end{lstlisting}

	\par At the same time, using \texttt{size\_t} appropriately makes your source code a little more self-documenting. When you see an object declared as a \texttt{size\_t}, you immediately know that it represents a \textbf{size} in bytes or an \textbf{index}, rather than an error code or a general arithmetic value.
	
	\par \texttt{ptrdiff\_t} type is a base signed integer type of C/C++ language. The type's size is chosen so that it can store the maximum size of a theoretically possible array of any type. 
\begin{lstlisting}[numbers=none]
int A = -2;   // should use ptrdiff_t here
unsigned B = 1; // should use ptrdiff_t here.
int array[5] = { 1, 2, 3, 4, 5 };
int *ptr = array + 3;
ptr = ptr + (A + B); //Error on 64 bit OS.
printf("%i\n", *ptr);
\end{lstlisting}
	
	\par  A good article is "Why size\_t matters", another one is "About \texttt{size\_t} and \texttt{ptrdiff\_t"}. 

\subsection{Complex compound Type}

	 In C++, compound types refer to types that are derived from other types and are more complex. These include reference types, pointer types, array types, function types, pointer to member types, and class types. These types can be combined in various ways, such as a function pointers that receive arrays and return classes, which can make declarations more complex but also more flexible in usage.

	
	\par In C, arrays are implemented as pointers to their first element. When you declare an array, you get a pointer to the first element of the array. Therefore, certain array operations can be expressed as corresponding pointer operations. 
	
\begin{lstlisting}
int arr[5] = {1, 2, 3, 4, 5}; //int * ptr = arr;
arr[1] = 3  //*(ptr+1) = 3;
\end{lstlisting}

	\par If you understand this equivalence, you can understand the following statements: An array of integers is a pointer to integers, an array of floats is a pointer to floats, an array of pointers is \textbf{a pointer to pointers}, and an array of arrays is \textbf{a pointer to arrays}. Regarding a pointer to a pointer, you can think of it as a ragged two-dimensional array. Concerning a pointer to an array, you need to know how to declare it correctly in syntax. 
	
	\par A pointer to a pointer is mostly used in ragged arrays and arrays of lists. For a ragged character array, you can use a null character as an end marker, while for a ragged integer array, you need to include extra size information. If you want to modify a pointer parameter, you can use \texttt{int* \&p}; this is more clear and direct than using a pointer to a pointer.
\begin{lstlisting}
int** p = new int* [2]; //that is array of pointer.
p[0] = new int[2];   //xxx    //that is ragged array
p[1] = new int[3];   //xxxx

p[0][1] = 0;
int* &rp = p[0]; 

delete [] p[0]; //there are three new above,
delete [] p[1]; //so, there are three delete here.
delete [] p;			
\end{lstlisting}	
	
	\par A pointer to array is a complex declaration in C++. It is like a pointer to a function. Let me introduce pointer to an array first. 
\begin{lstlisting}
int a [2] = {1, 3};
int b [3] = {1, 2, 3};

int (*p)[] ; //pointer to array, can omit the dimension, but you can not increment it.
p = &b; //p = &a is OK, (*p)[1] is ok, but ++p error

int (*p)[3]; // C/C++ both support int(*p)[] and int(*p)[3]
p = &b;  //p = &a is error, (*p)[1] is ok, ++p is also OK.	
\end{lstlisting}	
	
%	\par When using \texttt{typedef}, the basic syntax remains the same, but the identifier becomes a type instead of a variable. It is common practice to use a capital letter to denote that the identifier is a type.
%\begin{lstlisting}[]
%struct Block{
%	int i;
%	int j;
%} bb;  //define variable, bb is variable.
%
%typedef struct Block{
%	int i;
%	int j;
%} BB;  //define type, BB is type 	
%\end{lstlisting}	
	
	\par Pointer to functions is like pointer to array. They both need parentheses around \texttt{(*variable\_name)}, pointer to array need \texttt{[dimension]} after the \texttt{(*variable\_name)}, pointer to function need \texttt{( parameter )} after \texttt{(*variable\_name)}. 
	
\begin{lstlisting}
int (*pointer_to_fun)( int ) ;  //( parameter ) after variable name
int (*pointer_to_array) [3];    //[dimension] after variable name
\end{lstlisting}	

	\par The basic method for interpreting complex declarations is to start by finding the identifier name and using it as a center point to expand both to the right and to the left, following the "right-then-left" rule. A good reference is here: How to interpret complex C/C++ declarations. You can google and read it. Next, I will use this method to analyze a complex declaration. 
\begin{lstlisting}
int (* array_fun_pointer[2])( float ) 
\end{lstlisting}
\begin{description}
	\item[1] The first step, get the variable name, look right, found that it's array. what types are in the array?
	
	\item[2] Then look left, found that pointer, then that is an array of  pointer.
	
	\item[3] Then look right, found that this is parentheses, that is function. so pointer to function, what is return type of this function?
	
	\item[4] then look left, parameter is \texttt{int}, and return type is \texttt{int}.
	
	\item[5] In summary, it's a array, each element in this array is pointer to function, the function receive a \texttt{float} as parameter and return \texttt{int}. 
\end{description}	

	\par Let's resolve another challenging declaration. Below code is a pointer to function which returns complex type. This is a function pointer, The function input a \texttt{int} and return a pointer. The return pointer points to an array, and array's element type is \texttt{int *}.
\begin{lstlisting}
int * (* (*fp1) (int) ) [10];
//Start from the variable name -> fp1
//Nothing to right but ) so go left to find * -> is a pointer
//Jump out of parentheses and encounter (int) -> a function take int as argument
//Go left, find * -> this function return a pointer
//Jump put of parentheses, go right and hit [10] -> to an array of 10
//Go left find * -> pointers to
//Go left again, find int * -> that is int* [10]		
\end{lstlisting}	

	\par From the introduction above, we can see that writing complex declarations involving function pointers and arrays can be challenging. The good news is that we can use \texttt{typedef} to simplify this process. This allows for easier use and readability of complex function pointer types.

\begin{lstlisting}
int (*pointer_to_fun)( float ) ;  //complex 
typedef int (*FOO_PTR_T)( float ); //use typedef here,
FOO_PTR_T pointer_to_fun;	 //easy to define pointer_to_fun now. 

int (*array_fun_pointer[2])( float ) //complex declarations, array of pointer.
FOO_PTR_T array_fun_pointer[2];	     //same declaration, much clear now.
\end{lstlisting}	

	\par Just like \texttt{typedef}, you can also use "using alias" to simplify complex compound types in the above example in modern C++. 
\begin{lstlisting}
int * (* (*fp1) (int) ) [10]; //can be rewritten to next three lines by "using alias".
using MyArray = int* [10];           //1) Define pointer array
using MyFuncPtr = MyArray* (*)(int); //2) Define pointer to fun
MyFuncPtr fp1;                       //3) Use new type define variable

MyArray* MyFunc(int x) {
	...
}
fp1 = MyFunc;
MyArray* arr = fp1(5); //invoke MyFunc function.
\end{lstlisting}

\subsection{Some type categories}
\subsubsection{Aggregate}
		
	 \textbf{The basic idea of aggregate type is that you can use aggregate list initialization}. All the detail definition of an aggregate can be traced back to this main purpose. In source code level, an aggregate is an array or a class with no user-declared constructors, no private or protected non-static data members, no base classes, and no virtual functions.
\begin{lstlisting}[numbers=none]
class NotAggregate1{
	int x; //x is private by default and non-static
	virtual void f() {} //remember? no virtual functions
};
		
class Aggregate1{
private:
	void f() {} // ok, just a private function
};
\end{lstlisting}

	\par In C++11, Previously, an aggregate could have no user-declared constructors, but now it can't have user-provided constructors. Is there a difference? Yes, there is, because now you can declare default constructors by using " = default;" 
\begin{lstlisting}[numbers=none]
struct Aggregate {  //it's still aggregate type in C++ 11
	Aggregate() = default; 
};
\end{lstlisting}

%	\par In C++11, an aggregate cannot have any brace-or-equal-initializers for non-static data members. What does this mean? Well, this is just because with this new standard, we can initialize members directly in the class like this:
%\begin{lstlisting}[numbers=none]
%struct NotAggregate {
%	int x = 5; 
%	std::vector<int> s{1,2,3}; // valid in C++ 11
%};
%\end{lstlisting}

	\par  An aggregate class can have a non-aggregate data member. Because it will not stop us from using aggregate initialization for the aggregate class. You can see the example code below, value in brace list can be used to call non-aggregate user define constructor. So for class \texttt{Test}, it is still aggregate type.
\begin{lstlisting}[]
class Foo{
public:
    Foo(int i): i_{i}{ };
    int i_;
};

struct Test{
    Foo f;
    int k;
};

cout<<is_aggregate_v<Foo><<endl; //No, because we have user define constructor
cout<<is_aggregate_v<Test><<endl; //Yes, it can include non-aggregate.
Test t = {1,2}; //can use aggregate init here. 1 is used by Foo(int i ) constructor.
\end{lstlisting}

	\par Now let's see how aggregates are special. They, unlike non-aggregate classes, can be initialized with curly braces \{\}. 
\begin{lstlisting}[frame=single, language=c++]
struct X{
	int i1;
	int i2;
};
	
struct Y{  //Y is aggregate type. 
	char c;
	X x;
	int i[2];
	float f; 
protected:  //although has protected:, it's static 
	static double d; 
private:    //alghought has private:, it's function, not member variable
	void g(){}      
}; 
//      c       x      inti[2]
Y y = {'a', {10, 20}, {20, 30}}; //initialized by list initialization, f  in Y is 0
\end{lstlisting}
	
	\par From previous examples we may know the definition of aggregates, let's try to understand the restrictions on aggregate types; that is, why they are there. We should understand that memberwise initialization with braces implies that the class is nothing more than the sum of its members. If a user-defined constructor is present, it means that the user needs to do some extra work to initialize the members therefore list initialization would be incorrect. If virtual functions are present, it means that the objects of this class have (on most implementations) a pointer to the so-called vtable of the class, which is set in the constructor, so brace-initialization would be insufficient. Further more, an aggregate is basically a simple collection of data that does not have any invariants the class would have to guarantee. Since there is no invariant and thus all combinations of possible values of the member make sense, there is no point in making them private since there is nothing to protect.
	

\subsubsection{POD, trivial and literal type}
	
	 For objects of POD types, it is guaranteed by the standard that when you \texttt{memcpy()} the contents of your object into an array of char or unsigned char, and then \texttt{memcpy} the contents back into your object, the object will hold its original value. Do note that there is no such guarantee for objects of non-POD types. Also, you can safely copy POD objects with \texttt{memcpy}.
	
	\par An aggregate class is called a POD if it has no user-defined copy-assignment operator and destructor and none of its non-static members is a non-POD class, array of non-POD, or a reference.
	
\begin{lstlisting}[numbers=none]
struct POD{
	int x;
	char y;
	void f() {} //no harm if there's a function
	static std::vector<char> v; //static members do not matter
};
	
struct AggregateButNotPOD1{
	int x;
	~AggregateButNotPOD1() {} //user-defined destructor
};
	
struct AggregateButNotPOD2{
	AggregateButNotPOD1 arrOfNonPod[3]; //array of non-POD class
};
\end{lstlisting}
	
%	\item POD-classes, POD-unions, scalar types, and arrays of such types are collectively called POD-types. POD-classes are the closest to C structs. Unlike them, PODs can have member functions and arbitrary static members, but neither of these two change the memory layout of the object. So if you want to write a more or less portable dynamic library that can be used from C and even .NET, you should try to make all your exported functions take and return only parameters of POD-types.
		
	
	\par In C++ 11, The idea of a POD is to capture basically two distinct properties: 1)It supports static initialization. 2) Compiling a POD in C++ gives you the same memory layout as a struct compiled in C. So the definition has been split into two distinct concepts: \textbf{trivial classes} and \textbf{standard-layout classes}, because they are more useful than POD. The standard now rarely uses the term POD, preferring the more specific \textbf{trivial} and \textbf{standard-layout} concepts.

	\par If this is a trivial class, then it has trivial constructor/destructor/copy/assignment. When we build, copy or destruct these types, we don't need to call these trivial constructor/destructor..., \textbf{but just call malloc() or memcpy()to improve efficiency.} 
	

		
	\par One property of trivial class is that it supports static initialization. Static initialization is initialization of some variable with a compile-time value such that the value ends up being "baked into" the executable image (no code needs to be actually run). Another point of triviality is that the type can be treated exactly like a fundamental type, in that objects of the type can be copied and moved with \texttt{memcpy()} and constructed destructed without doing anything. Hence, triviality requires a type be essentially made only of fundamental types. T
\begin{lstlisting}[numbers=none]
struct Foo {
	int x;
	int y;
};
Foo foo = {0,1}; //if you define it global, this init happens in compiling time.
\end{lstlisting}

	\par trivial class is not aggregate class, for example, it can include private non-static data member. STL has some type traits to help you to judge if a type is POD, trivial or standard layout.
\begin{lstlisting}[numbers=none]
struct Trivial {
public:
	int a;
private: // no restrictions on access modifiers
	int b;
};

struct NonTrivial : Trivial {
	virtual void f();  // virtual members make non-trivial ctors
};	

cout<<std::is_pod<T>::value;
cout<<std::is_trivial<Trivial>::value;  //return true here. 
cout <<std::is_standard_layout<T>::value;
\end{lstlisting}
	
	\par If a class is trivially copyable (a superset of trivial classes), it is ok to copy its representation over the place with things like \texttt{memcpy}. In STL, \texttt{std::copy} use \texttt{std::is\_trivially\_copyable} as a dispatching flag to decide whether to call \texttt{memcpy} or call object copy constructor.
	
\begin{lstlisting}[numbers=none]
template <class T> 
void copy(T* source, T* destination, int n, trivial_false_type){
	for (; n > 0; n--,source++,destination++){
		//call constructor
	}
}
	
template <class T> 
void copy(T* source, T* destination, int n, trivial_true_type){
	if(non overlap)
		memmove(source, destination, n); //much faster here!
	else
		memcpy(source, destination, n);
}
\end{lstlisting}

\par Difference between trivial and standard layout. Both standard layout and trivial can use \texttt{memcpy} safely. But trivial doesn't guarantee that it has the same memory layout with C language.
\begin{lstlisting}[numbers=none]
struct N { // neither trivial nor standard-layout
	int i; // because there is virtual destructor
	virtual ~N();
};

class T { // trivial but not standard-layout
	int i;
private: //access control, then the compiler is free to choose a layout.
	int j;
};

struct SL { // standard-layout but not trivial
	int i;
	~SL();
};

struct POD { // both trivial and standard-layout
	int i;
};
\end{lstlisting}

	\par A literal type is a type that can qualify as constexpr. This is true for scalar types, references, certain classes, and arrays of any such types. A class that is a literal type is a class (defined with class, struct or union) that has a trivial destructor. And it is an aggregate type, or has at least one constexpr constructor or constructor template that is not a copy or move constructor. The detail can be found in cppreference website.
\begin{lstlisting}[]
struct A { };
struct B { ~B(){} };

cout << is_literal_type<int>::value ; //int&, int* and struct A all return true.
cout << "B: " << is_literal_type<B>::value;  //return false here.

struct point {
	constexpr point(int x_, int y_): x(x_),y(y_){}
private:
	int x,y;
};

static_assert( point(3,4).hypot() == 25 );
std::cout << std::is_literal_type<point>::value; //return ture, has constexpr constructor	
\end{lstlisting}

\par The reason why a literal type cannot have a non-trivial destructor is that it would prevent the type from being used in constant expressions. A constant expression is an expression that can be evaluated at compile time, and it is used in various contexts, such as initializing global or static variables or defining template arguments. If a literal type had a non-trivial destructor, it would require dynamic memory allocation and deallocation, which cannot be done at compile time. As a result, the type would no longer be suitable for use in constant expressions, and it would no longer be a literal type.	

\par Summary of different type categories:
\begin{itemize}
	


	\item Aggregate refers to a type that can be initialized using list-initialization syntax. This type's definition is not recursive. It describes an characteristic to support list-initialization syntax. 

	\item POD is obsolete after C++11 and it has been expanded to two distinct concepts: \textbf{trivial classes} and \textbf{standard-layout classes}.  \textbf{Trivial class is not sub-concept of POD, it's totally new definition.}  Standard-layout classes has the same layout as structs in C, so it has better portability.
	

	\item A trivial class can be created, moved, and destructed by only memory operation without any side effects. This allows for improved efficiency in certain contexts, such as using static initialization, using \texttt{memcpy()} instead of the copy constructor, or overwriting memory to destruct it. 

	
	\item If want to compatibility with C, you must ensure that the type is trivial AND standard-layout (not only layout compatible). For data exchange via network or file, you may use a type that satisfies only trivial or standard-layout. I would recommend either aiming for both or at least standard-layout. Because with only trivial, you risk that future compiler's or a different compiler on the other side, do rearrange data members, and then a receiver may have a different layout understanding than the sender.
	
	\item Understand aggregate, trivial, standard-layout and literal type from semantic, not syntactic perspective. A good article about this topic is "What are Aggregates and PODs and how/why are they special?" in StackOverflow.

\end{itemize}	
	 
	

\section{Type specifier}
\subsection{cv-qualifier}
\subsubsection{const variable and const function}
	
	 \texttt{const} must be initialized when you declare it. \texttt{static} will be initialized to default value(usually zero value) if you don't assign a value to it manually. 
	
	\par A top-level \texttt{const} indicates that the pointer itself is constant. When a pointer can point to a constant object, we refer to that \texttt{const} as a low-level const. For reference types, you cannot change the reference itself, so top-level const is always present by default, and you can only set low-level const.
\begin{lstlisting}[frame=single, language=c++]
int i = 0;
int * const p1 = &i; // const is top-level
const int *p2 = &ci; // const is low-level

const int *const p3 = p2;
const int &r = ci; //const in reference type is always low-level
\end{lstlisting}
	\begin{description}
		\item[Line 5:] \texttt{const} applies to the type to its left in C++ essentially. However, there's an exception that if you put it on the extreme left of the declaration, it applies to the first part of the type. Right \texttt{const} modify * on its left side. Left \texttt{const} is in the first position, so it modify the first part of the type(\texttt{int}). 
	\end{description}
	
	\par \texttt{const} mainly used in three places inside of function: 1) functions parameter. 2) function return. ( just used for \texttt{const} reference, not for return value) and 3) member function.

	
	\par For value type parameters, the function signature is the same whether or not you include the \texttt{const} keyword in front of the value parameter. Including it will cause a redefinition error. For non-value parameters, top-level const is considered part of the function signature. For example, \texttt{g(int\&)} and \texttt{g(const int\&)} are two different overload functions.
\begin{lstlisting}[frame=single, language=c++]
int f( int );   //just one function, 
int f( const int ); // redeclares f(int)

int g( int& );  //overload, two functions
int g( const int& );
\end{lstlisting}
	
	\par For \texttt{const} value type parameter in the code below, the \texttt{const} qualifier prevents code inside the function from modifying the parameter itself. Such an assurance helps you to quickly read and understand this function. Under some circumstances, this might even help the compiler generate better code. 
\begin{lstlisting}[frame=single, language=c++]
double cube (const double side){
	return side * side * side;
}
\end{lstlisting}
	
	\par Similar to the assert statement, it's important to use the \texttt{const} keyword aggressively in C++. When using a pointer or reference as a function parameter, you should always include the \texttt{const} keyword in front of it, since most of the time you don't need to modify it. If the compiler complains, you can then remove the \texttt{const} keyword. This approach will force you to use \texttt{const} more. (Personal style, follow with discretion. :) )
	
	\par When function return value type, don't use \texttt{const} at all. It will not allow you to use rvalue and move. 
\begin{lstlisting}[frame=single, language=c++]
const time operator+(const time &t){  //bad smell
	time temp;
	return temp.bla = bla+t.bla;
}  //because + return const, compiler doesn't use move, low efficient here.

time t3(t1+t2);
\end{lstlisting}
	
	\par When function return reference or pointer, you can use const to restrict modify it. That is a typical usage of \texttt{const} as function return. 
\begin{lstlisting}[numbers=none]
class String{
	const char& operator[](int position) const; 
}
\end{lstlisting}
	
	\par Most of time, only index operator \verb=[]=, assignment operator and \verb|<<|, \verb|>>| return reference. For assignment operator, we only need to return \texttt{\&}.  For istream and ostream overload, don't need return \texttt{const} either. 
\begin{lstlisting}[numbers=none]
Array &Array::operator=(const Array &right) {
	....
	return *this; //enables x=y=z
}
\end{lstlisting} 
	
	\par Common function interface design: you can see \texttt{const} only used in pointer or reference type. You should use more \texttt{const} in your code.
\begin{center}
	\begin{tabular}{|c|c|c|}
		\tophline
		\textbf{type} & \textbf{read} & \textbf{write} \\ \tophline
		
		primitive (char, int, float) & pass value & pointer or reference \\ \tophline
		class, array, structure  & const pointer or reference &  pointer or reference \bottomhline
	\end{tabular}
\end{center}
	
	

\subsubsection{const in class}
	
	 When \textbf{const} is used in class. There are four usages.
	\begin{enumerate}
		\item In \textbf{const} member function, you can't change any member variable,(If you change it, it will report a compile error). It will make const obj can invoke this function.
\begin{lstlisting}[numbers=none]
void A::fun() const{ //const is used as function specifier.
	this->m_a = 100; // compile error here.
}
\end{lstlisting}
		
		\item \texttt{const} obj can only call \texttt{const} function. But non-const obj can call ALL functions( \texttt{const} or non-const).
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
class Foo {
public:
	void inspect() const;  //promises NOT to change *this
	void mutate();      //might change *this
};

void userCode(Foo& changeable, const Foo& unchangeable){
	changeable.inspect();   // Okay: doesn't change
	changeable.mutate();    // Okay: changes
	unchangeable.inspect(); // Okay: doesn't change
	unchangeable.mutate();  // ERROR:
}
\end{lstlisting}

		\item If you want to return a member of a object from a const method, you should return it using reference-to-const or by value. 
\begin{lstlisting}[frame=single, language=c++]
class Person {
public:
  const std::string& name_good1() const; //good style,return const reference
  const std::string name_good2() const;  //good style, return value
  std::string& name_evil() const;  //bad style, client can change const obj.
  int age() const;  //good style
};

void myCode(const Person& p){ //through bad interface,
  p.name_evil() = "Igor";     // change const object
}
\end{lstlisting}
		
		\item The most common use of \texttt{const} overloading is with the subscript operator. If you need to create your own class that has a subscript operator, here's the rule of thumb:\textbf{ subscript operators often come in pairs.} One has \texttt{const} specifier, the other has not. 
\begin{lstlisting}[numbers=none]
class Fred { /*...*/ };
class MyFredList {
	public:
	const Fred& operator[] (size_t index) const;
	Fred&  operator[] (size_t index);
};
\end{lstlisting}
		
	\end{enumerate}
	
	\par \texttt{mutable} specifier allows you to modify a member variable in a class by a const method. Why do we need this specifier? Behind "mutable", It's an argument between bitwise const and logical const. Logical const is when an object doesn't change in a way that is visible through the public interface. An example would be a class that computes a value the first time if required, then caches the result.
	
	In the example below, \texttt{getLength()} is a memberwise const function that simply reads a length value without modifying it from outside the class. However, within the function, it may need to change some private member value. In this case, you can use the \texttt{mutable} keyword so that the \texttt{const getLength()} function can modify and cache a \texttt{length\_} value. A const function only restricts changes made within the function itself, and doesn't require the caller to be a const object. We declare \texttt{getLength()} as const because, logically, it only reads the value and doesn't change anything. If we didn't declare it as const, const objects wouldn't be able to call the \texttt{getLength()} function at all.
\begin{lstlisting}[frame=single, language=c++]
class TextBook  {
private:
	mutable int length_;
	mutable bool isValid;
public:
	void getLength() const {
		if(isValide == false){
			length_ = strlen(*p);
			isValid = true; 
		}
		return length_
	}
}
\end{lstlisting}
	
		
	\par In summary, the const keyword applied to a member function serves two purposes: \textbf{For outside, it broadens the scope of where the function can be applied; For inside, it imposes restrictions on certain operations and ensures that the function does not accidentally modify the object's data}.
	\begin{itemize}
		\item For outside, if you declare \texttt{getArea()} const function, it will make both const obj and non-const obj can call this member function. This is good. if you don't define it as const member function, only non-const obj can invoke this function. For outside, const increase interface applicable scope.
		
		\item Inside const member function, you need to follow below rules:
		\begin{enumerate}
			\item You can't change member variable anymore, (if you really want, use mutable keyword.) 
			\item Inside const member function, it will think all member variable const, so \texttt{vector<int> v;} will be const implicitly, return non-const iterator will be error.
\begin{lstlisting}
class Foo{
public:
  vector<int> v;
  vector<int>::iterator get_iter() const {
    return v.cbegin(); //correct, should return  vector<int>::const_iterator
    //return v.begin(); //error, return vector<int>::iterator
  }
};
\end{lstlisting}

			\item You must return const reference for const subscript operator. 
		\end{enumerate}
	\end{itemize}
	
	\par Above "outside and inside theory" is a great analogy, which can help you quickly understand \texttt{const} design concept and basic usage. The same "outside and inside theory" can also be used to help understand \texttt{constexpr}, which will be introduced in the next section.
	
	\par when you declare mutable, you'd better use mutex to synchronize it. It's called M\&M rule in "GotW \#6b Solution". A good reference article about const is GotW 6. 
		
		

\subsection{constexpr}

\subsubsection{Basic definition}
	
	 The first conception is \textbf{constant expressions}. A constant expression is an expression that can be \textbf{evaluated at compile time}. It has many advantages, such as performance optimization and can be used in places that require compile-time evaluation, for example, template parameters and array-size specifiers.
	 
\begin{lstlisting}
int n = 1;            //n is not a constant expression
std::array<int, n> a1; //ERROR 
const int cn = 2;     // cn is a constant expression
std::array<int, cn> a2;// OK 
\end{lstlisting}
	
	\par Before C++11, we can only use \texttt{const} to build const expression (left side of below figure). After C++11, by introducing \texttt{constexpr} specifier, we expand the constant expression scope. For example, a constexpr function with known parameter can be constant expression too (right side of below figure). That is the basic idea of \texttt{constexpr}, If you understand this, you can understand a lot of complex syntactic knowledge below.
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.9\linewidth]{pics/constexpr.png}
		\caption{Basic idea of constexpr}
		\label{fig:constexpr}
	\end{figure}
	
	\par \texttt{constexpr} can be used in three places: 1) constexpr variable, 2) constexpr obj, 3) constexpr function. constexpr function can be thought as a kind of "metafunction".
	
	\par The \textbf{constexpr specifier} declares that it is possible to evaluate the value of the function or variable at compile time. Such variables and functions can then be used where only compile time \textbf{constant expressions} are allowed (provided that appropriate function arguments are given). 
\begin{lstlisting}[frame=single, language=c++]
constexpr int fun(int a, int b){return a+b;}
	
constexpr int const foo = fun(2,3) ; // without line 1 constexpr declaration, 
int a[fun(2,3)];                     //we can't use fun in this way in line 3 and 4.
\end{lstlisting}
		
	

	
	\par Difference between constant expression and \texttt{constexpr}:
	\begin{itemize}
		\item Declaring a function as constexpr does not necessarily guarantee that it will be evaluated at compile time. It can be used for such, but it can be used in other places that are evaluated at run-time, as well.
		
		\item An object may be fit for use in constant expressions without being declared constexpr. for example: \texttt{const int N = 25}.
	\end{itemize}
	
	\par Difference between \texttt{constexpr} with \texttt{const}:
	\begin{itemize}
		\item \texttt{const} describes that the variable cannot be changed at runtime, while \texttt{constexpr} describes the ability of the variable to be computed at compile time.
		
		\item When you declare \texttt{constexpr} obj, it implicit \texttt{const.} But not all \texttt{const} is \texttt{constexpr.}
\begin{lstlisting}
constexpr int const foo = 42; //line 1 and 2 are same 
constexpr int       foo = 42; 
\end{lstlisting}
		
		\item \texttt{constexpr} just means \texttt{const} on top level. If you want to specify the low level \texttt{const}, you need to write it out.
\begin{lstlisting}
constexpr int pb = &bar;   //line1 and line 2 are not same. 
constexpr int const *pb = &bar; 
\end{lstlisting}
		\begin{description}
			\item[Line 2:] \texttt{pb} itself is constexpr, when we initialize it, \texttt{\&bar} must be constant expression too. At the same time, \texttt{pb} points const int, it means that we can't use \texttt{pb} to change \texttt{bar}.
		\end{description}
	\end{itemize}
	


\subsubsection{constexpr variable and object}
	
		
		\par constexpr variable must be initialized when you declare it. The full-expression of its initialization, including all implicit conversions, constructors calls, etc, must be a constant expression ({must be known at compile time). If you want to get value from a function, you have to use constexpr function to assign value to it. 
		
\begin{lstlisting}
constexpr int sum(int i, int j){
	return i+j;
}
int i,j;
cin>>i>>j;
const int result = i+j; //OK
const int ce = sum(i,j); //OK
constexpr int result = i+j;  //ERROR, can't calculate in compile time
constexpr ce = sum(i,j); //ERROR
\end{lstlisting}		
	
	
	\par For constexpr class, it must has corresponding  constexpr constructor. You can't define constexpr object if the class has no constexpr constructor. constexpr constructor has to be declared as default or delete or the function body must be empty (C++11). It can only use literal or constexpr user-defined type, and can't use exception handling.

	
	\par Other restraints for constexpr class includes:
	\begin{itemize}
		\item Can not have virtual base classes.
		
		\item Requires that each base object and each non-static member has to be initialized in the initialization list of the constructor or directly in the class body. 
		
		\item Consequently, it holds that each used constructor (e.g of a base class) has to be constexpr constructor and that the applied initializers have to be constant expressions.
	\end{itemize}
	
\begin{lstlisting}[frame=single, language=c++]
class MyInt{
public:
    constexpr MyInt()= default;
    constexpr MyInt(int fir, int sec): myVal1(fir), myVal2(sec){}
    MyInt(int i){ myVal1= i-2; myVal2= i+3; }
    constexpr int getSum() const {return ...}
    
private:
    int myVal1= 1998;
    int myVal2= 2003;
};

constexpr MyInt myIntConst1;  //default constructor is constexpr
MyInt myInt2;
constexpr int sec= 2014;     
constexpr MyInt myIntConst3(2011,sec); //two parameter constructor is constexpr
int arr[myIntConst3.getSum()];
static_assert( myIntConst3.getSum() == 4025, "2011+014 = 4025" );
constexpr MyInt myIntConst5(2000); //Error, constructor is not a constexpr function
\end{lstlisting}
	\begin{description}
		\item[Line 3-4:] A constexpr class must have a constexpr constructor. 

        \item[Line 6:] If a member function needs to be used in constexpr statement, it must be constexpr too. Note, the qualifier of constexpr member function must be const too, such as \texttt{getSum} in the above code.

		\item[Line 13 and 14:] You can declare both constexpr and non-constexpr object.
		
		\item[Line 15 and 16:] If you want to use constexpr to initialize constexpr variable, you must guarantee all the parameter are constexpr expression, such as \texttt{sec} in the above code.
		
	\end{description}



\subsubsection{constexpr function}

	  \texttt{Constexpr} can be used with both member and non-member functions, as well as constructors. It declares the function fit for use in constant expressions. When you declare a function as constexpr, you just tell the compiler that this function is a kind of \textbf{"pure function"}. The pure function has no state, and when you run it, it has no side effect.
	\begin{itemize}
		\item The return value is only determined by its input values.
		\item Given input values, the return value may be calculated in compiling time. 
	\end{itemize}
	
	
	\par The pure function has some advantages compared with ordinary funciton: Always return the same result when given the same arguments, so the function call can be replaced by the result, and the order of function call is not important. (That is why you can run it at compiling time). Compiler itself can't judge if a function is pure function, that's why programmer come to rescue. The programmer indicate this function is a "pure" function, so compiler can \textbf{For outside} use it in another constant expression context, \textbf{For inside} calculate it in compiling time. 
	
	\par On the first sight, you should declare constexpr function everywhere, but it's not a good idea either. That makes a constexpr qualifier an irrevocable design decision. You cannot remove this qualifier without an incompatible change to your API. It also limits how you can implement that function, e.g. you would not be able to do any logging within this function. Not every trivial function will stay trivial in eternity. That means you should preferably use constexpr for functions that are \textbf{inherently pure functions}, and that would be actually \textbf{useful at compile time} (e.g. for template metaprogramming). It would not be good to make functions constexpr just because the current implementation happens to be constexpr-able. In semantic level, you should have something that can be evaluated down to a constant while maintaining good readability and allowing slightly more complex processing than just setting a constant to a number. Take \texttt{max( a, b )} for example: it allows for compile-time calculation when called with constant values, rather than deferring to runtime computation.
\begin{lstlisting}[numbers=none]
constexpr int MeaningOfLife ( int a, int b ) { return a * b; }
constexpr int meaningOfLife = MeaningOfLife( 6, 7 );
	
template< typename Type > 
constexpr Type max(Type a, Type b) {return a < b ? b : a; }
\end{lstlisting}		
		
%	\item constexpr functions compile much quicker than the equivalent template-based solutions, which scale linearly with the depth of the template-recursion. Where compile-time evaluation is not necessary, using inline functions or functions with internal linkage would seem more appropriate than constexpr. Both constexpr and inline are for performance improvements, inline functions are request to compiler to expand at compile time and save time of function call overheads. In inline functions, expressions are always evaluated at run time. constexpr is different, here expressions are evaluated at compile time.

	
	\par Compared with ordinary function, constexpr functions:
	\begin{itemize}
		\item \textbf{For outside}. is able to be used in the another constant expression (such as \texttt{constexpr int sum = cfun(2,3);} ) But it doesn't mean that it must be used in constant expression (such as \texttt{int sum = cfun(i,j);})
\begin{lstlisting}[frame=single, language=c++]
constexpr int cfun(int i, int j){
	return i+j;
}
int fun(int i, int j){
	return i+j;
}

int i, j;
constexpr int sum = fun(2,3);  //Error
constexpr int sum = fun(i,j);  //Error
constexpr int sum = cfun(2,3); //OK
constexpr int sum = cfun(i,j); //Error

int sum = fun(2,3);  //OK, for non constexpr variable sum
int sum = fun(i,j);  //OK  both fun and cfun work well
int sum = cfun(2,3); //OK
int sum = cfun(i,j); //OK	
\end{lstlisting}
		
		
		\item \textbf{For inside}. Constexpr function adds a lot of constraints on its implementation.
	\end{itemize}
	
	
	\par In C++11, there are a few restrictions on constexpr functions. First, they have to be non-virtual. Second, they have to have arguments and a return value of a literal type. Literal types are the types of constexpr variables. Third, the function body must be extremely simple: apart from typedefs and static asserts, only a single return statement is allowed. For constructors, only an initialization list, typedefs, and static asserts are allowed. However, \texttt{=default} is also allowed.
	
\begin{lstlisting}[frame=single, language=c++]
constexpr int gcd(int a, int b){
	return (b== 0) ? a : gcd(b, a % b);
}  //use ternary to replace if
\end{lstlisting}
	
	\par In C++14. constexpr function can include: conditional jump instructions or loop instructions and more than one instruction. The arguments and the return type must be \textbf{literal types} (i.e., generally speaking, very simple types, typically scalars or aggregates)
		
\begin{lstlisting}[numbers=none]
constexpr auto gcd(int a, int b){
	while (b != 0){
		auto t= b;
		b= a % b;
		a= t;
	}
	return a;
}
\end{lstlisting}

    \par Even with constexpr parameter, constexpr function doesn't guarantee to be evaluated at compile time. There are three contexts in which a constexpr function \textbf{MUST} to run at compile time. 
    
    \begin{enumerate}
    	\item The constexpr function is executed in a context which is evaluated at compile time. This can be a \texttt{static\_assert} expression such as with the type-traits library or the initialisation of a C-array.
    	
    	\item The value of a constexpr function is requested during compile time with constexpr: \texttt{constexpr auto res = func(5);}
    	
    	\item A template parameter or enum or switch statement.
    \end{enumerate}
    
	\par \textbf{Use constexpr, const, and noexcept more aggressively.} This adds more compile-time checks, gives the compiler more information to optimize better, and has the added benefit of making you think more critically about your current actions. And remember: the longer it takes for your C++ program to compile, the greater your sense of accomplishment. :)

	\par A good document is "Demystifying constexpr" and you can google it. 

\subsection{static and volatile}
		
	 In C++, global and static variables are initialized to default values. However, \texttt{auto} variables are not initialized for efficiency reasons.
		
	\par You can't initialize a static member variable inside the class declaration; you need to put it in a .cpp file. However, if the static data member is a constant of integer or enumeration, you can initialize it inside the class declaration. If you have a constant member inside a class, it is better to use \texttt{const static} because it cannot be changed, and all objects can share the same static value.
\begin{lstlisting}[frame=single, language=c++]
class{  //in .h file
	static int obj_num;  // you can't initialize
	const static int months = 12; // you can initialize inside the class
};

int class::obj_num = 12; //in .cpp, no static keyword anymore.	
                     //will be 0 if you don't initialize it.
\end{lstlisting}	
	
	\par static member function has two usages:
	\begin{enumerate}
		\item It can be invoked just by class name, not by a object instance, so you can define a class and a lot of static math function inside it, just like namespace usage.
				
		\item A static function can't access class data members, only class static member data, because static functions doesn't use \texttt{this} pointer.
	\end{enumerate}
	
	\par \texttt{static} can be used restrict the scope. (internal linkage) After C++ 11, static variable inside a function is thread safe, so it's an important improvement for singleton pattern.
\begin{lstlisting}[frame=single, language=c++]
int global = 0;  //All files
static int s_i = 50; //just in this file
main(){
	static int s_i = 100;  //just in this block
	printf("%d %d", ::s_i, s_i); //print 50 and 100
}
\end{lstlisting}
	
	\par Summary: The usage of static in C++ depends on where it is used, as it can be used to declare static member variables, static member functions, and local static variables, each with different implications for the scope and lifetime of the object.
	\begin{itemize}
		\item Use it inside a function. Invisible outside of function, static life time and valid until program end.
		
		\item Use it inside a class. only one copy for all instances, and access by static member function.
		
		\item Use it before global variable to create an internal link and avoid name conflicts. However, in modern C++, it is preferable to use an unnamed namespace now.
	\end{itemize}

	\par In C++, the \texttt{volatile} keyword is used to indicate that a variable may be modified outside of the control of the program. Specifically, it tells the compiler not to optimize away or cache accesses to the variable.
\begin{itemize}
	\item When accessing hardware registers or memory-mapped I/O: In these cases, the value of the variable can change unexpectedly, so using volatile ensures that the variable is always read from or written to memory.
	
	\item When using a variable that is modified by another thread or signal handler: Without volatile, the compiler may optimize away accesses to the variable, resulting in incorrect behavior.
\end{itemize}

\par It's worth noting that using volatile can have a performance cost, as it prevents the compiler from optimizing certain code paths. As a result, it's important to use volatile only when necessary, and to understand the potential trade-offs. Do not use "volatile" except in low-level (embedded c) code that deals directly with hardware. 
\begin{lstlisting}[frame=single, language=c++]
void waitForSemaphore(){
	volatile uint16_t* semPtr = WELL_KNOWN_SEM_ADDR;
	/*well known address to my semaphore*/
	while ((*semPtr) != IS_OK_FOR_ME_TO_PROCEED);
}		
\end{lstlisting}	


\section{Name}
\subsection{Namespace}

	 Don't put a lot of stuff in the global scope. Learn to use namespaces to split the global scope into different sub-scopes. If you develop a library of functions or classes, you should put them in a new namespace, just like the std namespace in STL. Don't put your own class into the namespace \texttt{std}. Usually, the namespace should be your project name, and you can add your company name in front of it if you like.
		
	\par Using :: before a function name indicates the global namespace. For example, \texttt{::max} will hide \texttt{std::max}. In this way, you can define your own \texttt{max} function in the global scope and use \texttt{::max} to call your own max function.
	
	\par Namespaces can be located at the global level or inside other namespaces. They can't be placed in a block, so it has external linkage by default, that is to say it can be accessed by multi translation unit(files). There are three ways to use namespaces:
\begin{enumerate}
	\item using declaration, such as \texttt{using sp::name;}.
	\item using directive, such as \texttt{using namespace std;}.
	\item specify by namesapce name, such as \texttt{sp::name}.
\end{enumerate} 
	A using-declaration introduces a member of another namespace into the current namespace or block scope. It's a recommended way to use namespaces.  
\begin{lstlisting}[numbers = none]
using sp::name;   //1) using declaration, recommend
using namespace sp;   //2) using directive, not recommend
sp::name   //3) specific refer it
	
namespace ns{
	int zy;
}
using std::string; //using declaration
using namespace ns;
int main(){
	string str = "abc" //don't need to use std::string.
	int zy = 0; //it will hide ns::zy
	cin>>zy; //read into local zy
}
\end{lstlisting}


	\par Don't use a using directive in any header file because it will "pollute" all the .cpp files that include this header file. If you have to use a using directive in your .cpp file, put it after all the include files. Use a using directive as little as possible in any .cpp file. Instead, use scope-resolution or using-declaration more often. This will help avoid polluting the namespace.
\begin{lstlisting}[numbers=none]
#include <iostream>
using std::cout;
using std::endl;
cout<<"Hello world"<<endl;	
\end{lstlisting}	

	
	\par For implementation code, there are four methods to put it into namespace. Method 3 and method 4 are recommended.
	
\begin{lstlisting}[numbers=none]
namespace Yan{ //a.h
	Class Foo{
		void mem_fun();
	};
}
	
using Yan::Foo;  //method 1. using declaration
void Foo::mem_fun(){.......}
	
using namespace Yan; //method 2. using directive. It's bad style.
void Foo::mem_fun(){.........}
	
void Yan::Foo::mem_fun(){.........} //method 3. It's good style.

namespace Yan{  //method 4. can include more contents inside.
	void Foo::mem_fun(){......}
}
\end{lstlisting}

	
	\par unnamed namespace just like \texttt{static} to specify its content to local file scope. At the same time, make anonymous namespace as small as possible.
	
\begin{lstlisting}[numbers=none]
// a.cpp file
static int count;

namespace{ // A better method to use namespace.
	int count;
}
\end{lstlisting}
	


\subsection{Name lookup}
	 The function call process consists of three phases: 1) name lookup, 2) overload resolution, and 3) access control. Here's a detailed explanation of each phase:
	\begin{enumerate}
		\item First, compiler looks function names in the \textbf{immediate scope},  and makes a list of all functions that have right names  (regardless of whether they're accessible or even take the right number of parameters). Please note, \textbf{If compiler has found function name, even the parameters don't match, compiler will not continue outward search. It stops here and barks}. It's a safe measure, compiler think the immediate scope is "priority zone". Maybe you omit parameter, so compiler should not search outward implicitly. Only if compiler doesn't find any same function name at all, then compiler continue to "search outward" into the next enclosing scope and repeat.
		
		\item If there are more than one candidate functions after the step 1, the compiler perform overload resolution and then apply access rules. In one word, overload resolution does not go beyond scopes! Overload resolution has a good introduction: "C++ Primer plus" chapter 8 "Which Function version the compiler pick". The main idea is: \textbf{exact match non-template > template > argument conversion(promotion or implicit conversion)}. Compiler will first match function name and number of arguments, then look for template deducted function, then use implicit conversion to try match. So implicit conversion happens after template.
		
		\item If the compiler finds a suitable function definition, it checks whether the calling code has access to that function based on the function's access control level. If the calling code can't access it (maybe private member function), compiler reports an error.
		
	\end{enumerate}
	

\subsubsection{Name searching scope}
	
	There are four examples about "immediate scope".
	 
	\begin{enumerate}
		\item Class scope:
\begin{lstlisting}
void f1(int i ){...};
class Foo{
	void f1(string & str){};
	void f2(void){
		f1(3); //compiler bark here! it only see f1(string &) in immediate scope
	}
};
\end{lstlisting}
		
		\item Derived class scope. \texttt{g} in line 11 reports error. If compiler found name \texttt{g} in \texttt{Derived} class, it will stop looking for another name in outward scope (\texttt{Base} class). Because argument number is not match, compiler barks.
\begin{lstlisting}
struct Base{
	int f( int );
	int g( int );
};
		
struct Derived : public Base{
private:
	int g( std::string, bool );
};
Derived d;
d.g(3); //error: 
d.f(3); // ok, no f in Derived class, then look for outward and find B::f(int)
\end{lstlisting}

		
\item Nested namespace scope (global includes namespace N).
\begin{lstlisting}
void f1(int i ){...};

namespace N{
	void f1(string & str){};
	void f2(void){
		f1(3); //compiler will bark here! Use ::f1(i)to specify global one
	}
};
\end{lstlisting}

		\item Nested scope. A class name or enumeration name can be hidden by an explicit declaration of that same name -- as an object, function, or enumerator -- in a nested declarative region \{\}.
\begin{lstlisting}[numbers=none]
int x =2;
{
	int x = 3; 
	cout<<x; //output 3
}
\end{lstlisting}
		
	\end{enumerate}
	
	
	\par How to expand searching scope?  You can use "using declaration" to introduce name into the immediate scope. For example, You can use :: to specify global variable name or function if you have same name in you local scope.  Or use \texttt{Base::} to specify Base scope name if you have same name in derived class.
\begin{lstlisting}
struct Base{
	int g( int );
};

struct Derived : public Base{ 
	using Base::g;  //method 1: using declaration, can overload later
private:
	int g( std::string, bool );
};
Derived d; 
d.g(3) // correct
d.Base::g(3);       // method 2: use scope specifier 
\end{lstlisting}
		

	\par Overloading only occurs within the same name scope and not in the hierarchy. Therefore, any same-named function in the base class will not be visible in the derived class. You can use a using declaration to add the function to the derived class, and then it will compile. However, it's recommended that you don't redefine or overload any non-virtual functions from the base class in your derived class.


\subsubsection{ADL}
	 For a class X, all functions, including non member functions, that both "mention" X and "supplied with" X are logically part of X, because they form part of the interface of X. Supplied with X means that function is defined in the same .h file with type X. Keep a type and its nonmember function interface in the same namespace, 1) in logic, these nonmember function can be regarded as type interface, 2) avoid name ambiguous problem in the future.
\begin{lstlisting}[numbers=none]
namespace N{
	class X {};
	X operator+( const int& i, const X& ); //have to be non member function
}

x3 = 333+x2;	
\end{lstlisting}	
	
	\par On the contrary, put types and functions in separate namespaces unless they're specifically intended to work together.
	
\begin{lstlisting}[numbers=none]
#include <vector>
namespace N {
	struct X {};
}

template<typename T> // this template should not be put in the namespace N
int* operator+( T , unsigned ) {/* do something */}	
\end{lstlisting}	
		
	\par Koenig, also called Argument-Dependent Lookup (ADL) lookup. If you supply a function argument of class type \texttt{NS::T} in line 8, when the compiler looks up the correct function name, it wil consider matching names in the namespace (here \texttt{NS}) containing the argument's type.
	
\begin{lstlisting}[]
namespace NS{
	class T { };
	void f(T);
}
	
NS::T parm;
int main() {
	f(parm); // OK, Found NS::f in line 2 by ADL, then calls NS::f
}
\end{lstlisting}

	\par Compiler applies ADL whenever it's doing name lookup (building a candidate set) for an unqualified function call. If the name of the thing-being-called has any :: qualification, then ADL won't kick in because you have specified lookup scope by using \texttt{::} manually. If the thing is not "a function call," then ADL won't kick in. (Of course, we don't try to apply Argument-Dependent Lookup to names that don't have arguments.) 

\begin{lstlisting}[numbers=none]
namespace A {
	struct A { operator int(); };
	void f(A);
}
namespace B {
	void f(int);
}

A::A a;
f(a);     // with ADL, calls A::f(A)
B::f(a);  // calls B::f(int), ADL will not be applied here.  
\end{lstlisting}
	
	\par Another typical usage of ADL is for resolving \texttt{operator<<} problem. The stream insertion \texttt{operator <<} and stream extraction \texttt{operator >>} are often overloaded as non-member functions, even though they access the private members of the stream classes. This is because these operators are typically used in a chain with other operators, and it can be more convenient to overload them as non-member functions to allow for easier chaining.
	
\begin{lstlisting}[frame=single, language=c++]
namespace Foo { // FooBigNum.h
	struct bignum {
		bignum operator++();
	};
	std::ostream& operator<<(std::ostream&, bignum); 
}

namespace Goo { // GooBigNum.h
	struct bignum {
		bignum operator++();
	};
	std::ostream& operator<<(std::ostream&, bignum);
}

namespace GOO{
	Foo::bignum b;   // refers to Foo::bignum
	++b;             // calls Foo::bignum::operator++()
	std::cout << b;  //ADL use here. If no ADL, compiler fails. 
}
\end{lstlisting}
\begin{description}
	\item[Line 18:] UH-OH! We should call \texttt{operator <<} in line 5 in \texttt{Foo} namespace. If there is not ADL, we call \texttt{operator <<} in ine 12, compiler will stop because we can't change \texttt{Foo::bignum} to \texttt{Goo::bignum}.
\end{description}
	
	\par ADL can bring name lookup ambiguous problem.  When you call \texttt{f(parm)} in line 8, number 2 function \texttt{f} is in global scope, so it is in the \textbf{searching scope} default. But ADL bring number 1 function \texttt{f} (line 8) in namespace \texttt{NS} into searching scope, and there are two same options now, compiler can't decide which one is better then barks here.
	
\begin{lstlisting}[]
namespace NS { // some header T.h
	class T { };
	void f( T ); //  number 1, add new function
}
void f( NS::T ); //number 2	
int main(){
	NS::T parm;
	f(parm); // ambiguous: NS::f  or global f?
}
\end{lstlisting}
		
	\par During name lookup in C++, the language deliberately assigns greater relevance to a member function over a non-member function, when the function is called with a class object or a pointer/reference to a class object. This is because a member function is more closely associated with the class it belongs to than a non-member function.
\begin{lstlisting}[]
namespace NS{
	class X { };
	void f( X );
}
	
class B{   // <-- B is a class, not namespace
	void f( NS::X );
	void g( NS::X parm ){
		f(parm); // call B::f, not ambiguous, event ADL bring f function (line 3) from NS.
	}
};
\end{lstlisting}
	


\section{Expression and operators}

\subsection{Statement and expression}
	
	
	 Statements and expressions are fundamental concepts in the C++ language. These concepts are foundational, practical knowledge and other advanced concepts, such as xvalues and references, build upon them. Therefore, understanding statements and expressions is crucial before delving into more complex topics.
	
	\par An expression in C++ is defined as a sequence of \textbf{operators} and their \textbf{operands}, which collectively specify a computation or calculation. Common operators encompass assignments, increments, arithmetic operations, logical operations, comparisons, member accesses, and more.
	
	
\begin{lstlisting}[numbers=none]
a=b, a+=b /*assignment*/ ++a, a++  /*increment*/    a+b, a&b    /*arithmetic */      
a&&b, !a  /*logical*/    a<b, a!=b /*comparision*/  a[b], a->b  /*member access*/
\end{lstlisting}	
	
	\par Statements are fragments of the C++ program that are executed in sequence. Statements which ends with semicolon are executed. C++ mainly includes the following types of statements: expression statements, compound statements, selection statements(\texttt{if, switch}), iteration statements(\texttt{while, for}) and jump statements(\texttt{break,continue, return, goto}). Most statements are expression statements.
	
\begin{lstlisting}[numbers=none]
int n = 1;               // declaration statement
n = n + 1;               // expression statement
return 0;               // jump statement	
\end{lstlisting}	
	
	
	\par Difference between statement and expression.
	\begin{itemize}
		\item Expression: Something which evaluates to a value, such as \texttt{1+2/x}. Please note here, any expression has a value.
		
		\item Statement: A line of code which does something. Example: \texttt{GOTO 100;} and all statements are followed by a semicolon. In C/C++, every syntactic expression can become a statement just by tacking a semicolon along the end. The designers of C/C++ realized that no harm was done if you were allowed to evaluate an expression and throw away the result. 
		
\begin{lstlisting}[]
x+y    //is expression;
x+y;   //is statement, but throw away the result
fun(i) //Function call is a expression, because it can yield a value.
b=c;   //is statement, an action, assign a value to a variable.
a=b=c  //b=c is an expression. 	
\end{lstlisting} 					
		
	\end{itemize}
	

\subsection{operator}

	 In order to calculate a expression properly, there are three important concepts: 1)precedence of operator; 2) associativity of operator; and 3) order of evaluation. 


	\par The first four precedence group of C++ operators. \\ 
\begin{tabular}{| c | p{0.1\textwidth} | p{0.7\textwidth} |}
	\hline
	Precedence & Operator & Description  \\
	\hline
	\textbf{group 1} & \texttt{::} & scope resolution  \\
	\hline
	\textbf{group 2} &  \specialcell[t]{ \texttt{a++}, \texttt{a--} \\ \texttt{a()} \\ \texttt{a[]} \\ \texttt{.} \\ \texttt{->} }  & postfix increment, function call, subscript, member access  \\
	\hline
	\textbf{group 3} & \specialcell[t]{ \texttt{++a}, \texttt{--a} \\ \texttt{!} \\ \texttt{*} \\ \texttt{\&} \\ \texttt{new} }  & perfix increment, logic, dereference, address-of. Most group operator has left-to-right associativity, but his group operator has right-to-left associativity. Please note this point. \\
	\hline
	\textbf{group 4} & \specialcell[t]{ \texttt{.*} \\ \texttt{->*} } & pointer-to-member  \\
	\hline
	\textbf{group 5 to 17} & various operators  & https://en.cppreference.com/w/cpp/language/operator\_precedence  \\
	\hline
\end{tabular}

	\par pointer-to-member isn't use very often, so I would like to give an example below. 
\begin{lstlisting}
struct S{
	S(int n) : mi(n) {}
	mutable int mi;
	int f(int n) { return mi + n; }
};

struct D : public S{
	D(int n) : S(n) {}
};

int S::* pmi = &S::mi;
int (S::* pf)(int) = &S::f;

const S s(7);
std::cout << s.*pmi << '\n';

D d(7); // base pointers work with derived object
D* pd = &d;
std::cout << (d.*pf)(7) << ' ' << (pd->*pf)(8) << '\n';	
\end{lstlisting}
	
	\par Associativity: In programming languages, the associativity (or fixity) of an operator is a property that determines how operators of the same precedence are grouped in the absence of parentheses. Associativity is only needed when the operators in an expression have the same precedence. Usually + and - have the same precedence. Consider the expression 7 - 4 + 2. The result could be either (7 - 4) + 2 = 5 or 7 - (4 + 2) = 1. The former result corresponds to the case when + and - are left-associative, the latter to when + and - are right-associative. In C++, both + and - are left to right associativity, so 7 - 4 + 2 should equal 5. The following examples demonstrate different associativity. 
\begin{lstlisting}
int a, b = 1, c = 2
a+b+c //+ is left to right associativity,  equivalent (a+b)+c
a=b=c //= is right to left associativity,  equivalent a=(b=c)
a<b<c; //ERROR code, 
a<b && b<c //correct code, but has short circuit effect. 
\end{lstlisting}

\begin{description}
	\item[Line 3:] Line 3 involves the associativity of the equals sign. In C++ language, the equals sign (=) is right-associative, which means that when there are multiple assignments in a single expression, the rightmost assignment is performed first. For example, in the expression "\texttt{a = b = c}", The value of \texttt{c} is assigned to \texttt{b} first, and then the value of \texttt{b} (which is now \texttt{c}) is assigned to \texttt{a}. This is because the equals sign has right-to-left associativity, meaning that the right-hand side is evaluated before the left-hand side.
	
	\item[Line 4:] logical operator's associativity is \textbf{left-to-right}. it means that:
	\begin{enumerate}
		\item \texttt{a<b} will be calculated first and \texttt{a<b} yields a bool value: \texttt{temp\_bool}. 
		
		\item Then we calculate if \texttt{temp\_bool<c}. The code can be compiled successfully, but the semantic is wrong and is not what you expect.  
	\end{enumerate}
	  
\end{description}

    \par Most of operators are left-to-right associativity, there are major two groups of operators which are right-to-left associativity.
    \begin{enumerate}
    	\item Precedence group 3 in the above table. 
    	\begin{center}
    		\begin{tabular}{|c|c|c|c|c|c|c|c|}
    			\tophline
    			Prefix increment & \texttt{++} & Prefix decrement & \texttt{--} & bit complement & \texttt{\~{}} & logic not & \texttt{!} \\
    			
    			\tophline
    			
    			address & \texttt{\&} & indirection & \texttt{*} & unary negation & \texttt{-} & Unary plus & \texttt{+}
    			\bottomhline
    		\end{tabular} 
    	\end{center}
    	\item Another group operators are assignment(\texttt{=}) and various combined assignment(\texttt{+=}, \texttt{-=},..) operators, they have low precedence (group 16).
    \end{enumerate}


	\par Prefer Prefix increment (\texttt{++i}) in a for loop. When you use \texttt{++i} or \texttt{i++} inside expression, there are differences. Prefix and postfix are both syntax sugar, in order to reduce typing. But prefix represents \textbf{one statement}, postfix means \textbf{two statements}.
	
\begin{lstlisting}[numbers=none]
for(int i = 0;i<10; ++i)
j=++i; // one statement: j = i+1;
j=i++; // two statement: 1)j = i;  2)i=i+1;
\end{lstlisting}
	
	\par How to understand \texttt{*p++} ? Precedence of postfix \texttt{++} is higher than both \texttt{*} and prefix \texttt{++}. Associativity of postfix \texttt{++} is left to right.
\begin{lstlisting}[frame=single, language=c++]
++*p; //++(*p) ; prefix ++ and * has same precedence,  both right to left
*p++; // 1) it means *(p++);  2) *(p++) equal *p ; p=p+1;
      //Why post increment has higher Precedence? if it has same precedence with *
      //The code will be translated into the (*p)++, That is not what we want.
\end{lstlisting}		

	\par \texttt{*p++} is used often for reducing typing. You need to understand it, although I don't encourage you to write this style of code. 
\begin{lstlisting}
while(*p != '\0'){
	p= p+1;
}
//can be written to below code
while(*p++ != '\0')	 
\end{lstlisting}

	\par In C++, the order of evaluation of expressions is not always defined. This means that the compiler can choose to evaluate expressions in any order that it deems appropriate, as long as the overall behavior of the program is consistent with the C++ standard. However, there are some rules that govern the order of evaluation in certain cases. For example, in a function call, the arguments are evaluated from left to right before the function is called. Similarly, the order of evaluation of the operands in a binary operator is usually left to right, with a few exceptions such as the logical AND (\&\&) and logical OR (||) operators, which perform short-circuit evaluation. It's important to note that relying on a specific order of evaluation can lead to bugs and is generally considered bad programming practice. It's better to write code that is explicitly clear and does not depend on a specific order of evaluation.
	

\chapter{I/O}

\section{Stream conception}

	 In C++, a stream is an abstraction that represents a sequence of bytes. This sequence can be read from or written to various sources, such as the console, files, or memory buffers. The stream abstraction provides a uniform way to handle different sources. There are three main I/O stream in C++: standard stream (\texttt{cin, cout}), file stream (\texttt{fstream}) and string stream (\texttt{stringstream}).
	
	\par Neither C++ nor C has built input and output in the language. They use functions (C) or other I/O objects (C++) in language library. C++ I/O class and header file is illustrated below: 
	\begin{center}
		\includegraphics[scale=0.5]{pics/io.png}
	\end{center}
	
	\begin{itemize}
		
		\item Acronym \textbf{iofs} stands for three header files <iostream> <fstream> and <sstream>. <iostream> includes <ios> automatically. They are three main header file you should includes in your C++ application. The main components in C++ I/O are three I/O classes and their corresponding buffer classes: \texttt{iostream (streambuf)}, \texttt{fstream (filebuf)}, \texttt{stringstream (stringbuf)} and four pre-defined object: \texttt{cin, cout, clog} and \texttt{cerr}. \texttt{clog} is just like \texttt{cerr}, but \texttt{cerr} is unbuffered, meaning that the output is immediately sent to the output device. 
		
		\item C++ normally flushes the input buffer when you press enter. For output to the display, C++ program normally flushes the output buffer when you transmit a newline character, or reaches an input statement. \verb=>>= and \verb=<<= don't need to format string,  C++ will automatically convert it, it's better than \texttt{printf()} and \texttt{scanf()} in C language.
		
		\item Through inheritance, \texttt{fstream} and \texttt{cin(cout)} has the same API interface. \textbf{All the knowledge of \texttt{cin} can be used directly for \texttt{fstream} and \texttt{stringstream}.} I like this feature the most.
	\end{itemize}
	
	\par \texttt{peek()} returns the next character from the input stream without extracting it. For example, if you want to read input up to the first newline or period, using \texttt{peek} allows you to check for these characters without actually reading them into the \texttt{input} array.
\begin{lstlisting}[numbers=none]
char input[80];
int i = 0;
char ch;
while( (ch=cin.peek()) != '.' && ch != '\n'){
	cin.get(input[i++]); //Note prefix ++ usage here. 
}
input[i] = '\0'; //The result input doesn't include '.' or '\n';	
\end{lstlisting}	
	
	\par The \texttt{gcount()} method returns the number of characters read by the last unformatted extraction method. This includes characters read by \texttt{get()}, \texttt{getline()}, \texttt{ignore()}, or \texttt{read()}, but not by the extraction operator. The \texttt{putback()} function inserts a character back into the input buffer.
	



\section{Input stream in C++}

%\subsection{Input basic knowledge}

	 For input stream, you need to master: \textbf{One basic idea, Two languages, Three data types.}
	\begin{itemize}
		\item \textbf{One basic idea:} To make \textbf{continuous} input, you need to use \texttt{while(inputMethod)}. Two things can happen in this process:
		\begin{enumerate}
			\item The user wants to end input (e.g., by pressing Ctrl+D or Ctrl+Z) or read to the end of file stream or string stream.
			
			\item Reading fails (e.g.,  when using \texttt{cin>> int}, but inputting the letter 'a').
		\end{enumerate}
		
		In the previous two scenarios, \texttt{inputMethod/inputObject} will return false and exit the \texttt{while} loop. To distinguish between \texttt{EOF} or \texttt{error} inside the while loop, you need to use some flag or status. Alternatively, you can continue the input while loop or skip the input while loop entirely.
		
		\item \textbf{Two languages:} For c and c++, they use the different inputMethods functions or objects to read in different data type. 
		
		\item \textbf{Three data types:} They are: 1) character (white space) 2) number and word (no space in middle), and 3) string (include space in middle).
		
		\begin{tabular}{|p{0.05\textwidth}|p{0.25\textwidth}|p{0.22\textwidth}|p{0.28\textwidth}|}
			\tophline
			& Number and non-white  character word & Character (including white characters) & string(line)\\
			\tophline
			C &\texttt{scanf("\%d \%f \%c \%s",\&i, \&f,\&c);}  & \texttt{int a = getchar();} & \texttt{fgets(char*p, n, stdin)} \\
			\tophline
			C++ & \verb|cin>>i>>f>>c>>w;| & \texttt{cin.get(char \& c);} \newline  \texttt{Ch = cin.get();} & \texttt{cin.get( char *p, n);} \newline \texttt{cin.getline(char *p, n)}; \newline \texttt{getline(cin, string)};
			\bottomhline
		\end{tabular}
		
	\end{itemize}
		
	\par When you use \texttt{scanf()} function to read, you need to specify exact data type.
	\begin{enumerate}
		\item h:  \texttt{short int} or \texttt{short unsigned}. Example: \texttt{\%hd} or \texttt{\%hu}.
		
		\item l:  a \texttt{long int} or \texttt{long unsigned}, or double (for \%f conversions.) Example: \texttt{\%ld, \%lu,} or \texttt{\%lf}.
		
		\item *: Tells \texttt{scanf()} do to the conversion specified, but not store it anywhere. This is what you use if you want \texttt{scanf()} to skip (eat) some data but you don't want to store it anywhere; you don't give \texttt{scanf()} an argument for this conversion. Example: \texttt{\%*d}.
	\end{enumerate}
	
	
	\par \texttt{scanf("\%c" \&c)} will read any character, including white space character. If you want to \texttt{scanf()} skip any white space, you can use space before \texttt{\%c}.
	
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
while(true){
	scanf("%c",&c);
	//scanf(" %c",&c);  //skip any white space
	printf("you input: %d" c);
}
//When you input "a(enter)", output will be:
//you input: 97('a' ascii code)
//you input: 10('enter' ascii code)	
\end{lstlisting}		
	
	\par \verb=cin>>c= will not read (just skip) white characters(tab, space , newline), If you want to read them from input buffer, You should use \texttt{getchar()} or \texttt{cin.get()}; 
\begin{lstlisting}
cin>>c;
cout<<"you input:"<<c<<endl;

//When you input  "    a(enter)" output will be:
//you input: a, then cursor wait here, skip enter and space.	
\end{lstlisting}	

	\par Below methods are used to read one word (no space inside the word).
	
\begin{lstlisting}[frame=single, language=c++]
scanf(%s,char_array) //c, read a word until white character. not read newline
cin>> char_array     //c++, or
cin>> str;           //str is std::string
\end{lstlisting}	

	\par Below methods are used to read one line (may including space in the line).
\begin{lstlisting}[frame=single, language=c++]
gets(char_array)  //c read a line	
fgets(char_array, n , FILE *) //recommend to use this for safety.
	
cin.getline(char * ,int n) // c++ read and discard newline.
cin.get(char * ,int n)     // The first parameter is pointer.
std::getline(istream&  is, string& str)			
\end{lstlisting}	

	
	
	\par If you want the user to input his or her name (including first name and last name) in one line, using \verb=cin>>= or \texttt{scanf()} will terminate the string after it reads the first space. The best way to handle this situation is to use the function to read the whole line, then extract first name and last name separately. 
	
	


\subsection{Main input function in C++}
		
	 Regarding input using \texttt{cin}, please remember the following mnemonic: Three \texttt{get()} functions, two \texttt{getline()} functions, other use \verb=operator >>=. The interface of these functions are illustrated in the below code. Pay attention here: the last \texttt{getline} function is not member function of istream, in fact, it is defined in <string> header file. It's just a helper function to read input into the std::string object directly. 
\begin{lstlisting}[frame=single, language=c++]
int iostream::get();      //three get functions
istream& iostream::get (char& c);
istream& iostream::get (char* s, streamsize n, char delim);

istream& iostream::getline (char* s, streamsize n, char delim ); //two getline
istream& getline (istream&  is, string& str, char delim); //is not istream member	
\end{lstlisting}	

	
	\par Difference between \texttt{cin.get(char)} and \texttt{int = cin.get()}.
\begin{lstlisting}[frame=single, language=c++]
while(cin.get(c)) // use cin.get(char) in reading loop
	
cin.get() != '\n' //use cin.get() return character to test sth.	
cin.get()!= EOF //cin.get() return int to compare with EOF	
\end{lstlisting}		
	\begin{description}
		\item[Line 4:] Use \texttt{int} to compare with EOF, because EOF may not be expressed by char type.
	\end{description}
	
	\par Three confused functions to read line: \texttt{cin.get} and \texttt{cin.getline} do almost the same thing although they have the different name. 
\begin{lstlisting}[numbers=none]
cin.get ( char* s, streamsize n); //don't discard delimiters
cin.get ( char* s, streamsize n, char delim ); // overload with delim

cin.getline (char* s, streamsize n); //you must specify n here. 
cin.getline (char* s, streamsize n, char delim ); //overload version

istream& getline (istream&  is, string& str); //easy to use.
istream& getline (istream&  is, string& str, char delim); //overload version.
\end{lstlisting}
	
	\begin{enumerate}
		
		\item Each group has a overload functions with extra \texttt{char delim}. You can also think the first function is same as \texttt{get(s, count, '$\backslash$n')}, that is, reads at most \texttt{n-1} characters and stores them into character string pointed to by \texttt{s} until '$\backslash$n' is found.
\begin{lstlisting}
std::istringstream input("abc|def|gh");
std::vector<std::array<char, 4> > v;

std::array<char, 4> a;
while(input.getline(&a[0], 4, '|')){
	v.push_back(a);
	a.clear();
}

for (const auto& a : v)
	print("{}", a);
\end{lstlisting}
		
		\item If you don't know the maximum length of each line, you can use \texttt{getline(cin, string)} and don't need to input any length (although you can reserve the length of the string if you want to avoid allocating memory). If you want to read a line into a \texttt{std::string} directly, avoid using \texttt{cin.getline} because it only reads into a character array.
		
		\item \texttt{cin.get()} doesn't discard delimiters from the input stream. However, \texttt{cin.getline()} will read and discard the newline character. This is easy to remember because a \textbf{line} is defined by a newline character.
		
		\item In \texttt{cin.getline(char* s, streamsize n, char delim)}, The failbit flag is set if the function extracts no characters (newline is a character), Or if the delimiting character is not found once (n-1) characters have already been written to \texttt{s}. Note that if the character that follows those (n-1) characters in the input sequence is precisely the delimiting character, it is also extracted and the failbit flag is not set. In \texttt{cin.get(char* s ,  int n)}. The failbit flag is set only if the function extracts no characters. All versions set the value of gcount() to the number of characters extracted. If you are talking about the newline character from a console input, it makes perfectly sense to discard it, so use \texttt{cin.getline()}. Or you don't want to customized flexible reading logic, just read a line from a file, please use \texttt{fin.getline()}.
		
		\item \texttt{cin.get(char* s, n)} is more flexible than \texttt{cin.getline(char* s, n)}. Because when it read to the array is full, it doesn't set failbit. At this time you can use \texttt{gcount()} or \texttt{peek()} to see if next character is newline. It's more customized than \texttt{cin.getline(char* s, n)};
\begin{lstlisting}
//When you input "abc def"
while (cin.getline(line, 100)) {
	cout <<"gcount= "<< cin.gcount() << endl; //output 8, reading '\n'
}

while (cin.get(line, 100)) {
	cout <<"gcount= "<< cin.gcount() << endl; //output 7, leave '\n' in input stream
}
\end{lstlisting}
		
		\item The above rules may look complicated, but if you understand them from a semantic perspective, it will be easier to understand and remember. The \texttt{cin.getline()} function is designed to read a line, so it has specific rules for handling newlines: 1) If it meets newline, it will read it in and discard it. 2) If it doesn't meet newline, it will set failbit flag (fail to read a line!).  On the other hand, \texttt{cin.get(char*p, n)} is simply a version of \texttt{cin.get(char)} that reads multiple characters.
	\end{enumerate}
	
	\par \texttt{cin.read(char* s, std::streamsize count)} function has the same interface with \texttt{cin.get(char* s, std::streamsize count)}, but it doesn't append a null character at \texttt{count-1} position, It's not intend for keyboard input, but for binary format of file or string stream.
\begin{lstlisting}
ifstream is{"test.txt", std::ios::binary | std::ios::ate}; // Note here ios::ate
auto size = is.tellg();	 //this statement can tell you how big the file is.
std::string str(size, '\0'); // construct string to stream size
is.seekg(0);
if (is.read(&str[0], size))
std::cout << str << '\n';
\end{lstlisting}

\begin{lstlisting}
std::string bin = {'\x12', '\x12', '\x12', '\x12'};
std::istringstream raw(bin);
raw.seekg(0);
std::uint32_t n;
if (raw.read(reinterpret_cast<char*>(&n), sizeof n))
std::cout << std::hex << std::showbase << n << '\n'; //output 0x12121212
\end{lstlisting}

	\par For input stream, we can use \texttt{istream\_iterator} work with STL container or algorithms.
\begin{lstlisting}
std::istream_iterator<int> ib{ cin }, ie{}; //ie is end iterator
std::vector<int> v(ib, ie);
for (auto e : v) {
	cout << e << " ";
} //in windows console, Ctrl+z will end input and print out vector.	

ifstream inputFile("aa.txt"); 
list<int> data(istream_iterator<int>{inputFile}, istream_iterator<int>{}); 
//fill in the container directly. 

std::istringstream str("0.11 0.22 0.33 0.44");
std::partial_sum(std::istream_iterator<double>{str},  //use with algorithm
std::istream_iterator<double>{}, std::ostream_iterator<double>{std::cout, ", "});		
\end{lstlisting}


\subsection{Input error}

	 To handle input errors, keep in mind that in C language, the functions typically return either EOF or NULL, whereas In C++, the input stream, such as \texttt{cin} or \texttt{fin}, will generally be converted to \texttt{false} when you use them in the boolean context.
	
	\begin{center}
		\begin{tabular}{|c|c|c|c|}
			\tophline
			& Number, non-white & character, white  & string \\
			\tophline
			C language & \texttt{scanf} return EOF & \texttt{getchar} return EOF & \texttt{fgets} return NULL \\
			\tophline
			C++ language& \texttt{cin} converted to false & \texttt{cin} converted to false & \texttt{cin} converted to false \bottomhline
		\end{tabular}
	\end{center}
	
	\par When you can't continue to read from input stream, you need to know if it's end of file (EOF) or fail. In C language, you can use \texttt{feof()} and \texttt{ferror()} function, in C++, you can use \texttt{cin.eof()}, \texttt{cin.fail()} or \texttt{cin.bad()} three member functions of input stream. \texttt{cin.bad()} means serious system error happens, and input buffer can't be consistent and can't recovery anymore. When \texttt{failbit} or \texttt{badbit} are set, \texttt{cin.fail()} returns true, so you need to judge it by \texttt{bad()} again if this information is important for you. Usually, \texttt{bad()} is not used very often.
	
	\par The \texttt{eofbit} is an interesting topic. When you reach the logical end-of-file position (but have not yet read it), the \texttt{eofbit} will not be set. Instead, it's set by a read function and not by position, in other words, the \texttt{eofbit} is set by the last read EOF position. If you want to avoid reading on end-of-file position, you can use the \texttt{std::istream::peek()} function.  When you read the EOF position, both the \texttt{failbit} and the \texttt{eofbit} are set. So if the \texttt{EOF} is set, the \texttt{failbit} must also be set. If only the \texttt{failbit} is set, it means that an input error has occurred. In either of these two conditions, the \texttt{istream} will be converted to \texttt{false} by the \texttt{operator bool}.
	
	%	\item In http://en.cppreference.com/w/cpp/io/basic\_ios/operator\_bool . You can see eofbit are true and failbit are false, operator bool return true. I don't' know when it will happen. \textbf{ eof() function returns "true" after the program attempts to read past the end of the file.}  But when read action set eofbit, it will set failbit at the sametime, so bool operator will return false because failbit are set.
	
	
	\par You can use \texttt{clear()} and \texttt{setstate()} to set the states. Why? It depends on what the program is trying to accomplish. They provide a means for you to change the state of the input stream. \texttt{setstate()} is different from \texttt{clear()}: \texttt{clear()} clears all the status bits, but \texttt{setstate()} sets specific bits. For end-users, we don't use \texttt{setstate()} very often, we just use \texttt{clear()} more.
	
	\par You can use\texttt{ ios::exceptions()} method to control if exceptions will be thrown, when the \texttt{eofbit}, \texttt{failbit} and \texttt{badbit} is set.
\begin{lstlisting}[frame=single, language=c++]
std::ifstream file;
file.exceptions ( std::ifstream::failbit | std::ifstream::badbit );
try {
	file.open ("test.txt");
}
catch (std::ifstream::failure e) {
	std::cerr << "Exception opening/reading/closing file\n";
}			
\end{lstlisting}
	
	
	\par For \texttt{rdstate()}, it will return all the bit values. You can use the bitwise operator \& to check if a specific bit (such as the \texttt{failbit}) has been set. However, in practice, you can just use \texttt{fail()} directly. Therefore, we don't use this function very often.
\begin{lstlisting}[frame=single, language=c++]
std::ifstream is;
is.open ("test.txt");
if ( (is.rdstate() & std::ifstream::failbit ) != 0 )
std::cerr << "Error opening 'test.txt'\n";	
\end{lstlisting}	
	
	
	\par The \texttt{clear()} function is very important. When \texttt{cin.fail()} returns \texttt{true}, you have to use \texttt{clear()}. Otherwise, all subsequent \texttt{cin} operations will not work. For example, when you input "12345Enter", line 2 \texttt{cin.getline(str, 5)} will only read "1234" characters(4=5-1),and set the \texttt{failbit} to \texttt{true}. If you don't clear the failbit, the \verb=cin>>ch;= in line 6 will not read any character. 
	
\begin{lstlisting}[]
char ch, str[20];
cin.getline(str, 5); 
cout<<"flag1:"<<cin.good()<<endl;    // check good bit, return false
cin.clear();   //without, cin>>ch below will not work at all
cout<<"flag1:"<<cin.good()<<endl;    // check good bit again, return true now
cin>>ch;
cout<<"str:"<<str<< " ch:" <<ch<<endl;
//output is below:
flag1:0 // good()return false
flag2:1 // good()return true after clear().
str:1234 ch:5	
\end{lstlisting}	
	

\subsection{Common input pattern}

	 For continuous reading, it is a \texttt{BAD} idea to test the stream in the loop condition check and then read or write to it inside the body of the loop statement. This is because the act of reading may make the stream bad. It is usually better to do the read as part of the test.
	
\begin{lstlisting}[numbers=none]
while(!cin.fail()){  // that is bad programming style
	cin>>i;  //here may make stream fail(), then i maybe is not valid value
	.....     
}	
\end{lstlisting}	
	
	\par If you just want to input, You don't want to distinguish between end-of-file and fail, you can use below pattern: test and read at the same time. 
	
\begin{lstlisting}[numbers=none]
while(scanf("%d",&i) != 1) //in c language, use these to exit loop!
while((int c = getchar())!=EOF)
while( fgets(line, sizeof(line), fp) != NULL )

while(cin>>input)  //in C++ language, use bool operator to exit loop.
while( cin.get(p, 20) )
while( getline(ifstream, string) )	
\end{lstlisting}	
	
	\par If you want to know if you've reached the end-of-file or if you need to handle errors, you can use the code below. 
	Below code want to read an integer, when user inputs letter, such as "abc enter", it will read all the letters and discard them, and wait for you input integer again. 
\begin{lstlisting}[frame=single, language=c++]
int x;
While(true)  {
	cin>>x;// or getline(ifstream, string);
	if(cin.eof()){   //If it's EOF, you press CTRL+D
		... //take action
	}	
	if(cin.fail()){    //deal with invalide input, such as "abc\n"
		cin.clear();   //Important. clear state and buffer
		while(cin.get()!='\n')  //read "abc\n" and discard them
			continue ;          
		cout<<"Please input integer here"<<endl; //give user a prompt.
		continue; //jump to the line 2, console will pause and wait for user
	}
	...  // user input integer, then begin to work.
}	
\end{lstlisting}	
	
	\par In the previous example, Why do we need to distinguish \texttt{eof()} and \texttt{fail()}? We don't want to end the problem when using input invalid data. When fail happen, maybe there are still invalid character in the input buffer. After clean input the buffer, code can continue to read integer from input buffer. There are three methods to clean invalid character in the buffer.
\begin{lstlisting}[numbers=none]
cin.clear();    //Important. clear state and buffer
while(cin.get()!='\n')     // method 1
	continue ;     

while(!isspace(cin.get())) //method 2
	continue;  

basic_istream& ignore(streamsize _Count=1, int_type _Delim = traits_type::eof());
cin.ignore(5, 'a');
cin.ignore(numeric_limits<streamsize>::max(), '\n');	
\end{lstlisting}	
	
%	\item You can use \texttt{istream\_iterator} instead of a while loop. Details on how to use it can be found in the iterator section of the STL chapter. 
	
	%\begin{lstlisting}[frame=single, language=c++]
	%class A{
		%private:
		%	int x,y;
		%	friend istream& operator>>(istream& in, A&);
		%	friend ostream& operator<<(ostream& in, const A&);
		%};	
	%istream& operator>>(istream& in, A& a){
		%	in>>a.x>>a.y;
		%	return in;
		%}	
	%ostream& operator<<(ostream& out, const A& a){
		%	out<<a.x<< " " <<a.y;
		%	return out;
		%}
	%	
	%vector<A> v;
	%copy(istream_iterator<A>(cin), istream_iterator<A>(), back_inserter(v));
	%copy(v.begin(), v.end(),ostream_iterator<A>(cout, "\n"));
	%\end{lstlisting}
	
	\par In summary, it is better to use a conditional statement to exit the loop. If you need to take specific actions to handle end-of-file or fails, use a \texttt{while(true)} loop. Read in \texttt{while} loop first, and then use \texttt{cin.eof()}, \texttt{cin.fail()}, \texttt{cin.clear()} functions to handle and continue/exit the loop.
	
%	\item How to read csv file. you need to use locale object. 
%\begin{lstlisting}[frame=single, language=c++]	
%struct Trade {
%	long long time;
%	string name;
%	int quantity;
%	int price;
%	friend fstream& operator >> (fstream& in, Trade& t);
%};
%fstream& operator >> (fstream& in, Trade& t) {
%	in >> t.time>> t.name>>t.quantity>>t.price;
%	return in;
%}
%
%struct csv_whitespace : std::ctype<char> {
%	static const mask* make_table() { // make a copy of the "C" locale table
%		static std::vector<mask> v(classic_table(), classic_table() + table_size);
%		v[','] |= space;  // comma will be classified as whitespace
%		return &v[0];
%	}
%	csv_whitespace(std::size_t refs = 0) : ctype(make_table(), false, refs) {}
%};
%
%fstream fin("C://C++//input.csv", ios_base::in);
%fin.imbue(locale(cin.getloc(), new csv_whitespace));
%Trade t;
%while (fin >> t) {
%	cout << t.name << endl;
%	cout << t.time << endl;
%}			
%\end{lstlisting}		
	
\section{Output stream in C++}

\subsection{Output stream}

	 For \texttt{cout}, it can recognize the data type automatically, and it is extensible. You can redefine the \verb=<<= operator so that \texttt{cout} can recognize and output your own data type.
\begin{lstlisting}[frame=single, language=c++]
class Foo{
	....
	//overload operator << should be non-member friend function.
	friend ostream & operator<<(ostream& s,const Foo &r);
}
ostream & operator<<(ostream& s, const Foo &r){
	s<<Foo.a<<Foo.b<<endl;
	return s;
}	
\end{lstlisting}	
	
	\par Only use \texttt{std::endl} if you absolutely need to make sure that some output needs to materialize immediately. Each call to \texttt{std::endl} flushes the output buffer and writes the output immediately. This can lead to serious performance degradation, if done frequently. You can also use \verb=cout<<flush= to force flushing the output buffer.
	
	
\begin{lstlisting}
std::cout << "some text" << std::endl;
std::cout << "more text" << std::endl; //bad

std::cout << "some text\nmore text\n"; //good	 
\end{lstlisting}	
	
	\par  How to print pointer address in C and C++?
\begin{lstlisting}[numbers=none]
printf("%p", (void*) p);  //print pointer in C

char* amount = "dozen";   //print pointer in C++
cout<< amount  ;          //print "dozen" string	
cout<<(void*) amount;     //use (void*) to print the address of pointer.
\end{lstlisting}		
	
	\par Formatting is crucial for output. It's important to be familiar with common manipulators that control output format. These include number base manipulators like \texttt{hex}, \texttt{oct}, and \texttt{dec}, as well as field width manipulators such as \texttt{width}, \texttt{fill}, and \texttt{precision}. The \texttt{setf()} function can be used to set these manipulators. You don't need to remember all the manipulators. When you want to use them, you can go to CPP reference website to look. There is a better solution in C++ 20, that is \texttt{std::format()} and \texttt{std::print()}, I will introduce them in the next section. 
	
\begin{lstlisting}[]
#include <iomanip> //should include this head file.
std::ios_base::fmtflags f( cout.flags() ); //remember current format
cout << "In hex: 0x" // now load up a bunch of formatting modifiers
<< hex << uppercase << setw(8) << setfill('0')<< 42<<endl; 
cout.flags(f); // restore the original format.  
\end{lstlisting}	
	
	
	\par Just like \texttt{cin.read(char* p, size\_t n)}, \texttt{cout.write(char* p, size\_t n)} is mainly used for binary format. It just output \texttt{n} character, it will not stop even meet a null character.

\subsection{Output function in modern C++}

	
	 Two new functions used for output in modern C++ are \texttt{std::print} and \texttt{std::println} in <print> header and \texttt{std::format} function in <format> header. 
\begin{lstlisting}
print/format(string) --> std::string
print/format(format-string, arguments...)--> std::string
format_to(@output, format-string, arguments...)
print(file, format-string, arguments...)	
println(...)  //same as print, each output ends with a new-line.	
\end{lstlisting}	
	

	
	
	
	\par Below picture illustrate the basic usage of format syntax, I also give some examples and explanation following,  for more detail you can goto hackingcpp.com. 
	\begin{center}
		\includegraphics[width=0.9\linewidth]{pics/format.drawio.png}
	\end{center}
	
	\begin{itemize}
		\item  These functions supports placeHoder \{\} and index number. 
\begin{lstlisting}
print("{}, {}, {}\n", 'a', 'b', 'c');    //output: a, b, c
print("{2}, {1}, {0}\n", 'a', 'b', 'c'); //output: c, b, a
print("{0}{1}{0}\n", "XX", "abc");	     //output: XXabcXX 	
\end{lstlisting}			
		
		\item Any character before '<', '\^{}' and '>' is fill character, they must appear with these align character together.  Any character appearing without align character is type indication. 
\begin{lstlisting}
std::print("{:b>6}", 26); //b is fill, output bbbb26
std::print("{:b}", 26); //b is type, output 11010
\end{lstlisting}

	\item Pad and width can be used together or separately.
\begin{lstlisting}
std::print("{:6}", 26); //output 26
std::print("{:06}", 26); //output 000026, with 0b prefix
\end{lstlisting}

	\item what is '\#'? For integral types, when binary, octal, or hexadecimal presentation type is used, the alternate form inserts the prefix (0b, 0, or 0x) into the output value.
\begin{lstlisting}
std::print("{:b}", 26); //b is type, output 11010
std::print("{:#b}", 26); //b is type, output 0b11010
\end{lstlisting}

	\item Dot can be used in float point and \texttt{std::string} and usage of dot in the format string is different.
\begin{lstlisting}
std::string s = "abcde";
std::print("{:.1}\n", s); //output a,  don't forget :

double d = 34.591;
std::print("{:08.3}", d) //output 000034.6, .3 means precision is 3.
\end{lstlisting}

	\item \texttt{std::print} supports different location format with "\texttt{L}". 
\begin{lstlisting}
int i = 10000000;
std::print("{}\n", i);  //10000000 //no location format 

auto s = std::format(std::locale("en_US.UTF-8"), "{:L}", i);
std::print("{}\n", s); //10,000,000	 //US format to output number. 	
\end{lstlisting}

%	\item A little further explanation about width and local. 
%\begin{lstlisting}
%std::print("{:.{p}}\n", s, fmt::arg("p",3)); //embedded {} here!
%\end{lstlisting}
	
	\end{itemize}
	
	    \par An example of \texttt{std::format}. It uses the same format syntax as std::print, but it simply returns a string instead.
\begin{lstlisting}[]
cout<<std::format("Default:\t{} {:g} {:g}\n", 1.5, 1.5, 1e20);
cout<<std::format("Rounding:\t{:f} {:.0f} {:.22f}\n", 1.5, 1.5, 1.3);
cout<<std::format("Padding:\t{:05.2f} {:.2f} {:5.2f}\n", 1.5, 1.5, 1.5);
cout<<std::format("Scientific:\t{:E} {:e}\n", 1.5, 1.5);
cout<<std::format("Hexadecimal:\t{:a} {:A}\n\n", 1.5, 1.3);

Default:        1.5 1.5 1e+20  //below is output
Rounding:       1.500000 2 1.3000000000000000444089
Padding:        01.50 1.50  1.50
Scientific:     1.500000E+00 1.500000e+00
Hexadecimal:    0x1.8p+0 0X1.4CCCCCCCCCCCDP+0	
\end{lstlisting}	

	\par \texttt{std::print} also support print container directly. When I publish this book, only clang support this new feature, also need to use compiler switch: "-std=c++23  --stdlib=libc++".
\begin{lstlisting}
vector v{1, 2, 3};
std::println("{}", v);	//output is [1, 2, 3]
\end{lstlisting}
	
%	\item  The presence of a fill character is signaled by the character following it, which must be one of the alignment options. If the second character of format\_spec is not a valid alignment option, then it is assumed that both the fill character and the alignment option are absent.
%	
%	\item Output the custom type. Any type \texttt{T} can be made formattable/printable by specializing template \texttt{fmt::formatter<T>}. For most of code, you can just copy these boilerplate code and it will works. 
%	\begin{lstlisting}
%		struct person{
%			std::string first_name;
%			std::string last_name;
%			size_t social_id;
%		};
%		
%		// fmt::formatter full template specialization
%		template <>
%		struct fmt::formatter<person>{
%			// Parses the format specifier, if needed (in my case, only return an iterator to the context)
%			constexpr auto parse(format_parse_context& ctx) { return ctx.begin(); }
%			
%			// Actual formatting. The second parameter is the format specifier and the next parameters are the actual values from my custom type
%			template <typename FormatContext>
%			auto format(const person& p, FormatContext& ctx) {
%				return format_to(
%				ctx.out(), 
%				"[{}] {}, {}", p.social_id, p.last_name, p.first_name);
%			}
%		};
%		
%		fmt::print("User: {}\n", person { "Juana", "Azurduy", 23423421 });
%	\end{lstlisting}
	


\section{File stream and string stream}


	 When you have a good understanding of \texttt{cin} and \texttt{cout}, you will find that file operations are also quite simple. You just need to replace \texttt{cin} or \texttt{cout} with the appropriate \texttt{ifstream}, \texttt{ofstream} or \texttt{fstream} object. They share the same interface (API) and usage. That's the one of advantages of OOP.
	
\begin{lstlisting}[numbers=none]
std::fstream ifs("test.txt", ios_base::in| ios_base::binary);
char c = ifs.get();           // use all previous input methods
while(ifs.getline(p, 200)){  //follow all previous input pattern
	...
}
\end{lstlisting}	

	\par \texttt{ifstream} is only reading stream; \texttt{ofsteam} is only writing stream;  \texttt{fstream} is both writing and reading stream. For \texttt{ios\_base::binary} mode, use \texttt{write()} and \texttt{read()} funciton. For writing, pay attention to the difference between \texttt{ios\_base::trunc} and \texttt{ios\_base::app}
	
	\par Random access is used mostly on binary file, because the position can be pinpointed exactly. \texttt{seekg()} moves pointer and use \texttt{seekg()} for input and \texttt{seekp()} for output(\texttt{p} is put, \texttt{g} is get).  \texttt{tellp()} and \texttt{tellg()} functions tell the position of the pointer.
	
	\par You can build a \texttt{stringstream} from a \texttt{string} or convert a \texttt{stringstream} back to a \texttt{string}. The \texttt{stringstream} class is a convenient way to manipulate strings as if they were independent I/O devices. It's often useful for converting between strings and numerical types. Using \texttt{stringstream} is similar to using \texttt{iostream}, making it easy to learn. The \texttt{stringstream} class is used for inserting and extracting data to/from string objects, acting as a stream for the \texttt{string} object. Unlike \texttt{cin} and \texttt{cout}, it doesn't have an input/output channel.
	
\begin{lstlisting}[frame=single, language=c++]
char sentence []="Yan is 41 years old"; //C language method
char str [20];
int i;
sscanf (sentence,"%s %*s %d", str, &i); //use sscanf here. 
sprintf(.....);

stringstream outstr;                //C++ method, change number to text
outstr<<123333.00;                  //use stream operator input number directly
string str = outstr.str()  

string str_number = "123 456 789";  //C++ method, change string to number 
istringstream instr(str_number); 
while(instr>>number)      
	cout<<number<<endl		
\end{lstlisting}	
	
	
	
	\par An example of usage of \texttt{stringstream}, counting the number of words in a string.
\begin{lstlisting}[frame=single, language=c++]
string str = "Simple Questions To Check Your Software Testing Basic Knowledge"; 
stringstream s(str);  
string word; 
int count = 0;
while (s >> word)// here s is just like cin 
	count++;	
\end{lstlisting}	
	
	\par We usually use \texttt{stringstream} and \texttt{std::getline} to finish token task.
\begin{lstlisting}[]
string str1;
getline(cin, str1); //input "yan.x.zhao"
stringstream ss(str1); //build a stringstream,
while (std::getline(ss, str1, '.')) {  //geline support input delim
	cout << str1 << endl; //output yan x zhao
}	
\end{lstlisting}

	\par I/O streams work seamlessly with containers and iterators in the STL, making your code much simpler. You can think of an I/O stream as a type of "container" as well.
	
\begin{center}
	\includegraphics[width=0.95\linewidth]{pics/stream.drawio.png}
\end{center}

	\par Based on prior knowledge, we can implement a code snippet to read CSV files.
\begin{lstlisting}
ifstream file("csv.txt");
std::string line;
while(std::std::getline(file,line)){
	std::vector<std::string> result;
	std::stringstream lineStream(line);
	std::string cell;
	
	while(std::getline(lineStream,cell, ',')){
		result.push_back(cell);
	}
	// if there is a trailing comma with no data after it.
	if (!lineStream && cell.empty()){
		result.push_back("");
	}
	
	//just output, you can add your own logic below:
	for(auto e: result){
		cout<<e<<" ";
	}
}
\end{lstlisting}


\chapter{Initialization}
\section{Basic knowledge}

\subsection{Basic principles and terminology}
	 Always initialize variables before first using them, including non-member objects of built-in types and pointers.
	
	\par There are three terminologies you need to distinguish: 1) initializer list, 2) list(brace) initialization, and 3) member initialization list (mem-init).

	\begin{enumerate}
		\item The member initialization list is used in C++ constructors to initialize all members inside an object. It offers several advantages, as detailed in the 'OOP' chapter. For example, reference-type member variables can only be initialized using the member initialization list. Additionally, it provides higher efficiency because we only call copy constructor of each member. 
		
		\item Brace initialization is a generic initialization syntax that supports uniform initialization, including for class members and aggregates. Additionally, it avoids narrowing conversions and vexing parse problems.
		
		\item Initializer list is \texttt{std::initializer\_list}. It is a  new data type. just like \texttt{std::list}.
	\end{enumerate}

	\par A constructor with one parameter is called a converting constructor in C++. However, since C++11, any constructor that is not declared with the specifier \texttt{explicit} is considered a converting constructor. In another word, whether a constructor is a converting constructor only depends on whether it has the \texttt{explicit} specifier. If there is no \texttt{explicit} specifier, even constructors with zero or more than one parameter are considered converting constructors, including both implicitly-declared and user-defined non-explicit copy constructors and move constructors. This is because the new standard provides a convenient syntax for passing arguments and returning values using braced-init-lists. Consider the following example:
\begin{lstlisting}[numbers=none]
struct Foo{
	Foo() { }           // converting constructor (since C++11)  
	Foo(int) { }        // converting constructor
	Foo(float, int) { } // converting constructor (since C++11)
};

Foo fun(Foo f) {
	return {1.0f, 5}; // CONVERTING two numbers into a Foo object.
}

fun({1.0f, 5});       // CONVERTING two numbers into a Foo object.
\end{lstlisting}	
		
	\par List(brace) initialization (syntax description) is also called uniform initialization (semantic description). In this book, uniform initialization, list initialization or brace initialization are interchangeable. In syntax level, it uses a pair of (\{\}) to enclose initializer values.
	
	\par List initialization is a feature that permits the usage of a consistent syntax to initialize variables and objects ranging from primitive types to aggregates. Although the syntax is uniform, it carries out different actions depending on the type being initialized. For instance, it may perform value initialization or call a converting constructor.
	 	
	\par The type of initialization is not determined by its syntax, but rather by the type of the variable.
	
\begin{lstlisting}
struct Foo1{
	int x;
	int y;
};
Foo1{1,2}; //perform aggregate initialization, because Foo1 is aggregate type.

struct Foo2{
	int x;
	int y;
	Foo(int x, int y){} //has user defined constructor
}
Foo2{1,2}; //perform direct initialization, because Foo2 is not aggregate type
\end{lstlisting}

	\par The type of initialization is not determined by the type of constructor, but rather by the type of the variable. Default initialization doesn't always use default constructor. Copy initialization doesn't always invoke copy constructor.
\begin{lstlisting}
int i; //default initialization, without default constructor.
int j = i; //copy initialization, without copy constructor.
\end{lstlisting}
	
	\par A good reference page is \verb|https://en.cppreference.com/w/cpp/language/initialization|. Anytime you have a question, you can go there to get the official explanation. 

\subsection{Static initialization and dynamic initialization}
	 In the same translation unit, formally, C++ initializes static and global variables in this order:
	\begin{enumerate}
		\item Static initialization. First zero initialization, then const initialization.
		
		\item Dynamic initialization.
	\end{enumerate}
		
\begin{lstlisting}[numbers=none]
int g0;  //zero initialization
int g1 = 42;    //  constant initialization
extern int f();
int g2 = f();   //  dynamic initialization
\end{lstlisting}

	\par In C++, the dynamic initialization of objects occurs after the static initialization. This order may lead to subtle bugs, especially when there are dependencies between static objects in different translation units. Here’s an example to illustrate such issues:
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
int a = f(); // call f here
int x = 22; // but this line is executed first.
int f() {
	++x;
	return x; 
} //x equals to 23, not 22. because static init is earlier than dynamic.
\end{lstlisting}

	
	\par In C++, the order of initialization for global objects within a single translation unit is well-defined: objects are initialized in the order they are defined. However, the order of initialization of global objects across different translation units is not guaranteed(see Effective C++ Item 47). This may lead to subtle and hard-to-diagnose bugs when one global object depends on another one.
	
\begin{lstlisting}[frame=single, language=c++]
#include "x.h" // File x.cpp
X x;    //x maybe initialize before y or after y.
	
#include "y.h" // File y.cpp
extern X x;
Y y;
Y::Y(){  //this is Y constructor, 
	x.goBowling(); //Here x maybe not be constructed yet.
}
\end{lstlisting}
	
	\par  When dealing with global objects across multiple translation units, you have two main strategies to avoid the pitfalls of uncertain initialization order:
	\begin{enumerate}
		\item Avoid global objects: Prefer local static objects or other design that don't rely on global state.
		
		\item Use the singleton design pattern: Ensure that an object is created when first accessed, thereby controlling the initialization order explicitly.
	
	\begin{lstlisting}[numbers=none]
#include "x.h"  // File x.cpp
X& getX(){
	static X x;   //static X* px = new X();
	return x;     //return *px
}
	
#include "y.h" // File y.cpp
Y y;
Y::Y(){
	getX().goBowling();
}
\end{lstlisting}

	\end{enumerate}


\subsection{Initialization  categories}

\subsubsection{Six kinds of initialization}
	 There are six \textbf{initialization methods} in C++:
	\begin{enumerate}
		\item Default initialization behaves differently depending on the context and the type of the variable being initialized. Pay attention to the following two points:
		\begin{enumerate}
			\item Default Initialization does Not necessarily call the default constructor: If a class type has a default constructor, it will be called. However, for built-in types (like \texttt{int}, \texttt{char}, \texttt{double}, etc.), default initialization does not call any constructor.
			
			\item Default Initialization does Not necessarily set the variable to zero: For built-in types, default initialization results in an indeterminate value if the variable is not explicitly initialized. This can lead to unpredictable behavior if the variable is used before being set to a known value.	
		\end{enumerate}
			
\begin{lstlisting}[numbers=none]
T t;  //default initialization syntax
new T;  
\end{lstlisting}

	
\begin{lstlisting}
struct T1 { int mem; };
struct T2{
	int mem;
	T2() { } 
};
int static s_n; // static non-class, a two-phase initialization: first, zero initialization, then default initialization does nothing. static and default initialization are not exclusive each other, they can be combined. 

int n;          // non-class, the value is indeterminate
std::string s;  // class, calls default constructor, s is "" (empty string)
std::string a[2]; // array, default-initializes the elements, a is {"", ""}
//  const T1 t1;  // error: const class with implicit default constructor
T1 t1;            // class, calls implicit default constructor
const T2 t2;   // const class, calls the user-provided default constructor
               // t2.mem is default-initialized (to indeterminate value)	
\end{lstlisting}



	\item Value initialization syntax and example.
\begin{lstlisting}[numbers=none]
T(); T{};   //value initialization syntax
new T(); new T{};
Class::Class(...): member(), member{} {...} 
// class member initializer lists (value Init)
\end{lstlisting}


\begin{lstlisting}
struct T1{
	int mem1;
	std::string mem2;
}; // implicit default constructor
struct T2{
	int mem1;
	std::string mem2;
	T2(const T2&) { } // user-provided copy constructor, no default ctor
}; //T2 with user-proviced copy constructor
struct T3{
	int mem1;
	std::string mem2;
	T3() { } // user-provided default constructor
};
std::string s{}; // class => default-initialization, the value is ""
int n{};                // scalar => zero-initialization, the value is 0
int* a = new int[10]{}; // array => value-initialization of each element 0

T1 t1{};    // class with implicit default constructor =>
            //t1.mem1 is zero-initialized 0, t1.mem2 is default-initialized ""
//T2 t2{};	// error: class T2 has no default constructor.
T3 t3{};    // class with user-provided default constructor =>
         // t3.mem1 is default-init to indeterminate, t3.mem2 is default-init ""
\end{lstlisting}

		\item Direct initialization syntax and example.
\begin{lstlisting}[numbers=none]
T object(arg, ... );
T(arg1, arg2, ... );
new T(args, ...)
: member(args, ...)   // class member initializer lists
T(other)              // function-style cast
static_cast<T>(other) // explicit static_cast
[arg](){...}          // lambda closure arguments captured by value
\end{lstlisting}


\begin{lstlisting}[numbers=none]
struct Foo {
	int mem;
	explicit Foo(int n) : mem(n) {}
};

Foo f(2);   // f is direct-initialized:
Foo f2 = 2; //error, because constructor is explicit.
\end{lstlisting}

		\item Copy initialization syntax and example. Pay attention here, only one argument on the right side of equal assignment in the copy initialization expression.
\begin{lstlisting}[numbers=none]
T object = other;     // Initialization via assignment
T array[N] = {other}; // In array-initialization, the individual value are copy-init
f(other)                 // Pass-by-value
return other;            // Return-by-value
catch (T object)         // Catch-by-value
throw object;
\end{lstlisting}

\begin{lstlisting}[]
struct Foo {          
	Foo(int) {}
};
Foo foo{3};
Foo foo1 = foo; // copy initialization of Foo 
\end{lstlisting}

		\item Aggregate initialization is used when initializing arrays or simple struct (all-member-public, no user-provided constructor.)
\begin{lstlisting}[numbers=none]
T object = {arg1, arg2, ...}; // If T is an array or a simple struct
T object{arg1, arg2, ...};    // If T is an array or a simple struct
\end{lstlisting}

\begin{lstlisting}[numbers=none]
struct S {
	int x;
	struct Foo {
		int i;
		int j;
		int a[3];
	} b;
};

S s1 = { 1, { 2, 3, {4, 5, 6} } };
S s2 = { 1, 2, 3, 4, 5, 6};   // same, but with brace elision
S s3{1, {2, 3, {4, 5, 6} } }; // using direct-list-initialization syntax
S s4{1, 2, 3, 4, 5, 6};       // brace elision is ok without = after C++ 14.
\end{lstlisting}

		\item Reference initialization. It must has a reference symbol \texttt{\&} in the expression.
\begin{lstlisting}[numbers=none]
T & ref = object ;
T & ref = { arg1, arg2, ... };
T & ref ( object ) ;
T & ref { arg1, arg2, ... } ;
\end{lstlisting}
	\end{enumerate}

	\par Summary of six initialization methods:
\begin{enumerate}
	\item Without parentheses, compiler uses the default initialization.
	
	\item Using empty braces \{\}, compiler initializes the variable with a default value. The compiler uses a user-defined value if one exists, otherwise it sets the value to zero.
	
	\item Using parentheses with a value initializes the variable with the specified value.
	
	\item When passing a variable to a function or returning a variable from a function by value, it's considered as a copy initialization.
	
	\item Aggregate initialization can only be used for aggregate types.
	
	\item Reference initialization is the simplest form of initialization.
\end{enumerate}

	\par After learning about the six forms of initialization, it's important to understand some key differences between them. In the following sections, I'll explain the distinctions between value initialization and default initialization, direct initialization and copy initialization, and traditional copy initialization and list copy initialization.


\subsubsection{Value initialization and default initialization}
 
	 Let's take a look at some examples that demonstrate the difference between value initialization and default initialization.
	\begin{itemize}
		\item Class has no default constructor. 
\begin{lstlisting}[frame=single, language=c++]
struct Foo{ //no or delete default constructor
	Foo() = delete;
	int i;
};
				
Foo foo;     //Error, call to deleted constructor of Foo
Foo foo1{};	 //Error with same reason.
\end{lstlisting}
	
		\item Class has a implicit default constructor.
\begin{lstlisting}[frame=single, language=c++]
struct Foo{ //implicit default constructor
	int i;
};				

Foo foo;     //foo.i is random value
Foo foo1{};	 //foo1.i is zero.		 
\end{lstlisting}

%\begin{description}			
%\item[Line 7:]	 It's a \textbf{default initialization}. Standard says: if T is a non-POD (until C++11) class type, then... otherwise, no initialization is performed: the objects with automatic storage duration (and their subobjects) contain \textbf{indeterminate values}. Because Foo is POD class, so default initialization doesn't nothing, leave indeterminate values.
%
%\item[Line 8:]  It's a \textbf{value initialization}. \texttt{Foo} has a implicitly-defined constructor. Standard says: "if T is a class type with a default constructor that is neither user-provided nor deleted (that is, it may be a class with an implicitly-defined or defaulted default constructor), the object is \textbf{zero-initialized} and then it is default-initialized if it has a non-trivial default constructor;"
%\end{description}

		\item Class has a defaulted default constructor. How to understand \texttt{"= default"} in line 2?. Because class has its own copy constructor, so compiler doesn't produce implicit default constructor. In order to generate one, you should use \texttt{"= default"}.
\begin{lstlisting}[frame=single, language=c++]
struct Foo{ //implicit default constructor
	Foo() = default; 
	Foo(const Foo&){...};
	int i;
};
	
Foo foo;     //foo.i is random value
Foo foo1{};	 //foo1.i is zero.		 
\end{lstlisting}

%\begin{description}			
%	
%	\item[Line 8:] It's a defaulted default constructor.  Standard says: if T is a non-POD (until C++11) class type, the constructors are considered and subjected to overload resolution against the empty argument list. The constructor selected (which is one of the default constructors) is called to provide the initial value for the new object;
%	
%	\item[Line 9:] It's a value init. Standard says: "A class with an implicitly-defined or defaulted default constructor, the object is zero-initialized."
%\end{description}


		\item Class has a user-defined default constructor. If there is a user-defined constructor, the compiler will call that constructor. If the user-defined constructor does not initialize all the member variables, then the uninitialized member variables will have random values. 
\begin{lstlisting}[frame=single, language=c++]
struct Foo{ //implicit default constructor
	Foo();
	int i;
};
Foo::Foo() = default; //like Foo::Foo() {}, it is user defined constructor.
    		
const Foo cfoo; //cfoo.i is random value 
Foo foo;     //foo.i is random value
Foo foo1{};	 //foo1.i is random value.	

Foo* pf = new Foo;   //just like Foo foo; pf->i is random 
Foo* pf1 = new Foo{};  //pf1->i is random, same as Foo* pf2 = new Foo();
\end{lstlisting}

	 \item Value initialization also kick in when you use \texttt{new}. Detail can be found: "Do the parentheses after the type name make a difference with new?"

	\end{itemize}
		
\par Summary:
\begin{itemize}
	\item \texttt{Foo foo()} is not an initialization call at all, it's a function declaration. 
	
	\item If there is no a default constructor, both \texttt{Foo foo;} and \texttt{Foo foo1\{\};} will fail. 
	
	\item If there is an implicitly-defined or defaulted default constructor, \texttt{Foo foo;} and \texttt{Foo foo1\{\};} are different. \texttt{Foo foo1\{\};} perform zero initialization, so member \texttt{i} inside \texttt{Foo} is 0. 
	
	\item If there is an user-defined default constructor, \texttt{Foo foo;} and \texttt{Foo foo1\{\};} both call user-defined default constructor. If it does nothing, then \texttt{i} inside \texttt{Foo} is random.
	
	\item The behavior of value initialization depends on whether you have a user-defined constructor. If you don't provide one, the compiler performs zero initialization. However, if you define a user-defined constructor, the compiler calls your defined constructor directly instead of performing zero initialization. This is because you have higher priority than the compiler in determining how the object should be initialized. Prefer value initialization, as it helps avoid random values when no user-defined constructor is provided.
\end{itemize}


\subsubsection{Copy initialization and direct initialization}

	 It's crucial to distinguish between copy initialization and the use of a copy constructor. When invoking the copy constructor directly, it falls under direct initialization. In contrast, copy initialization involves two stages: first, a temporary object is created, followed by copying this temporary object to initialize the new object. During direct initialization, only one constructor is called, determined by the compiler through overload resolution. 
	
%	These definitions outline the theoretical differences between copy initialization and direct initialization. However, in practice, compiler optimizations may obscure or simplify the intricacies of the initialization process, don't consider compiler optimization when you want to decide if a initialization is copy initialization or not. 
	
\begin{lstlisting}[frame=single, language=c++]
ClassTest ct1("ab"); //direct initialization
ClassTest ct2 = "ab"; //copy initialization
ClassTest ct3 = ct1; //copy initialization, there is = in the expression
ClassTest ct4(ct1); //direct initialization, not copy initialization
ClassTest ct5=ClassTest();//copy initialization, ClassTest has default constructor
\end{lstlisting}
\begin{description}
%	\item[Line 2:] When compiler optimizations are turned on, the behavior of copy initialization may be different than what's described by the theoretical definition. For example, consider the case of initializing an object \texttt{ct2}, if the copy constructor is private, the compiler will stop the compilation. However, if the copy constructor is public, the compiler may optimize the initialization process and call the single-argument constructor directly, bypassing the creation of a temporary object. Even though the single-argument constructor is called directly, this is still considered copy initialization.
	

	\item[Line 4:] The statement is direct initialization, not copy initialization although it invokes copy constructor. Because in theoretical it's only one step, call a constructor by overload. For compiler, maybe line 3 and line 4 take the same action when optimization is on, but they are different initilazation method theoretically. The C++ standard precisely defines different initialization methods according to how variables or objects are initialized syntactically, not on the actions that a compiler may take during compilation. This distinction is crucial for understanding different initialization method.
	
\end{description}

	\par Copy initialization and direct initialization has different behavior in some context: 
	\begin{enumerate}
		\item The first difference lies in \texttt{explicit} specifier. Constructor with \texttt{explicit} only direct initialization.
\begin{lstlisting}[frame=single, language=c++]
struct foo{
	explicit foo(int);
};
foo f0 (42);  // OK
foo f1 = 42;  // not allowed

std::string s = "test";        // OK: constructor is non-explicit
std::string s2 = std::move(s); // this copy-initialization performs a move

//  std::unique_ptr<int> p = new int(1); // error: constructor is explicit
std::unique_ptr<int> p(new int(1));  // OK: direct-initialization
\end{lstlisting}

		\item Direct initialization can be thought of as a function call to an overloaded function, where the constructors of T (including explicit ones) act as functions, and x serves as the argument. Overload resolution is used to find the best matching constructor, and implicit conversions are performed as needed. Direct initialization has access to all available constructors and can perform any implicit conversions required to match the argument types.

\begin{lstlisting}[]
struct A {
	operator int() { return 12;}
};
struct B {          //conversion link is: A-->int-->B 
	B(int) {}
};

A a;
B b1 = a; //Fail, it's copy initialization, but fail. why? In the right side of =, 
          //we need two user-defined conversion, A-->int, then int-->B. Usually,
          //only one user-define conversion is allowed in one expression. 

B b2{a};  //OK, call A::operator int(), then B::B(int), just 
          //one user-defined conversion involved in this statement.
B b3 = {a};  //also OK, like line 12. not copy, but list initialization.
auto b4 = B{a}; //OK, like line 12. not copy initialization, but direct init.
\end{lstlisting}

		
%		\item Copy initialization constructs an implicit conversion sequence: It tries to convert x to an object of type T. (It then may copy over that object into the to-initialized object, so a copy constructor is needed too - but this is not important below) copy initialization can just set up one implicit conversion sequence.
%
%\begin{lstlisting}
%struct B;
%struct A { 
%	operator B() {cout<<"A-o-B,"; return B();}
%};
%struct B { 
%	B() { }
%	B(A const&) { cout <<"A-c-B,"; }
%};
%struct C{
%	operator A() {cout<<"C-o-A,"; return A();}
%};
% 
%A a;
%B b = a;  //OK, print A-o-B
%
%C c;
%B b1(c); //OK, print C-o-A, A-c-B
%B b2 = c; //ERROR
%\end{lstlisting}
%
%\begin{description}
%	\item[Line 14:]  copy initialization will construct a conversion sequence when variable \texttt{a} is not type B or derived from it (which is clearly the case here). So it will look for ways to do the conversion, and will find the following two conversion candidates: 1) \texttt{B(A const\&)} and \texttt{operator B(A\&)}. Because variable \texttt{a} is not \texttt{const}, so operator version wins. 
%	
%	\item[Line 17:] Direct initialization behaves like a function call. it will do any implicit conversion it needs to match up argument types.
%	
%	\item[Line 18:] copy initialization can just set up one implicit conversion sequence. Although there is two steps conversion: C-->A-->B, but there is not one step conversion C-->B. So copy initialization fail here.
%\end{description}
	\end{enumerate}

	\par Summary:
\begin{enumerate}
	\item In one word, whether it's copy initialization or direct initialization doesn't depend on whether it calls the copy constructor. On the syntax level, it checks if there is an equal sign and there is only one argument on the right side of equal sign.
			
	\item For explicit constructor, only direct initialization works. It call constructor directly and do any implicit conversion it needs to match up argument types.
	
	\item For a successful copy initialization, 1) make sure copy constructor accessible (not private) 2) on the right side of =, just one implicit conversion is allowed.

    \item Usually, we don't make copy constructor \texttt{explicit} for class \texttt{Foo}, because it will disable function call with \texttt{Foo} parameter and return \texttt{Foo} object from a function. \textbf{We only make one parameter constructor explicit}.
\end{enumerate}

		
%    \par A good link is \verb|https://www.cnblogs.com/pluse/p/7088880.html|. A good article is "Is there a difference between copy initialization and direct initialization?"


%\subsubsection{explicit}
%\begin{itemize}
	%\item When copy constructor is explicit. I never see any source code with explicit copy ctor, so just for studying purpose. 
%\begin{lstlisting}[frame=single, language=c++]
%class A{
%public:
	%A(int a = 0);
	%explicit A(const A &a){} //EXPLICIT copy constructor
%};
	
%void funcX(A a) {
	%//ERROR, take A by value (implicit copying)
%}
%A funcY(){ 
	%A a;
	%return a; //ERROR, returning A by value(implicit copying)
%}
%A a1 = a; //ERROR, implicit copying of A not allowed
%A a1(a); //OK - EXPLICIT copying allowed
%A a = 1;
%\end{lstlisting}
	%\begin{description}
		%\item[Line 4:] \textbf{Usually, we don't make copy constructor explicit, because it will disable function call and return value.}
		
		%\item[Line 14 and 15:] Difference between \texttt{A a(a1)} and \texttt{A a = a1}.  They are almost same. But When copy constructor is explicit,  \texttt{A a1 = a} will not work, but \texttt{A a1(a)} work.
		
		%\item[Line 16:] \textbf{With explicit copy constructor, A a = 1 still work.But when the copy ctor is private, A a = 1 fail }.Although we don't call copy ctor directly, but we need to make sure it accessible. We don't consider copy ctor's explicit in this case.
	%\end{description}
	
	%\item When parameterized constructor and copy ctor are both explicit.
%\begin{lstlisting}[frame=single, language=c++]
%class A{
%public:
	%explicit A(int k):m_a(k){};
	%explicit A(const A& rhs){m_a = rhs.m_a;};
	%int m_a;
%};
	
%A a=110;// ERROR
%A a(110) //this will work here.
%A a1 = a; // ERROR, because copy constructor is explicit.
%\end{lstlisting}
	%\begin{description}
		%\item[Line 8:] it's copy list init, It will call constructor directly, because \texttt{A(int k)} is explicit, so it fails.
		%\item[Line 9:] Work, satisfy explicit requirement
		%\item[Line 10:] it's copy list init, It will call constructor directly, because \texttt{A(const A\& rhs)} is explicit, so it fails.
	%\end{description}
	
	%\item  When single parameter constructor is explicit. That is the production level source code. 
%\begin{lstlisting}
%class A{
%public:
	%explicit A(int k):m_a(k){};
	%A(const A& rhs){m_a = rhs.m_a;};
	%int m_a;
%};
	
%A a = 1; // fail. 
%A a = {1}  //fail
%A a = A{1}  //work
%A a = A(1)  //work
%\end{lstlisting}
	%\begin{description}
		%\item[Line 3 and 4:] Most of time, Single parameter constructor is explicit, copy ctor is not.
		
		%\item[Line 7 and 8:] With explicit A(int i) constructor, A a = 1 will fail, but A a = A{1} will work.
	%\end{description}


%\item \textbf{Summary:}
%\begin{enumerate}
	%\item The first step is to see the right side of =, if converting constructor is explicit, we have to use A\{1\} to explicit call it. For example: \texttt{A a = A\{1\}} will work. \texttt{A a = 1} will not work. 
	
	%\item The second step is to see when you use brace init. if it has initlizer\_list constructor, it has strong preference. we will talk about it later.
	
	%\item The third step is to see if copy constructor is explicit. if yes, A a = A\{1\} will fail, but A a = \{1\} work.
	
	%\item \textbf{explicit copy constructor only disable A a1=a; but not disable A a1=1; But private copy ctor will disable both.}
	
%\end{enumerate}

%\begin{figure}[h]
	%\centering
	%\includegraphics[width=0.8\linewidth]{pics/copy_init.png}
	%\caption{}
	%\label{Explicit and init }
%\end{figure}

%\begin{tabular}{|p{0.27\textwidth}|p{0.6\textwidth}|}
	%\tophline
	%Expression & meaning \\
	%\tophline
	%A a = (i), A a=\{i\} & explicit converting constructor will not work \\
	%\tophline
	%A a = A(i), A a = A\{i\} & explicit copy constructor will not work 
	%\bottomhline
%\end{tabular}


%%\item Last summary about previous three sections.
%%\begin{figure}[h]
%%	\centering
%%	\includegraphics[width=0.9\linewidth]{pics/copy_list.png}
%%	\caption{difference between direct, copy and list-copy init}
%%	\label{fig:copylist}
%%\end{figure}

%\end{itemize}

\subsubsection{Aggregate initialization}

	

%    \item You can use brace elision in aggregate initialization, which makes the syntax a bit simpler.
%\begin{lstlisting}
%struct A{
%	int foo;
%	double bar;
%};
%struct Aarray{
%	A data[2];  //data is an internal array
%};
%int main() {
%	array<int, 5> a{1,2,3,4,5}; // no =, no nested aggregated.
%	
%	Aarray a1{ { {0, 0,1},{2, 3.4} } } // OK, must has a extra {} here,
%	Aarray a1 { //this is start of list initialization
%		{  //<--this tells the compiler that initialization of `data` starts
%			{ //<-- initialization of `data[0]` starts
%				0, 0.1
%			}, //<-- initialization of `data[0]` ends
%			
%			{2, 3.4}  //initialization of data[1] starts and ends, as above
%		} //<--this tells the compiler that initialization of `data` ends
%	};
%	Aarray a2{ {0, 0.1}, {2, 3.4} }; //error, this is too many initializers error
%	Aarray a3 = {0, 0.1, 2, 3.4}; //you can use brace elision
%	Aarray a4{0, 0.1, 2, 3.4}; //After c++ 14, you don't need =
%}	
%\end{lstlisting}
%\begin{description}
%	\item[Line 11:] If you don't want to use brace elision, you have to tell where the initialization begin by adding extra \{\}.
%\end{description}

 \texttt{std::array} doesn't have any constructors, so it is an aggregate type. 
\begin{lstlisting}
template<typename T, std::size_t N>
struct array {
	T __array_impl[N];
};
\end{lstlisting}
 
 \par In below code, both \texttt{S1} and \texttt{S2} are aggregates, which means we can use brace elision feature when we initialize \texttt{S1} and \texttt{S2}.  Whether you use braces with or without an equal sign, the semantics are the same. However, if an element in the aggregate list is not an aggregate type, you cannot use brace elision. For example, \texttt{S3} is not an aggregate, so you can't use brace elision feature here. When you can't use brace elision, you must use correct nested braces for aggregate initialization, An example can be seen in the below code. 

%		\item  Inside array, it's just another C type array,(\texttt{int a[3]}), so when you use aggregate initialization without brace elision, you have to add extra \{\} to specify it's the boundary of \texttt{int a[3]}. The basic idea is the same as previous code \texttt{struct Aarray}.

\begin{lstlisting}
struct S1 {  //S1 is an aggregate type
	S1() = default;
	int x;
	int y;
};
struct S2 { //S2 is also an aggregate type
	S2() = delete;
	int x;
	int y;
};
struct S3 { //S3 is NOT an aggregate type
	S3(int x1, int y1) {x = x1; y = y1;}
	int x;
	int y;
};
//We use use brace elision feature here, there is no {} inside {}.
std::array<S1, 3> a11{1, 2, 3, 4, 5, 6}; //or std::array<S1, 3> a12={1, 2, 3, 4, 5, 6};

//std::array<S3, 3> a31{1, 2, 3, 4, 5, 6}; compile fail here, can't use brace elision.
std::array<S3, 3> a31{{{1, 2}, {3, 4}, {5, 6}}}; //must use correct nested brace. 
std::array<S3, 3> a32 { //this is start of list initialization
	{ //--> the beginning of initialization of __array_impl[N] inside std::array
		{ //this "{" indicate the beginning of initialization of `a31[0]`
			1, 2
		}, //this "}" indicates the end of initialization of `a31[0]`
			
		{3, 4}  //initialization of a31[1] starts and ends, as above
	} //--> the end of initialization of __array_impl[N] inside std::array
};

\end{lstlisting}

\par Regarding aggregate initialization, here are some points to consider:

\begin{itemize}
	\item Starting from C++14, you don't need to use the assignment operator in brace elision.
	
	\item If a member inside the aggregate is also an aggregate, you can simply use brace elision style.
	
	\item If a member inside the aggregate is not an aggregate, or you prefer to use nested braces to specify the delimiter, you must add extra braces for \texttt{std::array} type. For example, consider the \texttt{struct S3} in the previous code.
\end{itemize}

\section{List initialization}

		
	 List (brace) initialization is a new syntactic form that supports three initialization methods. It's important to note that value list initialization can also be considered as a form of value initialization.
	\begin{enumerate}
		\item Value list initialization. It can avoid vexing parsing problem.
\begin{lstlisting}[numbers=none]
T object{};
T{};
new T{}
Class { T member{}; };
: member{}  // Class member initializer lists
\end{lstlisting}

		\item Direct list initialization.
\begin{lstlisting}[numbers=none]
T object{arg, ...};
T {arg, ...};
new T{arg, ...}

Class {  // Class member initializer
	T member{arg, ...}; 
};
		
: member{arg, ...} // Class member initializer lists
\end{lstlisting}

		\item Copy list initialization. It has a equal sign in the statement or used in function parameter and return.
\begin{lstlisting}[numbers=none]
T object = {arg, ...};
object = {arg, ...};
Class { T member = {arg, ...}; }; //Class member default initializer
function({arg, ...}); //Initializes temporary for the function arg
return {arg, ...};  //Initializes temporary for return value
\end{lstlisting}
	\end{enumerate}
		

\par The difference between traditional copy initialization and copy list initialization:

\begin{itemize}
	
	
	  \item Copy list initialization is identical to direct list initialization except in one situation:  constructor has been declared as \texttt{explicit}.
	
\begin{lstlisting}
struct Foo{
	explicit foo(int);
};
Foo f0 {42};    // OK
Foo f1 = {42};  // copy-list-initiliazation, fail here due to explicit
\end{lstlisting}

	\item Copy initialization always considers availability of copy constructors, while copy list initialization doesn't.
\begin{lstlisting}
class B {};
struct A {
	A(B const&) {}
	A(A const&) = delete;
};

B b;
A a1 = {b}; //OK, it doesn't need copy constructor in line 4. 
A a2 = b;   //Error, because it need copy constructor in lin4, but it's delete
\end{lstlisting}

	\item Difference between direct initialization, copy initialization and copy list initialization.
\begin{lstlisting}
A a(b); vs A a = b;   // direct initialization vs. copy initialization
A a(b); vs A a = {b}; // The are the same, only different with "explicit"
A a = b; vs A a = {b};// they are different although look similar
\end{lstlisting}
	

\begin{center}
	\includegraphics[width=0.45\linewidth]{pics/copy_list.png}
\end{center}


\end{itemize}	

%	\item Another important difference is a little subtle, can be demonstrated by below code:
%	\begin{enumerate}
%		\item traditional copy initialization uses notion of user-defined conversion sequences (and, particularly, requires availability of copy constructor, as was mentioned)
%		
%		\item \texttt{T a = \{\}} is like \texttt{T a\{\}}. So list copy initialization just performs overload resolution among applicable constructors, i.e. list initialization can't use operators of conversion to class type
%	\end{enumerate}
%\begin{lstlisting}
%struct Intermediate {};
%struct S{
%	operator Intermediate() { return {}; }
%};
%struct S1{
%	S1(Intermediate) {}
%};
%	
%S s;
%Intermediate im1 = s; // OK, s-->Intermediate by a user-defined conversion(line 3)
%Intermediate im2 = {s}; // ill-formed, just look Intermediate constructor.
%S1 s11 = s; // ill-formed 
%S1 s12 = {s}; // OK
%\end{lstlisting}
%	
%	\begin{description}
%		
%		\item[Line 11:] list copy initialization just performs overload resolution among applicable constructors, i.e. List initialization can't use operators of conversion to class type. Intermediate has not constructor with S as argument.
%		
%		\item[Line 12:] copy initialization can just set up one implicit user-defined conversion sequence. In this case 1) S change to Intermediate by operator, 2) from Intermediate to S1 by constructor.  You can see there are two implicit conversion.
%		
%		\item[Line 13:] list copy initialization use constructors, and it will do any implicit conversion it needs to match up argument types. In this case 1) S change to Intermediate by operator(line 3), 2) call S1's constructor and pass this temporary Intermediate object into(line 6). 
%	\end{description}
	
	\par Copy list initialization also supports multiple arguments, which can be useful in function argument and return contexts. 
\begin{lstlisting}[frame=single, language=c++]
struct A{
	int i;
	explicit A(int a = 0):i(a){cout<<"one";}
	A(int a , int b ):i(a){cout<<"two";}
	A(const A &T){ cout<<"copy constructor";} 
};
		
A too = (1,2); //Fail here, comma is operator, (1,2) became 2, then try to call
               //single parameter constructor (line 3). explicit disables A too = 2;
A too = {1,2}; //Works, call two parameter constructor directly. 
A fun(A); 
fun({1,2}) {return{3,4};}//argument and return by using copy list initialization
\end{lstlisting}	
	
	\par Copy list initialization with single argument is just a direct initialization although they have the different syntax. Copy list initialization with multiple arguments constructor make function call and return easier, illustrated by the previous source code. A good article is "Any difference between copy-list-initialization and traditional copy-initialization?"


\subsection{List initialization advantages}
			 
	
	  Empty braces denote value initialization, which typically initializes types to binary zeros. Pay attention here, we can't use () instead of \{\} because vexing parsing problem. The vexing parsing problem will be introduced in the next section.
\begin{lstlisting}[numbers = none]
int i{}, double d{};     //i becomes 0, d become 0.0, can't use () here         
int *p{};   //initialized to nullptr
char s[12]{}; // all 12 characters are initialized to '\0'
char *p=new char [5]{};  //all five chars are initialized to '\0'		
std::string s{}; // s becomes "" can't use () here  
std::vector<float> v{}; //v becomes an empty vector
\end{lstlisting}

    \par List initialization can avoid narrowing problem.
\begin{lstlisting}[numbers=none]
double val = 7.4;
int i {val}; //error, possible truncation.
\end{lstlisting}

    \par List initialization can help you to define anonymous variables. Creating anonymous variables is useful for passing or returning values without using temporary variables. Anonymous objects are typically treated as rvalues, meaning they do not have an address and can only be passed or returned by value or const reference. If you need to use the object more than once or take its address, you must create a named variable instead of an anonymous one.

\begin{lstlisting}[frame=single, language=c++]
Cents add(const Cents &c1, const Cents &c2){
	return Cents{c1.getCents() + c2.getCents()};
	// return anonymous Cents value
}

cout <<add(Cents{6}, Cents{8}).getCents(); //Cents{6} is temporary variable.
\end{lstlisting}

    \par Using copy list initialization to pass or return values from a function without explicitly specifying the type can be beneficial for future-proofing. If you later rename the class, copy list initialization using braces will continue to work seamlessly. In contrast, copy list initialization using parentheses would necessitate updating the type name.

\begin{lstlisting}
MyClass2 fun (MyClass2 m) 
fun(MyClass2(2011,3.14)); //before C++ 11, fun ( (2011,3.14) ) doesn't work


fun( {2011,3.14} );  //works after C++11, you can skip typename MyClass2
MyClass2 fun ( MyClass2 m ){
	return {2011,3.14};  //better style, skip typename MyClass2 here. 
	//return MyClass2(2011, 3.14); //bad style, not future-proofing.
}

MyClass2 mc2;
mc2 = {2011, 3.14}  // or MyClass2(2011, 3.14)
\end{lstlisting}

    \par List initialization supports a wide range of types with a uniform syntax, including aggregates, class members, and STL containers. Here are a few examples of how to use list initialization for these types:
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
// Before C++11
double *pd= new double [3]; // can't initialize them
rectangle w( origin(), extents() ); //vexing problem happen here. 
vector<int>     v;  //need for loop to initialize it.
for( int i = 1; i <= 4; ++i ) v.push_back(i);

// After C++11 (note: "=" is mostly optional)
double *pd= new double [3] {0.5, 1.2, 12.99};
rectangle     w   = { origin(), extents() }; 
vector<int>   v   = { 1, 2, 3, 4 };
std::map<std::string,int> myMap{{"Scott",1976}, {"Dijkstra",1972}};	
\end{lstlisting}

    
    \par The uniform syntax provided by list initialization makes it easier to write generic template functions that can be used with a wide range of types. This isn't just an aesthetic issue; it can also have practical benefits when writing code that needs to be able to initialize any type. For example, when using perfect forwarding, the flexibility of list initialization can be especially useful:
 
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
template<typename T, typename ...Args>
void forwarder( Args&&... args ) {
	T local = { std::forward<Args>(args)... };
	// ...
}
//Below statements work because we use list initialization inside forwarder function. 
forwarder<int>            ( 42 );                  
forwarder<rectangle>      ( origin(), extents() ); 
forwarder<complex<double>>( 2.71828, 3.14159 );    
forwarder<mystruct>       ( 1, 2 );                
forwarder<int[]>          ( 1, 2, 3, 4 );          
forwarder<vector<int>>    ( 1, 2, 3, 4 );  	        
\end{lstlisting}


\par A non-static data member initializer (NSDMI) must use a brace-or-equal-initializer.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
class Foo{
public:
	Foo(): myData{1,2,3,4,5}{} // can initialize directly.
private:
	int myData[5];
	int equals = 42;                      //OK
	std::unique_ptr<Foo> braces{new Foo}; //OK
	std::vector<int> bad(6);  // 6 elements, all value are 0.
	std::vector<int> good{6}; // 1 element, value is 6. 
};
\end{lstlisting}
	

	
	
	%address is \\ \verb=https://greek0.net/cpp/initialization.html=
	
	\par Summary of list initialization advantage:
\begin{itemize}
	\item Provide value initialization automatically.
	\item Avoid narrowing problem.
	\item Avoid vexing problem. 
	\item Input and return temporary variable easier. Using \{\} directly without type name. 
	\item More uniform syntax, for aggregated, class member and STL container. 
\end{itemize}

\par A good reference article is GotW \#1 Solution: Variable Initialization or Is It? Another good one is: Overview of C++ Variable Initialization. 


\subsubsection{Vexing parsing}
\begin{enumerate}
	\item The basic reason behind of vexing parsing comes from C++ standard: \textbf{"If it can be a function declaration, it is".}
	
	\item Using parentheses to group variable names when declaring them is a legal and common practice in C++. This can be especially useful when declaring function pointers or other complex types. For example, to declare a function pointer variable, you must use parentheses to group the variable name of the function pointer. Here are a few examples of how to use parentheses when declaring variables:
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
int f(int);   //a function return a int
int *f(int);  //a function return pointer
int (*f)(int); //a function pointer, you must use () here to group variable name.
\end{lstlisting}
	
	\item It also means that you can have below C++ statements. Although unnecessary, but line 2 and line 4 are all legal statements.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
int x;
int (x); //same as above
int f(int x);
int f(int (x)); //same as above
\end{lstlisting}
	
	\item For function declaration (not function definition), you can omit the parameter name.   
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
int f(int x);
int f(int (x));
int f(int); //three statements are same. 
\end{lstlisting}
	
	\item For object, it becomes a little more interesting.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
int (x); // just like int x;

class A{
	A(int a);
...}
	
int a = 10; 
A(a); //you want to define a temporary object A, but compile think its as A a; It
      //triggers compiler error, redefine a, because a has been defined in line 7.
const A& ar = A(a); //this is OK, 
(A(a)); //If you want a temporary A object, use another parentheses or A{a}  
\end{lstlisting}

	
	\item From the perspective of the compiler, the following three function declarations are all interpreted as the same function:
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
int f(double (*pf)()); //standard way
int f(double pf()); //You can omit parentheses, just like int x and int (x);
int f(double ()); //for function f, you can also omit variable name.
\end{lstlisting}
\begin{description}
    \item[Line 2] Function arguments are adjusted to be a pointer to function arguments. That is only applicable in function parameter context. 
\end{description}

	\item After considering all the previous introductions, you will understand below code. When you try to use a temporary \texttt{Foo} object, but compiler interpret it as function declaration.
\begin{lstlisting}[frame=single, language=c++]
class Foo{
	......
};
	
Foo x(); //x is function declaration, you should use Foo x; or Foo x{};
	
Foo x(Foo());  // x is a function declaration, Foo() is funciton pointer type
Foo x(Foo (i)); //x is a function, Foo(i) equal Foo i; because () can be omitted
//vs.
Foo y{Foo{}};  // y is a variable, build with a temporary Foo object
\end{lstlisting}
\begin{description}
	\item[Line 7:] Declare a function \texttt{x}, receive a function pointer \texttt{Foo ()}, return \texttt{Foo}. Here, We omit the function parameter name, That is to say, \texttt{Foo (*para) ()}  equals \texttt{Foo  ()} in this context.
	
	\item[Line 8:]  Why \texttt{Foo(i)} equal \texttt{Foo i}; but \texttt{Foo()} in line 7 is a function pointer? If \texttt{Foo(int)}, then it will be a function pointer. Function declaration need type name, not a variable name, \texttt{i} here is variable name.	
\end{description}

%	\item Before C++11, you need add another pair parentheses to change it from declaration to expression. After C++11, you can use braces.
%\begin{lstlisting}[frame=single, language=c++, mathescape=true]
%Foo x{Foo{i}}; //x will not be translated into function declaration.   
%Foo x{Foo{}}; //same as before. 
%\end{lstlisting} 

	
	\item The most complex problem. A range container constructor. In line 1, although we want to define a \texttt{list<int>} variable \texttt{data}, but \texttt{data} here is interpreted as a function declaration by compiler. In this function declaration, the first parameter is \texttt{dataFile}, type is \texttt{istream\_iterator<int>}; The second parameter is function pointer. For the first parameter, you can add () around its name; For the second, you can omit parameter name. All these rules have been introduced before. In order to fix this problem, we can use a pair of \{\} to replace (), as illustrated in line 2. 
	
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
list<int> data(istream_iterator<int>(dataFile), istream_iterator<int>()); //error
list<int> data(istream_iterator<int>{dataFile}, istream_iterator<int>{});//OK now
\end{lstlisting}

		
	\item The main reason for the vexing problem is that parentheses can be used to both grouping variable and function pointer declarations, which can create ambiguity when is used to declare a temporary objects. In other words, the vexing problem occurs when using parentheses and an unnamed temporary variable to initialize another variable. To fix this issue, we can use list initialization instead. A good reference is "everything that can be a declaration is a declaration".
	
\end{enumerate}



\section{Initializer\_list and auto}
\subsection{initializer\_list}
	 The problem originated from the way arrays are initialized in the C language, which cannot be used for C++ container objects. In generic programming, a "uniform initializer" is needed to enable consistent syntax for variables and arrays. To achieve this, C++11 introduced the \texttt{std::initializer\_list} template, which acts as a proxy class. We can define a constructor for a vector that takes an \texttt{std::initializer\_list} parameter to enable uniform initialization.
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
int array[] = {1,2,3,4,5}  //OK 
vector<int> vt = {1,2,3,4,5} //doesn't work before C++11 

vector( std::initializer_list<T> init)
vector<int> vt = {1,2,3,4,5} //Work, call previous constructor
\end{lstlisting}
		
	\par STL library container, \texttt{std::list}, \texttt{std::vector} and \texttt{std::map} all support \texttt{std::initializer\_list} constructor. You also can use it in your own class, function or range.
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
void f(const initializer_list<string> &slst){
	....
}
f({ "Good", "morning", "!" });
	
// A braced-init-list can be used in return or function parameter.
vector<int> test_function() { return {1, 2, 3}; }
void TestFunction2(vector<int> v) {}
TestFunction2({1, 2, 3}); // Call a function using a braced-init-list.
	
for (int i : {-1, -2, -3}) {} // Iterate over a braced-init-list.
\end{lstlisting}

	\par  Common usage of \texttt{std::initializer\_list} pattern: 1) \texttt{std::initializer\_list} should be class constructor parameter. 2) It uses braces to initialize. 3) The number of parameter inside braces is flexible but the type should be the same.

\begin{lstlisting}[frame=single, language=c++,mathescape=true]
vector( std::initializer_list<T> init)
vector<int> vt = {1,2,3,4,5} //call the constructor in line 1.
\end{lstlisting}
	
	\par Mostly, list initialization and \texttt{std::initializer\_list} can be used together. For example if you want to initialize a map you can use an \texttt{std::initializer\_list} of list initialization of the \texttt{std::pair}: Here, the type of the pairs is clear and the compiler will deduce, that '\{"Alex", 522\}' in fact means \texttt{std::pair<std::string const, int>\{"Alex", 522\}}.
	
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
std::map<std::string, int> scores{ 
	{"Alex", 522}, {"Pumu", 423}, {"Kitten", 956} 
};
\end{lstlisting}

	\par An empty pair of braces can indicate either value initialization or an empty \texttt{std::initializer\_list}, so it's important to know how to distinguish between the two.
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
class Widget{
	Widget(){cout<<"default";}
	Widget(initializer_list<int>){cout<<"init";}
};
Widget w1; // calls default constructor.
Widget w2{};  //calls default constructor too.
	
Widget w4({});//std::initializer_list constructor with empty list 
Widget w5{{}}; //Same
\end{lstlisting}
	
	\par When non-empty list initialization is used and there are overload \texttt{initializer\_list},
	\textbf{it always match initializer\_list}. Compilers' determination to use \texttt{initializer\_list} constructors is so strong, even there is exact match available. 
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
struct Widget {
	Widget(int i, bool b); // #1
	Widget(int i, double d); // #2
	Widget(std::initializer_list<long double> il); #3
};
	
Widget w1(10, true); //  calls #1
Widget w1{10, true}; // call #3, 10 and true convert to long double
Widget w2(10, 5.0); //  calls #2
Widget w2{10, 5.0}; // call #3, 10 and 5.0 convert to long double
\end{lstlisting}

	\par Semantic difference between usage parentheses or braces in the \texttt{std::vector} class constructor. 
\begin{itemize}
	\item When initializing a vector with a list of values to be stored in the object (such as the elements of a vector), it is recommended to use list initialization. 
	
	\item On the other hand, if the values are used to describe the intended value/state of the object (such as the size argument of a vector), it is recommended to use parentheses. In other words, if the constructor behaves like a normal function call with some additional, parameterized operations, then it's preferred to use parentheses. For instance, the size argument of a vector fall under this category.
	
	\item Frankly speaking, \texttt{std::vector} has a bad design when considering the constructor with \\ \texttt{std::initializer\_list} parameter overload. You should try to avoid this ambiguity when you design your own class, especially be careful with \texttt{std::initializer\_list} parameter. 
\end{itemize}
	
	
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
std::vector<int> v1(10, 20);  //create 10-element vector, all elements 20.
std::vector<int> v2{10, 20};  //create 2-element vector, element are 10 and 20
\end{lstlisting}
		
	

\subsection{Auto initialization(Almost Always Auto)}

	 Three main usages of \texttt{auto}: 1) Use in initialization expression. For example, you can assign lambda to an \texttt{auto} type variable; 2) \texttt{auto} parameter in a lambda. 3) \texttt{auto} return type in a function.  
	 
	    
%		with help of \texttt{auto} parameter and \texttt{auto} type, you can build \textbf{generic lambda}. 

	\par Auto initialization sets the type of a declared variable from its initializing expression at compile-time. It is recommended to use \texttt{auto} when initializing a variable with an expression.
\begin{lstlisting}[numbers=none]
auto a = expr 
auto a = T{expr} //when you want to commit to a certain type

auto s = "Hello";  //s is const char* just like const char* s = "Hello";
auto str = string{"Hello"} // this time is string
auto p = &x  //p is pointer, prefer to use auto* p, because it stresses the intent
auto v = {1, 2, 3}    // v is std::initializer_list type.

auto* p = new vector<pair<int, string> >; //save typing on the left side.
std::vector<std::pair<int, std::string>> array;
auto it = array.begin();    //don't need container iterator type
auto w = make_unique<widget>(); //template class or function
auto l = [](){..};              //for lambda, you have to use auto
\end{lstlisting}
	
	\par About the auto \texttt{type} deduction, please refer to the later chapter "Generic programming". The basic idea is quite simple: take exactly the type on the right-hand side, but strip off top-level \texttt{const/volatile} and reference \&/\&\&. If you want your auto declaration to be \texttt{const}, or if you want your \texttt{auto} declaration to be a reference, you have to add them explicitly.
	
\begin{lstlisting}[frame=single, language=c++]
const auto iter = modmap.find(123); //specify const
auto& mod = vec[17];  //specify &, without &, mod will not be reference type
                      //although vec[17] return reference type
for (const auto& element : myarray) {  //a read only reference.
	//do stuff that reads from element
}
\end{lstlisting}
	
	\par \texttt{auto} can be used in template function return type.
\begin{lstlisting}
template <typename F, typename T>
auto apply(F&& f, T value){ return f(value); }
\end{lstlisting}

	\par Advantages of using \texttt{auto}:
	\begin{itemize}
		\item Avoidance of uninitialized variables. 
\begin{lstlisting}[numbers=none]
auto x2; // error! initializer required
auto x3 = 0; // fine, x's value is well-defined
\end{lstlisting}

		\item Avoidance of verbose variable declarations on the left side of =.
\begin{lstlisting}[frame=single, language=c++]
template<typename It>
void fun(It b, It e) {
	//typename std::iterator_traits<It>::value_type currValue = *b;
	auto currValue = *b; //using auto is much simpler here.
}

auto ii = find_if(people.begin(), people.end(), match_name );               
if (ii != people.end()){...}
\end{lstlisting}

		\item Avoidance of problems related to "type shortcuts". It's very importance here because \texttt{auto} guarantees correct and performance.
\begin{lstlisting}[frame=single, language=c++]
std::vector<int> v;
int sz = v.size(); 
auto sz = v.size(); //v.size() return size_t, not int

std::unordered_map<std::string, int> m;
for (const std::pair<std::string, int>& p : m){//bad style, manual defined type
for (const auto& p : m){  //better style with auto 
\end{lstlisting}

	\item Good maintenance for future modification. 
	
%	First, change id type in line 3 to line 4, if we use \texttt{auto} in line 8, we don't need to change at all. But if we use \texttt{int}, then we need to change from \texttt{int} to \texttt{GUID} too.
%\begin{lstlisting}[frame=single, language=c++, mathescape=true]
%struct record {
%	std::string name;
%	int id;
%	//GUID id; 
%};
%
%//int id =  find_id(const std::vector<record> &people...
%auto id = find_id(const std::vector<record> &people, const std::string &name)
%\end{lstlisting}
	\end{itemize}
	

	\par There are two points need to be noticed. The first one is using \texttt{auto} with \texttt{vector<bool>}, The second is combining \texttt{auto} with list initialization.
	
	
	\par The below code doesn't work because the \texttt{std::vector} template is specialized for \texttt{bool}, optimizing space by storing each boolean value in one bit within a byte. Due to this optimization (where returning a reference to a single bit isn't possible), \texttt{vector<bool>} uses a 'proxy iterator' pattern. A 'proxy iterator' is an iterator that, when dereferenced, doesn't yield an ordinary \texttt{bool \&}, but instead returns a temporary object—a proxy class convertible to \texttt{bool}. The proxy class returned is a prvalue, so we can't use \texttt{auto \&} to refer to it. Instead, you can use \texttt{const \&} or an rvalue reference to refer to it. Both "proxy" class and \texttt{std::ref} share the same design idea.
\begin{lstlisting}[numbers=none]
vector<bool> v = {true, false, false, true};
auto &x = v[1] //error
auto &x = *v.begin() //error 

for (auto&& elem : v) //OK
for (const auto& elem : v) //also OK		
\end{lstlisting}	
	
	
	\par When use \texttt{vector<bool>::operator[]} and \texttt{auto} together, you just created a copy of that reference-like proxy object.
\begin{lstlisting}
vector<bool> v(6, false);
auto x = v[0]; //avoid use auto with vector<bool> 
bool y = v[1];
x = true; //Not correct, v[0] has been changed to true, it's unexpected. 
y = true; //correct, v[1] has NOT been changed. 	
\end{lstlisting}
	
\begin{center}
	\includegraphics[width=0.43\linewidth]{pics/auto2.png}
\end{center}


	\par In below code, prior to C++17 the type for all the following variable (\texttt{a, b, c} and \texttt{d}) is deduced to \texttt{std::initializer\_list<int>}. There is no difference between the direct-list-initialization and the copy-list-initialization on the result of the type deduction. In another word, When you use = and \{\} together, it will deducted as \texttt{std::initializer\_list}, no matter how many parameters are there inside the \{\}. After C++ 17, For copy list initialization auto deduction will deduce a \texttt{std::initializer\_list<T>} if all elements in the list have the same type, or be ill-formed. For direct list initialization auto deduction will deduce a T if the list has a single element. \textbf{In one word, when \texttt{auto} used with = and \{\}, it will deduct \texttt{std::initializer\_list<T>}}.
		
\begin{lstlisting}[numbers=none]
auto a = {42};   // std::initializer_list<int> //Before C++ 17, it's not nature
auto b {42};     // std::initializer_list<int> //direct-list-initialization
auto c = {1, 2}; // std::initializer_list<int>
auto d {1, 2};   // std::initializer_list<int>

auto a = {42};   // std::initializer_list<int>// After C++ 17
auto b {42};     // b is int type
auto c = {1, 2}; // std::initializer_list<int>
auto d {1, 2};   // error, too many 
auto e = { 1, 2.0 }; // error: cannot deduce element type
\end{lstlisting}



\section{Initialization summary}

%\subsection{How to analyze initialization expression}
%\begin{itemize}
%	
%	\item List initialization must be able to handle different kinds of types, such as built-in types, aggregates, and classes with different constructors. This adds complexity to the analysis, and it's important to read the C++ reference carefully to analyze the initialization syntax step by step.
%\begin{lstlisting}
%A a{}; //value initialization
%A a{1};	 // direct initialization or aggregate initialization depends on A type	
%\end{lstlisting}		
%	
%	
%	\item I will provide a real example to demonstrate how to analyze a initialization statement with help of a reference to the C++ standard document for further understanding.
%\begin{lstlisting}
%struct A {
%	A(int i) : i(i) {}
%	A() = default;
%	int i;
%};
%
%A a{};  //a.i is 0, not random value	
%\end{lstlisting}	
%	
%	\begin{description}
%		\item[Line 7:]  The list initialization of \texttt{A}, Why it's list initialization? Because it use \{\}; *1 item satisfied, so perform value initialization. Please note here, *1~*5 item refer to "Excerpts from C++ standard" below. Check *3 item, not satisfied, because we have default constructor. Then it meets all requirements in *4 item, so perform zero-init.
%	\end{description}
%	
%\begin{lstlisting}
%struct A {
%	int i;
%	int j;
%};
%cout<<is_aggregate_v<A><<endl; //output: 1
%A a{1};  //  i = 1, j = 0;	
%\end{lstlisting}	
%	
%	
%	\begin{description}
%		\item[Line 7] List initialization of A, Check *1 item but fail, \texttt{A} has no default constructor. \texttt{A} is aggregated type, according to *2 item, aggregate-initialization kick off. According to *5 item, \texttt{j} is initialized to 0		
%	\end{description}
%	
%	\item  Excerpts from C++ standard: 
%				
%	{\footnotesize \verb|https://en.cppreference.com/w/cpp/language/list_initialization| \newline
%	*1 (\textbf{For list initialization})If the braced-init-list is empty and T is a class type with a default constructor, value-initialization is performed. 
%	\newline
%	*2 Otherwise, if T is an aggregate type, aggregate initialization is performed.
%	
%	
%	\verb|https://en.cppreference.com/w/cpp/language/value_initialization|	\newline
%	*3 if T is a class type with no default constructor or with a user-provided or deleted default constructor, the object is default-initialized; 
%	\newline		
%	*4 if T is a class type with a default constructor that is neither user-provided nor deleted (that is, it may be a class with an implicitly-defined or defaulted default constructor), the object is zero-initialized and then it is default-initialized if it has a non-trivial default constructor; 
%	
%	\verb|https://en.cppreference.com/w/cpp/language/aggregate_initialization|\newline
%	*5 If the number of initializer clauses is less than the number of members and bases (since C++17) or initializer list is completely empty, the remaining members and bases (since C++17) are initialized by their default member initializers,}
%
%
%	
%	\item Based on previous introductions, you can follow below logic to analyze C++ initialization.
%	\begin{center}
%		\includegraphics[width=0.95\linewidth]{pics/init.png}
%	\end{center}
%		
%\end{itemize}

\textbf{Common used forms in initialization and comparison.}


\begin{lstlisting}[frame=single, language=c++,mathescape=true]
widget w;          // (a) default initialization with default constructor.
widget w();        // (b) function declaration, vexing parsing problem.
widget w{};        // (c) default initialization or value initialization

widget w(x);       // (d) (d) and (e) are both direct initialization.
widget w{x};       // (e) both call constructor widget::widget(x) 

widget w = x;      // (f)
widget w = {x};    // (g)

auto w = x;        // (h)
auto w = widget{x};// (i)
\end{lstlisting}	
	
	\begin{itemize}
	
		\item In (d) and (e), The variable \texttt{w} is initialized directly from the value of \texttt{x} by using \texttt{widget::widget(x)}. If x is also of type \texttt{widget}, this invokes the copy constructor. Otherwise, it invokes a converting constructor. (e) is better than (d) to avoid narrowing, for example: \texttt{int a(1.2)} pass, but \texttt{int a{1.2}} fail. For (e), it prefer to use constructor that takes an \texttt{initializer\_list}. Please also note this point here.
		
		\item For (f), when \texttt{x} is type of \texttt{widget}, just like (d). When \texttt{x} is not type of widget, \textbf{conceptually} the compiler first implicitly converts \texttt{x} to a temporary \texttt{widget} object if an implicit conversion is available, then move-constructs \texttt{w} from that temporary rvalue, using copy construction as "the slow way to move" as a backup if no better move constructor is available. Note that I said "conceptually" a few times above. That's because practically compilers are allowed to, and routinely do, optimize away the temporary and, if an implicit conversion is available, convert (f) to (d), thus optimizing away the extra move operation. However, even when the compiler does this, the \texttt{widget} copy constructor must still be accessible, even if is not called, the copy constructor's side effects may or may not happen. \textbf{For (g), This is called “copy list initialization.” It means the same as \texttt{widget w\{x\}};} except that explicit constructors cannot be used. It’s guaranteed that only a single constructor is called. (only converting constructor is called, no copy constructor).
		
		\item (h) \texttt{w} has the same type as \texttt{x}, only single copy constructor of \texttt{x} is called. (i) is the most consistent spelling when you do want to commit to a specific type and explicitly request a conversion if needed, and once again the \{ \} syntax happily avoids lossy narrowing conversions. In practice on most compilers, only a single constructor is called-similarly to what we saw with (f) and (g).
		
%		\item Some initialization examples based on previous introductions.
%		
%\begin{lstlisting}[frame=single, language=c++,mathescape=true]
%class Test{
%public:
%	int i;
%	explicit Test(int a = 0):i(a){}
%	Test(const Test &T){ cout<<"copy constructor";} 
%};
%
%Test too = 2;  //test for (f) 
%Test too = {2} // test for (g)
%
%Test too;  
%auto w = too //test for (h)
%auto w = Test{2} //test for (i), no semantic difference with: Test w{2};	
%\end{lstlisting}		
%		\begin{description}
%			\item[Line 8 and 9:] Both (f) and (g) work and no call copy constructor (no output:"copy ctor"); If converting constructor has explicit both fail, If copy constructor is private, (f) fail, but (g) is still OK. Because \texttt{A a = \{b\};} is just like \texttt{A a(b);}
%			
%			
%			\item[Line 13:] you can use \texttt{auto w = Test(2)}, it just call converting constructor, even converting constructor is explicit, it can work too. No copy constructor is called at all. \texttt{w} is not const reference. List initialization \{\} is better, it more generic and avoid narrow \texttt{auto w = Test\{1.2\}} fail. 
%		\end{description}
		
	\end{itemize}

%	\item A similar example, given below code snippet, the syntax analysis and comparison: 
%	
%\begin{lstlisting}[frame=single, language=c++]
%class A{
%public:
%	A(){};
%	A(int k):m_a(k){};
%	A(const A& rhs){m_a = rhs.m_a;};
%	int m_a;
%};
%void fun(const A &a){}
%int i = 3;	
%\end{lstlisting}		
%	
%
%	The syntax analysis for the default constructor is given below. \\
%	\begin{tabular}{|p{0.23\textwidth}|p{0.68\textwidth}|}
%		\tophline
%		Expression & Syntax analysis \\
%		\tophline
%		\texttt{A a, A a\{\}} & \texttt{a} is object, call default constructor. \\
%		\tophline
%		\texttt{A a()} & \textbf{declare function a,vexing problem happens here.} \\
%		\tophline
%		\texttt{A()} & A temporary A obj or declaration, detail is in vexing problem \\
%		\tophline
%		\texttt{B b(A())} & \textbf{declare function, vexing problem}, A() is function pointer \\
%		\tophline
%		\texttt{B b(A\{\})} & construct \texttt{b} object with temporary A object. \\
%		\tophline
%		\texttt{fun(A()),fun(A\{\})} & pass a temporary \texttt{A} object to \texttt{fun} 
%		\bottomhline
%	\end{tabular}
%	
%	The syntax analysis for the single parameter constructor is given below. 
%	
%	\begin{tabular}{|p{0.23\textwidth}|p{0.68\textwidth}|}
%		\tophline
%		Expression & Syntax analysis \\
%		\tophline
%		\texttt{A a(i), A a\{i\}} & parameterized constructor, direct initialization\\
%		\tophline
%		\texttt{A (i)} & \textbf{just like \texttt{A i}, you have define \texttt{i}, so compiler barks.} \\
%		\tophline
%		\texttt{A\{i\}} & A temporary A obj\\
%		\tophline
%		\texttt{B b(A(i))} & declare a function \texttt{B b(A i)}; vexing problem \\
%		\tophline
%		\texttt{B b(A\{i\})} & build \texttt{b} with temporary \texttt{A} object \\
%		\tophline
%		\texttt{fun(A(i)),fun(A\{i\})} & work, fun(A i) will not a declaration, because there are no return value.\\
%		\tophline
%		\texttt{B b(A a(i))}  & compile error, because \texttt{A a(i)} is not a expression(it doesn't yield a value). Compiler will first interpret it as function declaration first, but \texttt{A a(i)} is not declaration (it defines a variable a), ( \texttt{A(i)} and \texttt{A()} are both type). So it continue to interpret as B constructor, then it ask a value from expression, but \texttt{A a(i)} is not expression either, in the end, compiler is not happy.  \\
%		\tophline
%		\texttt{fun(A a(i))} & Same as above.
%		\bottomhline
%	\end{tabular}
%	
	%	\item Further explanation about previous table. Here we follow the basic C++ parsing rule: \textbf{If there is possible, it will use declaration first. }.
	%\begin{lstlisting}
	%int i = 5;
	%A(i); //redefine variable i, just like A i; compiler error
	%A a = A(i);
	%B b(A(i)); //function delcaration
	%B b(A a(i)); //compile fail
	%\end{lstlisting}	
	%	\begin{description}
	%		\item[Line 3:] \texttt{A(i)} will build temporary \texttt{A}, because there is assignment sign, so \texttt{A(i)} can't be declaration, otherwise it can't be suitable for the context.
	%		
	%		\item[Line 4:] interpret \texttt{A(i)} as declaration, and it suitable for the context.
	%		
	%		\item[Line 5:] For \texttt{B b(A a(i))}, 
	%	\end{description}
	
	
%		 \par A good article about this is "Initialization in C++ is Seriously Bonkers"



\textbf{Key points of this chapter}

	 \par Understanding some basic conceptions, such as aggregate type, copy-list-initilization, converting constructor. All the high level usages are based on these basic conceptions. It's important to be familiar with the six basic initialization methods and know how to distinguish them. For instance, initialization with the equal sign is known as copy initialization.
	
	\par Six initialization methods and list initialization are irrelevant and orthogonal. List initialization syntax can be interpreted as aggregated init, value init, direct initialization or copy initialization and it brings its own advantage.
	
	\par Know the difference between value initialization and default initialization. Know the differences between direct init, copy initialization and list copy initialization.  
%\begin{lstlisting}
%A a(1) or A a{1} //direct initialization
%A a = 1;  //copy initialization
%A a = {1}; //list copy initialization, same as direct initialization	
%\end{lstlisting}	
		 
	\par Know when to use list initialization and it's advantage. Know the basic usage of \texttt{initializer\_list} and the difference between list initialization. Just pay attention when the class has \texttt{list\_initiaizer} constructor, and know the auto \texttt{usage} and its pitfall.
	
	\par There are three levels of initialization knowledge in C++. The first level is the syntax level, which determines whether we use braces or parentheses, an assignment operator, or a function return, among other things. From this level, we can go deeper to another level to determine what kind of initialization methods are available. There are six different methods. Finally, we can reach the semantic level, which depends on the specific data type for the detailed initialization action.
	
	\begin{center}
		\includegraphics[width=0.60\linewidth]{pics/sum_init.png}
	\end{center}
	
	For example, if T is an aggregate type, we use aggregate initialization. If the braced-init-list is empty and T is a class type with a default constructor, we use value-initialization. In other words, '\texttt{A a\{x, y\}}' may be a direct initialization or an aggregate initialization, depending on the data type of \texttt{A}. This is an essential point for you to understand better about initialization in C++.
	
	

\textbf{Initialize suggestions}

		 I don't intend to make this chapter overly complex or confusing, but the intricacies arise from the C++ standard's attempt to introduce uniform list initialization while maintaining compatibility with older standards and existing code. It's akin to making an elephant dance with a heavy chain – no easy task. For developers who aren't compiler developers or language experts, following below simple rules can suffice: \textbf{Use \texttt{auto} when there is an expression, and use \{\} when there isn't.}
		
		
	\begin{enumerate}
		\item If right side is expression, \texttt{new} operator or function, use \textbf{\texttt{auto var = expr;}}.  Pay attention to two pitfalls when use \texttt{auto} with vector<bool> and use \texttt{auto} with \texttt{initializer\_list}
		
		\item Otherwise, Use \textbf{list initialization if possible.}  Use \{\} even in default initialization, maybe it's redundant for some types, but it's good habit and keep your style consistency. For example, use \texttt{String str\{\};} instead of \texttt{String str;}. When using list initialization, pay attention two traps for \texttt{std::initilizaer\_list} when class has overload constructor with \texttt{initializer\_list} argument.
\begin{lstlisting}
foo{1, 2} //Always call constructor with initializer_list(conversion match)
	      //even there is non initializer_list constructor(exact match).
	
vector v(10, 2) and vector v{10, 2}; //Semantic between () and {}.
\end{lstlisting}
%		\begin{enumerate}
%			\item If type has list initialization constructor, list initialization will use it first, and very strongly. 
%			
%			\item Semantic difference between \texttt{vector v(10, 2)} and \texttt{vector v\{10, 2\}}. 
%		\end{enumerate}
		
		\item For a specific scenario, if you intend to initialize a variable \texttt{f1} with the same type another variable \texttt{f2}, use copy initialization. Because in case of they have different type, you'll never accidentally invoke an explicit conversion constructor, which generally interprets the provided value differently.
\begin{lstlisting}
class Foo{
	explicit Foo(int); //explicit here, it's important
	Foo(const Foo& other);
};	
	
Foo f1 = f2; //good style, in case of f2 is int, it will report error here,
Foo f1(f2);  //bad style, if f2 is int, it will call Foo(int) here. 
Foo f1 = {f2};  //good style too, just like line 1 and use { } consistently.
\end{lstlisting}		
		\begin{description}
			\item[Line 6-7:] You think that \texttt{f1} and \texttt{f2} are the same type, but this failure indicates that they have different type. However, line 7 will call explicit single parameter constructor directly and doesn't give you this kind of helpful hint. 
		\end{description}
		
	\end{enumerate}

%\item The idea of the whole chapter can be summaried by one word: \textbf{Use \texttt{auto} when there is an expression, and use \{\} when there isn't.} and two precautions when use \{\} when class has overload constructor with \texttt{initializer\_list} argument.
%
%\begin{lstlisting}
%auto with vector<bool>      // 1) the first pitfalls of auto
%auto with initializer_list  // 2) the second pitfalls of auto
%
%foo{1, 2}    //1) Always call constructor with initializer_list with legal conversion
%             //even there is best match non initializer_list constructor.
%             
%vector v(10, 2) and vector v{10, 2}; // 2) difference between () and {}.
%\end{lstlisting}



\par The whole idea can be illustrated by below graph:
\begin{center}
	\includegraphics[width=1.0\linewidth]{pics/init_trip.drawio.png}
\end{center}


	
	
%		\item Basic rules:
%	\begin{enumerate}
%		\item If the (single) value you are initializing with is intended to be the exact value of the object, use copy (=) initialization (because then in case of error, you'll never accidentally invoke an explicit constructor, which generally interprets the provided value differently). In places where copy initialization is not available, see if brace initialization has the correct semantics, and if so, use that; otherwise use parenthesis initialization (if that is also not available, you're out of luck anyway).
%		
%		\item If the values you are initializing with are a list of values to be stored in the object (like the elements of a vector/array, or real/imaginary part of a complex number), use curly braces initialization if available. 
%		
%		\item If the values you are initializing with are not values to be stored, but describe the intended value/state of the object, use parentheses. In another word, if the constructor resembles a normal function call (it performs some more or less complex operations that are parameterized by the arguments) then using the normal function call syntax(parentheses). Examples are the size argument of a vector or the file name argument of an fstream. 
%		
%\begin{lstlisting}
%vector<int> b{10,20}; //fills the vector with the arguments
%vector<int> c(10,20); //uses arguments to parameterize some functionality, Like filling the vector with 10 integers.
%vector<int> d{}; 
%\end{lstlisting}
%		\begin{description}
%			\item[Line 3:] Default initialization, use \{\}. For vector, maybe it's redundant, but it's good habit and keep your style consistency. For example, \texttt{int i}; and \texttt{int i\{\}}.
%		\end{description}
%	\end{enumerate}
%
	


\chapter{Memory}

\section{Memory functions in C}

	
	
	 That is a long story. In the C language, what happens if you forget a header file? In short, it will produce a warning in C99, but not in C89, and the compiler will assume the "implicit int" rule. This means that it presumes a function without a prototype (declared in the header file) will simply return an \texttt{int} type. Based on these rules, if you comment out \texttt{stdlib.h} in the code below, the compiler will assume that \texttt{malloc} returns an \texttt{int}. This code will run on a 32-bit computer because \texttt{int} and \texttt{int*} have the same length. However, on a 64-bit computer, \texttt{int*} is 64-bit and \texttt{int} is 32-bit, so half the data will be lost and your code will crash. What's worse is that if you add an \texttt{(int*)} cast, it will suppress the warning message. By doing so, you are effectively killing the only clue that something is wrong, which is not a good practice.
	
	
	
\begin{lstlisting}[frame=single, language=c++]
// include "stdlib.h"
int *sieve = (int *)malloc(sizeof(int)*length);	// Bad, suppress warning here.
int *sieve = malloc(sizeof(int)*length);        // Good, produce a warning.
\end{lstlisting}

	\par \texttt{malloc} actually returns \texttt{void*} type. We don't recommend using the \texttt{(int*)} cast at all, so the next question is whether \texttt{void*} can be implicitly cast to \texttt{int*} or other pointer types in assignment. The answer is \textbf{YES}.
		
	
	\par In the C language, we can use \texttt{NULL} to initialize pointer types.
\begin{lstlisting}[numbers=none]
#define NULL ( (void*) 0)
int *p = NULL;  //legal
FILE * f = NULL;  //legal
\end{lstlisting}
	
	\par In C++, the literal \texttt{NULL} is just defined as 0. The statement \texttt{int *p = (void *) 0} is no longer legal since C++ is a type-safe language. To resolve this issue, C++11 introduced the keyword \texttt{nullptr}.
	
\begin{lstlisting}[numbers=none]
int *p = NULL; //illegal in C++
cout<<is_integral<decltype(nullptr)>::value; //false
cout<<is_integral<decltype(NULL)>::value; //true

f(int i)
f(int * p); 
f(NULL);  //will call f(int i).
f(nullptr) //will call f(int *p)
\end{lstlisting}
	

	\par \texttt{calloc()} zero-initializes the buffer, while \texttt{malloc()} leaves the memory uninitialized. Zeroing out the memory may take a little more time, so you probably want to use \texttt{malloc()} if performance is an issue. If initializing the memory is more important, use \texttt{calloc()}, \texttt{calloc()} might save you a call to \texttt{memset(p, 0, size)} later.
		
	\par When you use \texttt{memcpy}, the destination cannot overlap the source at all, but \texttt{memmove} can. This means that \texttt{memmove} might be slightly slower than \texttt{memcpy}, as it cannot make the same assumptions. For example, \texttt{memcpy} might always copy addresses from low to high. If the destination overlaps after the source, this means some addresses will be overwritten before being copied. \texttt{memmove} would detect this and copy in the other direction - from high to low - in this case. However, checking this and switching to another (possibly less efficient) algorithm takes time.
		
	\par \texttt{realloc} reallocates the given area of memory. It must be previously allocated by \texttt{malloc()}, \texttt{calloc()}, or \texttt{realloc()} and not yet freed with a call to \texttt{free} or \texttt{realloc}. Otherwise, the results are undefined. \texttt{realloc} may or may not change the original address.


\begin{lstlisting}[]
str = (char *) malloc(15);
strcpy(str, "tutorialspoint");
printf("String = %s,  Address = %p\n", str, str);

/* Reallocating memory */
str = (char *) realloc(str, 25);
strcat(str, ".");
printf("String = %s,  Address = %p\n", str, str);
\end{lstlisting}
	
	\par When you use \texttt{realloc}, don't assigned the return value to the input pointer \texttt{ptr}. Instead, use another local pointer, such as \texttt{new\_ptr}, because if \texttt{realloc} fails, it will not overwrite the original \texttt{ptr}.
\begin{lstlisting}[numbers=none]	
void *new_ptr = realloc(ptr, new_size);
if (!new_ptr) {
	// deal with error;
}
ptr = new_ptr
\end{lstlisting}


\section{new operator in C++}
\subsection{Four different sub-topics of new operator}
	 There are four sub-topics related to the \texttt{new operator}: 
	 \begin{enumerate}
	 	\item new\_handler. For the default \texttt{new operator}, you can use \texttt{set\_new\_handler} to adjust the behavior when enough memory can't be allocated.
	 	\item no throw. When allocation fails, don't throw an exception, but return \texttt{nullptr} (since C++11).
	 	\item placement new. It does not allocate memory, only constructs object on a given memory.
	 	\item \texttt{operator new}. It only allocates memory, without constructing.
	 \end{enumerate}
	 
\begin{lstlisting}[frame=single, language=c++]
std::set_new_handler(noMem);  //1) new_handler 
Foo* p1 = new Foo;//call noMem if fail, throw exception if no new handler

Foo * p2 = new (std::nothrow) Foo; // 2) no throw
new (p2) Foo;   //placement new    // 3) placement new

Foo* p3=(Foo*)::operator new(sizeof(Foo));  // 4) operator new
\end{lstlisting}
	

	\par The \texttt{nothrow} \texttt{new operator} only ensures that the \texttt{operator new} inside it will not throw an exception, but will return \texttt{nullptr} if the allocation fails. However, it does not guarantee that the constructor of \texttt{Foo} will not throw an exception. Therefore, it is not a fully mature design. In other words, we do not recommend using this type of \texttt{nothrow new} operator in the production code.

	
	\par The \texttt{new operator} will call the constructor function of a class, but \texttt{malloc} will not call the constructor function. Therefore, in C++, you should use the \texttt{new operator} instead of \texttt{malloc}.
		
	
	\par When you have to use array \texttt{new} (new int[100];) to allocate an array, you must use the array \texttt{delete} (delete [] p;). If you don't use array \texttt{delete}, you may end up deleting only the first object in the array. If you use array \texttt{delete} on a single \texttt{new}, it's undefined behavior. Any time you want to use \texttt{new} to allocate an array, ask yourself if you can replace it with \texttt{std::vector} or \texttt{std::string}. If the answer is 'yes', don't use array \texttt{new}. 
	
%	The system will remember the size corresponding to \texttt{pa}. With \texttt{[]}, it will iterate with the size. When you forget \texttt{[]}, it will only free the first object, causing a memory leak.
	
	
\begin{lstlisting}[frame=single, language=c++]
Foo pa* = new Foo[10]; //array new
delete [] pa;  //array delete
\end{lstlisting}	
	
	\par Basic logic of array new. An basic implementation can be found in "Inside the C++ Object Model" 6.2 chapter
\begin{lstlisting}[numbers=none]
vec_new(int elem_count, int size, funptr constructor){
	total_size = size*elem_count;
	ptr_array = new char[total_size];
	registrate pair of ptr_array elem_count to system
	while(elem<end of address){
		(*constructor)(elem) //call the constructor
		elem+=size;
	}
}	
\end{lstlisting}
	
	\par When you use array \texttt{new} with inheritance, there is one important thing to notice: don't use a base pointer to point to an array with a derived class. Why is it dangerous? When you use \texttt{delete [] bp}, the system will think that it's a base array, and each element in it is just a base object. Therefore, virtual functions won't play a role here. For more details, please refer to the 'Inheritance' section in this book. Note that \texttt{bp[2]} is not a pointer; polymorphism only works when we use a pointer or reference.
\begin{lstlisting}[frame=single, language=c++]
Base *bp = new Derived[10]; //always use Derived *dp = new Derived[10];
bp[2]    //dangerous, undefined. size is wrong: bp+sizeof(base)*2
delete [] bp; //dangerous, 1)size is wrong, 2)it will call base::~base()	

Base b, Derived d; //The whole idea is just like assigning Devirved to Base
b = d;  // slice happens, but new and pointer hide the detail behind the scene.
\end{lstlisting}	
	

\subsection{new operator and delete operator}

   
     When you call the \texttt{new operator}, it invokes \texttt{operator new}, which in turn invoke \texttt{new\_handler}. This provides two opportunities to customize the behavior of the operator: you can customize \texttt{operator new} and you can customize \texttt{new\_handler}.
    
    
	\par Basic logic of \texttt{new operator}. Below is C++ pseudo code.
\begin{lstlisting}[]
Point3d *origin = new Point3d;
//will be converted to below code:	
if(origin = operator new(sizeof(Point3d))){ //call operator new to allocate memory
	try{
		origin = Point3d::Point3d(origin); //call constructor on the address
	}
	catch(...){  //if constructor throw an exception, no memory leak
		operator delete(origin);
		throw; //rethrow it to outside.
	}
}
\end{lstlisting}
	

	
\par Basic logic of \texttt{operator new}. This is throw version \texttt{operator new}, non-throw and placement \texttt{operator new} are quite alike. Most of time, we use \texttt{malloc} and \texttt{free} to allocate and free physical memory.
\begin{lstlisting}[frame=single, language=c++]
void * operator new(std::size_t size) throw(std::bad_alloc){
using namespace std; 
	if (size == 0){ //handle 0-byte requests by treating them as 1-byte request   
		size = 1;             
	}                 
	void *last_alloc;
	while (true) { //continue to try allocate memory.
		*last_alloc = malloc(size)
		if (last_alloc)
			return last_alloc;
		new_handler globalHandler = set_new_handler(nullptr); 
		set_new_handler(globalHandler); // allocation was unsuccessful,
		if (globalHandler)           //find current new-handling function
			(*globalHandler)();      // and call it.
		else 
			throw std::bad_alloc();
		}
}
	\end{lstlisting}
\begin{description}	
    \item[Line 11-12] Why we need to call \texttt{set\_new\_handler} twice, The first one get the current handler, and the second one changes it back. That is only way we can get the current handler. This idiom is also used in \texttt{set\_terminate} and \texttt{set\_unexpect}. C++11 introduces \texttt{get\_new\_handler()} function. We don't need to call \texttt{set\_new\_handler} twice. 
    
    \item[Line 13] At program startup, the value of \texttt{new\_handler} is a nullptr pointer. If an allocation fails inside of \texttt{operator new}, \texttt{globalHandler} is a nullptr, then \texttt{operator new} will throw \texttt{std::bad\_alloc} in line 16.
\end{description}


	\par More knowledge about \texttt{new\_handler}:
\begin{itemize}
	

	
%	\item \texttt{set\_new\_handler} function accepts a function pointer and returns the same type function pointer, which can make declaring this type of function a little difficult.
%\begin{lstlisting}[frame=single, language=c++]
%void failNew(){
%	cerr<<"operator new fail!!!"<<endl
%	abort();
%}
%set_new_handler(failNew);
%
%extern void ( * (*set_new_handler) ( void (*)() ) ) (); //complex declaration.	
% void (*(*cp) (void (*)())) ();
%
%typedef void(* FunPtr)();  //A better method is to use typedef
%FunPtr (*set_new_handler) (FunPtr);
%\end{lstlisting}
		
	\item When you simply want to allocate memory, \texttt{operator new} is generally better than using \texttt{malloc} because it offers more options. For example, you can use \texttt{set\_new\_handler} or choose whether to throw an exception.
\begin{lstlisting}[frame=single, language=c++]
Foo* p;
char* raw = operator new(sizeof(Foo)*100, std::nothrow);
//char* raw = new char[sizeof(Foo)*100]; //Also work!
if (raw == nullptr) abort();
\end{lstlisting}
	
	\item The function \texttt{new\_handler} is called by \texttt{operator new} when a memory allocation attempt fails. Its intended purpose is one of three things:
	
	\begin{enumerate}
		\item Make more memory available. \textbf{resolve the problem by myself.}
		
		\item Throw exception of type \texttt{std::bad\_alloc} or derived from \texttt{std::bad\_alloc}. \textbf{resolve the problem by a caller.}
		
		\item Terminate the program. e.g. by calling \texttt{std::terminate}. \textbf{(No resolve)}
	\end{enumerate}
	
\begin{lstlisting}[frame=single, language=c++]
void noMemory(){
	closeIE;  //method1 , release mem by close some current applications.
	set_new_handler(nullptr);  //method2, default throw bad_alloc exception.
	abort();  //method3, end application.
}

int main(void){
	set_new_handler(noMemory) //in the beginning of main() function.
	...
\end{lstlisting}

	\item If you want to have customized \texttt{new\_handler} for specific class, please refer to "effective C++ item 49". It uses Mixin idiom, which can be found in generic programming section in this book.
\end{itemize}



	\par The implementation of \texttt{new operator} can be illustrated by below figure. 
\begin{center}
\includegraphics[width=0.90\linewidth]{pics/new1_1.png}
\end{center}

	

\par Basic logic of \texttt{delete operator} and \texttt{operator delete}.
\begin{lstlisting}[numbers=none]
delete *ptr;

if (ptr != nullptr) {
	ptr->~Foo(); //destructor can't be private or protected
	operator delete(ptr);
}	
\end{lstlisting}

\begin{lstlisting}[numbers=none]
operator delete (void *ptr){
	if (ptr)
		free(ptr)
}	
\end{lstlisting}

	\par The implementation of \texttt{delete operator} can be illustrated by below figure. 
\begin{center}
	\includegraphics[width=0.90\linewidth]{pics/new1_2.png}
\end{center}

	
	

\subsection{Placement new}

	 To construct an object in memory that you already have allocated and had a pointer to, you can use placement new. If you use placement new to create an object in some memory, you should avoid using the \texttt{delete} operator on that memory. A demonstration code is below:
\begin{lstlisting}[frame=single, language=c++]
Foo* p;
char* raw = operator new(sizeof(Foo)*100, std::nothrow);
if (raw == nullptr) abort();
	
try {
	p = new(raw) Foo{};  //Call the constructor on raw
	p1 = new(raw+sizeof(Foo) ) Foo{};
}
catch (...) {
	operator delete(raw); // oops, constructor throw an exception
	throw;  // rethrow the constructor's exception
}

p->~Foo(); //call dtor directly, one chance you should call destructor directly.
p1->~Foo(); //call dtor directly,
operator delete(buffer);  //don't call delete [] raw or delete raw.
\end{lstlisting}
	
	\par Another example to use placement new in stack array. Learn how to use placement new in stack and how to use \texttt{reinterpret\_cast} and \texttt{alignas}.
\begin{lstlisting}[numbers=none]
struct ComplexType {
	int a;
	ComplexType() : a{0} {}
	~ComplexType() {}
};

int main() {
	char* dynArray = new char[256];
	//Calls ComplexType's constructor to initialize memory as a ComplexType
	new( (void*) dynArray) ComplexType();
	....
	reinterpret_cast<ComplexType*>(dynArray)->~ComplexType();
	delete[] dynArray; //Clean up memory once we're done
	
	//Stack memory can also be used with placement new
	alignas(ComplexType) char localArray[256]; //alignas() available since C++11
	new( (void*) localArray) ComplexType();
	...
	//Only need to call the destructor for stack memory
	reinterpret_cast<ComplexType*>(localArray)->~ComplexType();
}
\end{lstlisting}



\section{Operator new overload}
	 \texttt{new operator} (new expression) and \texttt{operator new} are two different things. \texttt{new operator} call \texttt{operator new} inside. There are three kind of \texttt{operator new}.
\begin{lstlisting}[frame=single, language=c++]
void* operator new (std::size_t size); 
void* operator new (std::size_t size, const std::nothrow_t& nothrow_value) noexcept;
void* operator new (std::size_t size, void* ptr) noexcept;	
\end{lstlisting}	
		
	
	\par You can't change the behavior of the \texttt{new operator} itself, but you can override the global \texttt{operator new} and overload it within a class. Pay attention to its arguments and return type, which is \texttt{void*}. The following code provides a simple demo without using \texttt{new\_handler}. The \texttt{operator new} function typically invokes the \texttt{malloc} function, which in turn typically calls \texttt{brk} for small chunks and \texttt{mmap} for larger chunks. Therefore, at its core, OS handles low-level memory allocation and release.
	
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
void* operator new(size_t size){ //global operator new
	cout<<"Yan's own operator new" ;
	void* mem = malloc(size);
	if(mem)
		return mem;
	else
		throw bad_alloc();
}

class Foo{ //class operator new
public:
	static void* operator new(size_t size);
		...
};
void* Foo::operator new(size_t size){
	cout<<"Foo's own operator new";
	....
}
	
int *p = new int[100]; //output "Yan's own operator new" here
Foo* fp = new Foo();  //output "Foo's own operator new" here
\end{lstlisting}

	\par In C++, after you define a name in a scope (e.g., in a class scope), it will hide the same name in all enclosing scopes (e.g., in base classes or enclosing namespaces), and overloading never happens across scopes. I have introduced this knowledge in the second chapter's "Name Lookup" section. When the name is \texttt{operator new}, if you provide any class-specific placement new, you should provide all of the standard forms (plain, placement, and nothrow). In the below code, your own placement new will hide plain new and nothrow new in the global scope.

\begin{lstlisting}[frame=single, language=c++, mathescape=true]
class C {
	static void* operator new(size_t, MemoryPool&); //placement operator new
	// hides all other forms operator new 
};

C* pc = new C() //compile failed here. 	
\end{lstlisting}

	In order to resolve the name hiding problem, you can define a Base class that includes the regular \texttt{operator new} and then have your own class inherit from it. More details can be found in "Effective C++ Item 52".
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
class StandardNewDeleteForms {
public:
	static void* operator new(std::size_t size) throw(std::bad_alloc) { 
		return ::operator new(size); }
	static void operator delete(void *pMemory) throw() { 
		::operator delete(pMemory); }
	static void* operator new(std::size_t size, void *ptr) throw() { 
		return ::operator new(size, ptr); }
	static void operator delete(void *pMemory, void *ptr) throw() { 
		return ::operator delete(pMemory, ptr); }
	...
};

class Widget: public StandardNewDeleteForms { // inherit std forms
public:
	using StandardNewDeleteForms::operator new; // make those three forms
	using StandardNewDeleteForms::operator delete; //in base class visible here
	
	static void* operator new(size_t size,  ostream& ls) throw(std::bad_alloc){
		// add a custom placement new here.
	}	
	static void operator delete(void *pMemory, std::ostream& logStream){}
		// corresponding placement delete
	}
};
\end{lstlisting}

	
	\par When should you provide your own operator new?  You want to add log function; You want to add some cookie before and after allocated memory (Visual Studio use this way to detect overflow in debug mode). You want to have quicker speed (memory pool). You want to have better alignment and so on. In summary, in below three contexts:
	\begin{enumerate}
		\item Performance: the default memory allocator is designed to be general purpose. Sometimes you have very specific objects you want to allocate, chapter 4 in "Modern C++ Design" presents a very well designed and implemented custom allocator for small objects.
		
		\item Debugging \& statistics: having full control of the way memory is allocated and released provides great flexibility for debugging, statistics and performance analysis.
		
		\item Customization to cluster related object together, and reduce size. Put guard block to avoid overrun and underrun. More detail can be seen in effective C++( third edition) Item 50
	\end{enumerate}
		

%	\par Why do we need operator array new? You can google the article "Why is ::operator new[] necessary when ::operator new is enough?" in the stack overflow. The basic idea is the same, I think that it just make you can have fine grain control. If you customize operator array new, it will only affect array new expression.  
%\begin{lstlisting}[numbers=none]
%void* operator new(size_t);   //operator new
%void* operator new[](size_t); //operator array new
%
%int* p = new int[5]; // call operator array new.
%\end{lstlisting}
	

\subsection{Placement operator new overload}

	
	 In C++, the operator new function can be overloaded to take more than one parameter: The first parameter passed to the operator new is always the size of the storage to be allocated, but additional arguments can be passed to this function by enclosing them in parentheses in the new-expression.
	
\begin{lstlisting}[frame=single, language=c++]
int * p = new (x) int; //is a valid expression that, at some point, calls:
operator new (sizeof(int), x);
\end{lstlisting}		
		
%	\item If operator new receive another parameter beside the \texttt{size\_t}, that is called placement new. The one with \texttt{void*} parameter is a special placement new operator. It is a special version that accepts \texttt{void*}, which can't be customized. This version essentially does nothing internally. For instance, in Visual C++, the default implementation simply returns the address passed into the call.
%\begin{lstlisting}[numbers=none]
%void* operator new (std::size_t size, void* pMemory){
%	return pMemory;
%}		
%\end{lstlisting}		
	
	\par Any another parameter beside the \texttt{size\_t} can also be called as "placement operator new". One of the versions of placement new is overloaded to accept a parameter \texttt{std::nothrow} (its type is \texttt{std::nothrow\_t}). The value itself is not used, but that version of \texttt{operator new} will return a null pointer in case of failure instead of throwing an exception.
\begin{lstlisting}[numbers=none]
void* operator new (std::size_t size, void* pMemory) throw(); //special 

void* operator new(std::size_t size, std::nothrow_t const&) noexcept;
char* p = new (std::nothrow) char [1048576];
if(!p){
	cout<<"Fail to allocate memory";
}
\end{lstlisting}	
	
	\par Some suggestions for placement operator new overload. You can see the context is very complicated, so don't overload placement new operator unless you have to. 
	
\begin{itemize}
	\item Don't overload placement operator new with extra \texttt{void} pointer.
\begin{lstlisting}[numbers=none]
void* operator new (std::size_t size, void* ptr) //1) not allow overload 
\end{lstlisting}	
	
	\item If you define your own placement \texttt{operator new}. You must provide your own corresponding placement \texttt{operator delete}. Because when the constructor throw exception, it calls the corresponding customized placement \texttt{operator delete}. If no such function, placement new does nothing and cause memory leak. Detail can be found in "effective C++ item 52"
\begin{lstlisting}[numbers=none]
void* operator new (std::size_t size, ostream& logStream) {
	logStream<<"use logStream output log here"<<endl;
	void temp = operator new (size);
	return temp;
}

void operator delete(void* p, ostream& logStream){
	delete(p);
}	

Foo* foo = new (std::cerr) Foo; // use you own operator new placement version.
\end{lstlisting}		

	\item When no exception is thrown, you still need to use "normal" delete to free the memory which allocated by placement operator new. It means that you need to provides two operator delete for customized placement new.
\begin{lstlisting}[numbers=none]
void* operator new (std::size_t size, ostream& logStream) {
	...
	void* temp = operator new (size);
	void* extra = malloc;
	return temp;
}
void operator delete(void* p, ostream& logStream){
	delete(p);
	free(extra);
}	
void operator delete(void* p){
	delete(p);
	free(extra);
}	
\end{lstlisting}
		
\end{itemize}	

	\par If you have to rewrite \texttt{operator new}, You need to read effective C++ Item 51 in detail. For example, all \texttt{operator new} should contain a loop calling a new-handling function. You also need to deal with request of zero size, you need to consider alignment, you can see the pseudo-code in Item 51. In one word, \textbf{Don't rewrite operator new unless you have strong reason}, because it's not an easy task. If you overload global operator new, both library and user application have to use your overload version, it is very aggressive and will cause problem. If you have to do it for some very specific reason: there are two options:

\begin{enumerate}
	\item Consider some library, such as Boost Pool library for large number small object allocations. 
	
	\item Rewrite \texttt{malloc} and use LD\_PRELOAD trick to load your own \texttt{malloc} first.
\end{enumerate}		
	
	\par A good article is "The many faces of operator new in C++", It gives detail information about \texttt{operator new} and how to rewrite it. You can google it.

%\section{Summary}
%Below figure illustrates what happen inside new operator and delete operator.
%\begin{figure}[ht]
%	\centering
%	\includegraphics[width=0.90\linewidth]{pics/new.png}
%	\caption{new operator and operator new.}
%	\label{fig:smartpointer1}
%\end{figure}


\chapter{Pointer and smart pointer}

\section{Raw pointer}


     When do you use a smart pointer? Here, I am reframing this question: When do you use a pointer? If you need a large array or memory resource, allocating it on the stack can cause a stack overflow. However, in practice, this requirement is deprecated because anytime you use \texttt{new[]}, you should consider using \texttt{std::vector} or \texttt{std::string} instead. Therefore, this usage is obsolete. Another common usage is for polymorphism, but you can use a reference as well if it’s just for polymorphism, therefore, this usage is also obsolete.


	\par The only common usage of a pointer is to control the lifetime of the object that the pointer points to. For example, you may create the object in function 1 and delete it in function 4, so the object is neither stack duration nor static duration. You may or may not transfer ownership between functions, or you may want to create an object at runtime based on runtime conditions or user input (or decide not to create it). In other words, you need object (reference) semantics, not value semantics. The code below demonstrates the usage of a pointer, where the \texttt{ToothBrush} object needs to be controlled in terms of its lifetime and created dynamically.

\begin{lstlisting}[numbers=none]
class Person{
public:
	ToothBrush* pbrush;
	buyNewBrush(string &name){
	    if(pbrush != nullptr){
		    	delete pbrush;
	    }
	    if(name == "Orlab"){
	          pbrush = new Brush();
	    }
	}
	~Person(){
		if(pbrush != nullptr){
			delete pbrush;
	    }
    }
};
Person Yan();
Yan.buyNewBrush("Oralb");
//......Three months later...........
Yan.buyNewBrush("Philip");
}
\end{lstlisting}

	
	\par The problems with raw pointers include buffer overruns, wild pointers, double deletes, memory leaks, mismatched \texttt{new} and \texttt{delete}, and memory fragmentation. To resolve buffer overruns and mismatched \texttt{new} and \texttt{delete} issues, we can use \texttt{std::vector} and \texttt{std::string}. To resolve wild pointer, double delete, and memory leak issues, we can use smart pointers. With the help of smart pointers, memory can be freed immediately, which is crucial for performance. For example, if the memory layout looks like this: XXXOXXX (X stands for free, and O stands for used), once we free O, we will have seven contiguous free memory slots. This not only frees up one byte of memory but also creates a larger chunk of memory for future allocations, which is critical in memory management.
	
	\par A raw pointer can be used as an alias for a variable. In C++, this kind of "alias" semantics can also be achieved using a reference. A reference has two characteristics: it is non-null and can't  be changed. In other words, the top level of a const reference is immutable. A reference always refers to the object with which it was initially initialized. This is why you must initialize it. Unlike a pointer, a reference does not have a wild pointer problem. Therefore, there is no need to test if a reference is a null reference. However, if you have a reference to a local variable inside a function, when the function finishes, it can still cause a dangling reference problem.
\begin{lstlisting}[numbers = none]
string &rs = s1;
rs = s2; //modified s1's value,rs still refer to s1
\end{lstlisting}	
	
	\par You can have a reference to a pointer, but a pointer to a reference is illegal. A reference is simply an alias to another object. You can't "point" to a reference because it is not an object in itself, but merely another name for a real object. In terms of syntax, a reference to a reference has a different meaning and is called an rvalue reference, I will introduce it in the next chapter. 
\begin{lstlisting}[numbers=none]
int *p;
int *& rp = p; // reference to pointer is OK, int *& is a reference.
int &* pr  //pointer to reference is ERROR, int &* is a pointer.

const int i = 12;
int& j = i; //ERROR, non-const reference can't refer to const object.
\end{lstlisting}	

	\par A raw pointer has a somewhat complicated relationship with arrays. Here are three points to help you understand this relationship:
\begin{enumerate}
	\item Array name represents address: The name of an array is essentially a address of the first element of the array.
	
	\item Address has type: The address of an array element has a specific type that corresponds to the type of the elements in the array.
	
	\item Pointer initialization: An address of a specific type can be used to initialize pointer of the same type.   
\end{enumerate}
	
	
\begin{lstlisting}
//char** ca = { "abc", "de" }; //Error
//char* ca[] = { {'a','b', 'c'} , {'d', 'e'} }; //Error
//int** da = { {1,2,3}, {4,5} }; //Error
//int* da[] = { {1,2,3}, {4,5} }; //Error

int* da[] = { new int[] {1,2,3}, new int[] {4,5} };//array of pointer, ragged
int** pda = da;  // da is adress of pointer
cout << *(*(pda + 1) + 1) << endl;// output 5

int da1[2][3] = { {1,2,3}, {4,5,6} }; //an array of array, square
int(*pda1)[3] = da1;  //da1 is address of array [3]
cout << *(*(pda1 + 1) + 1) << endl;// output 5

char* ca[] = { new char[] {'a', 'b', 'c', '\0'}, new char[] {'d', '\0'} };
const char* cca[] = { "abc", "de" }; //here, char* cca[] doesn't work.
\end{lstlisting}
	\begin{enumerate}
		\item The square array is different with ragged array, Usually, we use array of pointer to simulate ragged array, and we use \texttt{a[2][3]} to denote the squared array.
		
		\item While the syntax for \texttt{((p+a)+b)} is the same, different types of \texttt{p} will result in different interpretations by the compiler. There is a difference between a pointer to a pointer and a pointer to an array.
		\begin{center}
			\includegraphics[width=0.9\linewidth]{pics/array.drawio}
		\end{center}
		
		\item \texttt{char*} is a little different, we can use "abc" to represent \texttt{const char*}, at the same time, we also need to add null charter in the end of char array.
		
	\end{enumerate}
	


\section{Basic smart pointer knowledge}

\subsection{Implementation smart pointer?}

		 A simple \texttt{unique\_ptr} implementation. The default value for smart pointers is \texttt{nullptr} if you do not initialize them. This helps you avoid the problem of wild pointers.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
template <class T> 
class unique_ptr{
    T* ptr;
public:
    explicit unique_ptr(T* p = nullptr) : ptr(p) {}
    ~unique_ptr()                 {delete ptr;}
    T& operator*()     {return *ptr;} //return reference 
    T* operator->()    {return ptr;} //interpret as (p.operator->())->m
};
\end{lstlisting}

	\par When implementing smart pointers, consider below four points:

	\begin{enumerate}
		\item \texttt{operator *} and \texttt{operator ->} overload method.
		
		\item Declare copy constructor and assignment operator "delete" for \texttt{unique\_ptr}.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
unique_ptr(const unique_ptr&)    = delete;  
unique_ptr& operator=(const unique_ptr&)    = delete;
\end{lstlisting}

		\item For \texttt{shared\_ptr}, we need to pay attention to its reference count implementation. 
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
class shared_count {
public:
	void add_count();
	long reduce_count();
	...
private:
	atomic_int use_count_;
};	
\end{lstlisting}		

\begin{lstlisting}[frame=single, language=c++, mathescape=true]
template <typename T>
class smart_ptr {
public:  
	...
private:  
  T* ptr_;  
  shared_count* shared_count_;//don't use shared_count or static shared_count
};	
\end{lstlisting}		
		
		
		\item Template copy constructor. It is used to support assignment between child class smart pointer and parent class smart pointer. In line 5, you have to use \&\& (rvalue reference) because you can only \texttt{std::move} a \texttt{unique\_ptr} pointer, you can't copy it. 
		
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
template <typename T>
class unique_ptr{
	.....
	template <typename U>  
	unique_ptr(unique_ptr<U>&& other) { 
		ptr_ = other.release();  
	}
}

unique_ptr<parent> pc{new Child};
unique_ptr<parent> pp{std::move(pc)};
\end{lstlisting}

	\end{enumerate}


\subsection{Why doe we need smart pointer?}
	
	 "Just remember" is seldom the best solution! Therefore, smart pointers are essential for automatically managing the delete operation, especially when exceptions are thrown or when returning in the middle of code execution. Failure to invoke delete can lead to memory leaks. With smart pointers, however, exceptions thrown during function execution do not result in memory leaks. One of the most significant advantages of smart pointers is their ability to automatically manage exclusive or shared ownership of resources.

	\par There are four kinds of smart pointers: \texttt{auto\_ptr}, \texttt{unique\_ptr}, \texttt{shared\_ptr} and \texttt{weak\_ptr}. However, only \texttt{unique\_ptr}, \texttt{shared\_ptr} and \texttt{weak\_ptr} are recommended for use. \texttt{auto\_ptr} is now deprecated and should not be used in new code. When you get a chance, try doing a global search-and-replace of \texttt{auto\_ptr} to \texttt{unique\_ptr} in your code base. \texttt{weak\_ptr} is mainly used for observers; you can always use raw pointers or references for this purpose. Raw pointers can't check if the pointee object is still valid, but \texttt{weak\_ptr} can accomplish this task.
	
	\par Why is \texttt{auto\_ptr} not recommended? When you assign \texttt{targetP = sourceP}, it causes \texttt{sourceP} set to be \texttt{nullptr}. This can cause trouble when you use \texttt{sourceP} in the future. Additionally, you can't create containers that include \texttt{auto\_ptr}, as compiler will prohibit you from doing so!

\begin{lstlisting}[numbers=none]
auto_ptr<string> ps (new string("hello world") );
auto_ptr<string> ps1;
ps1 = ps;   // ps will be set null.
ps->size() // it will crash the application.

auto_ptr<string> parray[5]; //compiling error.
\end{lstlisting}

	
	\par When you construct a smart pointer, you must use: 1) a pointer, and 2) this pointer must be produced by \texttt{new}. You should not build a smart pointer by using the address operator, such as \texttt{unique\_ptr<double> ptr(\&int);}. Why? Because the smart pointer will call \texttt{delete} when it goes out of scope. The \texttt{delete} operator has to be used on a pointer produced by the \texttt{new} operator.
	
	
	\par A smart pointer supports flexible operations, such as obtaining the raw pointer by \texttt{get()} member function, relinquishing control of the pointed object by \texttt{release()}, and replacing the object it manages by \texttt{reset()}. A smart pointer also has a \texttt{bool} operator, which you can use to test if it's \texttt{nullptr} directly.

\begin{lstlisting}[numbers=none]
string * cp = new string("hello world");
shared_ptr<string> ps(cp);
string * cp1 = ps.get(); //use get() get normal pointer.

std::unique_ptr<int> ptr(new int(42));
if (ptr) std::cout <<  *ptr << '\n';
ptr.reset(); //
if (ptr) std::cout <<  *ptr << '\n';
\end{lstlisting}

	\par Smart pointer and \texttt{const} can have four different combination. \texttt{shared\_ptr<T>} and \texttt{shared\_ptr<const T>} are not interchangeable. \texttt{shared\_ptr<T>} is convertable to \texttt{shared\_ptr<const T>} but not the reverse.
\begin{lstlisting}[numbers=none]
shared_ptr<T> p;         //can be analogous to: T * p;
const shared_ptr<T> p;   //can be analogous to: T * const p;
shared_ptr<const T> p;   //can be analogous to: const T * p;
const shared_ptr<const T> p; //can be analogous to: const T * const p;

shared_ptr<int> pint(new int(4)); // normal shared_ptr
shared_ptr<const int> pcint = pint;
shared_ptr<int> pint2 = pcint; // error! 
\end{lstlisting}



\subsection{unique\_ptr basic usage}

 Create \texttt{unique\_ptr} from \texttt{new} operator. \texttt{make\_unique} is better than inside \texttt{new}, inside \texttt{new} is better than outside \texttt{new}. let me explain it in below code.
\begin{lstlisting}[frame=single, language=c++]
string * cp = new string("hello world");

unique_ptr<string> ps = cp; // NOT allow to assign unique_ptr directly.
unique_ptr<string> ps (cp); //Ok, not good, new is outside of constructor (line 1).
unique_ptr<string> ps (new string("hello"));//good , new is inside of constructor
auto ps( std::make_unique<string>("hello") );//best, call make_unique directly.
\end{lstlisting}

\par Create \texttt{unique\_ptr} from another \texttt{unique\_ptr}, you have to use \texttt{std::move}.
\begin{lstlisting}[frame=single, language=c++]
unique_ptr<string> ps1 (new string("hello world"));

unique_ptr<string> ps2 ( ps1 ); //compile error
unique_ptr<string> ps2 ( std::move(ps1) ); //ok, ownership transfer from ps1 to ps2
unique_ptr<string> ps2 = std::move(ps1) ; //ok, nothing delete, ps1 points to nullptr
\end{lstlisting}

\par When pass \texttt{unique\_ptr} value into a function.1) \textbf{For some existing \texttt{unique\_ptr}, use \texttt{std::move} to transfer ownership.} 2) \textbf{For new \texttt{unique\_ptr}, use \texttt{make\_unique} to assure exception safe.}	


\begin{lstlisting}[frame=single, language=c++]
void sink(unique_ptr<widget> arg1, unique_ptr<gadget> arg2);//function declaration

sink( std::move(exist_uptr_wi), std::move(exist_uptr_ga))
sink(make_unique<widget>(arg1, arg2),make_unique<gadget>(arg1, arg2));  
\end{lstlisting}


	\par An example of \texttt{reset()} and \texttt{release()}
\begin{lstlisting}[frame=single, language=c++]
auto ps1 (make_unique<string>("ps1"));
auto ps2 (make_unique<string>("ps2"));
ps1= ps2; //compile error, not allow copy
ps1 = std::move(ps2);  

ps1.reset(new string("ps3")); //pointer inside previous ps1 delete. 
string* pstr = ps1.release(); //reset and release 
\end{lstlisting}
\begin{description}
	\item[Line 4:]  Pointer inside previous \texttt{ps1} will be deleted. Pointer inside \texttt{ps1} point to \texttt{ps2} string now. pointer inside \texttt{ps2} will be set to nullptr.
	
	\item[Line 7:] Use \texttt{pstr} get pointer managed by \texttt{ps1}. Pointer in \texttt{ps1} will be set to \texttt{nullptr}. It's you duty to manage the memory which pointed by pointer \texttt{pstr} now.
\end{description} 

	\par If a program attempts to assign one \texttt{unique\_ptr} to another. The compiler allows it if the source object is a temporary rvalue (It will call move constructor or assignment of \texttt{unique\_ptr} inside.) and disallows it if the source object has some duration. In another word, \texttt{unique\_ptr} supports \textbf{source and sink idiom}.
\begin{lstlisting}[numbers=none]
uqique_ptr<string> fun(){
	return unique_ptr<string> temp(new string("yan");
}
pu2 = fun(); //OK, support source

void fun1(unique_ptr up);  //use move to support sink
fun1(std::move(other_up));
\end{lstlisting}

	\par If you just want to be a observer, not transfer ownership, you can get pointer, or use \texttt{unique\_ptr} reference.
\begin{lstlisting}[numbers=none]
unique_ptr<string> ps1 (new string("ps1"));

fun(string* pstr);  //use ps1.get() to the raw pointer inside unique_ptr
fun(unique_ptr<string> & ref_ptr); // use unique_ptr reference.
\end{lstlisting}


    \par \texttt{std::unique\_ptr} can be used inside of class. Below class \texttt{B} disable value-copying (or to define a suitable copy-constructor and operator= to handle it safely).
\begin{lstlisting}[numbers=none]
class Foo {  // this class doesn't support copy.
public:
   unique_ptr<int> uni_ptr;
   Foo() :uni_ptr(new int{0}) { }
};
\end{lstlisting}

	
	
	\par During construction, \texttt{std::unique\_ptr} objects can be configured to use custom deleters: arbitrary functions (or function objects, including those arising from lambda expressions) to be invoked when it's time for their resources to be destroyed. When a custom deleter can be implemented as either a function or a captureless lambda expression, the lambda is preferable. If a custom deleter is to be used, deleter's type must be specified by the second type argument in \texttt{std::unique\_ptr} template class.


\begin{lstlisting}[frame=single, language=c++, mathescape=true]
template<typename... Ts>
auto makeInvestment(Ts&&... params) {
	
	auto delInvmt = [](Investment* pInvestment) { //custom deleter
		makeLogEntry(pInvestment);  //save log information here. 
		delete pInvestment; 
	};

	std::unique_ptr<Investment, decltype(delInvmt)> pInv(nullptr, delInvmt);
	//specify the deleter's type when you create unique_ptr.
	if (...){
		pInv.reset(new Stock(std::forward<Ts>(params)...));
	}
	else if (... ) {
		pInv.reset(new Bond(std::forward<Ts>(params)...));
	}
	return pInv; // return unique_ptr pointer here.
}
\end{lstlisting}

    \par \texttt{std::unique\_ptr} is the C++11 way to express exclusive ownership, but one of its most attractive features is that it easily and efficiently converts to a \texttt{std::shared\_ptr}: This is a key part of why \texttt{std::unique\_ptr} is so well suited as a factory function return type. Factory functions can't know whether callers will want to use exclusive or shared ownership semantics.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
shared_ptr<Investment> sp=makeInvestment(arguments); //unique_ptr convert to shared_ptr
\end{lstlisting}
	
	\par If a vector contains \texttt{std::unique\_ptr<Fruit>} instead of raw pointers (to prevent memory leaks), the vector needs to copy elements in and out. However, \texttt{std::unique\_ptr} does not support copying. There are several methods to resolve this issue. One approach is to use \texttt{emplace\_back} with a new pointer, but this can lead to memory leaks if extending the vector size fails. A better method is to use an unnamed \texttt{std::unique\_ptr}. The best practice, however, is to use \texttt{std::make\_unique}.
	

\begin{lstlisting}[frame=single, language=c++]
class Fruit { ... };
class Pear : Fruit { ... };
class Tomato : Fruit { ... };

std::vector<std::unique_ptr<Fruit> > m_fruits;
m_fruits.emplace_back(new Pear); //method 1, bad method
m_fruits.push_back(std::unique_ptr<Fruit>(new Pear)); //method2, good method
m_fruits.push_back(std::make_unique<Pear>());//method3, best method 
\end{lstlisting}

	\par You can sort \texttt{unique\_ptr} objects in an STL container as long as you do not use methods or algorithms that copy or assign one \texttt{unique\_ptr} to another, such as \texttt{std::copy()}. Refer to Item 8 in "Effective STL" for more information. Why can you use \texttt{std::sort()} in the below code? \texttt{std::sort()} uses \texttt{std::swap()} function inside it, it doesn't copy \texttt{unique\_ptr} objects.

\begin{lstlisting}[numbers=none]
bool compare_by_uniqptr(const unique_ptr<SomeLargeData>& a,
                        const unique_ptr<SomeLargeData>& b) {
    return a->id < b->id;
}

std::sort(vec_uni.begin(), vec_uni.end(), compare_by_uniqptr); //ok
\end{lstlisting}

\begin{lstlisting}[frame=single, language=c++]
typedef std::unique_ptr<int> unique_t;
typedef std::vector< unique_t > vector_t;

vector_t vec2(5, unique_t(new Foo));     //Error (Copy)
vector_t vec3(vec1.begin(), vec1.end()); //Error (Copy)
std::copy(vec1.begin(), vec1.end(), std::back_inserter(vec2)); // Error (copy)

vector_t vec3(make_move_iterator(vec1.begin()), make_move_iterator(vec1.end())); 
//make_move_iterator return std::move_iterator.
\end{lstlisting}

	\par \texttt{unique\_ptr} has a \texttt{new []} version. The existence of \texttt{std::unique\_ptr} for arrays should be of only intellectual interest to you, because \texttt{std::array}, \texttt{std::vector} and \texttt{std::string} are virtually always better data structure choices than raw arrays. About the only situation I can conceive of when a \texttt{std::unique\_ptr<T[]>} would make sense would be when you're using a C-like API that returns a raw pointer to a heap array that you assume ownership of.
\begin{lstlisting}[numbers=none]
unique_ptr<double []>  pda(new double[5] );// it will call delete [] inside.
\end{lstlisting}

 
\subsection{shared\_ptr basic usage}
	
	 Every \texttt{shared\_ptr} has a control block inside of it. \textbf{When are control blocks created?} It's a very important question because it helps you better understand what happens when you create or assign a \texttt{shared\_ptr} variable.
\begin{center}
\includegraphics[scale=0.53]{pics/shared.drawio.png}
\end{center}


\begin{itemize}
	\item \texttt{std::make\_shared()}  always creates a control block. It produces a new object, so there is certainly no control block for that object at the time \texttt{std::make\_shared()} is called.
	
	\item A control block is created when a \texttt{std::shared\_ptr} is constructed from a unique-ownership pointer (i.e., a \texttt{std::unique\_ptr} ). As part of this construction, the \texttt{std::shared\_ptr} assumes ownership of the pointed-to object, and the unique-ownership pointer is set to \texttt{nullptr}.
	
	\item When a \texttt{std::shared\_ptr} constructor is called with a raw pointer, it creates a control block.
	
	\item When \texttt{std::shared\_ptr} constructors taking \texttt{std::shared\_ptrs} or \texttt{std::weak\_ptrs} as constructor arguments, it does \textbf{NOT} create new control blocks, because they can rely on the smart pointers passed to them to point to any necessary control blocks.
\begin{lstlisting}[frame=single, language=c++]
string * cp = new string("hello world");
shared_ptr<string> ps = cp; //NOT allow

shared_ptr<string> ps (cp);  //outside new, that is bad style. if later, you
shared_ptr<string> ps1 (cp); //build another shared_ptr from same cp, cause UB
shared_ptr<string> ps (new string("hello")); //inside new, good style
shared_ptr<string> ps( std::make_shared<string>("hello") ); //make, best style
\end{lstlisting}
	
	
\end{itemize}    

	\par Some examples of creating \texttt{shared\_ptr} from another \texttt{shared\_ptr}.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
shared_ptr<string> ps1 (new string("hello world"));
shared_ptr<string> ps2 ( ps1 );  //refence count is 2 now, shared by ps1 and ps2
shared_ptr<string> ps2 ( std::move(ps1) );
\end{lstlisting}
\begin{description}
	\item[Line 3:] the original \texttt{ps1} will become nullptr, and the  refence count does not get modified. Just transfer refence count to \texttt{ps2}. 
\end{description}

\begin{lstlisting}[frame=single, language=c++, mathescape=true]
shared_ptr<string> ps1 (new string("ps1"));
shared_ptr<string> ps2 (new string("ps2"));
ps1 = ps2;    //shared_ptr assignment usage.
ps1 = std::move(ps2);
ps1.reset(cp); 
\end{lstlisting}
\begin{description}
	\item[Line 3:] Use assignment  1) In \texttt{ps1}, previous reference count decrements 1. (If equal 0, it will delete) 2) \texttt{ps1} points to current reference count 3) and current reference count increments 1
	
	\item[Line 4:] Use move 1) In \texttt{ps1}, previous reference count decrements 1. (If equal 0, it will delete) 2) \texttt{ps1} points to current reference count 3) \texttt{ps2} will be set to nullptr. 
	
	\item[Line 5:] Use \texttt{reset}. pointer inside previous \texttt{ps1} will decrement 1. By now, current \texttt{ps1} points to \texttt{cp} and reference count will be 1.
\end{description}

	\par In summary, when assignment, decrement previous reference count by 1 and increment current reference count by 1; When copy constructor, increment current reference count by 1; When constructor from raw pointer, current reference count is 1;


\begin{center}
	\includegraphics[width=0.9\linewidth]{pics/shared_ptr.png}
\end{center}


	\par Just observer, not transfer or share ownership , you can get pointer, or use \texttt{shared\_ptr} reference. 
\begin{lstlisting}[numbers = none]
shared_ptr<string> ps1 (new string("ps1"));

fun(string* pstr);
fun(shared_ptr<string>& ref_ptr);
\end{lstlisting}

	\par Usage of \texttt{enable\_shared\_from}. If you don't use it, multiple distinct \texttt{shared\_ptr} objects with separate reference counts. For the same reason you must never create more than one \texttt{shared\_ptr} \textbf{from the same raw pointer}. 
\begin{lstlisting}[frame=single, language=c++]
int * p = new int{123};
shared_ptr sp(p);   //build two shared_ptr from same raw pointer p.
shared_ptr sp1(p);	//That is error, and will cause UB in C++.
	
class Test : public enable_shared_from_this<Test> {
public:
    shared_ptr<Test> GetObject(){
        return shared_from_this();  //correct way.
        //return shared_ptr<test>(this); //wrong way, from the same raw pointer.
    }
};
int main(int argc, char *argv[]){
    shared_ptr<Test> p( new Test( ));
    shared_ptr<Test> q = p->GetObject();
}
\end{lstlisting}

	\par The basic implementation of \texttt{enable\_shared\_this}. It uses CRTP design pattern and I will introduce CRTP design pattern in OOP chapter.  When we construct \texttt{shared\_ptr}, if the type is inherit from \texttt{enable\_shared\_this}, then we initialize a \texttt{weak\_ptr} pointer, later we can build \texttt{shared\_ptr} from this \texttt{weak\_ptr} pointer.  
\begin{lstlisting}[frame=single, language=c++]
template<class T>
class enable_shared_from_this {
	mutable weak_ptr<T> weak_this;
public:
	shared_ptr<T> shared_from_this() {
		return shared_ptr<T>(weak_this); 
	}
}
\end{lstlisting}



\subsection{weak\_ptr basic usage}

    
     The relationship between \texttt{std::weak\_ptr} and \texttt{std::shared\_ptr} begins at birth. \texttt{std::weak\_ptr} are typically created from \texttt{std::shared\_ptr}. You can only create a \texttt{std::weak\_ptr} out of a \texttt{std::shared\_ptr} or another \texttt{std::weak\_ptr}. A truly smart pointer deals with the problem of dangling pointers, where it can track when the object it is supposed to point to doesn't exist, this capability is precisely what \texttt{std::weak\_ptr} provides. You can't test if a raw pointer is dangling or not, but you can judge if a \texttt{weak\_ptr} is dangling or not.
    
    \par \texttt{std::weak\_ptr} can't be dereferenced, nor can they be tested for nullness. That's because \texttt{std::weak\_ptr} isn't a standalone smart pointer. It's an augmentation of \texttt{std::shared\_ptr}. Almost the only things you can do are to interrogate it to see if the managed object is still there, or construct a \texttt{std::shared\_ptr} from it.
    

\begin{lstlisting}[frame=single, language=c++,mathescape=true]
auto spw = std::make_shared<Widget>(); //reference count is 1
std::weak_ptr<Widget> wpw(spw);  //reference count remains 1
...
if (wpw.expired())
\end{lstlisting}

    \par The \texttt{lock()} method creates a new \texttt{std::shared\_ptr} that shares ownership of the managed object. If there is no managed object, the \texttt{shared\_ptr} returned by the method is empty.

\begin{lstlisting}
std::shared_ptr<Widget> spw1 = wpw.lock(); //if wpw's expired, spw1 is nullptr
auto spw2 = wpw.lock(); //same as above, but uses auto
std::shared_ptr<Widget> spw3(wpw); //if wpw expired, throw std::bad_weak_ptr.
\end{lstlisting}

    \par Common uses for \texttt{std::weak\_ptr} includes: caching, observer lists, and the prevention of \texttt{std::shared\_ptr} cyclic dependency.  All the detail can be seen in "Effective Modern ++" Item 20.
\begin{lstlisting}[frame=single, language=c++]
std::shared_ptr<const Widget> fastLoadWidget(WidgetID id){
	static std::unordered_map<WidgetID, std::weak_ptr<const Widget>> cache;
	auto objPtr = cache[id].lock();

	if (!objPtr) { // if not in cache,
		objPtr = loadWidget(id); // load it
		cache[id] = objPtr; // cache it
	}
	return objPtr;
}
\end{lstlisting}
\begin{description}
	\item[Line 5:] \texttt{objPtr} is \texttt{std::shared\_ptr} to cached object,  or \texttt{nullptr} if object's not in cache. For above requirement, you also can use raw pointer, But for raw pointer, you can't detect if original one has been delete. 
\end{description}

    \par An example of \texttt{shared\_ptr} cyclic dependency problem. Below code has memory leak. \texttt{A} and \texttt{B} doesn't have chance to call destructor. This cyclic dependency happens not only in \texttt{shared\_ptr}, but also in the header file and \texttt{std::mutex} scenario.
\begin{lstlisting}[]
class B;
class A {
    shared_ptr<B> sP1; // use weak_ptr instead to avoid CD
public:
    A() {  cout << "A()" << endl; }
    ~A() { cout << "~A()" << endl; }
    void setShared(shared_ptr<B>& p) {
        sP1 = p;
    }
};
class B {
    shared_ptr<A> sP1;
    weak_ptr<
public:
    B() {  cout << "B()" << endl; }
    ~B() { cout << "~B()" << endl; }
    void setShared(shared_ptr<A>& p) {
        sP1 = p;
    }
};
int main() {
    shared_ptr<A> aPtr(new A);
    shared_ptr<B> bPtr(new B);
    aPtr->setShared(bPtr);
    bPtr->setShared(aPtr);
}
\end{lstlisting}



\subsection{make function}

	
	 Never use \texttt{new} operator directly in C++14! Instead, prefer using the \texttt{make\_*()} function. However, if you need a custom deleter or are adopting a raw pointer from elsewhere, you can't use \texttt{make\_unique}. Also note that \texttt{make\_unique} was only introduced in C++14. This function perfect-forwards its parameters to the constructor of the object being created, then constructs a \texttt{std::unique\_ptr} from the raw pointer that \texttt{new} produces, and finally returns the created \texttt{std::unique\_ptr}.
	
	
	\par \texttt{std::make\_unique} and \texttt{std::make\_shared} are two of the three make functions: functions that take an arbitrary set of arguments, perfect-forward them to the constructor for a dynamically allocated object, and return a smart pointer to that object. The third make function is \texttt{std::allocate\_shared}
	
	\par make function has tree advantages: simply, exception safety and allocate once for efficiency.
	
	\begin{itemize}
		\item The \texttt{new} operator requires repeating the type being created, whereas the make functions do not. That's why using the make functions is generally better than using \texttt{new} operator. For a comparison, see the source code below.
		
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
auto upw1(std::make_unique<Widget>()); // use auto, it's better
std::unique_ptr<Widget> upw2(new Widget); 
		
auto spw1(std::make_shared<Widget>()); // better
std::shared_ptr<Widget> spw2(new Widget); 
\end{lstlisting}
		
		\item The second reason to prefer make functions has to do with exception safety. More explanation can be found in "More effective C++" item 21. 
		
		\item The third reason is allocation efficiency. Every \texttt{std::shared\_ptr} points to a control block that contains the reference count for the pointed-to object. When using \texttt{std::make\_shared}, a single chunk of memory is allocated to hold both the Widget object and the control block. If we don't use \texttt{make\_shared}, we would have to perform two separate allocation actions.
		
	\end{itemize}
	
	\par make function has its limitation:
	\begin{itemize}
		\item None of the make functions permit the specification of custom deleter.
		
		\item The perfect forwarding code uses parentheses, not braces. The bad news is that if you want to construct your pointed-to object using a braced initializer, you need to build \texttt{std::initializer\_list} outside and pass it into the make function.
\begin{lstlisting}
template<typename T>
void f(T para);

f({1,2,3}) //error, can't deduce type T

template<typename T>
void f(std::initializer_list<T> initList);
f({1,2,3}) //OK.
\end{lstlisting}

\begin{lstlisting}
auto upv = std::make_unique<std::vector<int>>(10, 20); //10 elements: 20, 20, ...
auto initList = { 10, 20 }; //create std::initializer_list outside
auto spv = std::make_shared<std::vector<int>>(initList); // 2 elements: 10 and 20
\end{lstlisting}
\begin{description}
	\item[Line 3:] create \texttt{std::vector} using \texttt{std::initializer\_list} constructor. You need to build \texttt{initializer\_list} variable outside of \texttt{make\_shared}. 
\end{description}
		
		\item As long as \texttt{std::weak\_ptr} refer to a control block (i.e., the weak count is greater than zero), that control block must continue to exist. And as long as a control block exists, the memory containing it must remain allocated. The memory allocated by a \texttt{std::shared\_ptr} make function, then, can't be deallocated until the last \texttt{std::shared\_ptr} and the last \texttt{std::weak\_ptr} referring to it have been destroyed
	\end{itemize}
	
	\par If you can't use make function for one of parameter of a function, you can create \texttt{shared\_ptr} first outside of the function, then \texttt{std::move()} it to the function parameter, it's better for this special scenario. 
\begin{lstlisting}[frame=single, language=c++]
std::shared_ptr<Widget> spw(new Widget, cusDel); //can't use std::make_shared
processWidget(spw, computePriority()); // correct, but not optimal; 

processWidget(std::move(spw),computePriority());//both efficient and exception safe
\end{lstlisting}

%	\item Guideline: Use \texttt{make\_unique} to create an object that is not shared (at least not yet), unless you need a custom deleter or are adopting a raw pointer from elsewhere.
	

%\subsection{Wrapping non-pointer resource in smart pointer}

\subsection{Customize deleter in unique\_ptr and shared\_ptr}

		
		 Both \texttt{std::unique\_ptr} and \texttt{std::shared\_ptr} use \texttt{delete} as their default resource-destruction mechanism, but they also support custom deleters. The deleter type is part of the \texttt{unique\_ptr} type but not part of the \texttt{shared\_ptr} type. \texttt{shared\_ptr} uses type erasure techniques, which are introduced in the "Generic programming" section.
		
\begin{lstlisting}[frame=single, language=c++]
auto loggingDel = [](Widget *pw){ // custom deleter
	makeLogEntry(pw);
	delete pw;
};

std::unique_ptr< Widget, decltype(loggingDel) > upw(new Widget, loggingDel);
std::shared_ptr<Widget> spw(new Widget, loggingDel);		
\end{lstlisting}
	
%	  \item \texttt{unique\_ptr} can input another deleter type. 
%\begin{lstlisting}[frame=single, language=c++, mathescape=true]
%template<class T, class Deleter = std::default_delete<T>> 
%class unique_ptr;
%
%template<typename T, typename D, bool Empty = std::is_empty_v<D>>
%class unique_ptr{
%	T* ptr;
%	D d;
%	...
%};
%
%template<typename T, typename D>
%class unique_ptr<T, D, true> : D{
%	T* ptr;
%	...
%};	
%\end{lstlisting}	
	

	\par \texttt{unique\_ptr} can input another deleter type. Below is a few kind of deleter and their size comparison.
	\begin{enumerate}
		\item \texttt{std::function} - heavy stuff, on a 64 bit machine, gcc shows that it occupies 40 bytes.
		
		\item Function pointer - it’s just a pointer, so now \texttt{unique\_ptr} contains two pointers: for the object and for that function, so \texttt{2*sizeof(ptr)} (16 bytes on the 64 bits machine).
		
		\item \textbf{Stateless functor (and also stateless lambda)} - it’s actually very tricky thing. You would probably say: two pointers, but it’s not. Thanks to empty base optimization - EBO the final size is just a size of one pointer, so the smallest possible thing.
\begin{lstlisting}
template<typename T, typename D, bool Empty = std::is_empty_v<D>>
class unique_ptr{
	T* ptr;
	D d;
	//..
};

template<typename T, typename D>
class unique_ptr<T, D, true> : D{
	T* ptr;
	// ...
};
\end{lstlisting}

\begin{lstlisting}[frame=single, language=c++]
Foo* createObject(int i_val, double d_val) {
	Foo* output = (Foo*)malloc(sizeof(Foo));
	return output;
}
struct FooDeleter {
	void operator()(Foo* p) const {
		destroy(p);
	}
};

using FooWrapper = std::unique_ptr<Foo, FooDeleter>;
FooWrapper foo{createObject(32, 3.14), FooDeleter{}};	
\end{lstlisting}

		
		\item State-full functor or Lambda - if there is some states inside the functor then we cannot do any optimizations, so it will be the size of ptr + sizeof(functor)
	\end{enumerate}

%	\item For stateless functors or lambdas, the size is just one pointer, which means we don't need to pay a space fee. That's why \texttt{unique\_ptr} has two template parameters, and one of them allows you to specify the deleter type. If the deleter type is an empty stateless functor, the size will be just one pointer. If you don't care about space, but value flexibility (e.g., you want to pass any caller-callable object), you can always add your own type erasure on top by using \texttt{std::function}. For example, you can have \texttt{unique\_ptr<T, std::function<void(T*)> >}.
		


	\par The \texttt{std::shared\_ptr} template has only one template parameter though: the type of the pointee. But you can use a custom deleter too, even though the deleter type is not in the class template, \textbf{std::shared\_ptr and std::functions use the same type erase technology to hold the various type callable object.} you can see the type erase technology in generic programming chapter later. Why do we have different design for \texttt{std::shared\_ptr} and \texttt{std::unique\_ptr} when considering customized deleter? Part of the reason is that \texttt{std::shared\_ptr} needs an explicit control block anyway for the ref count and sticking a deleter in isn't that big a deal on top. \texttt{unique\_ptr} however doesn't require any additional overhead, and adding it would be unpopular- it's supposed to be a zero-overhead class. 
	%\texttt{unique\_ptr} is supposed to be static. 
\begin{lstlisting}[frame=single, language=c++]
Foo* createObject(int i_val, double d_val) {
	Foo* output = (Foo*)malloc(sizeof(Foo));
	return output;
}

void destroy(Foo* obj) {
	free(obj);
}

std::shared_ptr<Foo> foo(createObject(32, 3.14), destroy);
\end{lstlisting}

%	\item In order to correctly use \texttt{shared\_ptr} with an array, you must supply a custom deleter. But we don't recommend using \texttt{shared\_ptr} with array. \textbf{Any time you new a array, you should first consider using STL container directly.}
%\begin{lstlisting}[numbers=none]
%template< typename T >
%struct array_deleter {
%	void operator ()( T const * p){
%		delete[] p;
%	}
%};
%
%shared_ptr<int> sp(new int[10],array_deleter<int>());	
%\end{lstlisting}


	
%		\item Based on the previous introduction about customized deleters, we can manage \texttt{FILE*} with smart pointers using the source semantic of \texttt{unique\_ptr}.
%\begin{lstlisting}[frame=single, language=c++]
%struct FILEDeleter {
%	void operator()(FILE *pFile){
%		if (pFile)
%		fclose(pFile);
%	}
%};
%using FILE_unique_ptr = unique_ptr<FILE, FILEDeleter>;
%
%FILE_unique_ptr make_fopen(const char* fname, const char* mode){
%	FILE *fileHandle= nullptr;
%	auto err = fopen_s(&fileHandle , fname, mode);  
%	return FILE_unique_ptr(fileHandle); 
%}
%
%FILE_unique_ptr pFilePtr = make_fopen("test.txt", "rb"); //no need to call fclose
%\end{lstlisting}		
%		
%		\item Just the same idea, if you want to use \texttt{shared\_ptr} wrap \texttt{FILE*}, see below example.
%\begin{lstlisting}[frame=single, language=c++]
%using FILE_shared_ptr = std::shared_ptr<FILE>;
%
%FILE_shared_ptr make_fopen_shared(const char* fname, const char* mode){
%	FILE *fileHandle = nullptr;
%	auto err = fopen_s(&fileHandle, fname, mode);
%	return FILE_shared_ptr(fileHandle, FILEDeleter()); // FILEDeleter() is variable, not type
%}	
%\end{lstlisting}		
%		
%		\item For \texttt{fstream}, it is different from \texttt{FILE*} as it uses value semantics and implements RAII. If you need to share ownership, you can pass a reference directly since it does not support copying.
%		
%\begin{lstlisting}[numbers=none]
%fp = fstream(name,mode)};
%setLogFile(ifstrea& );
%setLogFile(fp);
%\end{lstlisting}

	
%		\item For \texttt{unique\_ptr}, if you can deduct pointer type from deleter, \texttt{unique\_ptr} will use it directly, so you just know SC\_HANDLE is a kind of "pointer", but you don't know exact type, you can write just like below.  That is because in \texttt{unique\_ptr}, If you provide and deleter and inside deleter, you also provide pointer type. If that type exists, we use this as resource type, otherwise \texttt{T*}. Must satisfy NullablePointer.
%
%\begin{lstlisting}[frame=single, language=c++]
%struct SvcHandleDeleter{
%	typedef SC_HANDLE pointer; //define pointer type here
%	SvcHandleDeleter() {};
%	
%	void operator()(pointer h) const {
%		CloseServiceHandle(h);
%	}
%};
%	
%typedef std::unique_ptr<SC_HANDLE,SvcHandleDeleter> unique_sch;
%//you define pointer in side the deleter, so we use SC_HANDLE, not SC_HANDLE* 
%	
%unique_sch scm(::OpenSCManagerA(0, 0, SC_MANAGER_ALL_ACCESS));
%\end{lstlisting}
%	
%	\item For shared pointer, type-erasure makes it impossible with the current interface to achieve exactly what type you want. So you can use a dumb way, Just like a pointer to pointer. If you don't know what is behind SC\_HANDLE. 
%	
%\begin{lstlisting}[frame=single, language=c++]
%std::shared_ptr<SC_HANDLE> sp(new SC_HANDLE(
%              ::OpenSCManagerA(0, 0, SC_MANAGER_ALL_ACCESS)),
%	[](SC_HANDLE* p){ ::CloseServiceHandle(*p); delete p; });
%\end{lstlisting}
%
%		\item Different with previous example, if you know \textbf{HANDLE in windows is just void* type pointer}, so you can use this way to deal with windows handle. it will save you a lot of trouble. 
%	
%\begin{lstlisting}[frame=single, language=c++]
%struct HANDLEDeleter{
%	void operator()(HANDLE handle) const{
%		if (handle != INVALID_HANDLE_VALUE)
%		CloseHandle(handle);
%	}
%};
%	
%using HANDLE_unique_ptr=unique_ptr<void, HANDLEDeleter>;
%	
%HANDLE_unique_ptr make_HANDLE_unique_ptr(HANDLE handle){ ...
%	return HANDLE_unique_ptr(handle);
%}
%	
%auto hInputFile = make_HANDLE_unique_ptr(
%                            CreateFile(strIn, GENERIC_READ, ...));
%\end{lstlisting}
	
%	\par Use \texttt{shared\_ptr} to wrap a handle, A good introduction is "Making a HANDLE RAII-compliant using \texttt{shared\_ptr} with a custom deleter" in stackoverflow

	
\section{Smart pointer usage}
\subsection{Smart pointer and polymorphism}

\subsubsection{Pointer\_cast function}
	 The basic idea is that \texttt{shared\_ptr<Base>} and \texttt{shared\_ptr<Derived>} are not covariant at all. This is similar to how \texttt{vector<Base>} and \texttt{vector<Derived>} works. Even \texttt{Derived} inherit \texttt{Base},  You can't cast \texttt{shared\_ptr<Derived>} to \texttt{shared\_ptr<Base>} because there is no inheritance relationship between two shared pointer types. 
	
	\par The \texttt{shared\_ptr<T>(const shared\_ptr<Y>\&)} constructor doesn't help because it is only usable if \texttt{Y*} is implicitly convertible to \texttt{T*}, i.e. it is there to support the same pointer conversions as would happen implicitly, like \texttt{Derived*} to \texttt{Base*,} not \texttt{Base*} to \texttt{Derived*}. That is why we need \texttt{static\_pointer\_cast}.
\begin{lstlisting}
template< class T, class U > 
std::shared_ptr<T> static_pointer_cast( const std::shared_ptr<U>& r ) noexcept {
    auto p = static_cast<typename std::shared_ptr<T>::element_type*>(r.get());
    return std::shared_ptr<T>{r, p};
}
\end{lstlisting}
\begin{description}
	\item[Line 4:] That is called aliasing \texttt{shared\_ptr} constructor, detail can be google "std::shared\_ptr's secret constructor"
\end{description}

	\par An example of \texttt{static\_pointer\_cast} is below:
\begin{lstlisting}
struct Base {};

struct Derived : Base {
	void f() const {
		std::cout << "Sample word!\n";
	}
};

int main() {
	std::shared_ptr<Base> ptr_to_base(make_shared<Derived>());
	std::static_pointer_cast<Derived>(ptr_to_base)->f();
	std::dynamic_pointer_cast<Derived>(ptr_to_base)->f();
	static_cast<Derived*>(ptr_to_base.get())->f(); 
}
\end{lstlisting}


\subsubsection{Four casts in polymorphism}
 In this section, you need to know four types of smart pointer casting.
\begin{enumerate}
\item \texttt{share\_ptr} of Derived to \texttt{share\_ptr} of Base;
\item \texttt{share\_ptr} of Base to \texttt{share\_ptr} of Derived (down cast);
\item \texttt{unique\_ptr} of Derived to\texttt{share\_ptr} of Base;
\item \texttt{unique\_ptr} of Base to \texttt{share\_ptr} of Derived (down cast);
\end{enumerate}

		\par For \texttt{shared\_ptr}, it support Derived to Base copy or assignment. Behind the hood, you need to know the template member function. Detail can be found in effective C++ item 45 "Use member function templates to accept all compatible types". Why can you do that? because it get raw pointer and wrapped it again and compiler allow it.

		\par  For \texttt{shared\_ptr} of Base, you can't assign it to the \texttt{shared\_ptr} of Derived, so you must use \\ \texttt{static\_pointer\_cast} and \texttt{dynamic\_pointer\_cast}. They only support \texttt{shared\_ptr} and use \texttt{shared\_ptr} aliasing constructor, get raw pointer, use static or dynamic cast, then build Derived \texttt{shared\_ptr} too. Detail can be found: "std::static\_pointer\_cast vs static\_cast<std::shared\_ptr<A > >"

		\par If you don't want to shared ownership, but just want to be a observer, you can use reference, but for \texttt{shared\_ptr} Base reference, You have to use const. Why do we need const?
	
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
void doSomething(const std::shared_ptr<Base>& ptr) {
    std::cout<<ptr.use_count()<<std::endl; 
}

std::shared_ptr<Derived1> pd1 = std::make_shared<Derived1>();
//doSomething(pd1);  Will not compile here.
doSomething(shared_ptr<Base> temp(pd1)); //from pd1 build temporary shared_ptr<Base>
doSomething(static_pointer_cast<Base>(pd1));
\end{lstlisting}
	\begin{description}
	\item[Line 8:] \texttt{static\_pointer\_cast} also return a temporary base \texttt{shared\_ptr}. That is why you need \texttt{const} in line 1
\end{description}


	\par The static cast can also be used for checking downcasts, but it checks at compile time and may sometimes fail. Unlike the dynamic cast, which checks at run time and requires the class to have at least one virtual function. More details about this can be found in the second chapter. The basic idea is similar to the distinction between \texttt{static\_cast} and \texttt{dynamic\_cast}.

	\par For \texttt{unique\_ptr}, You can use \texttt{std::move} from Derived \texttt{unique\_ptr} to Base \texttt{unique\_ptr} directly.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
void doSomething(const std::unique_ptr<Base> ptr) {
    ptr->run();
}

std::unique_ptr<Derived1> pd1 = std::make_unique<Derived1>();
doSomething(std::move(pd1));
\end{lstlisting}

	\par For down cast \texttt{unique\_ptr}, There are no counter part of \texttt{static\_pointer\_cast}. So only way you can do is use release and wrap it again.

\begin{lstlisting}[frame=single, language=c++, mathescape=true]
template<typename TO, typename FROM>
unique_ptr<TO> static_unique_pointer_cast (unique_ptr<FROM>&& old){
	return unique_ptr<TO>{static_cast<TO*>(old.release())};
	//conversion: unique_ptr<FROM>->FROM*->TO*->unique_ptr<TO>
}

unique_ptr<Base> foo = fooFactory();
unique_ptr<Derived> foo2 = static_unique_pointer_cast<Derived>(std::move(foo));
\end{lstlisting}

	\par For const reference, there are three methods: 1) Use \texttt{std::move} 2) Change function interface 3) Change parameter.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
void f(const unique_ptr<Base>& base)
unique_ptr<Derived> derived = unique_ptr<Derived>(new Derived{});

f(derived); //this fail;

f(std::move(derived)); //method 1 work, Why?
//because int i = 3; const float& dr = i; compile OK
                       
void f(std::unique_ptr<Derived> const&); //method 2, Change function interface

std::unique_ptr<Base> derived = std::make_unique<Derived>(); //or
std::unique_ptr<Base> derived(new Derived); //method 3, Change parameter.
f(derived); //this work
\end{lstlisting}


	\par You can use smart pointer in both a braced scope (like a function) and a class scope. In these scope, smart pointers can manage exclusive ownership, shared ownership, or act as observers. In the following sections, I will delve into the relationship between smart pointers and classes, as well as their role in functions.

\subsection{Smart pointer and Semantic of RAII}

	
	 The fundamental concept of RAII (Resource Acquisition Is Initialization) is to encapsulate a resource within a local object, RAII objects acquire resources in their constructors and release them in their destructors, ensuring resource cleanup and preventing resource leaks.	
	
	\par In OS, memory is resource and can be accessed by a pointer, for this kind of resource, two famous RAII classes are \texttt{std::unique\_ptr} and \texttt{std::shared\_ptr}. 
	
	\par Other resources like file handle, \texttt{std::thread} and \texttt{std::mutex}, they all requires paired acquire/release function calls, such as \texttt{fopen}/\texttt{fclose} for file handle, \texttt{lock}/\texttt{unlock} for \texttt{std::mutex}. In this way, \texttt{fstream} class, \texttt{jthread} class and \texttt{lock\_guard} class are all RAII classes. For example, you can think of \texttt{lock\_guard} as a smart mutex that encapsulates a \texttt{std::mutex}, much like \texttt{unique\_ptr} encapsulates a raw pointer. 
	
	\par When working with OS, resources extend beyond simple memory or file handles. They can be other handles in WinAPI, we can also deal with this kind of resources by RAII idea


\begin{lstlisting}[numbers=none]
class RAII_Handle {
public:
	explicit RAII_Handle(std::wstring const& name)
	: handle { ::LoadLibrary(name.c_str()) } {}
	
	~RAII_Handle{
		::FreeLibrary();
	}
private:
	HMODULE handle;
};	
\end{lstlisting}

%	\item Whenever you're dealing with a resource that requires paired acquire/release function calls, it's crucial to encapsulate that resource in an object. Examples of such resources include , and \texttt{new}/\texttt{delete}. It's important to generalize resources, whether they're represented by a pointer \texttt{*p} pointing to a new object or a file handle. For instance, you can encapsulate a file handle in an \texttt{ifstream} and a pointer \texttt{*p} in a smart pointer.
%
%\begin{lstlisting}
%	FILE* fp = fopen("/path/to/file"); //C version,
%	// throw exception here, then resource leaking
%	fclose(fp); //this statement will not be executed. 
%	
%	fun{ //c++ version, fstream is RAII calss
%		fstream if("path/to/file")
%		if.getline()
%		// you don't need to if.close().
%	}
%	
%	std::unique_ptr<FILE, int(*)(FILE*)> myFile( fopen("myfile", "rb"),  fclose );              
%\end{lstlisting}
%\begin{description}
%	\item[Line 12] use smart pointer to wrap \texttt{FILE*} in C language. the custom deleter type is function pointer. The deleter function is: \texttt{fclose()} 
%\end{description}

%	\item Wrapping a pointer into a RAII class. Why do you use raw pointer? Maybe you need some customized action in runtime, or use handle is only method to use this resource or any other reason. And this time, you have to write your own destructor to release the resource.
%\begin{lstlisting}[numbers=none]
%class RAII_Class {
%	~RAII_Class(){//release m_resource here}
%private:
%	Resource* m_resource;	
%};	
%\end{lstlisting}

	\par When implementing RAII, be conscious of copy construction and assignment. The compiler-generated version probably won't be correct because it will cause two pointers or handles to refer to the same resource, which is absolutely a bad smell in code. Therefore:
\begin{itemize}
	\item If it's not copyable, use \texttt{=delete} on copy constructor. \texttt{std::unique\_ptr} is a good example of this idea.
	
	\item If it is copyable value semantic, duplicate the resource and follow the 'Rule of Four and Half'. Both \texttt{std::vector} and \texttt{std::string} are good examples of this idea.
\begin{lstlisting}[numbers=none]
Class RAII_Class{
	RAII_Class(const RAII_Class& rhs){
		m_resource = new Resource( *(rhs.m_resource));
	}
	
	RAII_Class(RAII_Class&& rhs){
		m_resource = rhs.m_resource;
		rhs.m_resource = nullptr;
	}
private:
	Resource* m_resource;
}		
\end{lstlisting}
	
	\item If it's copyable reference value, recommend to use \texttt{std::shared\_ptr} to manage it's lifetime to avoid 1) memory leak and 2) dangling pointer. 
\end{itemize}
			
	\par Smart pointers in C++ are good examples of RAII, but they go further. \texttt{std::unique\_ptr} denotes exclusive ownership by deleting its copy constructor at the syntax level, while \texttt{std::shared\_ptr} represents shared ownership by maintaining a reference count. In other words, smart pointers are not only RAII classes, but they also represent two different types of ownership.

	\par Next, I would like to talk about some common patterns of using RAII classes when defining your own class. You can use an RAII member or use a smart pointer to wrap resources in your own classes. When using a smart pointer, you want to express different ownership semantics. First and foremost, it's not recommended to use raw pointers directly unless you have strong reason.

	\begin{itemize}
		\item Use RAII member, In this way, you don't need to build destructor manually.
\begin{lstlisting}[]
struct Foo{
	string m_str; // RAII class
	vector<int> m_vc; //RAII class
};
\end{lstlisting}
			
				\begin{enumerate}
					\item RAII class and your own class have same life duration.
					
					\item \texttt{m\_str} and \texttt{m\_vc} are value semantic, so there is no ownership concern and is copyable(\texttt{Foo f1 = f2;}) and can move with efficiency(\texttt{Foo f1 = std::move(f2);} ). 
					
					\item If all members are RAII classes (have it's own copy and move special function), You don't need to write any special function in your class (\texttt{Foo}). Just follow the "Rule of Zero".
				\end{enumerate}
					
	\item Use smart point to wrap resource (pointers or handles) inside a class;
\begin{lstlisting}[numbers=none]
class RAII_Container {
	unique_ptr<string>  m_uniptr;
	vector<unique_ptr<int> > vc;
};
		\end{lstlisting}
\begin{enumerate}
	
		\item  When you wrap handle, you can custom this delete behavior. See source code below:
\begin{lstlisting}[numbers=none]
class module {
public:
	explicit module(std::wstring const& name)
	: handle { ::LoadLibrary(name.c_str()) } {}
private:
	using module_handle=std::unique_ptr<void,decltype(&::FreeLibrary)>;
	module_handle handle;
};
\end{lstlisting}
	\item For \texttt{unique\_ptr}, it has the following characteristics: 1) the same lifetime as the owning object, 2) exclusive ownership and not copyable by default, and 3) supports move operations. You can still follow the "rule of zero," meaning that you don't provide any customized special member functions, and the class will not be copyable. 

	\item For \texttt{shared\_ptr}; 1) same lifetime 2) shared ownership, 3) copyable and moveable. When you move a \texttt{shared\_ptr}, origin one is set to nullptr and ref count doesn't increase. You can still follow "rule of zero".
	
\begin{lstlisting}[numbers=none]
class Student{
	shared_ptr<SchoolBus> pBus;
}				
\end{lstlisting}
			
\end{enumerate}

	\end{itemize}

		
	\par A design example, suppose I want to design a \texttt{Car} class where people can change its engine, and it should support copying. In this context, your \texttt{Car} class should use raw pointers because: 1) value semantic members don't support customization (dynamic changes), and 2) \texttt{unique\_ptr} doesn't support copying. Therefore, you have to use \texttt{Engine *pEn} and follow the "Rule of Four and Half."
\begin{lstlisting}[numbers=none]
class Car{
	Engine *pEn; //follow "Rule of Five"
	~Car(){delete pEn} // assure RAII
}
\end{lstlisting}
		
	\par For some other non-copyable contexts, such as: 1) a Person class where the semantics require non-copyability, 2) situations where performance is a consideration, such as a \texttt{class Big \{int [30000];\}}, and 3) situations where the implementation constrains copying, such as a class with noncopyable member. In such contexts, you can use \texttt{unique\_ptr} to manage resources and make them uncopyable.
\begin{lstlisting}[numbers=none]
class Person{
    uniqu_ptr<Resource> pRes;
}
\end{lstlisting}
		
	\par In summary, design your class according to semantics. Don't use features just because the syntax supports them; instead, use them because they better represent relationships and constraints in real life.
	



\subsection{Smart pointer and function}

     \textbf{Inside a function}

\begin{itemize}
    \item When you want to create dynamically or large array, don't use new, consider STL container first.

    \item When you have to use new, and this function has \textbf{Ownership of pointer, means that they have the same life duration},  use \texttt{unique\_ptr}. In this way, you don't need delete and it's exception safe.
\end{itemize}
\begin{lstlisting}
fun(){
  Foo fo(1,2); //It makes obj directly, when you don't need dynamic.
  
  if(input == "Foo")
    uniqu_ptr<Foo> up(new Foo(1,2)); //dynamic, use new and smart pointer wrap it
}
\end{lstlisting}

    \par \textbf{Parameters of a function.}

\begin{itemize}

    \item Passing \texttt{unique\_ptr} by reference is for in/out \texttt{unique\_ptr} parameters. When the function is supposed to actually accept an existing \texttt{unique\_ptr} and potentially modify it to refer to a different object. 

    \item \texttt{const unique\_ptr} \& MUST be a observer. Another way is to use raw pointer as a observer directly, or use \texttt{std::weak\_ptr} parameter to accept \texttt{std::shared\_ptr} argument. 

    \item If you want to transfer ownership to callee from caller, use \texttt{std::uniqu\_ptr} and use \texttt{std::move}. Passing \texttt{std::unique\_ptr} by value means "sink".

    \item If you want to shared ownership to callee from caller, use \texttt{std::shared\_ptr}.

    \item Use a non-const \texttt{std::shared\_ptr\&} parameter only to modify the \texttt{std::shared\_ptr}. Use a \texttt{const shared\_ptr\&} as a parameter only if you're not sure whether or not you'll take a copy and share ownership; otherwise use \texttt{widget*} instead (or if not nullable, a \texttt{widget\&)}.

    \item When you assign \texttt{std::unique\_ptr} to \texttt{std::shared\_ptr}, use \texttt{std::move}.
\end{itemize}

\begin{lstlisting}[frame=single, language=c++]
Foo *fo = new Foo();  //bad style here.
fun(Foo * p);
delete fo;

fun(Foo &p); //use reference to improve efficiency

uniqu_ptr<Foo> up(new Foo() );
fun(uniqu_ptr<Foo>& up); //use reference, can't copy 

fun(uniqu_ptr<Foo> down);  //prototype
fun(std::move(up) ); //use move to transfer ownership.

std::unique_ptr<std::string> unique = std::make_unique<std::string>("test");
std::shared_ptr<std::string> shared = std::move(unique);
\end{lstlisting}


\par \textbf{Return from function.}
\begin{itemize}

    \item In below example, caller of \texttt{getExclusiveResource()} is a single owner, so return \texttt{unique\_ptr}.

\begin{lstlisting}[numbers=none]
unique_ptr<Foo> getExclusiveResource(){  // this is better.
........
	return unique_ptr<Foo>(new Foo{}) ;
}
\end{lstlisting}

	\item Below code use \texttt{shared\_ptr}, because \texttt{Server} is shared by all users, no by a single exclusive owner.
\begin{lstlisting}[numbers=none]
shared_ptr<Server> buildNewServer(){  // this is better.
	return shared_ptr<Server>(new Server()) ;
}

shared_ptr<Server> serverForClass1 = buildNewServer();
shared_ptr<Server> serverForClass2  = serverForClass1;
\end{lstlisting}

	\item If you are not sure about the ownership, return \texttt{unique\_ptr}, because you can convert \texttt{unique\_ptr} to \texttt{shared\_ptr} if necessary.
\end{itemize}

    \par About smart pointer and function interface. There is a good article. "GotW \#91 Solution: Smart Pointer Parameters"

\section{Smart pointer summary}

\subsection{Difference between value semantic and reference semantic}
	
	 A type has value semantics if the object's observable state is functionally distinct from all other objects of that type. This means that copying an object creates a new object, and modifications to the new object do not affect the original. In C++, all primitive types such as \texttt{bool}, \texttt{int}, \texttt{double}, and \texttt{char} exhibit value semantics. Container types in the STL such as \texttt{std::pair}, \texttt{std::vector}, \texttt{std::string}, and \texttt{std::map} also have value semantics.
	
	\par On the contrary, reference semantics do not involve copying an object. For example, when dealing with a person object, it's inappropriate to create a copy of one person from another. A type exhibits reference semantics if an instance of that type can share its observable state with another object external to it, such that changes made to one object affect the state of another.
	
	\par With reference semantics, assignment is a pointer-copy (i.e., a reference). Value semantics mean assignment copies the value, not just the pointer. C++ gives you the choice: use the assignment operator to copy the value (copy/value semantics), or use a pointer-copy to copy a pointer (reference semantics). C++ allows you to override the assignment operator to do anything your heart desires, however the default (and most common) choice is to copy the value.
	
	\par If a type wishes to have value semantics and needs to be stored dynamically allocated objects (\texttt{std::vector} is such case), it must perform \textbf{deep copies} during copy operations and copy assignment. This involves allocating new copies of the dynamically allocated objects in the customized copy constructor and assignment operator. 
	

	
	\par Should I normally use pointers to freestore allocated objects for my data members, or should I use “composition”? The answer is composition because it avoid extra layer of indirection. At the same time, the performance of the typical implementation of \texttt{malloc()} degrades when there are many allocations; OO software can easily become “freestore bound” unless you’re careful.
	
	There are two cases you have to use pointer, 1) A flexible content container, such as \texttt{std::vector}; 2) you need dynamic binding, because only pointer/reference support dynamic binding, such as strategy design pattern code below. 
\begin{lstlisting}
class Foo{
	Goo goo;  //composition, better performance.
	Goo* p_goo //pointers, not good performance. 
}

class Context{ //strategy in design pattern. 
	Strategy* strategy_;	
	//std::unique_ptr<Strategy> strategy_; //another way is to use unique_ptr
	...
\end{lstlisting}
	
%	The advantage of value semantics is easier lifetime management. Objects with value semantics must be stack-allocated, members of other objects, or elements within containers.
	
%	\item In C++, pointers have value semantics in terms of which object they point to, but they exhibit reference semantics in terms of the state of the object they point to. Typically, for classes designed with reference semantics, the copy constructor should be deleted to prevent unintentional copies. While objects with reference semantics cannot be directly copied, they can be accessed using pointers or references.

	\par Is smart pointer value semantic or reference semantic? Smart pointers in C++ generally exhibit reference semantics rather than value semantics. 
\begin{itemize}
	
	\item  Smart pointer is a kind of "wrapper" class. That is to say, it "wraps" a pointer, not "points" to a pointer. It is generally advised not to define a smart pointer in the following manner:
	
\begin{lstlisting}[numbers=none]
shared_ptr<Foo>* pFoo = new shared_ptr<Foo>(new Foo); //Wrong semantic.
\end{lstlisting}	
		
	\item When we just want to express reference semantic, smart pointer is also much better than raw pointer. Below code demonstrates how to use smart pointer to express reference semantic.
	
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
typedef shared_ptr<Parent> ParentPtr;

class Child : boost::noncopyable{
	explicit Child(const ParentPtr& myDad_) :myParent(myDad__){}
	..
private:
	weak_ptr<Parent> myParent;
}; 

typedef shared_ptr<Child> ChildPtr;
class Parent: public enable_shared_from_this<Parent>, private boost::noncopyable{
  	void addChild(){
  		myChild.reset(new Child(shared_from_this()));
  	}
private:
	ChildPtr myChild;
};
--------------------------------
ParentPtr p(new parent);
p->addChild(); //Child is created by parent.
\end{lstlisting}
\begin{enumerate}
	\item First, we should not use raw pointer to refer to each other, it's reference semantic, you can't know if the object which you refer is still valid.
	
	\item Then, you can't use two \texttt{shared\_ptrs} here. otherwise, it will cause cyclic reference.
	
	\item Then, you have to use one \texttt{shared\_ptr} and one \texttt{weak\_ptr}. Usually, owner (\texttt{Parent}) has \texttt{shared\_ptr}, the counter part (\texttt{Child}) has \texttt{weak\_ptr}. 
	
	\item \texttt{std::weak\_ptr} must use \texttt{std::shared\_ptr} to initialize. 
	
	\item In line 13, you can't use \texttt{this} here, because it is a raw pointer. Building \texttt{std::shared\_ptr} with raw pointer builds a new control block within it. A solution is to use \texttt{shared\_from\_this}.
\end{enumerate}

\end{itemize}
	
	\par In C++, you can pick and choose where you want reference semantics (pointers/references) and where you’d like value semantics (where objects physically contain other objects etc). In a large system, there should be a balance. C++ gives us an ideal situation: we choose reference semantics for objects that need unique identity or that are too large to copy, and we can choose value semantics for the others. Thus the highest frequency objects will end up with value semantics, since we install flexibility where it doesn’t hurt us (only), and we install performance where we need it most!

\subsection{Smart pointer usage suggestions}

	
	 Instead of using C \texttt{FILE*} and \texttt{char*} as strings, it's better to use the \texttt{std::fstream} class and \texttt{std::string} class. As a RAII classes, they are exception-safe and provide better type safety and memory management compared to \texttt{FILE*} and\texttt{ char*}. 

	
	\par In the implementation of smart pointers, several common C++ language characteristics are often utilized. For instance, \texttt{unique\_ptr} optimizes its base class to be empty, \texttt{shared\_ptr} employs type erasure techniques, and \texttt{enable\_from\_this} uses the Curiously Recurring Template Pattern (CRTP). These techniques are not only interesting but also highly valuable to learn and apply in future projects.
	
	
	\par You must ensure that there is only one manager object for each managed object. This is achieved by designing your code so that when an object is first created, it is immediately given to a \texttt{shared\_ptr} to manage. Any additional \texttt{shared\_ptrs} or \texttt{weak\_ptrs} that need to point to that object should be directly or indirectly copied or assigned from the initial \texttt{shared\_ptr}. The standard practice to achieve this is to construct the new object using a \texttt{shared\_ptr} constructor or to use the \texttt{make\_shared} function. 
	
	\par Sometimes, factory methods return a plain pointer to the object they create. In such cases, however, the caller should generally immediately assign this returned object to a \texttt{shared\_ptr} or \texttt{unique\_ptr}. 
	
%	Methods should return plain pointers only when it is intended for the caller to manage the ownership of the object (either exclusive ownership or shared ownership).
	


	\par Methods can take plain-pointers as their arguments for just observe it. Or use smart pointer to transfer or get ownership.
\begin{lstlisting}[frame=single, language=c++]
ObserveFun(Foo* p);
ObserveFun(unique_ptr<Foo> &p); //Just observer.

UniqueFun(unique_ptr<Foo> p);  //exclusive ownership
UniqueFun(make_unique_ptr<Foo>(new Foo() )); //get ownership
UniqueFun(move(other_unique_ptr) )  //transfer ownership

SharedFun(shared_ptr<Foo> p);
\end{lstlisting}

	\par If you want to fully leverage the benefits of smart pointers, it's crucial to avoid using raw pointers to refer to the same objects. Doing so can easily lead to issues such as dangling pointers and double deletions. Smart pointers provide a \texttt{get()} function that returns the raw pointer stored internally. However, this function should be used sparingly. It's best practice to keep the raw pointers encapsulated within smart pointers and utilize smart pointers exclusively wherever possible.
	

	\par Using a vector of raw pointers is not considered good design for two main reasons. Firstly, it's difficult to ascertain whether a raw pointer remains valid over time. Secondly, applying algorithms like `remove` on a vector of raw pointers can lead to memory leaks. For more detailed insights, refer to "Effective STL" items 33 and 7. Switching to a vector of smart pointers addresses both of these concerns effectively.
	

	\par Observer pointers are pointers which do not keep the pointed object alive. Raw pointers are OK to used purely as a means to achieve reference semantics and pass around non-owning, observing pointers. Just not to dereference a dangling pointer. A better option is to use \texttt{weak\_ptr}, provided that you have \texttt{shared\_ptr} already.
	

\begin{lstlisting}[frame=single, language=c++]
observe(subject * s1)
observe(weak_ptr<subject> wptr) //no owner and life time policy with weak_ptr
\end{lstlisting}

\par When do we use smart pointers? consider three key policies:
\begin{enumerate}
	\item \textbf{Ownership policy:} uses smart pointer.
	
	\item \textbf{Observer Policy:} uses raw pointer, reference or \texttt{weak\_ptr}. Prefer to use \texttt{weak\_ptr} if it is applicable in your scenario. 
	
	\item \textbf{Nullity Policy:} Not allow nullptr, prefer to use reference. 
\end{enumerate}
\begin{figure}[h!]
	\centering
	\includegraphics[width=0.75\linewidth]{pics/smartPointer.png}
	\caption{When to use smart pointer?}
	\label{fig:smartpointer}
\end{figure}


\chapter{lvalue reference and rvalue reference}

\section{rvalue reference and value category }
\subsection{lvalue, rvalue and value category}
	
	 Each C++ expression, whether an operator with its operands, a literal, a variable name, or any other construct, is characterized by two independent properties: type and value category. Every expression has a certain type, such as the expression 1+2 having the type \texttt{int}. Usually, the index \texttt{operator []} returns a reference type, and \texttt{std::move} returns an rvalue reference type. Furthermore, each expression belongs to exactly one of the three primary value categories: lvalue, prvalue, and xvalue. We will introduce xvalue later.
	
	\par The value categories of an expression determines two important but separate properties. Firstly, they determine whether the expression has an identity, which means it refers to an object with a variable name, even if the name is not explicitly used in the expression. In other words, the compiler needs to know which expressions can legally appear on either side of an assignment statement. For example, \texttt{5=x}; is an illegal statement in C++. Secondly, the value categories determine whether it is legal to implicitly move the expression's value. Specifically, they determine whether the expression, when used as a function parameter, will bind to rvalue parameter types or not.
				
   \par The definition of an lvalue as "something that can be put on the left side of =" is not entirely accurate. This is because even though \texttt{const int a} is also an lvalue, you cannot put \texttt{a} on the left side of =. Instead, an lvalue is characterized by three properties:
\begin{enumerate}
	\item lvalue has an identity: An lvalue refers to an identifiable location in memory and can have its address taken with the \texttt{\&} operator.
	\item lvalue can persist beyond the expression: An lvalue persists beyond a single expression.
	\item lvalue can be copied, but should not be moved (unless you use \texttt{std::move()} manually and explicitly), because the original value needs to remain intact.
\end{enumerate}
\begin{lstlisting}
"abc" //lvalue, string literal is an lvalue.
int a{}; //name varabile 
int& foo();
foo(); //lvalue, because function return reference.
++a; //prefix operator
*(p+1); //dereference of pointer
f.a // if f is lvalue.	
\end{lstlisting}

	\par On the contrary, prvalue has no \textbf{identity}, and will not \textbf{persist} beyond expression and should be moved for certain resource type object for high efficiency. Some rvalue are listed below:
\begin{lstlisting}
42    // literal.
int foo();  
foo(); //rvalue, because function return value (not reference).
a+b;   //result of arithmetic is pralue
&a //address 
satic_cast<double> a //casting and return temporary variable is pravlue
a++; //postfix operator
double{}; //temporary variable	
\end{lstlisting}

	\par Just remember that any expression that evaluates to an lvalue reference (e.g., a function call, an overloaded assignment operator, etc.) is an lvalue. Any function that returns an object by value is an rvalue.

\begin{lstlisting}[frame=single, language=c++, mathescape=true]
string& lvalue_fun();
lvalue_fun(); 
lvalue_fun() = "hello"; //OK, return value persist.
&lvalue_fun();          //OK, can get address because it has identity

string pvalue_fun();
pvalue_fun(); 
pvalue_fun() = "hello"; //ERROR, no persist.
&pvalue_fun();          //ERROR, no identity 	
\end{lstlisting}

	\par Why doesn't an rvalue persist in C++? Here are some key reasons:
\begin{enumerate}
	\item Storage Optimization: Rvalues are stored differently from lvalues, allowing the compiler more freedom to optimize code for better performance. A value can be stored in a CPU register and may never actually reside in memory, meaning it has no address. This optimization allows for more efficient use of resources.
	
	\item Temporary Nature: Rvalues are semantically temporary. They are often used for operations that produce a new value and are not intended to be accessed again. Because of their transient nature, they are typically stored in temporary locations or optimized away, making it impractical to map them to a specific address.
	
	\item Performance Considerations: Mapping an rvalue to an address would generally be counterproductive. Since rvalues are meant to be short-lived, maintaining a reference to their address could introduce unnecessary overhead and hinder performance optimizations such as register allocation or inlining.
\end{enumerate}	
	

\subsection{lvalue reference}
	 Why do we need to introduce reference in C++? In C++ 98, we introduce reference because some operator overloading functions are simply impossible or inefficient to perform without reference.
\begin{lstlisting}
struct integer { //this is a class
	integer(int v) : value(v) {}
	int value; 
};
//please note here, operator++ is not integer member function.
void operator++(integer i) { // This doesn't actually modify i
	i.value++;
}

//When defining your own operator++ the first argument to the function must be 
//of class- or enumeration-type, as specified in [over.inc]p1 in the C++ Standard:
void operator++(integer* i) { //ill-formed, won't compile
	*i.value++;
}

void operator++(integer& i) {  //only this option work.
	i.value++;
}
\end{lstlisting}

	\par Later, C++ introduces const lvalue references to provide a way to "materialize" an rvalue (temporary). This allows you to bind an rvalue to a reference, enabling functions to take rvalues as parameters without copying them.
\begin{lstlisting}
//integer{2}+integer{3} doesn't work with below function.
integer operator+(integer& i1, integer& i2) {
	return integer(i1.value + i2.value);
}

//integer{2}+integer{3} works with const reference.
integer operator+(const integer& i1, const integer& i2) {
	return integer(i1.value + i2.value);  //i1 and i2 is xvalue here.
}	
\end{lstlisting}

	\par  In other words, only lvalues can bind to non-const reference. Only \texttt{const} references can bind to temporaries and prolong the life of temporary variables (rvalues). Only stack-based \texttt{const} references can work in this way. If a \texttt{const} reference is a class member, it can't work in this way. \texttt{const} references bound to rvalues are widely used in copy constructors before C++11 (case 3 in the code snippet below).
\begin{lstlisting}[frame=single, language=c++]
Foo f(){ //case 1:
	return obj;
}
const Foo & rf = f(); //const reference bind to temporary.

class Foo{ // case 2, 
	Foo(int i);  
};
f(const Foo & crf); //A function f receive Foo object for read-only 
f(1); //from 1 build a temp Foo object, and const reference can bind it.

class Foo{ //case 3, Foo copy constructor
	Foo(const Foo& foo); //without const, line 15 will fail.
}
Foo f3{f1+f2}; //f1+f2 is rvalue	
\end{lstlisting}

     

%\item A \texttt{const} object reference passed into a function, if you want to return it , it must be \texttt{const} too. Usually, It has no any practical meanings when you do in this way. 
%\begin{lstlisting}[numbers=none]
%const int &fun(const int& i){ 
%	return i;
%}
%//or const_cast 
%int &fun(const int& i){ 
%	return const_cast<int&>(i);
%}
%\end{lstlisting}


	\par Rvalues denotes temporaries or objects that act like temporaries. What's special about temporaries is that they are used in a limited way: their value will be read once and then they will be destroyed. This observation is useful in implementing move semantics. So, what are move semantics? Move semantics don't really move a large amount of data; instead, they move an index of data, much like moving a file on a hard disk. If your class allocates a lot of resources, you should implement a copy constructor to avoid shallow copying. However, for some rvalues, performing an expensive deep copy is unnecessary because the temporary variable will disappear and doesn't need to be kept intact. This is where a new type is introduced to distinguish lvalues from rvalues and take different actions: for lvalues, we have to perform deep copy, and for rvalues, we just need to copy the pointer (handle) to the resource (shallow copy), and it's much more efficient.  
\begin{lstlisting}[numbers=none]
Foo::Foo(const Foo & rhs){
	while(ptr++;)
		ptr[i] = foo.ptr[i]  //expensive copy
}

Foo foo1 = foo2; //foo2 is lvalue, we have to copy
Foo foo1 = foo2+foo3; //foo2+foo3 is rvalue, can move to improve effecience. 
Foo foo1 = getFoo(); //rvalue, same
\end{lstlisting}  	


%\subsection{lvalue reference overload}
%\begin{itemize}
%		\item Reference type will not decide overload resolution.
%\begin{lstlisting}[numbers=none]
%void foo(int x)  { std::cout << "foo(int)"   << std::endl; }
%void foo(int& x) { std::cout << "foo(int &)" << std::endl; }
%
%int i = 42;
%int &j = i;
%foo(i);  //ambiguous call
%foo(j);  //ambiguous call, event j is reference type.
%\end{lstlisting}
%
%		\item \texttt{const} will not help to distinguish value and reference type.
%\begin{lstlisting}[numbers=none]
%void foo(int x)  { std::cout << "foo(int)"   << std::endl; }
%void foo(const int& x) { std::cout << "foo(cons int &)" << std::endl; }
%
%int i = 42;
%const int &j = i;
%foo(i); // ambigous call
%\end{lstlisting}
%
%	\item \texttt{const} will help to distinguish between reference type.
%\begin{lstlisting}[numbers=none]
%void foo(int &x)  { std::cout << "foo(int&)"   << std::endl; }
%void foo(const int& x) { std::cout << "foo(cons int &)" << std::endl; }
%	
%int i = 42;
%const int &j = i;
%foo(j); // call const version
%\end{lstlisting}
%
%
%		\item lvalue reference can only bound to lvalue, so we can use value category, help us to pick up the right function.
%\begin{lstlisting}[numbers=none]
%void foo(int x)  { std::cout << "foo(int)"   << std::endl; }
%void foo(int& x) { std::cout << "foo(int &)" << std::endl; }
%
%foo(2);	 //call foo(int x),2 is prvalue, so int& can't matches
%\end{lstlisting}
%
%\begin{lstlisting}[numbers=none]
%void foo(int x)  { std::cout << "foo(int)"   << std::endl; }
%void foo(int& x) { std::cout << "foo(int &)" << std::endl; }
%void foo(const int& x) { std::cout << "foo(cons int &)" << std::endl; }
%	
%foo(2);	 //ambious, 2 is prvalue, so const int & and int both match
%\end{lstlisting}
%
%\item summary:
%\begin{enumerate}
%	\item Given lvalue, reference type and value type produce ambiguous call.
%	\item Given lvalue, constness can't help distinguish reference type and value type.
%	\item Given const lvalue, constness help to distinguish const reference type and lvalue reference type.
%	\item both value and const lvalue reference can match rvalue, but lvalue reference can not. 
%\end{enumerate}
%\begin{center}
%	\begin{tabular}{|c|c|c|c|}
%		\hline
%		& value & lvalue reference  & const lvalue reference  \\
%		\hline
%		lvalue & OK &  OK & OK  \\
%		\hline
%		rvalue & OK & Not & OK   \\
%		\hline
%	\end{tabular}
%\end{center}
%
%\end{itemize}

\subsection{rvalue reference and move semantic}

	

	 We usually use type as the overload resolution method. For reference types, we can use the value category as an overload resolution method too. For example, before C++11, rvalues only matched const lvalue references; they would not match lvalue references. However, const lvalue reference has a problem: const reference can bind to both lvalue and rvalue, so we can't distinguish when to move or when to copy. This is an efficiency problem that we can't change. For rvalues, we sometimes don't want to perform an expensive copy; we want to perform a cheap move instead. That is why we need a new kind of reference type. Once we have such a new reference type, we can allow a function to branch at compile-time (via overload resolution) on the condition "Am I being called on an lvalue or an rvalue?" There are two requirements for the new reference type: it should only bind to rvalues, and we should be able to change it. In the code below, what should "????" be? Although \texttt{foo2} and \texttt{foo2+foo3} have the same type, they have different value categories (one is an lvalue and the other is an rvalue). That is why we invented rvalue references in C++11, which can only bind to rvalues.

\begin{lstlisting}[frame=single, language=c++]
Foo::Foo(const Foo & rhs){ //copy constructor
	while(ptr++;)
	    ptr[i] = rhs.ptr[i]  //expensive copy, O(n) time complexity 
}	

Foo::Foo(???? rhs){  //move constructor
	ptr = rhs.ptr;  //efficient move, just copy pointer itself, O(1) time complexity
	rhs.ptr = nullptr;
}	
	
Foo foo1 = foo2;  //use the first copy constructor
Foo foo1 = foo2+foo3;  //for right value, use move constructor
Foo foo1 = getFoo();  //same as previous line.
\end{lstlisting}

\begin{center}
		\begin{tabular}{|c|c|c|}
			\tophline 
			type & which value category can bind & changable \\
			\tophline 
			lvalue reference & lvalue(non-const)  &  Yes  \\
			\tophline  
			rvalue reference &  rvalue(non-const)&  Yes \\
			\tophline 
			const lvalue reference & lvalue or rvalue(const or non-const) & No  \bottomhline 
		\end{tabular} 
\end{center}

	\par If \texttt{X} is any type, then \texttt{X\&\&} is called an rvalue reference to \texttt{X}, which is a compound type in C++. For better distinction, the ordinary reference \texttt{X\&} is now also called an lvalue reference. Rvalue references will implicitly bind to rvalues and to temporaries that result from implicit conversions. For example, the following is well-formed because \texttt{float} is implicitly convertible to \texttt{int}; the reference would be to a temporary that results from the conversion.
	
	
\begin{lstlisting}
float f = 0f; 
int& i = f;   //can't compile, left value reference only can bind lvalue.
int&& i = f;  //int&& is rvalue reference, an bind to temporary variable.
\end{lstlisting}
	
	\par Rvalue references can be used to extend the lifetimes of temporary objects (note, lvalue references to const can extend the lifetimes of temporary objects too, but they are not modifiable through them):
	
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
std::string s1 = "Test";
std::string&& r1 = s1; //ERROR rvalue reference can't bind to lvalue.
		
const std::string& r2 = s1 + s1;//lvalue reference to const extends lifetime. 
r2+="test" //Error  can't modify through reference to const.
		
std::string&& r3 = s1 + s1; //rvalue reference extends lifetime
r3 += "Test"; //can modify through reference to non-const.                   
\end{lstlisting}
	 
	
	\par Here's an example of code demonstrating move constructor and move assignment in C++. Remember not to declare objects as \texttt{const} if you intend to move from them, as move requests on const objects are silently transformed into copy operations.
	
\begin{lstlisting}[numbers=none]
Foo::Foo(const Foo & rhs){
	while(ptr++;)
	  ptr[i] = rhs.ptr[i]  // expensive copy, copy each element inside array.
}
Foo::Foo(Foo&& rhs){ //no const here
	ptr = rhs.ptr;  //efficient move, just copy one pointer.
	rhs.ptr = nullptr;
}
Foo& Foo::operator=(Foo&& rhs){
	delete[] ptr;   // delete previous resource
	ptr = rhs.ptr;  // efficient move (steal)
	rhs.ptr = nullptr;
	return *this;
}
\end{lstlisting}
	
	\begin{itemize}
		
		\item The move constructor doesn't automatically move resources; you need to implement how to move by yourself. Without a move constructor, the normal copy constructor will treat \texttt{Foo f = f1 + f2;} and \texttt{Foo f = f1;} the same way.
		
		
		\item With move copy constructor, normal copy constructor deal with \texttt{Foo f = f1;}, and move copy constructor deal with \texttt{Foo f = f1+f2;}, for \texttt{f1+f2}, you can move resource, because nobody need to use \texttt{f1+f2} later any more. In move constructor, always set \texttt{rhs.ptr = nullptr}; And no \texttt{const} qualifier in move constructor and move assignment parameter.
		
	\end{itemize}
	
%	\item In below examples, Foo obj1=obj2+obj3. if you don't have move constructor, In operator + function, a temp obj is produced,  and when operator+ function return, another temp obj temp2 is produced .  Then in the end, objtemp2 is passed to ctor,  So, ctor is called three times. and copy content is also called three times.
%	
%\begin{lstlisting}[numbers=none]
%	Foo Foo::operator+( const Foo & f) const {
%			Foo temp = Foo(n+f.n);
%			//copy happen here.
%			return temp;
%		}
%		
%		Foo obj1=obj2+obj3  
%		// three constructor called without move ctor
%	\end{lstlisting}
%	
%	\item If you have move constructor. In operator + function, a temp objtemp1 is produced,  When return objtemp1, It will not produce objtemp2. (because objtemp1 is rvalue.) then objtemp1 is passed to move ctor. In side move ctor, the resource address has been move to new obj1.  Just one temp objtemp1 and one actual copy happen. ( just new pointer = old pointer; and old pointer = NULL).


\section{xvalue}

	In this section, there are three important points:
	\begin{enumerate}
		\item \texttt{std::move} and why do we need a new value type -- xvalue?
		\item Academic definition of xvalue and some practical expressions which are xvalue.
		\item Relationship between xvalue and rvalue reference.
	\end{enumerate}


\subsection{std::move function and xvalue}

	
	 C++11 allows you to use move semantics not just on rvalues, but also, at your discretion, on lvalues. A good example is the swap function, where moving lvalues can significantly improve efficiency. When you want to move a lvalue, you need to use \texttt{std::move()} to change it from lvalue to rvalue. 
	
\begin{lstlisting}[numbers=none]
template<class T> 
void swap(T& a, T& b) { 
	T tmp(std::move(a));
	a = std::move(b);  //std::move function return rvalue.
	b = std::move(tmp);
} 
\end{lstlisting}
	
	%\item By now, \texttt{std::move} must return rvalue, How? If \texttt{std::move} return value? \texttt{std::move(b)} is rvalue, but not good. Because it means that we have to copy input variable once inside \texttt{std::move}, then return the copied one. If \texttt{std::move} return  lvalue reference? \texttt{std::move(b)} is lvalue. If \texttt{std::move} return rvalue reference? \texttt{std::move(b)} is rvalue. Good! 

%    \item \texttt{std::move} returns a rvalue reference, we can put it on the left side of an assignment, so it's not a prvalue. At the same time, we can move it, so it's not an lvalue. The fact that sometimes rvalues could "materialize" and exist in storage in the limited scope of the function, and sometimes not have storage at all, can be confusing. This is why C++ further split up the concept of rvalues and defined the materialized values as xvalues, for "eXpiring values,"; and no-storage values as prvalues, for "pure rvalues." xvalue can both persist and be moved.
    
	\par Before C++ 11, we only use \textbf{persist and identity} to classify value into lvalue and rvalue. Then C++ 11 introduces \texttt{std::move()}. The return value of \texttt{std::move()} is unnamed rvalue reference. This unnamed rvalue reference has identity and move at the same time, so we divide lvalue into lvalue and xvalue and give them new name.  lvalue+xvalue = glvalue(persist)  and xvalue + prvalue = rvalue(move).
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
string str = "hello"
std::move(str)[0] = 'z';  //can persist and modify, print "zello"
string str1 = std::move(str) //can be moved
\end{lstlisting}
	
	\par Any expression must be one of three value categories: lvalue, xvalue, or prvalue. These three categories are complementary. lvalue pay attention to  identity and persist, rvalue = (xvalue + prvalue) shout "I can be moved" loudly. 
	
%	So we call \&\& rvalue reference, don't call it xvalue reference. 
	
		


	
	
\begin{minipage}{.5\textwidth}		
		\includegraphics[width=0.5\linewidth]{pics/xvalue2.drawio.png}
\end{minipage}	
\begin{minipage}{.5\textwidth}		
		\begin{tabular}{|c|c|c|}
			\tophline
			& persist(Has identity) & move \\
			\tophline
			lvalue & Yes & No \\
			\tophline
			pvalue & No & Yes \\
			\tophline
			xvalue & Yes & Yes \bottomhline
		\end{tabular}
\end{minipage}

	\par \textbf{xvalue definition}: a function call or an overloaded operator expression, whose return type is rvalue reference to object. That is to say, an xvalue is the result of certain kinds of expressions involving rvalue references. The result of calling a function whose return type is an rvalue reference is an xvalue. A function returns lvalue reference is lvalue; A function returns value is pvalue, and a function returns rvalue reference is xvalue

	\par In a simple word, xvalue is just value with identity and can be movable. In real life, it's  return value of \texttt{std::move()} or \texttt{static\_cast<A\&\&>}. A better introduction can be seen: " C++11 Tutorial: Explaining the Ever-Elusive Lvalues and Rvalues"

    \par Below code demonstrates some examples of xvalue.
\begin{lstlisting}
string&& xvalue_fun();

xvalue_fun(); //After you call this fun, value still exist. 
xvalue_fun() = "hello"// You can modify because it persist.
&xvalue_fun(); //You can get address because it has identity.
string a = xvalue_fun();// call move constructor, can move.

struct A {
	int m;
};

A&& f();  //f() is xvalue
f().m // f().m is also xvluae
A a;
A&& ar = static_cast<A&&>(a); //static_cast<A&&>(a) is xvalue, but ar is lvalue	
\end{lstlisting}

%\item After C++11, we added two new xvalues.
%\begin{enumerate}
%	\item \texttt{a[n]}, the built-in subscript expression, where one operand is an array rvalue;
%	\item \texttt{a.m}, the member of object expression, where a is an rvalue and m is a non-static data member of non-reference
%\end{enumerate}
	
    \par  \texttt{std::move()} not only doesn't actually move anything, it doesn't even guarantee that the object it's casting will be eligible to be moved. The only thing you know for sure about the result of applying \texttt{std::move()} to an object is that it return a xvalue. In fact, it's just type casting funciton. 

\begin{lstlisting}[frame=single, language=c++]
explicit Annotation(const std::string text)  //because text is const, 
: value(std::move(text)) //call copy constructor of std::string, not move constructor
\end{lstlisting}

	
	\par In summary: We want to move a lvalue, such as in \texttt{std::swap} function, so we have \texttt{std::move()} function. \texttt{std::move()} return neither lvalue nor prvalue, so we have to define a new type of value category: xvalue.
	
\begin{center}	
		\includegraphics[width=0.7\linewidth]{pics/xvalue.png}
		\label{fig:xvalue}
    \end{center}
		
		
	\par Distinguishing these three value categories (lvalue, xvalue and prvalue) is very important when you try to understand \texttt{decltype} deducting rule. I will introduce in "Generic programming" chapter.	

\subsection{Difference between xvalue and rvalue reference}

	 xvalue is defined based on rvalue reference. But you can't think that a rvalue reference is a xvalue. A named rvalue reference is lvalue, and unnamed rvalue reference is xvalue;
	
\begin{lstlisting}[frame=single, language=c++,mathescape=true]
void foo(int&& t) {
	//t is initialized with an rvalue expression, 
	//but is actually an lvalue expression itself inside function foo
}
	
std::string a;   //a, b, c are all lvalue.
std::string& b;
std::string&& c;
\end{lstlisting}

%	\item The most important thing to remember is that value categories classify expressions, not objects, variables, or types. Misunderstanding this distinction can lead to immediate issues. 
	
	\par Objects declared as rvalue references can exhibit characteristics of both lvalues and rvalues. The key criterion is whether the expression has a name: if it does, it's an lvalue; if it doesn't, it's an rvalue (xvalue). For example, in the code snippet below, \texttt{r} has a name, making it an lvalue. However, when \texttt{std::move} is applied to \texttt{r}, the function 'erases' the name through its operation, converting it into an unnamed rvalue reference, which is classified as an rvalue (xvalue).

	
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
void foo(int& );  // #1
void foo(int&& ); // #2

int&& r = 42;
foo(r); // will call #1, because r is lvalue, although type is rvalue reference.
foo(std::move(r)) //std::move return unnamed rvalue reference, will call #2	
\end{lstlisting}	
	
	\par Why is there such confusion? Here are the circumstances under which it is safe to move something:\\
	1) When it's a temporary or sub-object thereof. (prvalue) \\
	2) When the user has explicitly said to move it.
\begin{lstlisting}[frame=single, language=c++]
SomeType &&Func() { ... }
	
SomeType &&val = Func();
SomeType otherVal{val}; // Do you really want to perform "move" here? 
	....
cout<<val; 
\end{lstlisting}
\begin{description}
	\item[Line 6:] What happens if you forget you have "move" in line 4? It will crash! Therefore, the standard states that \texttt{val} is an lvalue because it's a named rvalue reference.
	
\end{description}
	
    \par Another trick applied this idea is when you implement the move constructor in a derived class.
    
\begin{lstlisting}[numbers=none]
Derived(Derived&& rhs):Base(rhs){//wrong, rhs is lvalue, call Base copy constructor
	// Derived-specific stuff
}
	
Derived(Derived&& rhs) : Base(std::move(rhs)){//correct, call base move constructor
	// good, calls Base(Base&& rhs)
}
\end{lstlisting}

	\par Based on previous introduction of rvalue reference and rvalue, the relationship can be illustrated by below figure.


	\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\linewidth]{pics/rvalue.drawio.png}
	\caption{rvalue reference explanation}	
	\label{fig:rvalue}
\end{figure}
	



\section{Forwarding reference}
\subsection{Definition}

	 \textbf{In new C++ standard, universal reference has been renamed as forwarding reference}. It's more descriptive name, It tells you universal reference should always been used as forwarding a parameter. Forwarding references arise in two contexts. The most common is function template parameters; The second context is \texttt{auto\&\&}.  
	
	\par How can we recognize if variable's type is a forwarding reference? 1)must be constrained \texttt{T\&\&} form, 2) type deduction happen. If the form of the type declaration isn't precisely \texttt{type\&\&}, or if type deduction does not occur, \texttt{type\&\&} denotes an rvalue reference.
\begin{lstlisting}
auto&& var2 = var1; // var2's type is forwarding reference

template<typename T>
void f(T&& param); // forwarding  reference

template<class T, class Allocator = allocator<T>>
class vector {
	template <class... Args>
	void emplace_back(Args&&... args); //args is forwarding reference. 
};
//------------below are not universal reference----
template<typename T>
void f(std::vector<T>&& param); // rvalue reference, because it isn't T&& form

template<typename T>
void f(const T&& param); // with const, so it's NOT forwarding reference.

template<class T, class Allocator = allocator<T>>
class vector { 
	void push_back(T&& x);//no type deduction happen here, it's a rvalue reference
};	
\end{lstlisting}	
	
	
	\par C++ defines type deduction rules for forwarding references: different rules apply for lvalues and rvalues. When passing an lvalue, \texttt{T} is deduced as \texttt{T\&}, whereas for rvalues, it is deduced as \texttt{T}. In pre-C++11, references to references were not allowed, and expressions like \texttt{A\& \&\&} would result in a compile error. C++11, however, introduces reference collapsing rules:
	
\begin{lstlisting}[numbers=none]
1) A& & becomes A&  2) A& && becomes A&  3) A&& & becomes A& 4) A&& && becomes A&&
\end{lstlisting}

	\par With forwarding reference type deduction rules and reference collapsing rules, I will provide a toy code to illustrate how and where to use these two rules? We define a forwarding reference in line 7 in the funciton \texttt{make\_obj}.
\begin{enumerate}
	\item When we input lvalue (line 13), according to forwarding reference type deduction rules, \texttt{T\&\&} will be deducted by \texttt{T\&}. Then when \texttt{std::forward function} return (line 2), it will return \texttt{T\& \&\&}, according to the reference collapsing rule, it will return \texttt{T\&}, return is lvalue. 
	
	\item When we input rvalue (line 14), according to forwarding reference type deduction rules, \texttt{T\&\&} will be deducted to \texttt{T}. Then when forward function return(line 2), it will return \texttt{T\&\&}, return is rvalue. 
	
	\item \texttt{std::forward} function (line 1) just do what it expects to do, keep function parameter (forwarding reference \texttt{T\&\&}) value category, and pass it to next step. The next step is invoking T's copy constructor in our toy example. 
	 
\end{enumerate}

\begin{lstlisting}[]
template<typename T>
T&& std::forward(typename remove_reference<T>::type& param){
	return static_cast<T&&>(param);
}

template<typename T>
T make_obj(T&& t){ //T&& is forwarding reference
	T t{std::forward<T>(t)};  //call T's copy or move constructor accordingly
	return v;
}
	
class Foo f;	
Foo f_result = make_obj(f);   //input lvalue
Foo f_result = make_obj(std::move(f)); input rvalue (xvalue)
\end{lstlisting}


	\par Based on previous rule, we can use forwarding reference to judge if a var is lvalue. In the case you pass a \texttt{std::string} lvalue, then T will deduce to \texttt{std::string\&} or \texttt{const std::string\&}, for rvalues it will deduce to \texttt{std::string}. That is an interesting example.
\begin{lstlisting}[frame=single, language=c++]
template <typename T>
constexpr bool is_lvalue(T&&) {
	return std::is_lvalue_reference<T>{};
}

std::string a("Hello");
is_lvalue(std::string()); // return false
is_lvalue(a); // return true  	
\end{lstlisting}	


	
%	\item You also can determine programmatic if an expression is rvalue or lvalue.
%\begin{lstlisting}[numbers=none]
%if (std::is_lvalue_reference<decltype(var)>::value) {
%	// var was initialised with an lvalue expression
%} else if (std::is_rvalue_reference<decltype(var)>::value) {
%	// var was initialised with an rvalue expression
%}
%
%string&& xvalue_fun();
%std::is_rvalue_reference<decltype(xvalue_fun())>::value //return true	
%\end{lstlisting}	
	
	

%	\item When to use \texttt{auto\&\&}? I will accept any initializer regardless of whether it is an lvalue or rvalue expression and I will preserve its constness. A good example of \\ "some\_expression\_that\_may\_be\_rvalue\_or\_lvalue;" is illustrated below:
%	
%\begin{lstlisting}[frame=single, language=c++]
%std::vector<int> global_vec{1, 2, 3, 4};	
%template <typename T>
%T get_vector(){
%	return global_vec;
%}
%
%template <typename T>
%void foo(){
%	auto&& vec = get_vector<T>(); 
%	auto i = std::begin(vec);
%	(*i)++;
%	std::cout << vec[0] << std::endl;
%}
%
%foo<std::vector<int>>();  //return rvalue in line 9
%std::cout << global_vec[0]; //global_vec[0] no change.
%
%foo<std::vector<int>&>(); //return lvalue in line 9
%std::cout << global_vec[0]; //global_vec[0] has change. 
%\end{lstlisting}
%
%\begin{description}
%	\item[Line 9:] only \texttt{auto\&\&} work here. \texttt{auto}, \texttt{auto\&} , \texttt{const auto\&}, \texttt{const auto\&\&} all failed. 
%\end{description}


\subsection{Usage of forwarding reference}
	 First and foremost, forwarding reference is mainly used as a function parameter. The function can be a function template or \texttt{fun(auto\&\& var)} format.
	
	\par The basic usage of forwarding reference can be illustrated by below figure.
	
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.6\linewidth]{pics/forward.drawio.png}
		\caption{Forwarding reference explanation}		
	\label{fig:forward}
	\end{figure}
	
	
	
	\begin{itemize}
				
		\item The primary capability of a forwarding reference function parameter is that it can bind to both lvalue expressions \texttt{t} and rvalue expressions \texttt{T \{\}} as illustrated by the above figure.
		
		\item Inside \texttt{forwarding\_fun}, you must use \texttt{std::forward} to forward \texttt{param} to \texttt{fun} function. 
		
		\item At the same time, \texttt{fun} must take different action toward lvalue and rvlaue. \texttt{std::forward()} will return different type(lvalue reference or rvalue reference) according to initial input. In another word, for lvalue input, \texttt{forwarding\_fun(t)}, \texttt{fun(T \&t)} will be called (path 1 in the above figure);  for rvalue input, \texttt{forwarding\_fun(T\{\})}, \texttt{fun(T \&\&t)} will be called (path 2 in the above figure);  
		
		\item The basic idea is clearly illustrated by the figure above, but why don't we call \texttt{fun()} directly? In fact, forwarding references are typically used in the following two slightly more complex scenarios, though they still follow the same basic idea.
		
		\begin{enumerate}
			
		
			\item Forward parameter to construct an object directly and avoid extra copying. Three important STL functions \texttt{emplace\_back}, \texttt{make\_shared} and \texttt{make\_unique} follow this idea. They are \textbf{variadic template} function template, because it need to receive \textbf{any number and any type} parameter. These three functions has "COPY" semantic inside the function, want to keep rvalue semantic of parameter to improve efficiency.
			
			\item Add additional functionality to an existing function 
\begin{lstlisting}
template<typename T>
void measureTimeFun(Args&&... args){ //T&& is forwarding reference
	//start time
	fun(std::forward<Args>(args)...)
	//stop and output time
}
\end{lstlisting}
			\item Most of time, we use variadic forwarding reference. 

	\end{enumerate}
		
%		\item Most of time, in your forwarding function, you have a container(string is container too), because move container is much cheaper than copy it. You have to use reference, means that need refer a existing one, you refer it because you want to copy it inside of your template function.
%		
%		\item I will accept any initializer regardless of whether it is an lvalue or rvalue expression and I will preserve its constness.  This is typically used for forwarding (usually with \texttt{T\&\&}). The reason this works is because a "forwarding reference", \texttt{auto\&\&} or \texttt{T\&\&}, will bind to anything.  
		

	\end{itemize}
	
	\par \texttt{auto\&\&} is also a forwarding reference. If you use \texttt{std::forward} on your \texttt{auto\&\&} reference to preserve the fact that it was originally either an lvalue or an rvalue, your code says: Now that I've got your object from either an lvalue or rvalue expression, I want to preserve whichever valueness it originally had so I can use it most efficiently. You need to use \texttt{decltype(var)} to get type information when you use the \texttt{std::forward} function on \texttt{var}. Please pay attention here: \texttt{var} was initialized with either an lvalue or rvalue, but \texttt{var} itself is an lvalue because named rvalues are lvalues.

\begin{lstlisting}[frame=single, language=c++]
auto&& var = some_expression_that_may_be_rvalue_or_lvalue;
use_it_elsewhere(std::forward<decltype(var)>(var)); //use decltype(var) here
\end{lstlisting}

	\par \texttt{auto\&\&} can bind to both lvalue and rvalue. You might say, well why not just use a \texttt{const auto\&} because that will also bind to anything? The problem with using a const reference is that it's const! You won't be able to later bind it to any non-const references or invoke any member functions that are not marked const.
\begin{lstlisting}[frame=single, language=c++]
auto&& vec=some_expression_that_may_be_rvalue_or_lvalue_vector;
auto i = std::begin(vec);
(*i)++;  //only auto&& work in this scenario

//below are other options, none of them work with (*i)++;
auto vec         = .. // will copy the vector, we wanted a reference
auto& vec        = .. // will only bind to modifiable lvalues
const auto& vec  = .. // bind to anything, vec is const, so i is const_iterator
const auto&& vec = .. // bind only to const rvalues, not universal reference	
\end{lstlisting} 	
	
	\par There are two points you need to know when you want to use forwarding reference:
	
\begin{enumerate}
	
	\item Most of time we use \texttt{std::forward} and forwarding reference together, because we want to forward the forwarding reference to another function. But for some special scenarios, we don't use \texttt{std::forward()} on forwarding reference, we just use it to accept both lvalue and rvalue. In the below code, if we use \texttt{void print(const T\& container)} here, \texttt{vec|view::filter(...)} will fail, because in C++ 20, some views can only bind to non-const variable, so I have to use forwarding reference here.  
\begin{lstlisting}
template<typename T>
void print(T&& container){
	for(const auto& e : container){
		std::cout<<e <<" ";
	}
	cout<<endl;
}
//void print(auto&& container) the same as previous function template

print(vec|std::view::drop(3)); //ok
print(vec|std::view::filter(...)); //ok with view::filter
\end{lstlisting}
	
	 
	\item Use \texttt{std::forward()} the last time inside your forwarding function. 
\begin{lstlisting}
template<typename F, typename... Args>
void invoke_n_times(F&& f, std::size_t count, Args&&... args){
	while(count-- > 1){
		std::invoke(f, args...);
	}
	// Move only the last one, if anything is movable.
	if(count == 0){
		std::invoke(std::forward<F>(f), std::forward<Args>(args)...);
	}
}
\end{lstlisting}
\end{enumerate}
	
%	\item Forwarding reference is used in three important STL functions \texttt{emplace\_back}, \texttt{make\_shared} and \texttt{make\_unique}. You can use them as a good example to study when and where you can use forwarding reference in your own project.
%	\begin{enumerate}
%		\item 
%		
%		\item \textbf{Forwarding reference}, because it's template, and I also want to keep rvalue semantic to improve efficiency.  The more you know these three functions, the better you understand forwarding reference.
%	\end{enumerate}




\subsection{Pros and cons of forwarding reference}

%	\item If you have a template class or template fun, universal reference is your only choice. An example can be seen in the last chapter, "decltype deduction" section.

	 For lvalue reference and rvalue reference overload method, more source code to write and maintain because there are two functions instead of a single function template. Furthermore, in some type conversion scenario, it can be less efficient. For example, consider this use of setName: \texttt{w.setName("Adela Novak")}; With the version of \texttt{setName} taking a forwarding reference, the string literal "Adela Novak" would be passed to \texttt{setName}, where it would be conveyed to the assignment operator for the \texttt{std::string name}. Data member \texttt{name} would thus be assigned directly from the string literal; no temporary \texttt{std::string} objects would arise. With the overloaded versions of \texttt{setName}, however, a temporary \texttt{std::string} object would be created for \texttt{setName}'s parameter to bind to, and this temporary \texttt{std::string} would then be moved into \texttt{name}.

\begin{lstlisting}[numbers=none]
class Widget {
public:
	template<typename T>
	void setName(T&& newName) // newName is forwarding reference
	{ name = std::forward<T>(newName); }
...
	string name;    
};

setName(const string& newName);  //for overload method, 
setName(string&& newName); //need a temporary string object for string literal here
\end{lstlisting}


	\par Overload has the poor scalability of the design. \texttt{Widget::setName} takes only one parameter, so only two overloads are necessary, but for functions taking more parameters, each of which could be an lvalue or an rvalue, the number of overloads grows geometrically, such as \texttt{std::make\_shared} function. Forwarding reference and variadic template parameter can provide the unify interface, that is why \texttt{std::make\_unique} and \texttt{std::make\_shared} and emplace-kind function are possible.

\begin{lstlisting}[numbers=none]
template<class T, class... Args> 
shared_ptr<T> make_shared(Args&&... args); 

template<class T, class... Args> 
unique_ptr<T> make_unique(Args&&... args); 
\end{lstlisting}

    \par You can use forwarding references, but inside, you have to use the \texttt{std::forward()} function, and implementation can be a bit complex. As a template, implementations must typically be in a header file. There are argument types that cannot be passed to forwarding reference (such as braced initializer: \{1, 2, 3\} and bitfields). If clients pass improper argument types, compiler error messages can be intimidating. (Detail can be seen in "Effective Modern C++" Item 27 and 30.)

    \par Avoid overloading on forwarding references, because it often results in the forwarding reference overload being called more frequently than expected. For more details, please refer to "Effective Modern C++" Item 26.
    
    %Perfect-forwarding constructors are particularly problematic because they typically provide better matches than copy constructors for non-const lvalues, and they can intercept calls from derived class constructors to base class copy and move constructors.



\subsection{std::move and std::forward implementation}
	
	 Both \texttt{std::move()} and \texttt{std::forward()} are just type-casting operations, not performing any real operations inside these two functions.
	
	\par \texttt{std::move()} has forwarding reference parameter, and return rvalue reference. It just uses \texttt{static\_cast} to perform type converting operation. 
\begin{lstlisting}[numbers=none]
template<typename T> // in namespace std
typename remove_reference<T>::type&&  move(T&& param){
	using ReturnType = typename remove_reference<T>::type&&; 
	return static_cast<ReturnType>(param);  //just static_cast operation here!
}
\end{lstlisting}
	   \par Why \texttt{std::move()} use forwarding reference as parameter. Just for more generic. We have introduced \texttt{vector<bool>} before, it returns a proxy value and it's rvalue. It's a extreme case, and I admit that. But in generic (template) programming, you will meet it too.
\begin{lstlisting}[]
std::vector<bool> v{true};
std::move(v[0]); // std::move on rvalue, OK
\end{lstlisting}	
	\par The implementation of \texttt{std::move()} can be illustrated by below figure.
\begin{center}
\includegraphics[width=0.95\linewidth]{pics/rvalue_ref_1.png}
\end{center}	
	
	\par Basic implementation of \texttt{std::forward()} has lvalue reference parameter, and return lvalue reference or rvalue reference according to the T type inside \texttt{std::forward<T>(t)} expression. 
\begin{lstlisting}numbers=none]
template<typename T>
T&& forward(typename remove_reference<T>::type& param){
	return static_cast<T&&>(param);
}
\end{lstlisting}

%	\begin{figure}[h]
%	\centering
%	\includegraphics[width=0.85\linewidth]{pics/rvalue_ref.png}
%	\caption{move and forward implementation}
%	\label{fig:rvalueref}
%\end{figure}

 \par In forward function, why parameter is \texttt{std::remove\_reference\_t<T>\& t}? Forward mainly used inside another funciton and function parameter has name, so it is lvalue.
\begin{lstlisting}
forward(int& r1); #1
forward(int&& r1); #2

void fun(int&& r){
	int& r1 = r;  //OK, r has name, so r is lvalue
	//int&& r1 = r;  //Error: cannot bind 'int' lvalue to 'int&&'
	forward(r) //it will call #1, not #2, because r is lvalue.
}
\end{lstlisting}

	\par The implementation of \texttt{std::forward} can be illustrated by below figure.
\begin{center}
	\includegraphics[width=0.85\linewidth]{pics/rvalue_ref_2.png}
\end{center}	

    
    \par The new standard has two overloaded \texttt{std::forward()} template functions. The next part is a little theoretical and if you don't want to go that deep, you can skip the below content in this section because you can still use \texttt{std::forward()} properly even if you don't know the implementation details behind it.
    
\begin{lstlisting}
template< class T >
constexpr T&& forward( std::remove_reference_t<T>& t ) noexcept;

template< class T >
constexpr T&& forward( std::remove_reference_t<T>&& t ) noexcept;	
\end{lstlisting}
	
	\par Why do we need the second overloaded function? It is for a very special case. The below code shows a scenario where we will use the second overload. The key point to understand this code is: Most of the time, we just forward function parameters, but in the code below (line 19), we forward a function return value, and the function return value is an rvalue.
	
	
\begin{lstlisting}
template< class T >
constexpr T&& forward( typename std::remove_reference<T>::type& t ){
	std::cout << __PRETTY_FUNCTION__ << '\n';
	return static_cast<T&&>(t);
}
template< class T >
constexpr T&& forward( typename std::remove_reference<T>::type&& t ){
	std::cout << __PRETTY_FUNCTION__ << '\n';
	return static_cast<T&&>(t);
}

void g(int&)  { std::cout << __PRETTY_FUNCTION__ << '\n'; }
void g(int&&) { std::cout << __PRETTY_FUNCTION__ << '\n'; }

template<class T>
auto f(T&& t){
	std::cout << __PRETTY_FUNCTION__ << '\n';
	//forward<T>(t).get() return different type here. 
	g( forward<decltype( forward<T>(t).get() )>( forward<T>(t).get() ) );
}

struct foo{
	int i = 42;
	int  get() && { std::cout << __PRETTY_FUNCTION__ << '\n'; return i; }
	int& get() &  { std::cout << __PRETTY_FUNCTION__ << '\n'; return i; }
};

f(std::move(foo1)); // output of this statement is below
\end{lstlisting}

	\par Below is the output the \texttt{f(std::move(foo1));},  Let me explain it in detail about what happen behind the output. 
\begin{lstlisting}
auto f(T &&) [T = foo]   #1
T &&forward(typename std::remove_reference<T>::type &) [T = foo] #2
int foo::get() && #3
T &&forward(typename std::remove_reference<T>::type &&) [T = int] #4
void g(int &&) #5
\end{lstlisting}
   
    \begin{enumerate}
    	\item template \texttt{f} function has forwarding reference. When we input rvalue, template parameter will be deducted by \texttt{T}, not \texttt{T\&}, \#1 shows the function type.
    	
    	\item Inside \texttt{f}, \texttt{t} is \texttt{foo\&\&}, but \texttt{t} itself is lvalue. The third forward function in line 18 returns \texttt{T\&\& (foo\&\&)}, that is to say \texttt{forward<T>(t)} return a rvalue. \#2 shows the third forward function type. 
    	
    	\item Once we have \texttt{foo\&\&}, we use it call \texttt{foo::get()}, it will call rvalue reference version. \#3 demonstrate it. 
    	
    	\item In line 18, from \#3 we know that get return \texttt{int}, so 1) The first forward will be deducted by \texttt{int}. 2) \texttt{get()} which return \texttt{int} is rvalue, so we need forward function can receive the rvalue, so the first forward function is dedecuted by \texttt{std::remove\_reference<T>::type \&\&}, \#4 proves this.
    	
    	\item The first forward return \texttt{int \&\&}, so it calls \texttt{g(int \&\&)} just like \#5 shows . 
    	
    	\item \texttt{PRETTY\_FUNCTION} is a powerful tool when you analyze the instantiation of a template function.
    \end{enumerate}
    


\section{Function interface-parameter}

\subsection{Read-copy function parameter design}


	 By now, you may imagine a function with parameters where three main operations are performed: 1) reading from the parameters, 2) copying from the parameters, and 3) writing to the parameters. When only reading is required, "\texttt{const type\&}" is the best option. For writing, "\texttt{type\&}" is suitable option.
	
	%because it allows modifications without the need to write anything new into the prvalue. Based on the previous explanation, the code below will not compile.
\begin{lstlisting}[numbers=none]
writeFun(Foo &);
writeFun(foo1+foo2) //ERROR, Foo & can't bind to rvalue.
\end{lstlisting}

	\par In the "read-copy" scenario, things become interesting. \textbf{If the parameter satisfies two points: 1) cheap to move and 2) copy semantic inside the function,  We need to consider the different strategy to deal with lvaue and right value separately}. 
	\begin{enumerate}
		\item Cheap to move type means that this is a kind of resource wrapper class. For example, \texttt{std::vector} and \texttt{std::string} are all cheap to move type. When we want to move, we just need to copy the pointer (handle) to the resource (memory) and we don't need to deep copy each element inside the chunk of memory. On the contrary, \texttt{std::pair<int, float>} is not a cheap to move type.
		
		\item You perform "copy semantic" from the parameter inside your function: such as assign it to others, build something new based on it (call constructor), or push it into a container (copy in), or return it (copy out). In all these cases, a form of "copy semantic" operation occurs within the function. For examples \texttt{make\_unique,} \texttt{emplace\_back} are this kind of functions.
		
	\end{enumerate}
	 
    
	\par In order to perform copy for lvalue and move for rvalue, we have four different methods. 
	
	\begin{enumerate}
		\item Overload fun to support \texttt{const Foo\&} and \texttt{Foo \&\&}. Copy constructor is typical example of this strategy. So usually function which accepts rvalue reference doesn't exist by itself, it just stay with another version to accept lvalue, \texttt{fun(const Foo\& foo);}
\begin{lstlisting}[frame=single, language=c++]
fun(const Foo& foo); //lvalue reference
fun(Foo&& foo); //rvalue reference
fun(foo1+foo2)  // call move constructor.
fun(f_return_foo()); // call move constructor.
\end{lstlisting}		
		
		\item Only use pass-value \texttt{fun(Foo)}, we will introduce it in the next section.
		\item Only use pass-rvalue-reference \texttt{Foo \&\&}. 
		\item Only use forwarding reference \texttt{fun(T\&\&)}.
	\end{enumerate}
	


\begin{tabular}{|p{0.25\textwidth}|p{0.32\textwidth}|p{0.32\textwidth}|}
\tophline
 & \textbf{lvalue}  & \textbf{rvalue} \\
\tophline
copyFun(Foo foo) & \specialcell[t]{copy parameter,move inside} & \specialcell[t]{move parameter, move inside} \\
\tophline
copyFun(Foo \&)  & copy inside & (NOT support) \\
\tophline
copyFun(const Foo \&) & copy inside & copy inside \\
\tophline
copyFun(Foo \&\&)  & (NOT support) & move inside \\
\tophline
\specialcell[t]{template<T\&\&> \\
copyFun(T \&\&)}  & copy inside & move inside 
\bottomhline
\end{tabular}

	\par For only read build-in type, such as \texttt{int, char, short, double}. You can use value directly, it has the same performance as reference. If you want to change it, you still need to use reference. 

\subsubsection{Only value solution}

	
	 Copyable parameters that are cheap to move can be passed by value. A value parameter example can be see in the below code. 

\begin{lstlisting}[frame=single, language=c++]
std::vector<std::string> getNewSortedVector (std::vector<std::string> names){
	std::sort(names);
	return names;
}

auto sn1= getNewSortedVector(input_names); //copy here
auto sn2= getNewSortedVector(get_names());//copy elision, construct directly
\end{lstlisting}
%\begin{description}
%	\item[Line 7:] \texttt{get\_names()} is an rvalue expression; move or omit the copy with copy elision optimization.
%\end{description}

%    \item If we use reference parameter instead value parameter, we have to copy it inside of function. We can't change because it's const reference, so have to copy it inside first. 
%
%\begin{lstlisting}[numbers=none]
%std::vector<std::string> sorted2(std::vector<std::string> const& names) {
%	std::vector<std::string> r(names);   // copy happen here
%	std::sort(r);  //change
%	return r;    //return
%}
%\end{lstlisting}
%
%
%
%\item A basic explanation is below:
%\begin{center}
%	\includegraphics[scale=0.5]{pics/copy1.png}
%\end{center}
%
%\item For left value, method 1 has extra move operation.
%
%\begin{center}
%\begin{tabular}{|c|c|c|c|}
%	\hline
%	left value input	& constructor & copy & move  \\
%	\hline
%	Method 1 & 1 & 1 & \textbf{\underline{1}} \\
%	\hline
%	Method 2&  1& 1 & 0  \\
%	\hline
%	Method 3&  1&  1& 0 \\
%	\hline
%\end{tabular}
%\end{center}
%
%\item For right value, method 1 has extra move operation, but method 3 has extra copy
%
%\begin{center}
%\begin{tabular}{|c|c|c|c|}
%	\hline
%	right value input	& constructor & copy & move  \\
%	\hline
%	Method 1 & 1 & 0 & 2(1)  \\
%	\hline
%	Method 2 & 1 & 0 & 1 \\
%	\hline
%	Method 3 & 1 & \textbf{\underline{1}} & 0 \\
%	\hline
%\end{tabular}
%\end{center}

%\item Comparison of three methods. 
%\begin{enumerate}
%	\item For method 1 for rvalue,  if you use -fno-elide-constructors, then it use 2 move, otherwise use 1 move(Copy-elision happens when we pass the parameter into the function). Even we use 2 move, \textbf{compared with method 3, it doesn't need a copy.}
%	
%	\item Method 2 is the best, but you need to write two overload functions.
%	
%	\item For method 3, When return, you can have RVO, no copy or move when we return. Only one copy inside the function.
%	
%	\item If don’t use method 2.  We are taught that reference is more efficient than value(it can avoid coping). But in our specific scenario(we still copy inside the function even we use reference). \texttt{if move is cheaper than copy, then method1 is better than method 3}. Although for lvalue, It use one more move, but for rvalue, it also use move, not copy(expensive operation).
%	  
%\end{enumerate}
%
%
%\item summary:
%\begin{enumerate}
%	
%	\item For non-cheap-move, such as all primitive type included class, move is just like copy, \textbf{So reference WIN!}
%	
%	\item For c++11 and cheap-move semantic, \textbf{value WIN!} The same idea can be seen in the "more effective C++ item 41". Don’t copy your function arguments. Instead, pass them by value and let the compiler do the copying. 
%	
%	\item For = operator in resource wrapper class, we don't need return value, but return reference, In this way, \textbf{value WIN!}. Detail can be found in use swap to implement = operator below. \textbf{That is the famous principal four and half rule.} One copy constructor, one move ctor, one value assignment, , one destructor, one swap(half).
%	
%\end{enumerate}
%

	\par You can apply this guideline immediately in assignment operators. The canonical, easy-to-write, always-correct, strong-guarantee, copy-and-swap assignment operator is often seen written this way. This follows the famous principle known as the "Rule of Four and a Half": one copy constructor, one move constructor, one assignment operator, one destructor, and one swap function (the half). In below code, \texttt{x} is a copy of the source. Trade our resources for \texttt{x}'s. Our (old) resources get destroyed with \texttt{x} when function finish.
\begin{lstlisting}[frame=single, language=c++]
T& operator=(T x){ 
	swap(*this, x);
	return *this;   
}
\end{lstlisting}

	\par You can't apply this idea into the copy constructor, otherwise it will cause dead recursive.
\begin{lstlisting}[frame=single, language=c++]
Class A{
	A(A a){..} //Can't declare in this way.
}
\end{lstlisting}

	\par Two good articles about this topic are:"Want Speed? Pass by Value." and "WANT SPEED? DON'T (ALWAYS) PASS BY VALUE."

\subsubsection{Use rvalue reference or forwarding reference}

    \par A more academic approach is to simply pass rvalue references to handle both lvalues and rvalues simultaneously. This concept can be further explored by searching for "Pass By Rvalue Reference Or Pass By Value". However, for lvalues, an auxiliary function is required to manage them effectively. Frankly speaking, it's not mainstream idea, because it's a little difficult to understand and need extra help funciton. Just keep it for an option.
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
T copy_to_temp(const T& t) { return t; }

SomeType t; 
s.initByRef(copy_to_temp(t)); //t is lvalue, need copy first.
\end{lstlisting}

%    \item The same idea can be applied to move-only types (such as \texttt{unique\_ptr<T>})
%\begin{lstlisting}[frame=single, language=c++]
%template<typename T>
%T move_to_temp(T& t) { return std::move(t); }
%
%void foo(unique_ptr<SomeType>&& param);
%unique_ptr<SomeType> p;
%foo(move_to_temp(p)); //note: this does move, p will become empty 
%foo(std::move(p)); //here, p will not become empty.  
%\end{lstlisting}


%VMore interesting example:
%\begin{lstlisting}[frame=single, language=c++]
%template<typename T>
%T move_to_temp1(T& t) { return std::move(t); }
%T&& move_to_temp2(T& t) { return std::move(t);}


%void foo(unique_ptr<SomeType>&& param);

%unique_ptr<SomeType> p;
%foo(move_to_temp1(p));  //compile ok, return value is prvalue
%foo(move_to_temp2(p));  //compile ok, return value is xvalue
%\end{lstlisting}
%\begin{description}
	%\item[Line 2:] here move constructor is called when return to a value
	%\item[Line 4:] here no move constructor is called, just reference value assignment.
%\end{description}



    \par The last option is universal reference. At this time, you have to use \texttt{std::forward()}.
\begin{lstlisting}[numbers=none]
template<typename T>
Fraction reduceAndCopy(T&& frac){ //only used in template function 
	frac.reduce();
	return std::forward<T>(frac); // have to use std::forward<T>
} 
\end{lstlisting}

	\par Comparison of previous three function interfaces design. 
	\begin{itemize}
		\item Overloading with const lvalue reference and rvalue reference is the most common strategy for designing read-copy function interfaces. It offers high efficiency but requires writing two separate functions.
\begin{lstlisting}[numbers=none]
void addName(const std::string& newName){
	names.push_back(newName); 
} 

void addName(std::string&& newName) {
	names.push_back(std::move(newName)); 
} 
\end{lstlisting}

		\item Using only a value parameter is also an option when ensuring that the copy occurs inside the function and \textbf{the move operation is cheap.} The advantage is that you only need to write one function, but there will be an additional move operation for both lvalues and rvalues. 
		
\begin{lstlisting}[numbers=none]
void addName(std::string newName) { 	
	names.push_back(std::move(newName)); 
} 
\end{lstlisting}		

		\item For forwarding references, maintaining just one function offers efficiency similar to that of overloaded functions. However, it comes with its own set of challenges, detailed in the section titled "Pros and Cons of Forwarding References."
		
\begin{lstlisting}[numbers=none]
template<typename T> 
void addName(T&& newName) { 
 	names.push_back(std::forward<T>(newName)); 
} 
\end{lstlisting}
	\end{itemize}


\section{Funciton interface-return}
%\subsection{funtion return basic introduction}
%\begin{itemize}
%	\item \textbf{These are two most important knowledge to understand function return.}
%	\begin{enumerate}
%		\item For no RVO, there are two steps when we return value.
%		\item RVO is a kind of copy elision. In RVO implementation, we implicit pass the result by reference.
%\begin{lstlisting}
%X bar(){
%	X xx;
%	return xx;
%}
%	
%X result = bar(); //change bar definition to below:
%void bar(x &__result){
%	__result.X::X() // default constructor call
%	....
%	return
%}
%\end{lstlisting}
%
%	\end{enumerate}
%	
%	\item Three basic knowledges about function return when no RVO:
%	\begin{enumerate}
%		\item It's very important understand there are two phrases when you return from function. The first step  is from inside fun fauto to outside of function ftemp(unname temporary), then fauto disappear(call destructor for value).  Then in second step, \textbf{Move} from ftemp to flast. because ftemp is rvalue.
%\begin{lstlisting}[numbers=none]
%Foo fun(){
%	return fauto;
%}
%		
%Foo flast = (ftemp created here)fun();
%\end{lstlisting}
%		\item ftemp is not on the stack, so you can use const ref or rref to prolong its life. ftemp is same with fauto, but maybe not same with flast(Will happen implicit conversion sometimes)
%\begin{lstlisting}[frame=single, language=c++]
%Foo fun(){
%	return fauto;
%}
%		
%const Foo& flast = (ftemp created here)fun();
%Foo&& flast = fun();
%\end{lstlisting}
%
%	\end{enumerate}
%	
%	\end{itemize}

\subsection{Return plain reference} 
	
		 \textbf{The basic principle is: don't return a reference unless it's absolutely necessary}. Why don't we usually return a references?
		
	\begin{enumerate}
		\item You want to return a reference to avoid copy of stack obj inside of function, but in fact it's totally wrong. We have RVO, When RVO is not applicable, compiler will call \texttt{std::move()} implicitly in some contexts.
		
		\item If you want to return a non-stack object, you can create an object with new and then return a pointer to it directly. Alternatively, you can use a reference parameter for read-only access by passing in a const reference. In this case, you don't need to return anything at all. Finally, you can use a reference parameter for write access, in which case you also don't need to return anything; the modification will be applied directly to the inputted reference. So why do we use plain reference return?
	\end{enumerate}
	
	\par Don't return a reference or pointer to private member variables through your public member functions. It will break encapsulation. At the same time, \textbf{never} return a reference that refers to a local variable; it will cause a dangling reference problem. When the client programmer uses a reference beyond its lifetime, the bug will typically be intermittent and very difficult to diagnose. Indeed, one of the most common mistakes that programmers make with the standard library is to use iterators after they are no longer valid, which is pretty much the same thing as using a reference beyond its lifetime.
	
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
string& a = FindAddr( emps, "John Doe" );
emps.clear(); //invalid a here
cout << a; //a has been dangling  
\end{lstlisting}
	
	\par As far as I know, return plain reference only happens: You input a reference first, such as overload \verb=<<=. Member function return some member data, such as  assignment operator and overload \verb=[]= inside a class. \texttt{=} and \verb|<<| are for support cascading syntactic usage: such as \verb|cout<<a<<b|, \texttt{a=b=c}.  \texttt{[]} is for support assignment \texttt{obj[3]= 12}.  That is all.

\begin{lstlisting}[numbers=none]
operator =  //three operators have "a pair of bars" :)
operator []
operator << and >>
\end{lstlisting}
	
%	\item If you want to return reference,  there is a defensible option that allows returning a reference and thus avoiding a temporary. But it's your last resort.
%\begin{lstlisting}[numbers=none]
%const string& FindAddr( /* pass emps and name by reference */ ){
%	for( /* ... */ ){
%		if( i->name == name ){
%			return i->addr;
%		}
%	}
%	static const string empty; 
%	return empty;
%}
%\end{lstlisting}

	\par An rvalue reference is still a reference, so all the reasons against returning a reference from a function apply equally to rvalue references. The most common scenario for returning an rvalue reference is with \texttt{std::move()}. This operation doesn't perform any movement within the function but acts purely as a type-casting operation.
	
%	\item If you want to return plain reference, or rvalue reference from a function, you have to input a plain reference or rvalue reference first, because you can't return any reference bound to local stack obj.
%	
%\begin{lstlisting}
%A&& rrfun1(A&& arg){
%	return std::move(arg);//arg is lvalue, so use move	
%}
%	
%A&& rrfun2(A& arg){
%	return std::move(arg);
%}
%	
%A a;
%A b= rrfun1(std::move(a) );
%A b = rrfun2(a); // a has been moved to b. 
%A&& c = rrfun2(a);
%\end{lstlisting}
%\begin{description}
%	\item[Line 12:] will not call move constructor at all. So you mean that I want to keep watch for a while, and obj a is still intact right now.
%\end{description}
 
	
	\par Next we talk rvalue reference qualifier. Please see two examples below. More details can be googled  "C++ Gems: ref-qualifiers"
	\begin{enumerate}

	\item The ref-qualifier \texttt{\&\&} says that the second function is invoked on rvalue temporaries, making the following move, instead of copy.
\begin{lstlisting}
struct Beta {
	Beta_ab ab;
	Beta_ab const& getAB() const& { return ab; }
	Beta_ab getAB() && { return move(ab); }// correct, 
};

Beta_ab ab = Beta().getAB(); //call line 4 function, not line 3 funciton.
\end{lstlisting}
	
	\item What should we return from ref-qualifier member function? value or rvalue reference?  In fact, return value is better if you just want to copy from the member function. If you return the rvalue reference, maybe it has dangling reference problem.  
\begin{lstlisting}
class Widget { 
	DataType values; 
public: 
	DataType& data() & { return values; } 
	DataType data() && { return std::move(values); }
	DataType&& data_ref() && { return std::move(values); }
};

auto d1 = Widget().data(); 
auto d2 = Widget().data_ref(); 
auto&& d3 = Widget().data_ref();
\end{lstlisting}
\begin{description}
	\item[Line 9:] Note that \texttt{d1} is deducted to be \texttt{Widget} type. rvalue returned by function call moves construct \texttt{d1}, if compiler implemented RVO copy elision, it just call move construct once inside the \texttt{data} function.
	
	\item[Line 10:] Note that \texttt{d2} is deducted to be \texttt{Widget} type according to \texttt{auto} type deduct rule. rvalue reference returned by function call moves construct on \texttt{d2}.
	
	\item[Line 11:]	\texttt{auto\&\&} is a forwarding reference, deducted to be \texttt{DataType\&\&} rvalue reference. \texttt{d3} is a dangling reference because temporary \texttt{Widget} is destroyed. Pay attention here, \texttt{d3} will not prolong the temporary \texttt{Widget()} life, because it is just \texttt{DataType} (\texttt{Widget}'s member) reference type. That is why we have dangling reference problem. 	
\end{description}
	
	\end{enumerate}

	\par A few good articles you can dig deeper:
	\begin{enumerate}
		\item Efficiency of C++11 \texttt{push\_back()} with \texttt{std::move} versus \texttt{emplace\_back()} for already constructed objects.
		\item view the default functions generated by a compiler?
		\item One variable initialization form to rule them all, via mandatory elision.
		\item Episode Eleven: To Kill a Move Constructor
	\end{enumerate}

	\par \textbf{A return value is better than returning an rvalue reference}. It has clearer semantics and supports RVO.


\subsection{Return value-RVO}

\subsubsection{Common RVO cases}
	 Return Value Optimization (RVO) is a form of \texttt{copy elision} where, during implementation, the function implicitly passes the result by reference. It occurs whenever a local value is returned from a function. The type of the local object matches that returned by the function, and this local object is the actual return value.
\begin{lstlisting}
X bar(){
	X xx;
	return xx;
}

X result = bar(); //change bar definition to below:
void bar(X &__result){ pass the result by reference here. 
	__result.X::X() // default constructor call
	....
	return
}	
\end{lstlisting}

	\par RVO is just a kind of copy-elision, some other common cases of copy-elision are below:
\begin{itemize}
	
	
	\item Temporary is passed to function value parameter.
\begin{lstlisting}[numbers=none]
void foo(Thing t);
foo(Thing()); //copy elision happen, build t parameter directly.	
\end{lstlisting}	
	
	\item Exception is thrown and caught by value.
\begin{lstlisting}[numbers=none]
void foo() {
	Thing c;
	throw c;
}

try {
	foo();
}
catch(Thing c) {  
}	
\end{lstlisting}
	
\end{itemize}


	\par RVO and name RVO. For name RVO, \texttt{t} has a name. It's called NRVO. 
\begin{lstlisting}[numbers=none]
Thing f() {
	Thing t;
	return t; //Name RVO
}

Thing f() {
	return Thing(); //RVO, no name, just temporary
}	
\end{lstlisting}

	\par Returning a local variable with \texttt{std::move()} is a common mistake among some beginner C++ developers who don't fully understand RVO, as it will disable RVO.
\begin{lstlisting}[numbers=none]
Snitch CreateSnitch() {
	Snitch snitch; //Basicly, RVO will trigger here
	//return std::move(snitch); Not good, when you use move, it disable RVO
}	
\end{lstlisting}

	\par Only return \texttt{local variable} can be used in RVO. Function parameter is not eligible for RVO. The following rules should be noted regarding the relationship between function parameters and RVO:
		\begin{itemize}
			
	\item A common misunderstanding is: to prevent unnecessary copies of value parameter, use \texttt{std::move} on it. In fact, even if the parameter isn't eligible for RVO or if different paths make it ineligible, you typically don't need to explicitly use \texttt{std::move}, as the compiler will handle this implicitly.

\begin{lstlisting}
Widget makeW(Widget w){
	return w  //w is value parameter, compiler will call std::move implicitly 
	//return std::move(w), don't do it. compiler call std::move instead. 
} 	
\end{lstlisting}			
			\item Lvalue reference parameter usually can not be moved, just copy (Don't call \texttt{std::move()} implicitly).
\begin{lstlisting}[numbers=none]
Matrix operator+(Matrix& lhs, const Matrix& rhs) {
	return lhs //for lvalue refence, return it directly.
}	
\end{lstlisting}


			
			\item If a function return value, and you want to return \textbf{a rvalue reference parameter}, you can use \texttt{std::move} in the return statement.
\begin{lstlisting}[frame=single, language=c++]
Matrix operator+(Matrix&& lhs, const Matrix& rhs){
	lhs += rhs; 
	return std::move(lhs); //move into return value, high efficiency. 
	//return lhs  //will copy, so low efficiency
} 		
\end{lstlisting}				
			\begin{enumerate}
				\item \texttt{lhs} is not local object, but parameter, so No RVO. 
				
				\item You may say: but \texttt{lhs} is rvalue reference, but \texttt{lhs} is name rvalue reference. It's lvalue.
				
				\item Just like you pass a lvalue reference, you can't move it unless you want to do it explicitly. That is why we need \texttt{std::move()} here. Frankly speak, this is typical example to demonstrate when you can use \texttt{std::move()} when you return value, so I recommend you to remember it.
			\end{enumerate}

	\item Last, use \texttt{std::forward} on forwarding references parameter when you want to return it. It just combines previous two scenarios(lvalue reference parameter and rvalue reference parameter) together. 
\begin{lstlisting}[numbers=none]
template<type T>
T operator+(T&& lhs) {
	return forward<T>(lhs) //for forwarding reference, std::forward it.
}		
\end{lstlisting}			
			
		\end{itemize}
	


\subsubsection{RVO limitations}
	 Different named object samples will not trigger RVO, but compiler still use \texttt{std::move()} when we return, so you don't need to call it explicitly.
\begin{lstlisting}[numbers=none]
RVO MyMethod (int i){
	RVO rvo;
	rvo.mem_var = i;
	if (rvo.mem_var == 10)
		return RVO();
	return rvo; 
}
\end{lstlisting}
	
	\par Returning a parameter or Global.
\begin{lstlisting}[numbers=none]
Snitch global_snitch;
Snitch ReturnParameter(Snitch snitch) {
	return snitch; //no RVO here, it's parameter
}
Snitch ReturnGlobal() {
	return global_snitch; //no RVO here either, it's global
}
\end{lstlisting}

	
	\par When return member, even an unnamed variable, RVO will not trigger. 
\begin{lstlisting}[numbers=none]
struct Wrapper {
	Snitch snitch;
};

Snitch foo() {
	return Wrapper{}.snitch; 
}

Snitch s = foo(); //no RVO here. call snitch constructor and move
\end{lstlisting}





\subsubsection{Some practical demos and analysis}
	
	 Given below code as experiment code:
\begin{lstlisting}[frame=single, language=c++]
class Snitch {   // Note: All methods have side effects
	Snitch() { cout << "c'tor" << endl; }
	~Snitch() { cout << "d'tor" << endl; }
	
	Snitch(const Snitch&) { cout << "copy c'tor" << endl; }
	Snitch(Snitch&&) { cout << "move c'tor" << endl; }
	
	Snitch& operator=(const Snitch&) {
		cout << "copy assignment" << endl;
		return *this;
	}
	
	Snitch& operator=(Snitch&&) {
		cout << "move assignment" << endl;
		return *this;
	}
};
	
Snitch CreateSnitch() {
	return Snitch();
}
	\end{lstlisting}
	
	\par Test 1 and output. That is a typical RVO example. Only one default constructor is called inside the \texttt{CreateSnitch} function, no any copy and move constructor are invoked here if you don't provide -fno-elide-constructors switch to compiler. 
\begin{lstlisting}[frame=single, language=c++]
Snitch s = CreateSnitch();
\end{lstlisting}
\par The compiler switch and its output:

	\begin{verbatim}
		with -fno-elide-constructors switch
		c'tor    //Snitch()
		move c'tor  //Snitch() to return value
		d'tor       //Snitch() destroy
		move c'tor //return value to s
		d'tor     //return value destroy
		d'tor     //s destroy
	------------------------------
		without -fno-elide-constructors switch
		c'tor   //s
		d'tor   //s destroy
	\end{verbatim}

	
	\par Test 2 and output. Because that is a assignment operation, RVO doesn't kick in here. Just construct first, then call assignment operator. 
\begin{lstlisting}[frame=single, language=c++]
Snitch s;
s = CreateSnitch();
\end{lstlisting}
The compiler switch and its output:
	
%with -fno-elide-constructors switch
%c'tor    //Snitch s
%c'tor    //Snitch() in side CreateSnitch
%move c'tor  //Snitch() to return value
%d'tor       //Snitch() destroy
%move assignment //return value to s
%d'tor     //return value destroy
%d'tor     //s destroy
%----------------------	

	\begin{verbatim}	
		without -fno-elide-constructors switch
		c'tor   //Snitch s
		c'tor   //Snitch()
		move assignment //s has been implicit passed to CreateSnitch, 
		                //so s = Snitch() happen inside CreateSnitch
		d'tor   //Snitch() destroy
		d'tor   //s destroy
	\end{verbatim}


	\par Test 3 and output. For function parameter, no RVO here. Because \texttt{rs} is rvalue reference parameter, you can use \texttt{std::move(rs)} to call move constructor explicitly to avoid copy.
\begin{lstlisting}[frame=single, language=c++]
Snitch CreateSnitch() {
	return Snitch();
}	
Snitch CSnitch(Snitch&& rs) {
	return rs;      //#1, a better option is #2
	return std::move(rs); //#2
}
	
Snitch s = CSnitch(CreateSnitch()); //output is below
\end{lstlisting}
	\begin{verbatim}
		without -fno-elide-constructors compiler switch
		c'tor   //Snitch ()
		copy c'tor // For #1 
		or move c'tor // For #2
		d'tor   //Snitch() destroy
		d'tor   //s destroy
	\end{verbatim}
%	\begin{verbatim}
%		with -fno-elide-constructors
%		c'tor    //
%		copy c'tor    //
%		d'tor       /
%		copy c'tor    //
%		copy c'tor    //
%		d'tor       /
%		d'tor     //r
%		d'tor     //
%	-------------------------
%		without -fno-elide-constructors
%		c'tor   //Snitch s
%		copy c'tor // For #1 or move c'tor // For #2
%		d'tor   //Snitch() destroy
%		d'tor   //s destroy
%	\end{verbatim}



%\subsubsection{return mulit value}
%\begin{itemize}
	%\item You can return pair, tuple and variant. 
	%\item for example, map.insert just return a pair. 
	%\item how to use variant as return value? find a example here
%\end{itemize}

\subsection{Function interface design summary}

		 We usually don't return references, whether they are lvalue references or rvalue references. Usually, only three operator overloads return lvalue references, only \texttt{std::move()} returns an rvalue reference, and \texttt{std::move()} is just a type cast. 
	
	
	\par When a function returns a value, try to use RVO (Return Value Optimization) first, so that no move or copy operations are performed. Never apply \texttt{std::move()} or \texttt{std::forward()} to local stack objects if they would otherwise be eligible for return value optimization. Only use \texttt{std::move()} on a rvalue reference parameter when you want to return this parameter to a value, it will call move constructor instead of copy constructor.  
	
			\par Based on the previous concepts of rvalue references, forwarding references, and RVO, the following figure illustrates the principles of function interface design for parameters and return values:
		\begin{center}
			\includegraphics[width=1.0\linewidth]{pics/move.png}
		\end{center}
	
	

%		\item \textbf{if RVO is not applicable, at the same time, move is not cheap, we should use referent parameter as return methond, such as big POD type, or use it in loop.} I think that it will be rare case. If you have good example of this, please tell me.
 
	


%\subsection{Summary of function interface design}
%\begin{itemize}
%		\item The main idea of function interface design can be see in the below figure:
%	\begin{figure}[h]
%	\centering
	

%	\caption{rvalue reference and function interface.}
%	\label{fig:rvalueref}
%	\end{figure}

%\end{itemize}

\section{Summary}
\begin{enumerate}
	\item This chapter introduces value categories, including lvalue, rvalue and xvalue.
	
	\item rvalue references can bind only to rvalues. For some resource wrapper classes, when we encounter rvalues, we can invoke move operation instead of copy. With rvalue references, we also introduce a naming rule: unnamed rvalue references are rvalues (e.g., \texttt{std::move()} uses this rule).
	
	\item Does \texttt{std::move()} return an lvalue or an rvalue? To address this, we invent a new value category, xvalue, and redefine rvalue to include both prvalue and xvalue.
	
	\item For some forwarding contexts, we introduce forwarding references and the reference collapsing rule to handle this problem. 
	
	\item Two important figures in this chapter are \ref{fig:rvalue} and \ref{fig:forward}. Please make sure you understand them. 
	
	\item In the end, we discuss how to design a function interface, which consists of two main parts: parameter design for read-copy scenario functions and function return design with RVO.
\end{enumerate}


\chapter{OOP}

\section{Object basic}

\subsection{class categories}
	 Basic class categories:
	\begin{itemize}
			
		\item Value-like types, such as \texttt{std::pair}, \texttt{std::vector}, and \texttt{std::string}, represent values and should naturally be copyable. In C++11, you should generally think of move as an optimization of copy, and so all copyable types should naturally be movable. Moving is just an efficient way of doing a copy in the often-common case that you don't need the original object anymore and are just going to destroy it anyway.
		
		\begin{enumerate}
			\item Has a public destructor, copy constructor and assignment operator with value semantics.
			\item Has no virtual function. It intendeds to be used as a concrete class, not as a base class.
			\item Instantiated on stack or as a member of an other class.
		\end{enumerate}
		
		\item Object (reference)-like types that exist in inheritance hierarchies, such as base classes and classes with virtual or protected member functions. These are normally held by pointer or reference, often a \texttt{Base*} or \texttt{Base\&}, and so do not provide copy construction to avoid slicing; if you do want to get another object just like an existing one, you usually call a virtual function like \texttt{clone}. These do not need move construction or assignment for two reasons: They're not copyable, and they already have an even more efficient natural "move" operation -- you just copy/move the pointer to the object and the object itself doesn't have to move to a new memory location at all.
		\begin{enumerate}
			\item Has a destructor that is public and virtual, but for some trait class, destructor can be protected, such as \texttt{std::unary\_function}.
            \item Establish interfaces through virtual functions.
			\item \textbf{Usually instantiated on heap, and used via a (smart) pointer or reference to support polymorphism.} 
        \end{enumerate}
		

    \item Policies are classes (or class templates) to \textbf{inject behavior} into a parent class, typically through inheritance. Through decomposing a parent interface into orthogonal (independent) dimensions, policy classes form the building blocks of more complex interfaces. An often seen pattern is to supply policies as user-definable template (or template-template) parameters with a library-supplied default. An example from the Standard Library are the Allocators, which are policy template parameters of all STL containers. Policy classes (normally templates) are fragments of pluggable behavior.
        \begin{enumerate}
            \item May or may not have state or virtual functions.
            \item They are not usually instantiated standalone, but only as a base or member. 
        \end{enumerate}

\begin{lstlisting}[numbers=none]
template<class T,class Allocator = std::allocator<T> > class vector;
\end{lstlisting}
	
	\item Traits are class templates to \textbf{extract properties} from a generic type. There are two kind of traits: single-valued traits and multiple-valued traits. Examples of single-valued traits are the ones from the header <type\_traits>. Single-valued traits are often used in template-metaprogramming and SFINAE tricks to overload a function template based on a type condition. \texttt{std::unary\_function} is also a kind of trait class.  A type trait is a simple template struct that contains a member constant, which in turn holds the answer to the question the type trait asks or the transformation it performs. For example, let's take a look at \texttt{std::is\_integral}. Another usage is like \texttt{std::remove\_reference}, it is a type trait that alters the type T it takes in input:

		\begin{enumerate}
			\item Contain only typedef and static functions, It has no modifiable state.
			\item Is not instantiated( constructor is private or disable)
		\end{enumerate}
	\begin{lstlisting}[numbers=none]
template< class T >
struct is_integral{
	static const bool value
	/* = true if T is integral, false otherwise */;
	typedef std::integral_constant<bool, value> type;
};
	
template <class T>
T f(T i){
	static_assert(std::is_integral<T>::value, "Int required.");
	return i;
}
std::cout << f(123) << '\n'; //output 123
\end{lstlisting}

    \item Exception class. They are thrown by value but should be caught by reference. 

	\item Ancillary classes typically support specific idioms, such as RAII.  Types that express unique ownership of a resource, such as \texttt{std::unique\_ptr}, are naturally move-only types, because they are not value-like (it doesn't make sense to copy them) but you do use them directly (not always by pointer or reference) and so want to move objects of this type around from one place to another.	

	\item Functor class, includes lambda. with operator() defined. This becomes more and more important and win a seat in this list. 
	
	\end{itemize}
	
    \par About class categories, I need to add a few points. Most of the time, we mainly use value objects and reference objects. The other kinds are a kind of special and easy to understand. For value objects, you can think that it's a data abstraction, which has zero or very little overhead. 
    
    \par For reference object, usually we don't support copy, for example, A people object has no meaning to copy himself. It has three points need to mention:
    
        \begin{enumerate}
            \item If it's only used for the interface, it will be an Abstract Base Class. There are two common idioms that can be used here: NVI (No virtual interface) and Non-leaf abstraction. Details can be seen later in the design section.

            \item Non-copyable class. such as thread, employee etc. You should disable the copy constructor when you find it's not fit into copy scenario.

            \item Copyable class. A good example is a music note, You can see the clone pattern in design pattern. Here music note is a kind of interface, so it's a ABC (Abstract Base Class); At the same time, client should be able to "copy" to generate new notes. Under such context, you can use virtual copy constructor, in another word, use \texttt{basePtr->clone()} virtual function. Clone pattern is just for this scenario. 

        \end{enumerate}


\subsection{Class interface design}
	
	 Nesting a class does not create a class member of another class. Instead, it defines a type that is known locally to the class that contains the nested class declaration. A good example is \texttt{std::vector<int>} and its iterator, \texttt{std::vector<int>::iterator}.
	
	\par A virtual function must be a member. Operators \verb=>>= and \verb=<<= are never members; they are class friend functions. 
	
%	Only non-member functions get type conversions on their left-most argument. In the previous example, if you want to support \texttt{2 * obj}, you need to make \texttt{operator*} a non-member function. Details can be found in \textit{Effective C++}.
	
	\par The \texttt{protected} keyword is not used very often; it is mainly used in the context of inheritance. A child class can access the base class's protected members. You should use the \texttt{private} keyword first if you truly want good \textbf{encapsulation}. Never return a reference or pointer to private or protected member data.
	
	\par In \textit{C++ Primer}, page 653, you can find a good example of a class interface. You should remember this as a basic pattern. If you use the \texttt{new} operator to allocate memory inside your class, you should define the copy constructor, assignment operator, destructor, move constructor, and move assignment operator. Usually, you should have these seven member functions. Alternatively, you can follow the Principle of Four and a Half, which will be introduced later. Put the class definition into a specific namespace is also a good style. You need to declare the operator \verb=<<= inside the namespace so ADL (Argument-Dependent Lookup) can access it correctly.
	
\begin{lstlisting}[frame=single, language=c++]
#pragma once  //below is string.h file
namespace Company_namespace{
	class String{
	public:
		String();  //default constructor
		String(const char *a ); // specify constructor		
		String (const String &);  //copy constructor
		String (String && other); //move copy constructor		
		String& operator=(const String &); //assignment
		String& operator=(String&& other); //move assignment
		String& operator=(const char*a); // option.
		
		~String();  		
		friend ostream& operator<<(ostream & os, const String & st);
		friend istream& operator>>(istream & is, String &st);		
	private:
		const static int NUM= 1000; // const used inside of this class.
		char* m_str;		
	};
}
\end{lstlisting}

        \par In above code, \texttt{String\& operator=(const char*a);} is an option, it makes \texttt{str=temp} more efficient? see C++ Primer P652.
	
\begin{lstlisting}[numbers=none]
String str; char temp[40];
str= temp // make it more efficient
\end{lstlisting}

	\par Prefer non-member, non-friend functions. A good example is begin function in STL. Non-member style can be used in generic programming better.  

\begin{lstlisting}[numbers=none]
std::vector<int> vi = {1,2,3};
auto i = vi.begin();
auto i = begin(vi);	 //Non-member style here, it provide more generic ability
\end{lstlisting}	
		
    \par Prefer minimal classes to monolithic classes. A big class is difficult to make error-safe because it tackles multiple responsibilities. It's also difficult to maintain, understand, and deploy.
	

\section{Object base paradigm}
\subsection{Constructor}

\subsubsection{Constructor basic and default constructor}

	 Normally, constructors, destructors, and assignment operators should be public unless you have a special requirement for a specific class or in a particular context. Avoid calling virtual functions in constructors and destructors. Details can be found in \textit{C++ Coding Standards}, item 49.
	
	\par Make constructors protected to prohibit direct instantiation. Make constructors private to stop inherit. That is an old trick, in C++14, you can use \texttt{=delete} to tell the compiler directly.
	
	\par Use default arguments to reduce the number of constructor.
\begin{lstlisting}[numbers=none]
class Brush{
	Brush();
	Brush(Color c);
	Brush(Texture t);
	Brush(Color c= Black,Texture t=Solid); //better style
}
\end{lstlisting}
		
		\par A copy constructor is called whenever a new variable is created from an object. This happens:
		
		\begin{enumerate}
			\item When a new object is initialized to an object of the same class.
			\item When an object is passed to a function by value.
			\item When a function returns an object by value.
			\item When the compiler generates a temporary object.
		\end{enumerate}
				
		\par For a reference, once assigned, it cannot be re-assigned. So if a class has a reference member, it can be initialized by the initializer list in the constructor and copy constructor. Meanwhile, compiler will mark copy assignment operator implicitly \texttt{deleted}. If you really need an assignment semantic, change the reference to a pointer or reference wrapper.
\begin{lstlisting}
struct A{
	int &ref;
	A(int &Ref) : ref(Ref) { }
	A(const A &second) : ref(second.ref) { }
};
int i = 2;
A a{i}, b{i};
b = a ; //compile error here
\end{lstlisting}
		



	
	 Avoid gratuitous default constructors. If an object can be created from 'nothing', consider providing a default constructor. For example, in containers, a default constructor allows creating an empty container without any input. It's reasonable to have a default constructor for containers. You can also declare your own converting constructor and use the system's implicitly generated one. You can use the keyword \texttt{default} to specify default behavior.
\begin{lstlisting}[frame=single, language=c++]
class Container{
	Container() = default; //use default is OK here.
	Container(int size) ;
}	
\end{lstlisting}

	\par If you define a specific constructor, system will not produce any default constructor for you. At this time, maybe you need to add default constructor by yourself.
		
	\par For some classes, allowing objects to be created without providing essential information is not advisable. For instance, when creating a class \texttt{Worker}, it's crucial to provide their SSN. In such cases, a default constructor is not recommended, as leaving the SSN uninitialized could lead to significant issues later on.
\begin{lstlisting}[numbers=none]
class Worker{
	char* SSN; // each worker should have SSN
	Worker(const char*);
	Worker(){SSN=nullptr); //bad smell.
}
\end{lstlisting}
	
	\par We should not declare a default constructor. In this way, our class design better represents the real world. However, we must understand the two sides of the coin. Without a default constructor, all of the following statements will produce errors during compilation. To fix these kinds of compilation errors, we can use a \texttt{Worker*} pointer or a \texttt{std::vector<Worker>}. This is the spirit of C++, where there is never a single best answer, and everything depends on the context.
	
\begin{lstlisting}
class Worker{
	char* SSN;
	Worker(const char* SSN);  //will not generate default ctor
};
Worker obj; //error
Worker* obj = new class{}; //error
Worker arra[10] //error
\end{lstlisting}


	\par Let's recap here. Any user-declared converting constructor will prevent the compiler from generating a default constructor. If a default constructor satisfies the class's semantics, such as in a container class, you can add it yourself or use \texttt{= default}. If a default constructor is not valid for the class's semantics, such as in a \texttt{Worker} class where an SSN is required for every worker, you should not declare it explicitly or use \texttt{= delete}. The absence of a default constructor can bring some inconvenience, such as not being able to define an array of this class (\texttt{Worker arr[10]};). However, I think that semantics are more important than syntax, and for the \texttt{Worker} class, I would prefer to delete the default constructor if we need an SSN for every worker.
	

\subsubsection{member initializer list}

	 \textbf{Always use a member initializer list instead of assignment inside a constructor.} This is one of the most important principles. You can use a member initializer list to initialize 1) non-static const data members, 2) reference members, 3) member objects which do not have a default constructor, and 4) when you need to pass arguments to a base class constructor.
\begin{lstlisting}[numbers=none]
struct A {
	int i;
	A( int );
};
struct B: A {
	B( int );
};
	
B::B(int x): A(x) { }//Initializer list must be used here. Before {} and after :
\end{lstlisting}		
		
	\par Why is a member initializer list more efficient? It requires only one copy constructor, which makes it more efficient. See the source code below for an example.

\begin{lstlisting}[frame=single, language=c++]
class(string &a, string &b): m_a(a),m_b(b){}; //just call copy constructor
		
class(string &a, string &b){   
	m_a = a;  // 1) call default constructor to build m_a,
	m_b = b;  // 2) then call assignment operator. low efficiency.
}; // http://www.geeksforgeeks.org/when-do-we-use-initializer-list-in-c/
\end{lstlisting}

	\par List members in an initialization list in the order in which they are declared in the class. See \textit{Effective C++} item 13 for more information. The order is important because member variables are always initialized in the order they are declared in the class definition. The order in which you write them in the constructor initialization list is ignored. Therefore, it is better to avoid having one member's initialization depend on other members.
	
\begin{lstlisting}[numbers=none]
class Student{
	string m_email;  //m_email will be init first, ignore order
	string m_first_name;  // in the constructor initialization list.
	Student(first_name) :m_first_name(first_name), m_email(m_first_anme+"@gmail"){}
\end{lstlisting}
		
%	\item Here's another example of an initialization order problem. If \texttt{GetType()} is a static member function or a member function that doesn't use its this pointer (that is, uses no member data) and doesn't rely on any side effects of construction (for example, static usage counts), then this is merely poor style but will run correctly. Otherwise (mainly, if \texttt{GetType()} is a normal nonstatic member function), we have a problem. Nonvirtual base classes are initialized in left-to-right order as they are declared, so \texttt{ArrayBase} is initialized before \texttt{Container}. Unfortunately, that means we're trying to use a member of the not-yet-initialized \texttt{Container} base subobject. Therefore, order is important!

	\par Here's another example of an initialization order problem. Non-virtual base classes are initialized in left-to-right order as they are declared, so \texttt{ArrayBase} is initialized before \texttt{Container}. Unfortunately, that means we're trying to use a member function (\texttt{GetType()}) of the not-yet-initialized \texttt{Container} base object.
		
\begin{lstlisting}[numbers=none]
template<class T>
class Array : private ArrayBase, public Container{
public:
	Array( size_t startingSize = 10 ): Container( startingSize ), 
	ArrayBase( Container::GetType() ){
		....
\end{lstlisting}
		

\subsubsection{Named constructor idiom and virtual constructor idiom}

	 First, let take a look common pattern of constructor, constructor is different, you have to use the same name. But it can't express semantic behind the function interface. In order to resolve this problem, we can use "named constructor" idiom. Please note here we use \texttt{static} here.  
\begin{lstlisting}
class Point {
public:
	Point(float x, float y); // Rectangular coordinates
	Point(float r, float a);  //Polar coordinates (radius, angle), fail to compile
};

class Point {
public:
	static Point rectangular(float x, float y); // named constructor
	static Point polar(float radius, float angle); // named constructor
	
Point p1 = Point::rectangular(5.7, 1.2); //use Point:: to call static member
Point p2 = Point::polar(5.7, 1.2);
\end{lstlisting}
	
	\par In some applications, objects need to be copied or assigned using base class pointers. For instance, if a class owns objects pointed to by abstract base class pointers, like a \texttt{Graph} managing pointers to various \texttt{Shape} objects (as illustrated in 'More Effective C++' item 25), a significant issue arises when performing assignments and copies such like this: \texttt{*pShape1 = *pShape2;}
	
\begin{lstlisting}
class Graph {
public:
	Graph(const Graph& f)
	: p_(f.p_->clone()) { }
	
	Graph& operator= (const Graph& f){
		if (this != &f) {              
			Shape* p2 = f.p_->clone();  //create new one 
			delete p_;                  //delete old one 
			p_ = p2;                    //assign
		}
		return *this;
	}
	// ...
private:
	Shape* p_;  //shape can be square, circle..., so we use Shape*
};
\end{lstlisting}
\begin{description}
	\item[Line 16:]  Please note here: \texttt{Shape*} here represents value semantic and reference semantic at the same time. If we use \texttt{Shape*->draw}, then it's reference semantic. It's also a value member inside the \texttt{Graph} class, that is why we need to call clone function for it.
\end{description}

	\par A normal constructor shall not be virtual or static. But for \texttt{Shape} class in the previous scenario, you can use virtual constructor idiom. The idiom uses virtual \texttt{clone()} member function (for copy constructing), or a virtual \texttt{create()} member function (for the default constructor). The purpose is to resolve the problem of assignment and copy between \texttt{Graph} object. As usual with this idiom, we declare a pure virtual \texttt{clone()} method in the base class \texttt{Shape}. It follow 'non-leaf class abstract' rule. Virtual function can have different return type and that is OK in C++ language. (as illustrated by line 12 and 13.)
	
\begin{lstlisting}
class Shape {
public:
	virtual ~Shape() { }                 
	virtual void draw() = 0;           
	virtual void move() = 0;
	// ...
	virtual Shape* clone()  const = 0;   
	virtual Shape* create() const = 0;  //return shape* here
};	
class Circle : public Shape {
public:
	Circle* Circle::clone()  const{return new Circle(*this); } //return Chircle*
	Circle* Circle::create() const{return new Circle(); }//Covariant Return Types  
};
Shape* s2 = s.clone();
Shape* s3 = s.create();
delete s2;    // You need a virtual destructor here
delete s3;
\end{lstlisting}



\subsection{Destructor}
	 \textbf{In inheritance context, all the base class destructor should be public and virtual. Or protected and non-virtual.}  If you don't declare base class destructor virtual, below code will only call base destructor. 

\begin{lstlisting}[numbers=none]
class Base {
public:
	int num;
	Base(int n):num(n){
		cout<<"Base::Constructor\n";
	}
	virtual ~Base(){   //Here must declare virtual
		cout<<"Base::Destructor\n";
	}
};

class Derived : public Base {
private:
	float money;
public:
	Derived(int n, float m):Base(n),money(m){
		cout<<"Derived::Constructor\n";
	}
	~Derived(){   //you can omit virtual here,better style is to add virtual!
		cout<<"Derived::destructor\n";
	}
};

Base *base_ptr = new Derived(1,200.0);
delete base_ptr;
\end{lstlisting}
	

	\par The base class destructor will be called implicitly by the child class destructor. Therefore, it's important to always implement the base class destructor, even if it's pure virtual. Additionally, it's essential to prevent exceptions from leaving destructors.
\begin{lstlisting}[numbers=none]
class Base {
	virtual ~Base() = 0;
};
Base::~Base(){} //Must give implementation, even function is empty. 
\end{lstlisting}	

	\par Normally you will have to explicitly declare your own destructor if:

	\begin{enumerate}
		\item When you are declaring a class which is supposed to serve as a base for inheritance involving polymorphism, need a virtual destructor to make sure that the destructor of a \texttt{Derived} class is called upon destroying it through a pointer/reference to \texttt{Base}.
		
		\item You need to release the resources required by the class during its lifetime. For example, if the class has a handle to a file, you need to close the file when the object is destroyed. The destructor is the perfect location for this. Another example is if the class owns an object with dynamic-storage duration. Since the lifetime of the object can potentially continue long after the class instance has been destroyed, you'll need to explicitly destroy it in the destructor.
	\end{enumerate}


\subsection{Member functions relationship}



	 When you write an empty class, the compiler will produce at least six member functions. Newer compilers will also produce move constructor and move assignment operators.
\begin{lstlisting}[numbers=none]
class Empty{};

Empty();  //default constructor
Empty(const Empty& rhs);
Empty& operator=(const empty & rhs);
Empty* operator&(){return this};
const Empty* operator&() const ;
~Empty();
\end{lstlisting}

	\par Most of time, compiler will write default implementation in these special member function. Why do you need to pay attention to them? The reason is that C++ by default treats classes as \textbf{value-like types}, but not all types are value-like. To know when to over write or disable them make you get correct code. A good reference is "Everything You ever wanted to know about move semantics" in slideshare.net.

	\par For these special member functions, main operations can be: 1) Not declare; 2) Compiler implicitly declare one; or 3) Use explicitly declare one. 

	\par First question is what can we \texttt{"declare"}? For example, we can declare it as "=deleted" or "=defaulted".
	
\begin{center}
	\includegraphics[scale=0.63]{pics/sm1.drawio.png} 
\end{center}



    \par Steps of generating special member function is illustrated below:
    
\begin{center}
\includegraphics[scale=0.8]{pics/ctor.png} 
\end{center}

	\par If you just define a class without any special member function, all six special member functions (One constructor, destructor, copy construtor, copy assignment, move construtor and move assignment) will be declared "defaulted" by compiler implicitly. 

%\begin{center}
%	\includegraphics[scale=0.5]{pics/sm2.png}
%\end{center}

	\par "Defaulted" can mean "deleted" if the defaulted special member would have to do something illegal, such as call another deleted function. "default" in \texttt{B} just tell compiler that I want to use compiler's version, and compiler version generate "delete" default constructor for class \texttt{B}. See an example below: 

\begin{lstlisting}[frame=single, language=c++]
class A{
	A() = delete;
};
class B{
	B() = default; 
	A a;
};
int main(){
	B b; //output: 'B::B()' is implicitly deleted because the
}	     // default definition would be ill-formed: 	      
\end{lstlisting}


	\par Next question is what differences are between \verb|=default| and user define empty constructor? 
	
\begin{lstlisting}[numbers=none]
struct noncopyable  {
	noncopyable() {};
private:
	noncopyable(const noncopyable&);
	noncopyable& operator=(const noncopyable&);
};
\end{lstlisting}
\begin{itemize}
	\item The copy constructor has to be declared privately to hide it, but because it's declared at all, automatic generation of the default constructor is prevented. You have to explicitly define the default constructor if you want one, even if it does nothing.

	\item Even if the explicitly-defined default constructor does nothing, it's considered non-trivial by the compiler. \textbf{It's less efficient than an automatically generated default constructor and prevents noncopyable from being a true POD type.}

	\item Even though the copy constructor and copy-assignment operator are hidden from outside code, the member functions and friends of noncopyable can still see and call them. If they are declared but not defined, calling them causes a linker error.

	\item Although this is a commonly accepted idiom, the intent is not clear unless you understand all of the rules for automatic generation of the special member functions. After C++11, A better solution is to use \texttt{=default} and \texttt{=delete}. 
\begin{lstlisting}[numbers=none]
struct noncopyable  {
  noncopyable() =default;
  noncopyable(const noncopyable&) =delete;
  noncopyable& operator=(const noncopyable&) =delete;
};
\end{lstlisting}

\begin{enumerate}
	\item Generation of the default constructor is still prevented by declaring the copy constructor, but you can bring it back by explicitly defaulting it. Explicitly defaulted special member functions are still considered trivial, so there is no performance penalty, and noncopyable is not prevented from being a true POD type.

	\item The copy constructor and copy-assignment operator are public but deleted. It is a compile-time error to define or call a deleted function.

	\item The intent is clear to anyone who understands \texttt{=default} and \texttt{=delete}. You don't have to understand the rules for automatic generation of special member functions.
\end{enumerate}

\end{itemize}

	\par Another question is what the differences are between using \texttt{=delete} and not declaring a member at all. Deleted members participate in overload resolution, while members that are not declared do not participate in overload resolution.
\begin{lstlisting}
struct X{
	template<class ...Args>
		X(Args&& ...args);
	X() = delete
};

X x; //without line 4, here will call template function in line 2.
     //with line 4, compiler will report error here.
\end{lstlisting}

    \par It's preferable to use deleted functions instead of privately undefined ones. Any function, including non-member functions and template instantiations, can be declared as \texttt{= delete}.

\begin{lstlisting}[frame=single, language=c++]
template <class charT, class traits = char_traits<charT> >
class basic_ios : public ios_base {
public:
	basic_ios(const basic_ios& ) = delete;
	basic_ios& operator=(const basic_ios&) = delete;
};

bool isLucky(int number); // original function
bool isLucky(char) = delete; // reject chars
bool isLucky(bool) = delete; // reject bools

template<typename T>
void processPointer(T* ptr);

template<>
void processPointer<void>(void*) = delete; //can't use void to instantiate.
\end{lstlisting} 

%    \item Why defaulted move member sometimes "deleted"? Detail can be found in "CWG 1402 is (imho) the most important bug fix to C++11". Another good article is google "Why is the move constructor neither declared nor deleted with clang? " In clang, it support C++11 standard better. 
    
%\includegraphics[scale=0.6]{pics/sm5.png} \newline


\subsubsection{Rules of implicitly declare }
	 The Default constructor, will not be implicitly generated if:
	
		\begin{itemize}
			\item You have explicitly declared any constructor.  Compiler doesn't create a default constructor if we write any constructor even if it is copy constructor.
		
			\item There is a member in your class that is not default-constructible (such as a reference, a const object, or a class with no or inaccessible default constructor)
		
			\item (C++11) you have explicitly told the compiler to not generate one using A() = delete;
		\end{itemize}

	\par The copy constructor, will not be implicitly generated if:
		\begin{itemize}
			\item You have explicitly declared a copy constructor (for class X a constructor taking X, X\& or const X\&)
			
			\item There is a member in your class that is not copy-constructible (such as a class with no or inaccessible copy constructor)
			
			\item (C++11) you have explicitly told the compiler to not generate one using A(const A\&) = delete;
		\end{itemize}


	\par The Copy Assignment Operator will not be implicitly generated if
		\begin{itemize}
		\item You have explicitly declared a copy-assignment operator (for class X an operator = taking X, X\& or const X\&) )
		
		\item There is a member in your class that is not assignable (such as a reference, a const object or a class with no or inaccessible assignment operator)
		
		\item (C++11) you have explicitly told the compiler to not generate one using A\& operator=(const A\&) = delete;
		\end{itemize}
	
	
	\par The Destructor will not be implicitly generated if 1) you have explicitly declared a destructor. 2) (C++11) you have explicitly told the compiler to not generate one using \texttt{\textasciitilde A() = delete};

	
	\par The Move Constructor or Move Operator(C++11) will not be implicitly generated if
		\begin{itemize}
		\item You have explicitly declared a move constructor or move assignment(for class X, a constructor taking X\&\&)
		
		\item there is a member in your class that cannot be moved (have deleted, inaccessible, or ambiguous)
		
		\item you have defined a copy assignment operator, copy constructor, destructor, or move assignment operator
		
		\item you have explicitly told the compiler to not generate one using A(A\&\&) = delete;
		\end{itemize}
	
	
	\par The Move Assignment Operator (C++11) will not be implicitly generated if
		\begin{itemize}
		\item You have explicitly declared a move assignment operator (for class X, an operator = taking X\&\&)
		
		\item You have defined a copy assignment operator, copy constructor, destructor, or move constructor.
		
		\item You have explicitly told the compiler to not generate one using A\& operator=(A\&\&) = delete;
		\end{itemize}
		
	\par A summary of previous rules is illustrated in below figure. 
	
	\begin{center}
		\includegraphics[scale=0.80]{pics/ob_m.drawio.png}
	\end{center}
	
\begin{itemize}
	
	\item The sixth and seventh row shows a rule: Declaring a copy operation (construction or assignment) indicates that the normal approach to copying an object (memberwise copy) isn't appropriate for the class, and compilers thinks that if memberwise copy isn't appropriate for the copy operations, memberwise move probably isn't appropriate for the move operations either, so we don't declare move operation function.
	
	\item The eighth and ninth row indicate the same idea as the previous, declaring a move operation (construction or assignment) in a class causes compilers to disable the copy operations.
	
	\item The two copy operations (copy constructor and copy assignment) are independent: declaring one doesn't prevent compilers from generating the other. The two move operations are NOT independent. If you declare either, that prevents compilers from generating the other.
	
	\item In the fifth row, C++11 deprecates the automatic generation of copy operations for classes declaring a destructor. If you declare a destructor, declare your copy members too. Provided the behavior of the compiler-generated functions is correct (i.e, if memberwise copying of the class's non-static data members is what you want), your job is easy, because C++11's \texttt{=default} lets you say that explicitly:

\end{itemize}
		
%\begin{center}
%\includegraphics[scale=0.6]{pics/sm4.png} \newline
%\end{center}

\subsection{Resource management policy}

     If a class comprises only value-like members, such as primitive types or standard library types, and does not require explicit resource management, it's preferable to rely on the compiler-generated default constructors and other member functions. This approach, known as the \textbf{Rule of Zero}, minimizes code duplication and potential errors associated with manual resource management.
\begin{lstlisting}[numbers=none]
class NoResource{
	std::string s, std::vector; // value-like member1; 
	int member_;                // value-like member2;
}
\end{lstlisting}

    \par If a class includes reference-like members, things become a little complex. You need to consider ownership and lifetime control. We can use the 'Four and a Half Rule,' which will be introduced later.

\begin{lstlisting}[numbers=none]
class OneRef{
	reference-like member1; //such as a handle or pointer.
}
\end{lstlisting}


\subsubsection{Rule of zero}
     The Rule of Zero states: If you can avoid defining default operations, do so! It simplifies and provides the cleanest semantics. If all members is a RAII class, no further work is needed. In other words, any time you have a resource, you can encapsulate it within a wrapper and transform it into a value-like member. This approach allows us to adhere to the Rule of Zero.

\begin{lstlisting}
class ZeroRule{
	unique_ptr<Foo> p; //don't use Foo* p;
	shared_ptr<Foo> p; //for shared ownership;
	string s;  //don't use char* p;
	vector<int> v; //don't use int* p;
	array<int> a; //don't use int *p;
	std::unique_ptr<void, decltype(&::FreeLibrary)> handle; //don't use HMODULE handle;
}	
\end{lstlisting}

	\par A variant of the Rule of Zero suggests: Stick to the Rule of Zero as long as possible. However, if you must define at least one of the Big Five (constructor, destructor, copy constructor, move constructor, copy assignment operator, move assignment operator) for non-resource managment purpose, default the rest. Why? When you explicitly declare a destructor, as we discussed earlier, it disables the default move operations but retain copy operations. As a result, client code will still compile but will silently invoke copy operations instead of move operations even for temporary variable, which can lead to inefficiencies. Using \texttt{=default} allows you to implicitly define move operations without specifying their bodies.
	 
\begin{lstlisting}
class X{
public:
	string a, b;
	X(X const& other) = default;
	X& operator=(X const& other) = default;	
	X(X&& other) = default;
	//the same X(X&& other) : a{move(other.a)}, b{move(other.b)} { }
	X& operator=(X&& other) = default;
	~X() { /* need to log something in the dtor */ }
};
\end{lstlisting}
   
    \par Whenever possible, you should consider following the Rule of Zero first. 
    
%    If there isn't a suitable wrapper class, such as \texttt{std::unique\_ptr} or \texttt{std::shared\_ptr}, to meet your requirements.
    

\subsubsection{Rule of four and half.}
	
	 For any class that manages a resource, defaulted implementation of copy constructor and destructor is not correct. That is why we need to provide user-defined copy constructor and destructor. For example, user-defined copy constructor performs deep copy, and simultaneously user-defined destructor frees (release) resources.
	

	\par Before C++11, without move semantics, we adhered to the \textbf{Rule of Three}: If a class required a user-defined destructor, a user-defined copy constructor, or a user-defined copy assignment operator, it almost certainly needs all three. After C++11 introduced move semantics, the \textbf{Rule of Three} evolved into the \textbf{Rule of Five}, adding a move constructor and a move assignment operator to manage resource ownership efficiently. A modern idiom is \textbf{Rule of Four and Half} with help of copy-and-swap idiom to implement assignment operation.
	
	\par  The basic content of \textbf{Rule of Four and Half} are:
	\begin{enumerate}
		\item The copy constructor.
		
		\item The move constructor.
		
		\item The destructor.
		
		\item The copy assignment operator. Don't need move assignment operator, in assignment operator, we pass only one kind of type--value. 
		
		\item The swap member function(that is a half).
	\end{enumerate}
	
	\par The old implementation of assignment operator need 1) avoid assignment self, and 2) return \texttt{*this} reference. There are two problems, the first one is the old implementation is not strong exception safe. For example, when we copy the content1, an exception has been thrown. Under such context, original one has been damaged. The second problem is so many duplicated code. The assignment code has almost the same code with copy constructor.
\begin{lstlisting}[numbers=none]
class & class::operator=(class &a){
	if(this == &a)
		return *this;  //avoid assign by himself
    this.content1 = a.content1; //
    this.content2= a.content2; 
	return *this ; // return *this reference.
}	
\end{lstlisting}
	
	\par The \textbf{copy-and-swap} idiom for assignment operator is a better solution, and elegantly assists the assignment operator in achieving two things: avoiding code duplication, and providing a strong exception guarantee. Conceptually, it works by using the copy-constructor's functionality to create a local copy of the data, then takes the copied data with a swap function, swapping the old data with the new data. The temporary copy then destructs, taking the old data with it. We are left with a copy of the new data. In order to use the copy-and-swap idiom, we need three things: 1)  a working copy-constructor, a working destructor (both are the basis of any wrapper, so should be complete anyway), and a swap function. The swap function can be a member function.
	
%    \item We should not use reference as function parameter. \textbf{No matter lvalue or rvalue, copy always happen inside assignment operator.}
%\begin{lstlisting}[numbers=none]
%dumb_array& operator=(const dumb_array& other){
%	dumb_array temp(other);
%	swap(*this, temp);
%	return *this;
%}	
%
%dumb_array da;
%da = f(); // use const & get the pvalue, // but inside the operator =, we copy. 
%// we didn't use move, so it's low efficient.	
%\end{lstlisting}
	
	\par  You only need one assignment operator with value parameter type. You don't need to provide two different assignment operator any more ( copy assignment operator and move assignment operator).
	
%	On a general note, a remarkably useful guideline is as follows: \textbf{if you're going to make a copy of something in a function, let the compiler do it in the parameter list.}
	
\begin{lstlisting}[numbers=none]
dumb_array& operator=(dumb_array other){
	other.swap(*this); 
	return *this;
}	

dumb_array da;
da = f(); // use move directly. high efficient.
\end{lstlisting}
	

	\par Based on previous introduction, the full code to follow \textbf{Rule of Four and Half} is here: 
\begin{lstlisting}[]
class dumb_array{
	dumb_array(const dumb_array& other): mSize(other.mSize), //1) copy constructor
			mArray(mSize ? new int[mSize] : nullptr){
		std::copy(other.mArray, other.mArray + mSize, mArray);
	}
	dumb_array(dumb_array&& other) noexcept{                 //2) move constructor
		*this.swap(other);
	}
	dumb_array& operator=(dumb_array other) noexcept{        //3) assignment
		other.swap(*this); 
		return *this;
	}
	~dumb_array(){delete [] mArray;}                         //4) destructor
	void swap(dump_array& rhs) noexcept{                     //5) swap
		using std::swap;
		swap(msize, rsh.msize);
		swap(mArray, rsh.mArray);
	}
	
private:
	std::size_t mSize;
	int* mArray;
};

void swap(dumb_array& first, dumb_array& second) {
	first.swap(second);
}
namespace std{
	template<> 
	void swap<dump_array>{dump_array& first, dump_array& seconde){
			first.swap(second);
		}
} 
\end{lstlisting}
\begin{description}
    \item[Line 14:] Why do we need member swap? because it can visit private member of class. Inside swap member function, you may use \texttt{std::swap} to exchange class member and label it noexcept.
    
	\item[Line 9:] Use swap member function to implement assignment operator, the function parameter is value, and label it as noexcept. 
	
	\item [Line 6:] Once we have swap member functions, we can use it to implement move constructor and label it \texttt{noexcept}. \texttt{noexcept} is very important, when we use \texttt{vector<dump\_array>}, when vector need expand its size, it will use move if move constructor is \texttt{noexcept}, if move constructor is not \texttt{noexcept}, it will use copy constructor which deep copy happens. 
    
    \item[Line 25-27:] If \texttt{dump\_array} has it's own namespace, then put swap non-member swap function into the same namespace. In this way, client can use ADL find this version and pick it up. If no own namespace, just put it in global scope.
    
\begin{lstlisting}
namespace_dr::dumb_array dr1;
namespace_dr::dumb_array dr2;
swap(dr1, dr2); // will go to namespace_dr to find the correct swap function.
\end{lstlisting}

    \item [Line 28-33:] You also need to put swap into the \texttt{std} namespace and make it specialization.
\begin{lstlisting}
using std::swap   //clients code should be like this
std::swap(dr1,dr2) //some people or STL library code will use this way
                   //also guarantee that your version can be called properly. 
\end{lstlisting}	

\end{description}
	
	\par An interesting example about copy and swap idiom.  For below software snippet, copy and swap idiom is slow than the default empty \texttt{X}. Why? Detail can be found in "Inefficiency of copy-and-swap idiom?" in stack overflow. In another word, don't use "copy and swap" on a class with some std container members, such as \texttt{std::vector} and \texttt{std::string}. 
\begin{lstlisting}
class X{  //
	std::vector<int> v_; //with std::container member
}

class X{ //copy and swap idiom
public:
	std::vector<int> v_;
	X& operator=(X x){
		v_.swap(x.v_);
		return *this;
	}
}
\end{lstlisting}

    	

\subsubsection{Summary of resource management}
     For non-resource classes, adhere to the Rule of Zero. For classes that manage resources, consider using the Rule of Four and a Half.

    \par You can use \texttt{=default} and \texttt{=delete} to explicitly declare certain special member functions in C++. For instance, if you define a destructor for logging purposes, which disables the generation of the default copy constructor, you can reintroduce it with \texttt{Foo(const Foo\& rhs) = default} in your class.
        
%    \item Based on the resource inside class, below describes scenarios where certain operations (copying and moving) are either allowed, preferred, restricted, or disallowed altogether.
%\begin{enumerate}
%    \item Objects that can be both moved and copied.
%    \item Objects for which it makes sense to copy but not move.
%    \item Objects for which it makes sense to move but not copy.
%    \item Objects which should neither be moved not copied.
%\end{enumerate}

	\par In addition to well-known idioms like the Rule of Zero and the Rule of Four and a Half, you can customize your own class management policies. These custom policies allow you to define unique behaviors for your classes that best represent the practical application semantics.
	
	\begin{itemize}
		\item Use the compiler-provided versions of these functions. In other words, you're not doing any resource management in the class.
		
		\item Write your own move functions, but don't support copying, such as \texttt{std::unique\_ptr}.
		
		\item Disable copying and move semantics for the class, because it doesn't make sense to allow it, such as \texttt{std::mutex}.
		
	\end{itemize}


\subsection{operator overload}
		 Overload means providing two (or more) functions or operator that perform similar, closely related tasks, differentiated by the types and/or number of arguments it accepts.  
		
		\begin{itemize}
			\item  In some cases it's worth arguing that a function of a different name is a better choice than an overloaded function.
			
			\item  In the case of constructors and operator, overloading is the only choice because we can't give them the different name. 
			
			\item Operator overloading is a compile-time polymorphism. It is an idea of giving special meaning to an existing operator in C++ without changing its original meaning.
			
			\item Sometimes, overload and default parameter have same client usage, as shown below. If there is a value that you can use for a default, use default parameter. Overload usually take different parameter type or different number of parameters.
\begin{lstlisting}[numbers=none]
void f();
void f(int x);
f() or f(10);

void g(int x = 0);
g() or g(10);		
\end{lstlisting}							
		\end{itemize}
		
	
		\par \textbf{Never overload \texttt{\&\&} operator, \texttt{||} operator and \texttt{comma} operator in C++.  Just remember it!}
		
		\par For all operators where you have to choose to either implement them as a member function or a non-member function, use the following rules of thumb to decide:
	\begin{enumerate}
		\item Binary operators = (assignment), [] (array subscription), -> (member access), as well as the unary () (function call) operator, must always be implemented as member functions, because the syntax of the language requires them to.
		
		\item If it is a unary operator, implement it as a member function.
		
		\item Needs a different type as its left-hand argument, such as operator \verb=<<=, use non-member function.
		
		\item If a binary operator treats both operands equally (it leaves them unchanged), implement this operator as a non-member function, such as \texttt{operator +} and \texttt{operator -}.
		
		\item Leftmost argument sometimes needs type conversion, use non-member.
		
		\item If a binary operator does not treat both of its operands equally (usually it will change its left operand), it might be useful to make it a member function of its left operand’s type, if it has to access the operand's private parts, such as \texttt{operator +=}.
		
		\item Can be implement by using the class public interface alone, use non-member.
	\end{enumerate}
	
	
	\par An example based on previous rules: If it's not a member function, declare it as a friend function if it needs to visit private member variable. If you want to \texttt{overload +} for class \texttt{Time} and supports \texttt{Time t; 3+t}; You need to define a friend function. In order to improve a \texttt{t+3} efficiency, you also can define a member function time \texttt{operator+(int i)} member function.
\begin{lstlisting}[frame=single, language=c++]
friend time operator+(const time &lhs, const time &rhs); //non-member, rule 4
friend time operator+(int,  const time &t) //nonmember, for 3+t, rule 5
time operator + (int i) //member, for t+3, avoid implicit, rule 6
operator += (const time& rhs)  // member, change left operand, so rule 6.
\end{lstlisting}

	\par Why does \verb|<<| need to be both a friend and a non-member? Its left operands are stream classes from the standard library, which cannot be changed. In other words, you need to write \verb|cout <<| obj. If you declare \verb|<<| as a member operator, you would have to write \verb|obj << cout|, which looks weird.
	
	\par The assignment operator overload should return a non-const reference. Some suggest using a const reference to prevent constructs like \texttt{(x = y) = z}, but this is uncommon in coding practices. In the STL, for example with \texttt{std::string}, the assignment operator simply returns a reference. This serves as a useful reference that when in doubt about interface design, consulting the STL library can provide valuable guidance.
	
\begin{lstlisting}[numbers=none]
class A& operator=(const class A& rhs){	
	//Do some things other
	return *this;
}	
\end{lstlisting}	
	

	
%	\item Keep in mind that only a class declaration can decide which functions are friends, so the class declaration still controls which functions access private data. Friend has three categories:
%	
%	\begin{enumerate}
%		\item Friend Class: just as TV and RemoteControl, you can declare RemoteControl a friend class inside TV.
%		
%		\item Friend Member functions: You can select some member functions to be friend of another class, in this way, you need forward declaration.  
%		
%		\item Common Friend method, a good example is overload \verb=operator <<=. 
%	\end{enumerate}
	

	\par Overloading operator sometimes can help you to avoid implicit type conversion. In the below example, we avoid creating a temporary \texttt{string} obj implicitly created by constructor.

\begin{lstlisting}[frame=single, language=c++]
class String{
	bool operator==(const String& lhs, const String& rhs);
};

bool operator==(const String& lhs, const char* rhs); //avoid implicit conversion.	

String str;
if(str =="hello") //avoid building a temp obj String("hello") with line 5.
\end{lstlisting}
	
	\par When implementing binary arithmetic operators such as \texttt{+}, \texttt{-}, and \texttt{*}, it's good practice to first implement compound assignment operators such as \texttt{+=}, \texttt{-=} and \texttt{*=}. These can then be used to implement the common operators. For example, you can use \texttt{+=} to implement \texttt{+}. This design provides two advantages: 1) it provides an additional function, and 2) it avoids code duplication. 
\begin{lstlisting}[numbers=none]
Vector2D& Vector2D::operator+=(const Vector2D& right){
	this->x += right.x;
	this->y += right.y;
	return *this;
}

Vector2D operator+(const Vector2D& lhs, const Vector2D& rhs){
	Vector2D result = lhs;
	result += rhs;
	return result;
}
\end{lstlisting}
	

	


\section{Object oriented paradigm}

\subsection{Inheritance}
\subsubsection{Polymorphism by inheritance}

	 Polymorphism is a powerful design mechanism in object-oriented programming that enables encapsulation of related types behind an abstract public interface. However, it comes with the cost of additional indirection, affecting both memory allocation and type resolution. Polymorphism is primarily supported through references and pointers.

\begin{lstlisting}[numbers=none]
class Base{
public:
	virtual void fun(){ cout<<"A";}
};
	
class Derived: public Base{
public:
	void fun(){cout<<"B";}
	int m_d = 100;
};
\end{lstlisting}

	\par Base pointer can't access class member in derived class directly. In line 4 and 5, pointer \texttt{pb} has type. The pointer type alter the interpretation of the size and composition of the memory. Pointer type is \texttt{Base}, so the size of memory which pointer address is \texttt{sizeof(Base)}, that's why you can't see the \texttt{m\_d} in \texttt{Derived} class at all. When you change the pointer type from \texttt{Base} to \texttt{Derived}, then the memory which pointer address is \texttt{sizeof(Derived)}, interpretation supports \texttt{->m\_d} now.
	
\begin{lstlisting}
Derived d;
Base* pb = &d;
cout<<d.m_d;    //OK,You can access class member by object directly.
//cout<<pb->m_d;   //ERROR 
//cout<<(*pb).m_d; //ERROR
cout<<static_cast<Derived*>(pb)->m_d; //OK, or use dynamic_cast to down-cast type
\end{lstlisting}


	\par Base object doesn't support polymorphism. When a base class object is directly initialized or assigned with a derived class object, the derived object is sliced to fit into the available memory resources of the base type. Virtual table content changed. There is nothing of the derived type remaining. Polymorphism is not present, and an observant compiler can resolve an invocation of a virtual function through the object at compile time, thus by-passing the virtual mechanism.
\begin{lstlisting}
Derived d;
Base b = d; //sliced happen here.
b.fun(); //output A
\end{lstlisting}

	\par A pointer or a reference support polymorphism because inside derived class, compiler builds virtual table, (adding indirect level.)
\begin{lstlisting}
Base& rb = d;
rb.fun(); //output B
Base* pb = &d;  //no sliced happen here
pb->fun(); //output B
(*pb).fun(); //output B, no sliced happen before.
\end{lstlisting}


\subsection{Member functions in inheritance}

\subsubsection{constructor and destructor in inheritance}
	  \textbf{The Derived constructor will always call the Base class constructor.} The idea behind this rule is to ensure that an object can be initialized properly. The constructor should NOT be virtual. If the \texttt{Derived} doesn't define any constructor, the compiler will implicitly define a default constructor, and this constructor will call the \texttt{Base} class's default constructor. If the \texttt{Derived} class has a constructor but doesn't explicitly call the \texttt{Base} class's specified constructor, the constructor of the \texttt{Derived} will call the \texttt{Base} class's default constructor (without any parameters). If the \texttt{Base} constructor only has a specified constructor and no default constructor, the compiler will produce an error. If you want to explicitly call the \texttt{Base} class's specified constructor, use the initialization list syntax in \texttt{Derived} class.
\begin{lstlisting}[frame=single, language=c++]
class Base{
public:
	Base();  //default constructor
	Base(int b); //converting constructor
private:
	int m_b;
};
	
class Derived: public Base{
public:
	Derived();  //default constructor
	Derived(int d, int b); // converting constructor1
	Derived(int d);     //converting constructor2
private:
	int m_d;
};
\end{lstlisting}

	\par If you don't use explicit initialization list syntax to call the \texttt{Base} class's specified constructor, you will either get an uninitialized value or you won't be able to initialize the base member, both of which are not good.
\begin{lstlisting}[frame=single, language=c++]
DeriveClass::DeriveClass(int b, int d){ // call default constructor, bad design
	m_d = d;    //m_b in base class is not initiliazed properly.
}	

DeriveClass::DeriveClass(int b, int d) {
	m_b = b;  //error, can't access private member in base class
	m_d = d;
}

Derived::Derived(int d, int b): Base(b){ // good design, 
	m_d = d;
}
//////////////////////////////////////////
Derived d1(2,3); //call converting constructor, explicit call Base constructor.
Derived d2(2);  // implicit call Base default constructor
Derived d3;   //if Base has no default constructor, d2 and d3 report error
\end{lstlisting}

	\par If a \texttt{Base} class has a destructor, but \texttt{Derived} doesn't have, compiler will produce an implicit default destructor for \texttt{Derived} class, and this implicit default destructor will call base class destructor. If you define a \texttt{Derived} destructor, It will call \texttt{Base} destructor automatically, you don't need to call it explicitly. The question is, How can you make sure you \texttt{Derived} destructor will be called if you use a \texttt{Base} class pointer or reference? You need to make the \texttt{Base} class destructor virtual. That introduce an important principle: \textbf{Make \texttt{Base} class destructor public and virtual} (polymorphic deletion by \texttt{Base} class pointer or reference).	
	
	\par The destructor is the only method that even if it is pure virtual has to have an implementation in order to instantiate derived classes (yes pure virtual functions can have implementations, being pure virtual means derived classes must override this method, this is orthogonal to having an implementation).
	
	\par Base classes need not always allow polymorphic deletion. For example, For \texttt{std::unary\_function}, it's base class, but it's just trait class.(extract type information from a function). You can declare its destructor as protect and non virtual. Then your client can't write below code:
\begin{lstlisting}[numbers=none]
template <class Arg, class Result>
struct unary_function{
	typedef Arg    argument_type;
	typedef Result result_type;
};

void f( std::unary_function* f ){
	delete f; // error, illegal code to use unary_function in this way.
}	
\end{lstlisting}	

	
	\par Don't call base destructor explicitly, It will be called automatically in the reverse order of construction. And you should give a base destructor a definition, Or linker will report error it even you don't call it in your source code.
	
	\par Never throw an exception from a destructor. If exception A is thrown, then stack unwinding will occur. When an object is destructed, its destructor is called, and if another exception B is thrown by the destructor, the application will call the terminate function immediately. If you encounter an exception in destructor, catch it inside the destructor.
	

\subsubsection{Copy constructor in inheritance}

	 Copy constructor (assignment constructor) in inheritance sometimes causes \textbf{slicing problem}.   Below five are all slicing problems, number 4 and number 5 is not very obvious. They all call \texttt{Base} class constructor.  No matter what you input a reference to a \texttt{Derived} class or not.
\begin{lstlisting}[numbers=none]
class Base{};
class Derived1 : Base{};
class Derived2 : Base{};
Derived1 d1;
Derived1 d2;
/////////////////////
Base b = d1; //1) slicing when you assign Derived class to Base class
	
Fun(Base b);
Fun(d1);  //2) slicing when copy construct
	
Base& Bref = d1;
Fun(Bref) //3) slicing when copy construct
	
Base* bp = new Base(Bref); //4) call base copy constructor
	
Base* bp1 = new Derived1();  //5) sibling slicing
base* bp2 = new Derived2();
*bp1 = *bp2;  // bp1 just copy Base part in Derived2.
//so bp1 now is MIXTURE of d1 and d2.
\end{lstlisting}

	\par When you have \texttt{Base} class pointer/reference, how to avoid slicing probem? The answer is: Virtual Clone method. A function's return type is never considered part of its signature. You can override a member function with any return type as long as the return type could be used wherever the base class return type could be used.
\begin{lstlisting}
class Base{
	virtual Base* Clone() = 0;
};
	
class Derived1 : Base{
	virtual Derived1* Clone(){return new Derived1(*this);} //Clone return Derived1
}
	
Base* Copy(Base& Bref){
	return Bref.Clone();
}
\end{lstlisting}

%	\item What does a typical user defined move constructor do?
%\begin{lstlisting}[numbers=none]
%class Child : public Base{
%	Member m_;
%	Child(Child&& x): Base(std::move(x)), m_(std::move(x.m_)){
%		x.set_to_resourceless_state();
%	}
%}
%\end{lstlisting}
	
	
%	\item Think a problem as below: how to make deep copy and avoid slicing in base class copy constructor?
%\begin{lstlisting}[numbers=none]
%class Base{};
%class Derived1 : Base{};
%class Derived2 : Base{};
%Derived d1;
%Derived d2;
%	
%Base* Copy(Base& Bref){
%	//How to avoid slicing and make deep copy here?
%}
%	
%Base& Bref = d1
%Base* d1p = Copy(Bref)
%
%Base& Bref = d2
%Base* d2p = Copy(Bref)
%	\end{lstlisting}
%	
%\item Continue- Think this problem: error method
%\begin{lstlisting}[numbers=none]
%Base* Copy(Base& Bref){
%	Base* p = new Base(Bref) //Slicing happen here, error!
%}
%\end{lstlisting}
%
%	\item Continue- Think this problem: TypeID method. Using \texttt{type\_id} and \texttt{dynamic\_cast} involve a lot of if and switch about type. Anytime if you use \texttt{dynamic\_cast} and \texttt{if}, you can think about using virtual function instead.
%\begin{lstlisting}[numbers=none]
%Base* Copy(Base& Bref){
%	int typeid;
%}
%\end{lstlisting}
%
%	
%\item Continue- Think this problem: Virtual Clone method.
%	A function's return type is never considered part of its signature. You can override a member function with any return type as long as the return type could be used wherever the base class return type could be used.
%\begin{lstlisting}[numbers=none]
%class Base{
%	virtual Base* Clone() = 0;
%};
%	
%class Derived1 : Base{
%	virtual Derived1* Clone(){return new Derived1(*this);}
%}
%	
%Base* Copy(Base& Bref){
%	return Bref.Clone();
%}
%\end{lstlisting}
%	
%	\item Continue- Think this problem: Change Design. Base is concrete class,  More Effective C++ Item 33 said "Making Non-leaf class abstract". So maybe you can change the inheritance system design.
	
	\par Assignment operator and copy constructor in inheritance summary:

	\begin{itemize}
		\item Default assignment operator and copy constructor in derived class which are implicitly produced by compiler will call default base assignment operator and copy constructor.
		
		\item If derived class has no its own resource, don't need to define derived class assignment operator and copy constructor, implicit one will call base one automatically.
		
		\item If derived class has its own resource, you have to define derived class assignment operator and copy constructor. Different with constructor and destructor, assignment operator and copy constructor in the derived class will \textbf{NOT} invoke assignment operator and copy constructor in the base class. You need to manually call base class assignment operator and copy constructor. Syntax looks like below: For copy constructor, just initialization list syntax. For assignment operator, use two different methods depends on if base class declare its own assignment operator(). More detail can be seen in effective C++ Item 16.
		
		
\begin{lstlisting}[frame=single, language=c++]
DerivedClass::DerivedClass(const DerivedClass &dc):BaseClass(dc){ //mem-init 
	...
}  
		
DerivedClass & DerivedClass::operator=(const DerivedClass &dc){
    BaseClass::operator = (dc);    //BaseClass has defined operator=
    ( (BaseClass&) *this ) = dc; //BaseClass hasn't defined operator=
    //( (BaseClass) *this ) = dc; not assignment, just call baseclass copy stor
}
\end{lstlisting}

\begin{description}
	\item[Line 7:] Base class has no assignment operator, change \texttt{*this} to \texttt{BaseClass \&} reference, if you change to \texttt{BaseClass}, It will call copy constructor.
\end{description}
		
	\end{itemize}

	\par For conversion constructors and destructors, the derived class always calls the base class's constructor or destructor. Even if you define your own constructor or destructor, it will implicitly call the base class's version. However, for copy constructors and assignment operators, the derived class's implicit constructor or operator will not call the base class's version. If you define your own copy constructor or assignment operator, you need to manually call the base class's version. This is the key difference between conversion constructors and destructors versus copy constructors and assignment operators.

%	\item There are three articles, you should read them together.\\
%\\
%https://herbsutter.com/2013/05/09/gotw-1-solution/
%\\
%https://stackoverflow.com/questions/21825933/any-difference-between-copy-list-initialization-and-traditional-copy-initializat
%\\
%https://stackoverflow.com/questions/1051379/is-there-a-difference-between-copy-initialization-and-direct-initialization


\subsection{Virtual function and override}

	 Almost all base classes have a virtual function. If a class does not contain a virtual function, it is an indication that it is not meant to be used as a base class, except for some base classes that are only intended for injecting a specific type, such as \texttt{unary\_function}.
	
	\par Only virtual functions are included in the vtbl. Friend functions can't be virtual functions because they are not even members of the class. When a function is declared virtual in a base class, it is automatically virtual in the derived class, but it is still a good idea to explicitly declare it using the keyword \texttt{virtual} in the derived class declarations as well.
	
	\par Do not rewrite non-virtual base member functions. It is not overriding, but overwriting. In fact, overwriting is not a standard concept in C++. Most of the time, you can refer to it as \textbf{name hiding}. If you redefine the same non-virtual function name in both the base and derived classes, you can't use dynamic binding, only static binding. 
\begin{lstlisting}[frame=single, language=c++]
class Base{
	f(int) {}
};
class Derived:public class Base{
	f(int)  {} // overwrite Base::f(int)
};

Base* pb = new Derived();
pb->f(3) // call base f, because pb is Base*, event it points to Derived. 	
\end{lstlisting}

	\par For overriding to occur, several requirements must be met:
	\begin{itemize}
		\item The base class function must be virtual.
		\item The base and derived function names must be identical (except in the case of
		destructor).
		\item The parameter types of the base and derived functions must be identical.
		\item The constness of the base and derived functions must be identical.
		\item The return types and exception specifications of the base and derived functions
		must be compatible. Don't need to be the same.
		
		\item To these constraints, which were also part of C++98, C++11 adds one more: The functions' \textbf{reference qualifiers} must be identical. Below code demonstrate reference qualifier usage:
\begin{lstlisting}
class Widget {
public:
	void doWork() &;  //This doWork applies only when *this is an lvalue.
	void doWork() &&; //This doWork applies only when *this is an rvalue.
}; 
	
Widget makeWidget(); // factory function (returns rvalue)
Widget w; // normal object (an lvalue)
w.doWork();  //call Widget::doWork &
makeWidget().doWork();  //call Widget::doWork &&
	\end{lstlisting}

	\end{itemize}
	
	\par Any small mismatch may not real override base virtual function, but creating a new virtual method with a different signature. In below code, all functions in \texttt{Derived} class are \textbf{NOT} overriding functions. 

\begin{lstlisting}[numbers=none]
class Base {
public:
	virtual void mf1() const;
	virtual void mf2(int x);
	virtual void mf3() &;
	void mf4() const;
};

class Derived: public Base {
public:
	virtual void mf1();  //no const
	virtual void mf2(unsigned int x); //type doesn't match
	virtual void mf3() &&;          //reference qualifier doesn't match
	void mf4() const;               //no virtual keyword in base class
};
\end{lstlisting}
	
	\par Use the \texttt{override} specifier in derived class member functions to check if they match with the member function in the base class. It can overcome all implicit non-override problems in the previous source code.
\begin{lstlisting}[numbers=none]
struct Base{
	virtual void foo();
	void bar();
	virtual void goo(const int);
};
	
struct Derived : Base{
	void foo() override; // OK: B::foo overrides A::foo.
	void bar() override; // Error: A::bar is not virtual.
	void goo(int) override; //Error; different signature. 
}
\end{lstlisting}
	
    \par Use \texttt{final} specifier in \texttt{Base} class, to stop \texttt{Derived} class to override it.
\begin{lstlisting}[numbers=none]
class Base{
	virtual void method1() final;
}
\end{lstlisting}
	

\section{Classes relationship}

\subsection{structure semantic}

\subsubsection{Relationship}

	 OOP has five relationships:
	\begin{description}
		\item[Composition] Composition exists when a member of a class has a \textbf{part-of} relationship with another class. Compositions are typically implemented via normal member variables or by pointers where the class manages all the memory allocation and deallocation. Semantically, it involves ownership, the same lifetime, and no change in the middle, such as a person and their head. You should use a composition relationship if possible. To qualify as a composition, an object and a part must have the following relationship:
		\begin{enumerate}
			\item The part (member) is part of the object (class).
			\item The part (member) can only belong to one object (class) at a time.
			\item The part (member) has its existence managed by the object (class).
			\item The part (member) does not know about the existence of the object (class).
		\end{enumerate}
		
		\item[Aggregation] Aggregation exists when a class has a \textbf{has-a} relationship with the member. Aggregations are typically implemented via pointer or reference. Semantically, it has ownership, maybe the same lifetime, and may change in the middle, such as a container and pointer (same lifetime, changeable), airport and airplane, and school and teacher. In an aggregation relationship, the class does not manage the existence of the members. To qualify as an aggregation, an object and its parts must have the following relationship:
		\begin{enumerate}
			\item The part (member) is part of the object (class).
			\item The part (member) can belong to more than one object (class) at a time.
			\item The part (member) does not have its existence managed by the object (class).
			\item The part (member) does not know about the existence of the object (class).
		\end{enumerate}
		
		\item[Association] Association is a looser type of relationship, where the class \textbf{uses-a} object. Associations may be implemented via pointer or reference, or by a more indirect means (such as holding the index or key of the associated object). Examples include people and toothbrush (same lifetime, changeable), teacher and student (not same lifetime, changeable), person and mother (not nullity), person and wife (nullity, no ownership, different lifetime). To qualify as an association, an object and an associated object must have the following relationship:
		\begin{enumerate}
			\item The associated object (member) is otherwise unrelated to the object (class).
			\item The associated object (member) can belong to more than one object (class) at a time.
			\item The associated object (member) does not have its existence managed by the object (class).
			\item The associated object (member) may or may not know about the existence of the object (class).
		\end{enumerate}
		
		\item[Dependency] Dependency definition: If class X's member function argument is class Y, X is dependent on Y. Dependency definition extension: For a class X, all functions, including free functions, that both "mention" X and are "supplied with" X are logically part of X, because they form part of the interface of X. "Supplied with" means that they appear in the same header file.
		An association almost always implies that one object has the other object as a field/property/attribute (terminology differs). A dependency typically (but not always) implies that an object accepts another object as a method parameter, instantiates, or uses another object. A dependency is very much implied by an association.
\begin{lstlisting}
public class A {
	private C c;  //Association, A has-a c
	public void myMethod(B b) { //Dependency, A references B
		b.callMethod();
	}
}
\end{lstlisting}
		
		\item[Inheritance] Main disadvantages: Tightly coupled, fragile, prone to be abused by developers.
	\end{description}
	

\begin{center}
	\begin{tabular}{|p{0.25\textwidth}|p{0.12\textwidth}|p{0.12\textwidth}|p{0.15\textwidth}|p{0.15\textwidth}|}
		\tophline 
		 & Composition  & Aggregation  & association & Dependency \\ 
		\tophline 
		Relationship type& Whole/part  & Whole/part  & otherwise unrelated  & otherwise unrelated  \\ 
		\tophline 
		Members can belongs to multi classes& no  & yes & yes & yes  \\ 
		\tophline 
		member existence managed by class& Yes & no & no   & no \\ 
		\tophline 
		Directionality & uni  & uni & uni or bidirectional & uni  \\ 
		\tophline 
		relationship verb& part-of & has-a & uses-a & depends-on 
		\bottomhline 
	\end{tabular}
\end{center}

	\par Composition is specific aggregation, and aggregation is specific association. They all used to describe structural semantic. Most of time, they have the same C++ syntax (member object inside another class), but different semantic. Sometimes, difference between aggregation and association is tricky, don't be too serious about it. 
\begin{lstlisting}
class AirPlane{
	Engine eng_; //composition.
	Passenger* pass_; //aggregation.
	Pilot* pil_ //association.
}
\end{lstlisting}

%	\item For Aggregation, It is not a very clearly defined concept and in my opinion it causes more confusion than it is worth. Toothbrush and people can be thought as association relationship more from \textbf{semantic relationship perspective}. composition and association are used more often than aggregation. From \textbf{implementation} perspective,  we can implement divide association into shallow copy and deep copy. 
%	
%	\begin{description}
%		\item[Association-shallow copy:] Foo has a pointer to Bar object as a data member.
%		\item[Association-deep copy:] Foo has a pointer to Bar object and data of Bar is deep copied in that pointer.
%		\item[Composition:] Foo has a Bar object as data member.
%	\end{description}

	
	\par We cannot map real-world relationships into C++ with 100\% accuracy. C++ is a programming language with its own syntax and semantic understanding. Just as we can't inherit an ellipse from a circle in C++, but we can do this in the real world. Therefore, we should not treat all the above relationships too pedantically!
	
	\par In the previous five relationships, inheritance is easy to understand but is the most commonly abused. I will introduce deeper thoughts about inheritance.
	

\subsection{Go deeper into inheritance}

\subsubsection{Basic syntactic knowledge about inheritance}

	
		 Both references and pointers support polymorphism. In C++ language, you can use inheritance with just the header and library files, without any additional source code.
		
		\par A pure virtual class can't be instantiated. It serves as an abstract interface, representing an agreement between the class author (developer) and the class user (client).
\begin{lstlisting}[numbers=none]
class Shape{
	virtual draw() = 0 
}	//you have to redefine it in your child class
			
class Circle: public Shape{
	...
}
\end{lstlisting}
			
	\par There are three kinds of inheritances. 
\begin{lstlisting}[frame=single, language=c++]
class B                    { /*...*/ };
class D_priv : private   B { /*...*/ };
class D_prot : protected B { /*...*/ };
class D_publ : public    B { /*...*/ };
\end{lstlisting}
	
	\begin{itemize}
		\item None of the derived classes can access anything that is private in \texttt{B}.
		
		\item In \texttt{D\_priv}, the public and protected parts of \texttt{B} are private.
		
		\item In \texttt{D\_prot}, the public and protected parts of \texttt{B} are protected. Protect used in three generation inheritance. By protected Inheritance, grandfather member become protected member in father, so grandson can still use grandfather's members.
		
		\item In \texttt{D\_publ}, the public parts of  \texttt{B} are public and the protected parts of \texttt{B} are protected (D\_publ is-a-kind-of-a B).
		
	\end{itemize}

	\par To make a public member of \texttt{B} public in \texttt{D\_priv} or \texttt{D\_prot}, state the name of the member with a \texttt{B::} prefix. E.g., to make member \texttt{B::f(int,float)} public in \texttt{D\_prot}, you can use:
\begin{lstlisting}[numbers=none]
class D_prot : protected B {
public:
	using B::f;  // Note: only introduce name here.
};
\end{lstlisting}

    \par If you want to reuse \texttt{std::string} code in the class \texttt{Student} (which also means a \textbf{has-a} relationship, as a student has a \texttt{string name}), you have two options. The first is composition, and the second is private inheritance.
\begin{lstlisting}[numbers=none]
class Student{ // 1) use composition.
	int getNameLen();
private:
	string m_name;
	vector<double> score;
};

int Student::getNameLen(){
	return m_name.length();
}
\end{lstlisting}

	\par In short, composition uses object names to invoke a method, whereas private inheritance uses the class name and scope resolution operator instead. If you need the base class itself, you can use a type cast such as \texttt{(const string\&) *this}; more details can be found in \textit{C++ Primer}, page 800. Using private inheritance is not a mainstream style, so please avoid it unless you are dealing with a corner case.
	
\begin{lstlisting}[numbers=none]
class Student: private string, private std::vector<double>{//2)private inheritance
	int getNameLen(); // We don't need private member data any more
}
int Student::getNameLen(){
	return string::length(); //use class name and scope-resolution operator
}
const string& Student::getName(){
	return (const string&) *this;
}
\end{lstlisting}


\subsubsection{"Is-A" relationship}

	
	
		 Inheritance has four levels of knowledge:
		\begin{enumerate}
			\item The basic design knowledge, such as manager is a person, apple is a fruit, etc.
			
			\item The basic syntax knowledge of pure virtual, virtual, and non-virtual functions.
			
			\item \textbf{Isolate change between Client and Implementation}. This is the highest level in design patterns. How do we understand the interface? It’s Client $\leftrightarrow$ Interface $\leftrightarrow$ Implementation. Through the interface, you ensure all changes happen on the implementation side and do not affect the client code at all.
			
			\item The ultimate purpose of inheritance is message-driven communication and cooperation between objects.
		\end{enumerate}
		
		\par Public inheritance is about substitutability, not merely reuse. For instance, if a client uses class \texttt{Base} and class \texttt{Derived} inherits from it, we shouldn’t view class \texttt{Derived} as simply reusing elements of \texttt{Base}. Instead, we should see class \texttt{Derived} as interchangeable with \texttt{Base} in the client's usage.
		
		\par A common mistake is inheriting from classes that were not designed to be base classes. For example, you might have a string class but want to change some behavior of the string. So you write: \texttt{class myString : public string}. We generally use inheritance only in the following scenarios:
		\begin{itemize}
			\item The client uses the string class through base class pointers or references.
			\item The base class has virtual functions.
			\item The derived class redefines the base class virtual functions.
		\end{itemize}
		
		As noted, these requirements are not met. Clients most often use a string by value directly, the string class does not have any virtual functions as it is a value class, and it was not designed to be inherited in this way.
		
		\par For example, if you want to change the \texttt{find} function inside the string class, you don't need to use inheritance. Just write a non-member function and pass a string object.
	
\begin{lstlisting}[numbers=none]
myFind(const string& str){
	//you customized behavior.
}
\end{lstlisting}
	
%    \item Even you have specific state, you also can use composition to avoid inheritance.
%
%\begin{lstlisting}[numbers=none]
%class MyString{
%	size_t length(){return str.length}
%	//just need to write forward function here;
%	
%	myFind(){
%		//You customized behavior.
%	}	
%	std::string str;
%}
%\end{lstlisting}
%	

		\par Public inheritance is actually "\textbf{is-substitutable}", not "\textbf{is-a}". For example, a circle is an ellipse and a square is a rectangle in math, but in OOP, you can't make a circle inherit from an ellipse because an ellipse has two foci. Similarly, you can't make a square inherit from a rectangle because \texttt{setWidth} works differently in a square (it changes the height at the same time), which breaks the Liskov Substitution Principle (LSP). The solution is to create an abstract base class (ABC) and have both circle and ellipse inherit from it.
		
		\par The previous example also explains that when you design a class, it doesn't need to represent a practical object like an animal, car, or person. It can represent an abstract concept. (This is why design patterns are such an important concept).
		
		\par Composition vs. Inheritance:
		\begin{itemize}
			\item Does TypeB need to expose the entire interface (all public methods) of TypeA, allowing it to be used wherever TypeA is expected? If so, this suggests inheritance. For example, a Cessna biplane would expose the full interface of an airplane, and possibly more, making it suitable to inherit from the Airplane class.
			
			\item Does TypeB only want some part of the behavior exposed by TypeA? This indicates a need for composition. A bird may need only the flying behavior of an airplane. In this case, it makes sense to extract it out as an interface/class and make it a member of both classes.
			
			\item Inheritance must pass the Liskov Substitution Principle. The previous example about ellipses and circles fails this test because an ellipse has \texttt{setLongAxis()} and \texttt{setShortAxis()}, but a circle doesn't have them at all.
		\end{itemize}
		
		
	\par There is a very good article that explains the ellipse and circle debate in the C++ community: \verb=https://isocpp.org/wiki/faq/proper-inheritance=. Here are a few important points:
	\begin{itemize}
		\item For inheritance, we should no longer understand it as an "is-a" relationship, but rather as a "is-substitutable" relationship.
		
		\item Substitutability is defined by the "contract". If the base class has a method \texttt{void insert(const Foo\& x)}, the \textbf{contract} of that method includes the signature (the name \texttt{insert} and the parameter \texttt{const Foo\&}), but also extends to the method’s advertised preconditions and postconditions.
		
		\item For the ellipse and circle dilemma, you can:
		\begin{enumerate}
			\item Weaken the base class promises,
			\item Strengthen the child class promises, or
			\item Drop the inheritance relationship altogether.
		\end{enumerate}
		
		\item Even if you drop the inheritance relationship, in the modern C++ age, you can use lambdas or closures to achieve some kind of dynamic behavior at runtime. This is a mainstream approach for the future. With \texttt{std::function}, perhaps we won't need as many behavioral design patterns from the 23 design patterns. 
	\end{itemize}


\subsection{"Has-A" relationship}
	
		 There are three methods to describe a has-a relationship: \textbf{1) private or protected inheritance, 2) composition, 3) templates}.
		
		\par Prefer composition; use private inheritance only when no other option because reusing via private inheritance can be syntactically awkward and harder to understand. 
		
%		One exception is when you need to access protected member functions of \texttt{std::string} or \texttt{vector<T>}; in such cases, private inheritance from these classes may be required.
		
		\par Now, I want to not only reuse class A, but also make a class A adaptable or changeable. For example, replacing the brakes of a car at runtime, there are two options:
		\begin{enumerate}
			\item Version 1: Abstract base class. in practice, considering the same lifetime and composition relationship, using a Brake object directly is better. However, if runtime polymorphism is required, then using pointers or references becomes necessary. Smart pointers (\texttt{std::unique\_ptr}) can also be used here.

\begin{lstlisting}[numbers=none]
class Brake {
public: 
	virtual void stopCar() = 0;
};	
class BrakeWithABS : public Brake {
public: 
	void stopCar() { ... }
};
		
class Car {
	Brake* _brake;
public:
	Car(Brake* brake) : _brake(brake) { brake->stopCar(); }
};
\end{lstlisting}
		
		\item Version 2: Template.
		
\begin{lstlisting}[numbers=none]
template<class Brake>
class Car {
		Brake brake;
public:
		Car(){ brake.stopCar(); }
};
		
\end{lstlisting}

%		\item Version 2b: Template and private inheritance.
%\begin{lstlisting}[numbers=none]
%template<class Brake>
%class Car : private Brake {
%		using Brake::stopCar;
%public:
%		Car(){ Brake::stopCar(); }
%};
%\end{lstlisting}
	\end{enumerate}
	
	\par I generally prefer Version 1 using runtime polymorphism because it offers flexibility, and all cars share the same type. It's also OOP mainstream design style in C++. In template implementation, \texttt{Car<Opel>} is a different type from \texttt{Car<Nissan>}. If high performance is a priority, especially when using brakes frequently, I recommend using the template approach (static binding). This approach is known as policy-based design. 
	
	\par Another example of policy-based design is \texttt{std::map}, where you can specify a functor type to compare elements within the map. Due to \texttt{std::map} being a template, policy-based design is the best option in this scenario.
	


\subsection{Ownership semantic}
	 Ownership may describe the relationship between two classes or between a class and its members. Ownership semantics differ from structural semantics, which concern the whole-part relationship. There are two kinds of ownership: exclusive ownership and shared ownership. Composition typically involves exclusive ownership, while aggregation usually involves shared ownership. Association can also imply ownership, such as between a person and their toothbrush or a person and their spouse. Ownership is a semantic concept.
	
	\par Ownership semantics have two subsidiary policies: lifetime policy and non-nullity policy.
	
	
\par An example of class \texttt{Man} and its explanation of design principle behind it. Please note here, it's a toy code, but considering lifetime and ownership factors, this design essentially satisfies the real-world relationships and constraints of various objects. 
\begin{lstlisting}
class Man{
	Heart t_ ; //same life time span
	unique_ptr<ToothBrush> pbrush_;  //exclusive ownership, 
	shared_ptr<Server> pserver_; //shared ownership with others
	weak_ptr<Gym> pgym_;  //no ownership, Gym is managed by shared_ptr outside
	Office* poffice_;     //no ownership, Office isn't managed by smart pointer outside
	Woman& mother;  //Nullity
	void getMoney(const Bank&);
	//or void getMoney(shared_ptr<Bank> &); if Bank object outside is smart pointer
}		
\end{lstlisting}
\begin{enumerate}
	\item For \texttt{Heart} class, it has the same life time with \texttt{Man} and \textbf{exclusive} ownership, so prefer “composition” than freestore object.
	
	\item For \texttt{ToothBrush} class, it should be dynamic (not the same life name with \texttt{Man}), it also has \textbf{exclusive} ownership, so \texttt{unique\_ptr} is a better option.   
	
	\item For \texttt{Server} class, it should be \textbf{shared reference} semantic, so uses \texttt{shared\_ptr} here. At the same time, \texttt{Server} is a member because it maybe used by many other member functions. This represents an \textbf{association} relationship. For \texttt{Bank}, you only use it when you want to get money, so use it as a parameter in functions. This represents a \textbf{dependency} relationship.
	
	\item For \texttt{Office} class and \texttt{Gym} class, no ownership, only reference semantic, you may use \texttt{weak\_ptr} here if \texttt{Gym} object is wrapped by \texttt{shared\_ptr} outside, or use pointer here if \texttt{Office} is not managed by \texttt{shared\_ptr} outside.
	
	\item \texttt{mother} object has non-nullity and reference semantic, so uses reference here. 
	
\end{enumerate}

		
%	\item In the figure and code below, you can see that we first consider \textbf{ownership}, then \textbf{lifespan}. Use C++ language features to describe the relationships and constraints between objects within your specific context. 
%	
%\begin{lstlisting}
%class Man{
%	Heart t_   
%	unique_ptr<Brush> pb_; 
%	shared_ptr<Woman> pwife_; 
%	Company* pb_; 
%	Woman& mother; 
%	void getMoney(const Bank&);
%}
%\end{lstlisting}


\begin{center}
		\includegraphics[width=0.92\linewidth]{pics/owner.drawio.png}
\end{center}


%\begin{description}
%	\item[Company or Bank] No ownership. A company is a member; it's important for you to have work and is used by many member functions. Therefore, it's a member. This represents an association relationship.  For Bank, you only use it when you want to get money, so use it as a parameter in functions. This represents a dependency relationship.
%	
%	\item[Monther] No ownership. It cannot be null and cannot be changed, so we use a reference.
%	
%	\item[Heart] Ownership, same life time, (No dynamic life)
%	
%	\item [Toothbrush] Ownership, dynamic lifespan, and exclusive ownership, so we use \texttt{unique\_ptr}.
%	
%	\item [Wife] Ownership, dynamic lifespan, and shared ownership, so we use \texttt{shared\_ptr}.
%\end{description}



\subsection{Examples about classes relationship}
	 OOP Example 1: Relationship between \texttt{Car} and \texttt{Engine} is composition, where the \texttt{eng} is compiler-generated (not dynamic), simply use a member object. Note that if the \texttt{Engine} class lacks a default constructor, you must use an initialization list in the \texttt{Car}'s constructor.
\begin{lstlisting}[frame=single, language=c++]
class Car{
	Engine eng; // member obj, not use pointer here.
	Car(int carArg, int engArg): eng(engArg){}
}
	\end{lstlisting}
		
	\par OOP Example 2: In a \texttt{People} and \texttt{ToothBrush} (Association) relationship, if they share the same lifetime or have exclusive ownership, use \texttt{unique\_ptr}. You can also use \texttt{unique\_ptr}'s reset function or move semantics from another \texttt{unique\_ptr}.
\begin{lstlisting}[frame=single, language=c++]
class People{
	unique_ptr<ToothBrush> unp_brush;
	
	buyNewBrush(string &name){
		unp_brush.reset(new ToothBrush());
	}
};
\end{lstlisting}

	\par OOP Example 3: Changing the semantics, a \texttt{School} may have a \texttt{Bus}, but the ownership policy tells us that the Bus can be shared by different schools. The lifetime policy tells us that the \texttt{Bus} and the \texttt{School} have separate lifetimes. So here, we should use \texttt{shared\_ptr}.
\begin{lstlisting}[numbers=none]
class School{
	shared_ptr<Bus> sp_bus;
}
\end{lstlisting}

	\par OOP Example 4: Some classes provide a container to hold multiple objects of another type. A value container is a composition that stores copies of the objects it is holding. A reference container is an aggregation that stores pointers or references to objects that live outside the container. For example, \texttt{std::vector} and \texttt{std::map} are containers that can hold multiple objects of another type.

%\begin{description}
%	\item[Line 5:] you can't use \texttt{unpbrush= new Brush()}, \texttt{unpbrush} assignment only support( unique\_ptr< T > \&\&); use reset, it will make original deleted automatically. Don't need destructor in Person class any more.
%\end{description}
	
%	\item OOP Example 3: In a \texttt{wife-husband} (Association) relationship, if you want to express \textbf{Strong Not Nullity}, use a reference. For instance, in a \texttt{Mother-Son} association, initialize the mother using an initialization list. If it involves Nullity, such as with a wife, use either a raw pointer, \texttt{weak\_ptr}, or \texttt{shared\_ptr}. Since there's no ownership involved, do not use \texttt{unique\_ptr} at all.
%	
%%	\item OOP example 3-1: What's different with raw pointer, weak\_ptr or shared\_ptr?
%	\begin{lstlisting}[]
%class Man{
%	Woman*  wife; //Can be set to nullptr. maybe change or live longer than you.
%	Woman& mother;  //Must initialize mother in initial list
%}
%\end{lstlisting}
%
%	
%	\item OOP Example 4: If it's a dependency, such as a friend relationship, most of the time, we just use a pointer or reference as a function parameter.
%\begin{lstlisting}[]
%class Man{
%	lendMoney(const Friend* mike);
%	lendMoney(const unique_ptr<Friend>& mike); //just use Friend in function,
%	lendMoney(const shared_ptr<Friend>& mike); //not a member of class
%}
%\end{lstlisting}
%	
%	\item OOP Example 5: Suppose a Man and Computer (associated from structural semantics) have a has-a relationship and the same lifetime. Don't use a pointer or reference; just copy from a common computer. Maybe later you can customize your computer, and it will not affect the common one. You can copy from \texttt{commonComputer} and initialize all Worker objects. Using an initialization list can improve efficiency in this case.
%\begin{lstlisting}[numbers=none]
%class Worker{
%	Computer m_desktop;
%	Worker (Computer u): m_desktop(u){}
%}
%	
%Computer commonComputer;
%Worker Yan(commonComputer);
%Worker Han(commonComputer);
%\end{lstlisting}
	
	

	


\section{Class interface design}

\subsection{Three big principles}
	 There are three basic rules about design pattern. One of them is Interface Segregation Principle(ISP), that is to say \textbf{Make Inferface simple and small.} The other two principles are:
\begin{enumerate}
	\item Liskov Substitution Principle(LSP)----Clients (Functions and Class) that use pointers or references to base classes must be able to use objects of derived classes without knowing it.  So all overrides of virtual member functions must \textbf{require less and provide more}. So you are able to make substitution successfully.
	
	\item Dependence Inversion Principle(DIP). Client doesn't depend on implementation. \textbf{Both clients and implementations depend on interface.} The "inversion" in Dependency Inversion Principle refers to the reversal of this traditional dependency relationship, which is an inversion of the control of dependencies. Instead of high-level modules controlling and depending on low-level modules, the control is inverted so that low-level modules depend on high-level modules through abstractions. This inversion can result in a more flexible and maintainable system.
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.69\linewidth]{pics/DIP.drawio.png}
		\label{fig:dip}
	\end{figure}
	
\end{enumerate}

	\par Example code below.  1)LSP: \texttt{Car} can use  \texttt{GasPower} or \texttt{ElePower} without know it. 2)DIP: \texttt{Car} is only depends on \texttt{Power*} interface 3)ISP: Interface should be small and separately. 

\begin{lstlisting}
class Car{
	....................
	Power* pow //Pointer or reference to the base class (Power* pow)
};
Car::start(){
	pow->ignite(); //Virtual function support dynamic-binding
}
class Power{
	virtual ignite();
};

class GasPower : public Power
class ElePower : public Power
Car car(gas);
car.start();
\end{lstlisting}



\subsection{Non-leaf classes abstract and NVI}


	 Non-leaf classes abstract rules states that don't derive from concrete classes. A problem with inheriting from a concrete type is that it creates some ambiguity as to whether code which specifies a certain type really wants an object of the specific concrete type (value semantic), or wants an object of a type which behaves in the fashion that the concrete type behaves (reference semantic). This distinction is vital in C++, since there are many cases where operations which will work correctly on objects of a certain type will fail badly on objects of derived types. The problem can be illustrated by the assignment of pointer to base class. That is why we should follow the "non-leaf classes abstract" rule and C++ coding standards 36 "Prefer providing abstract interfaces." They all suggest that you should only inherit from abstract interfaces. It also follows the Dependency Inversion Principle (DIP). When an abstract conception appears in more than one context, you need to build an abstract interface for it. More details can be found in "\textit{More Effective C++}" Item 33.


	\par NVI is making virtual functions nonpublic, and public function nonvirtual. This is similar with Template Method design pattern. About NVI, more detail can be found in "C++ coding standards Item 39" and "Virtuality herb sutter"

\begin{itemize}
	\item Prefer to make interfaces nonvirtual, using Template Method design pattern.
	
	\item Prefer to make virtual functions private.
	
	\item Only if derived classes need to invoke the base implementation of a virtual function, make the virtual function protected. For the special case of the destructor only: A base class destructor should be either public and virtual, or protected and nonvirtual.
	
		\item Inheritance usually has three common usage patterns: 
	\begin{enumerate}
		\item I want to inherit a interface. (pure virtual, you have to rewrite it in your child class by yourself) 
		
		\item I want to inherit a implementation, but I may or may not change it. (virtual, you may or may not rewrite it in your child class)
		
		\item I want to inherit a implementation, but I don't want to change it. (Non-virtual, you can't rewrite it at all)
	\end{enumerate}
	
\begin{lstlisting}[numbers=none]
class shape{
public:
	virtual draw() = 0 //pure virtual,  you have to override it in derived class
	virtual error();   //There is default implementation, but you may change it.
	int objectID();    //You should not rewrite it.
}		
\end{lstlisting}	
\end{itemize}

	\par A typical C++ design looks like this, we have a \texttt{Pilot} class can \texttt{AirPlane} class. This design violate both NVI and non-leaf class abstract rule, so it's not good design. 
\begin{enumerate}
	\item \texttt{fly()} is public virtual function, it violates NVI rule.
	\item AirPlane is not a abstract class, so it violates non-leaf classes abstract rule. If it's a abstract class, dereference pointer \texttt{*a1} in line 19 can't compile. 
\end{enumerate}
\begin{lstlisting}
class AirPlane{ //not a good design
	...
	virtual fly(){ default_fly;}
};

class AirPlane_A{
	//not define fly
};
class AirPlane_B{
	virtual fly(){ new_fly;}
};

class Pilot{
	AirPlane* plane;
}

AirPlane* a1 = new AirPlane_A(); 
AirPlane* a2 = new AirPlane_B();
*a1 = *a2; //dangerous, slicing problem happen here. 
\end{lstlisting}

\begin{center}
\includegraphics[width=0.6\linewidth]{pics/NVI_old.drawio.png}
\end{center}





    \par Below figure illustrates usage of "Non leaf class abstract", "DIP", "NVI" and template method. You should learn this example and do you best to understand all ideas behinds it. 
    
\begin{center}
	\includegraphics[width=0.99\linewidth]{pics/NVI1.drawio.png}
\end{center}

\par A improved design to follow NVI and non-leaf class abstract rule.
\begin{lstlisting}
class Abstract_AirPlane{ //not a good design
public: 
	fly(){pre_fly(); fly_imp(); post_fly();} //template method design pattern
	Abstract_AirPlane* clone() = 0;
private: 
	virtual fly_imp()= 0; //pure virtual, 
protected: 
	default_fly(){default fly implementation;}
};

class AirPlane_A{
	virtual fly_imp(){default_fly();}
	virtual AirPlane_A* clone(){return new AirPlane_A();}
};

class AirPlane_B{
	virtual fly_imp(){ default_fly();}
};	

class AirPlane_C{
	virtual fly_imp(){ ...you own fly implementation;}
};		
\end{lstlisting}
	


\section{Design patterns}
\subsection{Observer and visitor}
	 
	
	\par Visitor is a behavioral design pattern that lets you separate algorithms from the objects on which they operate.
	
	\begin{center}
		\includegraphics[scale=0.4]{pics/visitor1.png}
	\end{center}
	
	Observer is a behavioral design pattern that lets you define a subscription mechanism to notify multiple objects about any events that happen to the object they’re observing. It defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. 
	
	\begin{center}
		\includegraphics[scale=0.5]{pics/observer.png}
	\end{center}
	
	\par Both Obaserver and Visitor are behavioral design pattern. Although they have similar semantics in English, but they are totally two different design patterns from design perspective. 
\subsection{Composite, decorator and Proxy}
	
	 Composite pattern: It represents a tree structure of simple and composite objects by composing objects into hierarchies that depict part-whole relationships. The Composite pattern allows clients to treat individual objects and compositions of objects uniformly. It can be used as a recursive tree structure, such as in a file system tree. In this context, a folder serves as a composite, containing files as components, and a folder itself can be a component within another composite. 

	\begin{center}
	\includegraphics[width=0.49\linewidth]{pics/composite.png}
	\includegraphics[width=0.49\linewidth]{pics/com_file.png}
	\end{center}
	
	\par Proxy is a structural design pattern that lets you provide a substitute or placeholder for another object. A proxy controls access to the original object, allowing you to perform something either before or after the request gets through to the original object.
	
	\begin{center}
		\includegraphics[width=0.49\linewidth]{pics/proxy.png}
	\end{center}
	
	\par Decorator is a structural design pattern that lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors.
	
	\begin{center}
		\includegraphics[width=0.43\linewidth]{pics/decorator.png}
	\end{center}
	
	
	
	
	
	\par Composite, decorator and proxy are all structural design pattern. Why do I put these three design pattern together? They share the similar characteristics from structure diagrams. \textbf{They includes both inheritance and composition relationship between Base class and Derived class.} 
	\begin{itemize}
		
	\item In Composite pattern, \texttt{Composite}(Derived class) inherits from \texttt{Component}(Base class) and, at the same time, contains \texttt{Component}(Base class). \textbf{For external clients}, through inheritance, \texttt{Composite}(Derived class) can be treated as a \texttt{Component}(Base class). \textbf{For internal implementation}, through composition, \texttt{Composite}(Derived class) can be implemented by using multiple \texttt{Components}(Base class). The similar design pattern is Chain of Responsibility. If you know how to understand from both external clients and internal implementation, you can also understand Decorator, Proxy and Chain of Responsibility without any difficulties. 
	\begin{center}
		\includegraphics[scale=0.5]{pics/cr.png}
	\end{center}
	
	\item  Composite and Decorator have similar structure diagrams since both rely on recursive composition to organize an open-ended number of objects. 
	
	\item Decorator and Proxy have similar structures, but very different intents. Both patterns are built on the composition principle, where one object is supposed to delegate some of the work to another. The difference is that a Proxy usually manages the life cycle of its service object on its own, whereas the composition of Decorators is always controlled by the client.
	
 \end{itemize}
 
	
	


\subsection{Factory method, strategy and template method}
	 These three design patterns share similar UML structure but are applied in different scenarios.
	
	\par Factory Method is a creational design pattern that provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created.
	
\begin{center}
	\includegraphics[width=0.93\linewidth]{pics/template_method1.png}
\end{center}

	\par Strategy is a behavioral design pattern that lets you define a family of algorithms, put each of them into a separate class, and make their objects interchangeable.
	
\begin{center}
	\includegraphics[width=0.80\linewidth]{pics/template_method2.png}
\end{center}

	\par Template method is a behavioral design pattern that defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure.
\begin{center}
	\includegraphics[width=0.93\linewidth]{pics/template_method3.drawio.png}
\end{center}


	\par The common point among these three patterns is pushing the responsibility of change down into the child class. In the Factory Method pattern, we push the generation algorithm down to the child class. In the Strategy pattern, the entire algorithm is pushed down. In the Template Method pattern, we push parts of the algorithm down to the child class. This concept is widely utilized in the famous 23 design patterns.
	 


\subsection{Bridge}

\subsubsection{Multiple inheritance and bridge}
	
	 What is virtual inheritance? When a class inherits from two superclasses that share a common base class, multiple inheritance can lead to the diamond problem. This occurs when a subclass inherits two copies of the shared base class. To resolve this issue, the virtual keyword is used to ensure that only one instance of the base class is inherited. This approach follows specific constructor rules, detailed can be found in \textit{"C++ Primer"}. It's crucial to use multiple inheritance judiciously, applying it only when necessary to avoid such complexities.
	
\begin{lstlisting}[numbers=none]
class GrandFather{};
class Father1: virtual public GrandFather
class Father2: virtual public GrandFather
class Son : public Father1, public Father2	
\end{lstlisting}		
	
	\par Suppose you have land vehicles, water vehicles, air vehicles, and space vehicles. (Forget the whole concept of amphibious vehicles for this example; pretend they don't exist for this illustration.) Suppose we also have different power sources: gas powered, wind powered, nuclear powered, pedal powered, etc. How to design a class structure for this scenoria? There are at least three choices for the overall design: the bridge pattern, nested generalization, and multiple inheritance. Each has its pros/cons:
\begin{lstlisting}[numbers=none]
Class GasPowered :public Power //method 1: Multiple inheritance
Class LandVehicle :public Vehicle
Class LandVehicleGasPowered :public GasPowered, LandVehicle 

Class Vehicle{   //method 2: Bridge design pattern
	//
	Power * _power;
}

Class LandVehicle :public Vehicle  // method 3: Nested generalization.
Class LandVehicleGasPowered: public LandVehicle		
\end{lstlisting}	

	%	\begin{center}
	%		\includegraphics[scale=0.38]{pics/MI.png}
	%	\end{center}
%	
{\footnotesize 
	\begin{tabular}{| p{0.12\textwidth}|p{0.1\textwidth}|p{0.13\textwidth}|p{0.1\textwidth}|p{0.1\textwidth}|p{0.1\textwidth}|p{0.1\textwidth}|}
		\hline
		&  Grow \newline Gracefully? & Low \newline Code Bulk?  & Fine Grained Control? & Static \newline Detect Bad Combos?   & Polymorphic on Both Sides? & Share \newline Common Code?   \\
		\hline
		Bridge & Yes & Yes \newline(N+M chunks) & No & No  & No & Yes  \\
		\hline
		Nested \newline generalization & No & No \newline (NxM chunks) & Yes & Yes  & No & No  \\
		\hline
		Multiple inheritance & No & No \newline (NxM chunks) & Yes & Yes  & Yes & Yes \\
		\hline
	\end{tabular}
}		
	
	\par When can we use multiple inheritance? 
	
	\begin{enumerate}
		\item Will the users of Land Vehicle need to have a Vehicle\& that refers to a LandVehicle object? In particular, will the users call methods on a Vehicle-reference and expect the actual implementation of those methods to be specific to LandVehicles?
		
		\item Ditto for GasPoweredVehicles: will the users want a Vehicle reference that refers to a GasPoweredVehicle object, and in particular will they want to call methods on that Vehicle reference and expect the implementations to get overridden by GasPoweredVehicle?
	\end{enumerate}
	If both answers are "yes," multiple inheritance is probably the best way to go.
	
	
	\par Try especially hard to use ABCs when you use MI. In particular, most classes above the join class (and often the join class itself) should be ABCs. In this context, "ABC" doesn't simply mean "a class with at least one pure virtual function;" it actually means a pure ABC, meaning a class with as little data as possible (often none), and with most (often all) its methods being pure virtual.
	
	\par A design discussion can be seen in "C++ FAQ Inheritance-- Multiple and Virtual Inheritance"
	



\subsubsection{Comparsion between factory, bridge and visitor}
	 Factory, Bridge, and Visitor—these three design patterns share the same UML structure, so I will introduce them together. One is a creational pattern, one is a structural pattern, and the last one is a behavioral pattern. However, it's important to note that design patterns are based on semantics and concrete applications, not solely on UML relationships and structures.
	
	\par The similarities of these three are: all three patterns involve two abstract concepts (inheritance systems), and these two systems are interrelated. In the Factory Method pattern, their relationship is a generation; In the Bridge pattern, their relationship is an implementation; and in the Visitor pattern, their relationship is an application. How to understand application in Visitor design pattern? From the previous Visitor UML figure, you can think \texttt{Visitor} is a abstract algorithm, we \textbf{apply} this algorithm on our \texttt{Element}. 
	
	\par This example showcases the abstract factory, bridge, and visitor design patterns using bicycles and cars. Both bicycles and cars can be equipped with either a gas engine or an electric engine, resulting in four different vehicle configurations: gas bicycle, gas car, electric bicycle, and electric car. This context forms the basis of our example.

	\par The figure below illustrates the basic ideas and implementations of the three patterns. Each pattern consists of two basic abstract concepts and their relationships.
	\begin{enumerate}
		\item Factory pattern: When you build a bicycle, you need to have electric motor and thin tire, Factory declares the factory method that returns new product objects(bicycle) with different engine configuration. (Factory--create--Engine)
		
		\item Bridge pattern: When a vehicle run, it need to use one gas engine or electric motor. (Vehicle--implement--Engine)
		
		\item visitor pattern: For a car, we can add gas or charge electricity. (Vehicle--apply--Refillor) 
	\end{enumerate}
	
\begin{center}
			\includegraphics[width=0.95\linewidth]{pics/visitor.png}
\end{center}
	    
	    \par Visitor pattern also support double dispatch, how to understand it? From semantic point of view, \texttt{Vehicle} type and \texttt{Refillor} type (two types) decide \texttt{Refill()} method . From source code point of view, \texttt{Vehicle} first decide a \texttt{Refillor} (\texttt{Electric} or \texttt{Oil}), once it decide one (for example \texttt{Electric}), then pass \texttt{this} pointer to decide \texttt{Refill(Car*)} or \texttt{Refill(Bicyle*)} inside of ElectricRefill class. That is double dispatch, element (Vehicle) accept visitor (Refillor) base class pointer, and pass \texttt{this} pointer to visitor's visit method (Refill). 
	    



\chapter{Exception and error}


\section{Terminate application}
%\subsection{Different methods to terminate}
	 In C language, you can call \texttt{abort()}, \texttt{exit( status )}, \texttt{quick\_exit()}, and \texttt{\_exit()} to end your program at any time. They are all declared in the \texttt{<cstdlib>} header file.
	
	\par \texttt{exit( status )} terminates the process normally. A status value of 0 or EXIT\_SUCCESS indicates success, and any other value or the constant EXIT\_FAILURE is used to indicate an error. \texttt{exit( status )} performs the following operations: 1) flushes any unwritten buffered data, 2) closes all open files, and 3) may remove any temporary files that were created by the program (depending on how they are managed). When you call \texttt{exit( status )} or execute a return statement from main, static and global objects are destroyed in the reverse order of their initialization.
	
	\par \texttt{atexit()} registers a function to be called on normal program termination (via \texttt{exit( status )} or returning from the main function)
\begin{lstlisting}[]
void myProgramIsTerminating(void){
	cout<<"exit main function"<<endl;
}

int main(int argc, char**argv){
	atexit (myProgramIsTerminating);
	//abort(); abort will not call myProgramIsTerminating
}	
\end{lstlisting}		
	
	\par C++11 introduces \texttt{quick\_exit()}, which was added specifically to deal with the difficulties of ending a program cleanly when using threads. \texttt{std::quick\_exit()} is similar to \texttt{\_exit()}, but it provides the option to execute some code that was registered with \texttt{at\_quick\_exit} before the program terminates.
	
	\par \texttt{\_exit()} is called without performing any of the regular cleanup tasks for terminating processes, while \texttt{abort()} is called without destroying any objects and without calling any of the functions passed to \texttt{atexit} or \texttt{at\_quick\_exit}. However, if core dumps are enabled, \texttt{abort()} will dump the core. You can use this core dump to debug your program by analyzing it. Here's how to generate and use a core dump: when your program has an invalid memory operation, running the program may result in the following message:
\begin{lstlisting}[]
*** stack smashing detected ***: terminated
Aborted (core dumped)
\end{lstlisting}
	
	If you want your application to generate core dump, you need to run below commands: (In Ubuntu system)
\begin{lstlisting}[]
ulimit -c unlimited //configure once core file size limited,
sudo service apport start //run once to start apport.
./a.out //this will cause core dump
cat /var/log/apport.log // to see if core dump has been generated. 
gdb a.out /var/lib/apport/coredump/core.youname  // how to use core dump file
bt // give bt command in gdb enviroment, then you will know where 
// your programme perform invalid memory operation.	
\end{lstlisting}	
	
	\par When you use gdb, \texttt{abort()} can list stack frame information for you. It's very helpful for you to debug. \texttt{exit()} just end the application without any extra information.
	
	\par When \texttt{assert} fail, it just calls \texttt{abort}. 
\begin{lstlisting}[numbers=none]
assert(! "You should not reach here");
\end{lstlisting}
	
	\par \texttt{std::terminate()} will be automatically called in a C++ program when there is an unhandled C++ exception. This is essentially the C++ equivalent of \texttt{abort()}. \texttt{std::terminate()} calls a handler that is set by the \texttt{std::set\_terminate()} function, which by default simply calls \texttt{abort()}.
	
	
	\par In C, issuing a return statement from the main function is equivalent to calling the exit function with the return value as its argument. However, in C++, there are significant differences. When you use return in \texttt{main()}, destructors will be called for locally scoped objects. On the other hand, if you call \texttt{exit()}, no destructors will be called for locally scoped objects. Therefore, it's advisable not to use \texttt{exit()} in C++. Instead, use try-catch blocks and return \texttt{EXIT\_FAILURE} to ensure proper stack unwinding in \texttt{main} function. \texttt{exit()} is a C function and is not aware of, nor compatible with, C++ idioms. It does not perform cleanup on objects, including those in the same scope. This means that files may not be closed properly, potentially resulting in unwritten content.
\begin{lstlisting}[numbers=none]
int main() {
	try {
		// your stuff
	}
	catch( ... ) { // catch all exceptions.
		return EXIT_FAILURE;
	}
}		
\end{lstlisting}	
	
	\par The difference between \texttt{exit()} and \texttt{abort()} is that \texttt{exit()} allows the C++ run-time termination processing to take place, including calling global object destructors. On the other hand, \texttt{abort()} terminates the program immediately. The \texttt{abort} function bypasses the normal destruction process for initialized global static objects and also bypasses any special processing specified using the \texttt{atexit} function. In other words, if you use \texttt{abort()}, no objects will have their destructors called—neither global objects, static objects, nor local objects. You can think \texttt{abort()} as a kind of debugging function, which will keep the run-time information as much as possible. 
	
	\par According to previous introduction, if you want to end application in the other fun, you need to throw a exception, then leave it un-handle or re-throw it until it reaches \texttt{main}. When \texttt{main} returns, it will perform the necessary flush operations and destruct all local objects. In this way, stack unwinding will make sure all the destructor to be called. You can also skip the entire \texttt{catch} block. 
\begin{lstlisting}[frame=single, language=c++]
try{
	fun(){
		throw end_exception();
	}
}
catch(end_exception& ex){
	//do something here
	throw;
}		
\end{lstlisting}	
	
%	\begin{description}
%		\item[Source code:] Just skip the entire catch block. When the exception reaches the end of the catch block or is not caught at all, it will propagate to the \texttt{main} function where all local objects will be cleaned up properly. 
%	\end{description}
	


%\section{Bug and assert}
%\subsection{Use assert}
%
%\begin{itemize}
%	
%%	\item You can implement trace by you self.
%%\begin{lstlisting}[numbers=none]
%%#if defined NDEBUG
%%	#define TRACE( format, ... )
%%#else
%%	#define TRACE( format, ... )   printf( "%s::%s(%d)"
%%	format, __FILE__, __FUNCTION__,  __LINE__, __VA_ARGS__ )
%%#endif
%%	\end{lstlisting}
%	
%\end{itemize}

\section{Handling exceptions}



\subsection{Handle error in C}

	 There are three common error handling methods in C/C++ language: 1) global error code or error state, 2) return value, and 3) exceptions in C++.
\begin{lstlisting}[frame=single, language=c++]
errno(), strerror()  //C language, global error code or state. 
cin.fail()  //C++ language, returen value. 
\end{lstlisting}

	\par Besides the differences mentioned above, you can also use custom function pointers to implement customized error handling behavior. For example, the \texttt{set\_new\_handler} function allows you to specify a custom handler function for the \texttt{new} operator.

	\par \texttt{errno()} and \texttt{strerror()} is a typical C language style.

\begin{itemize}
	\item In general, you should detect errors by checking return values, and use \texttt{errno} or \texttt{perror()} only to distinguish among the various causes of an error, such as "File not found" or "Permission denied."
	
\begin{lstlisting}[numbers=none]
FILE * pFile = fopen ("unexist.ent","rb");
if (pFile==NULL)
perror ("The following error occurred");
\end{lstlisting}
	
	\item It's only necessary to detect errors with \texttt{errno} when a function does not have a unique, unambiguous, out-of-band error return (that is, because all of its possible return values are valid; one example is \texttt{atoi()}). 
	%		In these cases (and in these cases only; check the documentation to be sure whether a function allows this),
\begin{lstlisting}[numbers=none]
#include <cerrno>
errno = 0  // set it zero before call any math library function.
double not_a_number = std::log(-1.0);
if (errno == EDOM) 
std::cout << "log(-1) failed: " <<std::strerror(errno); //use strerror with errno
\end{lstlisting}	
	\item You can detect errors by setting \texttt{errno} to 0, calling the function, and then testing \texttt{errno}. Setting \texttt{errno} to 0 first is important, as no library function ever does that for you.
\end{itemize}

	\par C11 provide \texttt{fenv.h} file to expand \texttt{errno}
\begin{lstlisting}[frame=single, language=c++]
#include <math.h>       /* math_errhandling */
#include <errno.h>      /* errno, EDOM */
#include <fenv.h>
/* feclearexcept, fetestexcept, FE_ALL_EXCEPT, FE_INVALID */

#pragma STDC FENV_ACCESS on
errno = 0;
if (math_errhandling & MATH_ERREXCEPT)
feclearexcept(FE_ALL_EXCEPT);

sqrt (-1);
if (math_errhandling & MATH_ERRNO) {
	if (errno==EDOM) 
	printf("errno set to EDOM\n");
}	
if (math_errhandling  &MATH_ERREXCEPT) {
	if (fetestexcept(FE_INVALID)) 
	printf("FE_INVALID raised\n");
}	
\end{lstlisting}


\subsection{Exceptions or Bug?}

	 \textbf{Is it a bug or exception?} Exceptions are typically events that are beyond the control of the program or the user, while bugs are problems that are within the control of the program and can be fixed by changing the code. In other words, exceptions are things that can happen even if the program is perfectly correct, while bugs are things that should never happen if the program is written correctly. An example of exception is a failure to open a file. For exceptions, we should use \texttt{try\{\}} block and \texttt{catch\{\}} block to deal with them. On the other hand, if \texttt{age < 0}, it indicates a bug that needs fixing immediately.

\begin{lstlisting}[numbers=none]
FILE *f = fopen("hr.dat".....);
if(f==nullptr){   //it's exception, don't use assert here.
	return -1;
	throw runtime_error();
}
	
assert(age>=0); //Here use assert, because age<0 is bug, not exception.
fprintf(f, %d, age);	
\end{lstlisting}


	\par You can also think of an exception as a runtime error and a bug as a logical error. Bugs should be found as early as possible. There are two basic methods to find bugs: using assertions and conducting unit tests. I will introduce unit testing in the "Testing" chapter.
	
	\par For runtime errors, you need to throw and catch exceptions to handle them. Distinguishing between exceptions or bugs is important and it does not depend on the phenomenon but rather on the cause. For example, in the function \texttt{f(Foo* p)}, if \texttt{p} is \texttt{nullptr}, there are two possibilities reasons:

\begin{enumerate}
	\item \texttt{nullptr} is passed because application received bad data from an external user (for example, the user forgot to fill in a field and the database connection failed). In this case, you should throw an exception since it is a runtime situation (i.e., something that can't be detected by a careful code-review; it is not a bug). 
	
	\item \texttt{nullptr} is caused by a mistake in the code, for example, you forget to initialize it properly. You should definitely fix the bug in the caller's code. You can't merely change the code within \texttt{f(Foo* p);}, you must, Must, MUST fix the code in the caller(s) of \texttt{f(Foo* p)}.
\end{enumerate}

	\par In previous example, You can use \texttt{assert} first, after you code-review, found that it's not a bug, but cause by an exception, such as net disconnect, then you can change \texttt{assert} to \texttt{throw}. THAT IS  A GOOD STRATEGY!

\begin{lstlisting}[frame=single, language=c++]
fun(int* pi, int j){
	assert(j< 10); //logic error, You should use assert here
	assert(pi == nullptr)
	
	if(file.open()) //runtime error
		throw runtime_error();
}		
\end{lstlisting}

	\par The usage of \texttt{assert} depends on the context, but it's not always recommended to use \texttt{assert} to its fullest. Precondition and postcondition assertions are two important types of assertions, but there are other types of assertions that can also be useful, such as invariants, boundary checks, and null checks. Precondition assertions are used to test the validity of the arguments passed to a method before the method is executed. Postcondition assertions are used to test the validity of the results produced by the method after the method has completed its execution. 
	
	\par The idea behind using \texttt{assert} as precondition check is to immediately spot an abnormal case that may otherwise cause errors in other parts of the code. Without these \texttt{assert} precondition check, it may be difficult to trace the error back to its source position.
\begin{lstlisting}[frame=single, language=c++]
fun(char* p){
	assert(p!=nullptr); //use assert to do precondition check.
	...... // a lot of codes here
	.......//
	strcpy(p)  //application crash here. 
	fun1(p);  //or it will cause error in other function.
}			
\end{lstlisting}
	
	\par The syntax knowledge about \texttt{assert}:
\begin{itemize}
	
	\item Because assert is a function-like macro, commas anywhere in the argument that are not protected by parentheses are interpreted as macro argument separators.
\begin{lstlisting}
assert( min(1,2) == 1 );  // 1 ,(comma here) 2  ERROR
assert( (min(1,2) == 1) );  //  OK	
\end{lstlisting}

	\item Assertions are deactivated by defining preprocessor macro NDEBUG, e.g., with compiler switch: \texttt{g++ -DNDEBUG …}
	
	\item Assert is just \texttt{if()}+\texttt{abort()}: Difference of \texttt{assert} and return error(throw exception) is that abort will terminate you application immediately, and you can use GDB to trace back source easily.
	
	\item You can use \&\& to make \texttt{assert} print out more useful information. string literal is always true; when \texttt{I<5} is false, the whole condition will be printed out.
\begin{lstlisting}[frame=single, language=c++]
#include <cassert>
assert(age>=0 && "warning, age is negative here!");	
\end{lstlisting}

\end{itemize}	

	

\subsection{Exceptions in C++}
	 If you're unsure whether to use exceptions, it's generally recommended to use them in your project. In other words, if you don't have a solid reason against using them, just use them. Exceptions are primarily used to handle runtime, potentially recoverable errors such as:
\begin{itemize}
	\item A file write operation failed or file access operation failed because this file doesn't exist.
	
	\item No enough memory.
	
	\item Invalid value, which come from user input, not come from you error code logic.
	
	\item System communication software invalid protocol, format, or no response.
\end{itemize}

	\par unwinding the stack has cost problems, it make program 10\% larger and slower. So you can use \texttt{-fno-exceptions} compiler switcher to stop using it.

	\par Exception specification is add \texttt{throw} keyword in the end of function,  \texttt{throw()} means it will not throw any exceptions. In modern C++, exception specifications like \texttt{throw()} have been deprecated, and \texttt{noexcept} is preferred. \texttt{noexcept} is used to indicate that a function will not throw any exceptions. It's important to note that exception specifications do not integrate well with templates. Constructors, destructors, and assignment operators will automatically become \texttt{noexcept} if the functions they invoke are \texttt{noexcept}.
	
		\par All standard containers are required to implement the strong exception guarantee for most operations, ensuring commit-or-rollback semantics. This means operations like insertions either complete successfully or leave the container unchanged. "No change" also ensures that failed operations do not invalidate any iterators pointing to the container. However, there are two exceptions to this rule:
	\begin{enumerate}
		\item Multi-element inserts (iterator range inserts) are never strongly exception-safe across all containers.
		
		\item For \texttt{vector<T>} and \texttt{deque<T>}, inserts and erases (both single and multi-element) are strongly exception-safe, provided that type T's copy constructor and assignment operator do not throw exceptions.
	\end{enumerate}
	Inserting into or erasing from containers holding complex types (e.g., \texttt{vector<string>} or \\ \texttt{vector<vector<int> >}) are not strongly exception-safe.
	
	
	\par Standard exception includes logic\_error, domain\_error,  runtime\_error. Invalid\_argument, \\ out\_of\_bounds, range\_error, overflow\_error.

\begin{center}
	\includegraphics[scale=0.5]{pics/exception.drawio.png}
\end{center}


	\par A simple exception can be represented by a \texttt{const char*}, which can be caught using \texttt{const char* c}. A more complex example involves defining an exception class. You can create an exception class, throw an instance of it (throw \texttt{my\_exception\_class}), and catch it using a reference (\texttt{my\_exception\_class\&} ec). You don't need explicit define \texttt{my\_exception\_class} object and throw this object; throw  \\ \texttt{my\_exception\_class\{\}}; will avoid copy and is recommend way to follow.
\begin{lstlisting}[numbers=none]
throw my_exception_class{}; //good style

my_exception_class ex; //bad style.
throw ex	
\end{lstlisting}

	\par You can also build an exception class inside the C++ standard exception system. It needs to derive your class from base \texttt{exception} class and redefine the function \texttt{what()}. If your exception class has a very tight relationship with your real class, it can be declared as a nested class too.

\begin{lstlisting}[numbers=none]
Class my_ex :public std::exception{
	const char* what(){return "my_ex reason is here"}
}	
\end{lstlisting}




	\par Common usage idiom of \texttt{try} and \texttt{catch} block:
\begin{itemize}
	\item Handle an exception and continue executing, place the code in separate try-catch blocks. 
	
\begin{lstlisting}[frame=single, language=c++]
try{ 
	// code that throws an exception	
}
catch (Exception1& ex){
	// handle
}

try{ 
	// this code will execute unless the previous catch block 
	// throws an exception (re-throw or new exception) 
}
catch (Exception2& ex){
	// handle
}			
\end{lstlisting}
	
	\item When an exception is thrown, we have to deal with it immediately and don't want to continue to run, use one \texttt{try} block and multi \texttt{catch} blocks. 
\begin{lstlisting}[frame=single, language=c++]
try{ 
	// code that throws an exception	
	// this line won't be executed. 
}
catch (Exception1& ex){
	// handle
}
catch (Exception2& ex){
	// handle
}				
\end{lstlisting}		
	
	
	\item Properly order your catch-clauses by arranging them in inverse order of derivation. Catching exceptions by reference has two benefits: 1) It supports polymorphic exceptions, allowing you to catch exceptions from specific to more generic types. 2) It avoids unnecessary copying of exception objects.
\begin{lstlisting}[frame=single, language=c++]
void f(){
	// ...
	try {
		// ...
	}
	catch (Base& b) { /* ... */ }  //The order is WRONG here!
	catch (Derived& d) { /* ... */ } //base shadows Derived
	catch (...) { /* ... */ }        //... shadows std::exception& below
	catch (std::exception& e) { /* ... */ }
}	
\end{lstlisting}	
	
	\item Empty throw means that you throw present exception again. It usually appears inside of a \texttt{catch} block. 
\begin{lstlisting}[frame=single, language=c++]
catch(my_base_ex &ex){
	......
	throw; //not using throw ex, maybe ex is child class
}	
\end{lstlisting}		
	
	\item Don't use all throw and catch to replace return-code. For a simple function, if just return one error code and user will not forget to test return code, return-code method is more efficient than exceptions. 
\end{itemize}

	\par Compared with return error code, exception has some advantages:
\begin{itemize}
	\item  Can catch deeper called function exceptions. If you want to use return value, deeper called function is hard to deal with.
	
	\item Exceptions can be used in scenarios where returning a value directly is difficult or impractical: 
	\begin{enumerate}
		\item No return value, such as class constructor.
		\item All return value is normal value, such as \texttt{atoi()}.
	\end{enumerate}
	
	\item Exception can make correct path and error-handle path separately and clearly.
	
	\item You can't ignore exceptions; any unhandled exception can result in termination of the program.
\end{itemize}


	\par \textbf{Never throw any exception in destructor.} In another word, Destructors and deallocation must never fail. In you destructor, don't throw any exception, or catch all the exception inside of it. Otherwise it will call \texttt{std::terminate()} to stop the application.
	
	\par Throwing an exception in constructor is the best way to signal an error during object construction, since there's no return value. In C++, the lifetime of an object begins when its constructor completes. If the constructor throws an exception, the destructor is not called for that object. However, the destructors of any member variables whose constructors have already completed are still called.


\section{Usage suggestions}
\subsection{exception usage suggestion}

	 Exception handling is highly dependent on your application context. So it should be designed into a program rather than just added on. Consciously specify, and conscientiously apply. Develop a practical, consistent, and rational error handling policy early in design, and then stick to it. Ensure that it includes:

\begin{itemize}
	\item Identification: What conditions are errors.
	\item Severity: How important or urgent each error is.
	\item Detection: Which code is responsible for detecting the error.
	\item Propagation: What mechanisms are used to report and propagate error
	notifications in each module.
	\item Handling: What code is responsible for doing something about the error.
	\item Reporting: How the error will be logged or users notified.
\end{itemize}


	\par For different runtime errors, you can take various actions. And it's depends on you context of application. There are mainly four different levels here:

\begin{enumerate}
	\item Error is just warning, log or show it to user, then continue;
	\item Error can be resolved inside a function, the whole application can be continue after you resolve or retry, such as input error.
	\item Set global error code or return error code or throw exception. then caller decide what to do (return a error code or use exception)
	\item Errors can be serious and prevent an application from continuing, in which case it should stop gracefully (by throwing an exception to main function and return from there), or request debugging (by calling \texttt{abort}).
\end{enumerate}

%\item When to use assert ?
%\begin{enumerate}
%	\item Your problem comes from your own coding error.
%	
%	\item Bugs in your program are not something the user can handle, user can do nothing when he face "age should be not negative" unless age is inputted by a user (at this time, you should use return error code or exception to ask user input again)
%	
%	\item You have to stop your application. If you write negative age back to database, It may cause futuristic error for other user later, and it's very difficult to trace back.
%\end{enumerate}

	\par When to throw a exception (or return error code)? Exception and return a error code has the same philosophy. \textbf{let caller decide what to do next}.

\begin{itemize}
	\item As a general rule of thumb, throw an exception when your program can identify an \textbf{external problem} that prevents execution.
	
	\item Identify problems that the program can't handle and inform the user about them, because the user can handle them. For example, running out of memory space, non-existent file, no net connection, failed object construction, and receiving invalid data from the server, etc.
\end{itemize}

%	\item What to do in catch clause?
%
%\begin{enumerate}
%	\item You can actually handle the exception. Your catch clause handle the exception and continues execution without throwing any additional exceptions. Your caller never knows that the exception occurred.
%	
%	\item You can have a catch clause that does blah blah blah, after that you will rethrow the exception. 
%	
%%	In this case, consider changing the try block into an object whose destructor does blah blah blah. For instance, if you have a try block whose catch clause closes a file then rethrows the exception, consider replacing the whole thing with a File object whose destructor closes the file. This is commonly called RAII. 
%	
%	\item Show some messages or log exception, or give user a list options to select, then rethrow.
%\end{enumerate}

	\par Exception in C++ is a tool; use it properly and it will help you; Don't blame the tool if you use it improperly. "Wrong exception-handling mindsets" in c++ FAQ website section 17 is good reference paper. 


\subsection{Debug program}
	 Beside gdb, there are still a few useful debugger in Linux OS:
	\begin{itemize}
		\item cgbd: terminal-based frontend for gdb, sudo apt-get install cgbd (sudo apt install -y cgdb)
		\item gdbgui: brower-based frontend for gdb, https://gdbgui.com,  sudo pip install gdbgui
		\item visual studio code: can connect to gdb. 
	\end{itemize}
	
	\par When compiling your C++ code with g++, use the -g flag to include debugging information in the binary. This will allow gdb to map the executable code back to the source code, making it easier to inspect variables, set breakpoints, and step through the code. Also compile with -O0 to disable optimizations. Optimizations can rearrange or remove code, making it harder to debug.
\begin{lstlisting}
g++ a.cpp -g -O0 -o a -fsanitize=address
g++ a.cpp -g -O0 -o a -fsanitize=undefined
\end{lstlisting}

	\par Valgrind is a powerful tool for memory debugging, memory leak detection, and profiling in Linux programs. It helps developers identify issues like memory leaks, invalid memory access, and improper use of memory.
\begin{lstlisting}
valgrind [options] ./a [program options]
valgrind --tool=memcheck ./a
valgrind --tool=callgrind ./a // runtime profiling
valgrind --tool=drd ./a // multithreading error detection		
\end{lstlisting}	

	\par It's a good practice to always enable all warning options in your compiler using \texttt{-Wall}. When you receive a warning, address it promptly before continuing further with your development. This approach helps in identifying potential issues or problematic code early in the development process, ensuring cleaner and more reliable software.
	
	
	\par Recommended compiler flags for your first programs. Turn on the warning switch as many as possible.
\begin{lstlisting}
g++ -std=c++20 -Wall -Wextra -Wpedantic -Wshadow -Werror input.cpp -o output	

// below is production level recommended set
-Wall -Wextra -Wpedantic -Wshadow -Wconversion -Werror -fsanitize=undefined,address -Wfloat-equal -Wformat-nonliteral -Wformat-security -Wformat-y2k -Wformat=2 -Wimport -Winvalid-pch -Wlogical-op -Wmissing-declarations -Wmissing-field-initializers -Wmissing-format-attribute -Wmissing-include-dirs -Wmissing-noreturn -Wnested-externs -Wpacked -Wpointer-arith -Wredundant-decls -Wstack-protector -Wstrict-null-sentinel -Wswitch-enum -Wundef -Wwrite-strings		
\end{lstlisting}		

\par Sometimes it's not possible to eliminate a warning, or you may have a specific reason to keep a warning in place. If a warning originates from a header file that you cannot modify, you can use the \texttt{\#pragma} warning directive in your code to temporarily disable it and then restore it later. This approach helps manage warnings effectively in situations where modifying the header file is not an option.

\begin{lstlisting}[numbers=none]
#pragma warning(push)  //save original warning configuration.
#pragma warning(disable:4512); //disable warning.
#include<not_change.h>
#pragma warning(pop)  //restore original warning configuration.		
\end{lstlisting}
	

     
\chapter{Generic programming}
     
\section{Type deduction basic}


\subsection{template type deduction}

	 With the help of code below, I explain the basic rules for type deduction.
\begin{lstlisting}[numbers=none]
template<typename T>
void f(ParamType param);

f(expr); // deduce T and ParamType from expr
\end{lstlisting}

\begin{itemize}
	
	\item ParamType is a reference or pointer, but not a forwarding reference. If expr's type is a reference, \textbf{ignore the reference part}, then pattern-match expr's type against ParamType to determine T.
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
void f(T& param); // param is a reference
	
int x = 27; // x is an int
const int cx = x; //cx is a const int
const int& rx = x; //rx is a reference to x as a const int
f(x);    //T is int param's type is int&
f(cx);   //T is const int, param's type is const int&
f(rx);   //T is const int, param's type is const int&
\end{lstlisting}
	
	\item If ParamType is a Universal Reference, we use different rule for lvalue and rvalue.
	
	\begin{enumerate}
		\item If expr is an lvalue, both T and ParamType are deduced to be lvalue references. Although ParamType is declared using the syntax for an rvalue reference, its deduced type is an lvalue reference.
		
		\item If expr is an rvalue, the "normal" (i.e., Case 1) rules apply.
	\end{enumerate}
	
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
void f(T&& param); // param is now a universal reference
int x = 27; // as before
const int cx = x; // as before
const int& rx = x; // as before
	
f(x);   //x is lvalue, so T is int& param's type is also int&.
f(cx);  //cx is lvalue, so T  and param's type are const int&.
f(rx);  //rx is lvalue, so T  and param's type are const int&.
f(27);  //27 is rvalue, so T is int, param's is therefore int&&.
\end{lstlisting}

	
	\item ParamType is neither a pointer nor a reference. As before, if expr's type is a reference, ignore the reference part. After ignoring expr's reference-ness, if expr is const, ignore const too; if it's volatile, also ignore that.
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
void f(T param); // param is now passed by value
	
int x = 27; // as before
const int cx = x; // as before
const int& rx = x; // as before
f(x);   //T and param are both int
f(cx); //T and param are both int
f(rx); //T and param are both int
\end{lstlisting}

	
	\item We drop const and volatile qualifiers only for by-value parameters. For reference-to-const pointer or pointer-to-const pointer parameters, when skipping const, we skip only the top-level const.
\begin{lstlisting}
const int ci = 2;
int& ncr = ci; //compile error
const int& cr = ci; //compile ok
int v = ci; //compile OK, v is int, not const int

template<typename T>
void f(T param); // param is now passed by value
	
const int* const p1 = &x;
f(p1)   //Param is const int*, top const has been skipped. 	
const int*& rp = p1;
f(rp)  //Param is const int*, top const is default for reference. 
\end{lstlisting}
	\end{itemize}
	
	\par Conclusion:  Take four steps to decide:
	\begin{enumerate}
		\item Array or function decay to pointer, if they are not used to reference ParamType.
		\item Universal reference deduct different type for lvalue and rvalue. 
		\item Reference is ignored.
		\item For value-type ParamType, \texttt{const} and \texttt{volatile} are also ignored.
	\end{enumerate}
	
	\par If you are not satisfied with default type deduction, you can manually specify the type.  
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
void f(T param); 
	
int &x = a;
f(x)  //T is int
f<int&>(x) //T is int&
\end{lstlisting}


\subsection{auto type deduction}
	
\subsubsection{auto type deduction in expression}
	 Auto follows the same deduction rule as a template type. Template type deduction occurs when you call a function or build a customized type. Auto deduction happens when you initialize using assignment. In \texttt{auto} deduction, you can think of \texttt{auto} as the \texttt{T} in template deduction.
	
\begin{lstlisting}[frame=single, language=c++]
auto x = 27; // x is neither ptr nor reference
const auto& rx = x; //  rx is a non-universal ref.
auto && ax = 27; // ax is universal(forwarding) ref
\end{lstlisting}

    \par \texttt{auto\&\&} is a forwarding reference.
\begin{lstlisting}[frame=single, language=c++]
auto&& uref1 = x;  //x is int and lvalue, so uref1's type is int&
auto&& uref2 = cx; //cx is const int and lvalue, so uref2's type is const int&
auto&& uref3 = 27; //27 is int and rvalue, so uref3's type is int&&
\end{lstlisting}

	\par When using \texttt{auto}, you need to be careful with \{...\}. Details can be found in the fourth chapter, "Initialization" in the "Pitfalls of Auto" section.

	\par \texttt{auto} in a function return type or a lambda parameter implies template type deduction, not auto type deduction rule for expression.
\begin{lstlisting}[frame=single, language=c++]
template<typename T>  
void f(T x);
f({ 11, 23, 9 });  //error! can't deduce type for T
void f(std::initializer_list<T> initList);//OK
	
auto createInitList(){
	return { 1, 2, 3 }; //error! can't deduce type for { 1, 2, 3 }
}
	
std::vector<int> v;
auto resetV = [&v](const auto& newValue) { v = newValue; }; // C++14
resetV({ 1, 2, 3 });  //error! can't deduce type for { 1, 2, 3 }
\end{lstlisting}

	\begin{center}
        \includegraphics[scale=0.6]{pics/autotype.png}
    \end{center}




\subsubsection{auto parameter type deduction}
	 \texttt{auto} can be used in function parameter, it is just another kind of template function.

\begin{lstlisting}[numbers=none]
void fun1(auto i){
    cout<<i<<endl;
}
		
fun1(23);  //produce two overload fun1 function.
fun1("abc");
\end{lstlisting}

    \par generic lambda( just like template lambda). \texttt{auto} can directly hold closures(lambda), and in C++14, It can be used as lambda parameter.
\begin{lstlisting}[frame=single, language=c++]
auto adder  = [](auto op1, auto op2){ return op1 + op2; };
\end{lstlisting}
	
	\par In C++14, with help of \texttt{auto}, we can simplify lambda definition. 
\begin{lstlisting}[frame=single, language=c++]
auto derefUPLess =               
[](const std::unique_ptr<Widget>& p1,  const std::unique_ptr<Widget>& p2){
	return *p1 < *p2; 
};  //comparison func. for Widgets pointed to by std::unique_ptrs               

//C++14 version, values pointed to by anything pointer-like
auto derefLess = [](const auto& p1,  const auto& p2){
	return *p1 < *p2; 
}; 
\end{lstlisting}
	
	\par \texttt{auto \&\&} is forwarding reference. A good example \texttt{auto\&\&}(forwarding reference) comes from generic lambda. 
\begin{lstlisting}[frame=single, language=c++]
struct Functor{
    void operator ()() const &  { std::cout << "lvalue functor\n"; }
    void operator ()() const && { std::cout << "rvalue functor\n"; }
};

auto perfectLambda = [](auto&& func, auto&&... params) {
	std::forward<decltype(func)>(func)(
	std::forward<decltype(params)>(params)...
	);
};
auto lambda = [](auto func, auto&&... params) {
	func(std::forward<decltype(params)>(params)...);
};

Functor fun;
lambda(fun);  //output  lvalue functor
lambda(Functor{}); //output  lvalue functor
perfectLambda(fun); //output  lvalue functor
perfectLambda(Functor{}); //output  rvalue functor
    \end{lstlisting}


\subsubsection{auto return type deduction}
	 C++11 permits the automatic deduction of the return type of a lambda function whose body consists of only a single return statement, so we don't need to specify its return type.
\begin{lstlisting}[numbers=none]
[=]() -> some_type { return foo() * 42; } // ok
[=]  { return foo() * 42; } //ok,deduces "-> some_type"
\end{lstlisting}
	
	\par In C++14, this has been expanded in two ways. First, it now works even with more complex function bodies containing more than one return statement, as long as all return statements return the same type. Secondly, it now works with all functions, not just lambdas. Of course, this requires the function body to be visible.
\begin{lstlisting}
// C++14
[=] {               // ok, deduces "-> some_type"
	if( expr ) {
		return foo() * 42; // with arbitrary control flow
	}
	return foo() * 43; 
}                       
\end{lstlisting}
		
	\par Below will produce compile error, because it has ambiguity for return type of function \texttt{f}.
\begin{lstlisting}[numbers=none]
auto f(int i){  // It will cause compile error.
    if ( i < 0 )
    	return -1;
    else
    	return 2.0
}
\end{lstlisting}

%	\par In C++ 14, we can use auto directly in template function as return type. 
%\begin{lstlisting}[frame=single, language=c++, mathescape=true]
%template<typename T, typename U>  //C++ 11 syntax
%auto eff(T t U u) -> decltype(T*U){
%	....
%}
%
%template<typename T, typename U> //after C++ 14
%auto eff(T t U u) {
%	return t*u
%}	
%\end{lstlisting}

	\par For template function return type, we can use three different ways.	
	\begin{enumerate}
		\item C++ 11, use auto + trailing type.
\begin{lstlisting}[numbers=none]
template <class T>
auto addFooAndBar(T const& t) -> decltype(t.foo() + t.bar()) {
    return t.foo() + t.bar();  //trailing return type
}
\end{lstlisting}

	\item C++ 14, directly use \texttt{auto}.
\begin{lstlisting}[numbers=none]
template <class T>
auto addFooAndBar(T const& t) {
    return t.foo() + t.bar();
}
\end{lstlisting}

		\item Usage of \texttt{decltype(auto)}, I will introduce this topic in \texttt{decltype}. More detail can be found in Effective Modern C++ item 3.
	\end{enumerate}
	
	\par Prefer to use function return type deduction wherever applicable, avoid trailing return type unless you really need them, it makes your code harder to read.
	
	\par There are three ways to view deducted type. You can use IDE or use \texttt{typeid} or \texttt{std::type\_info::name}. Another trick is to use compiler error message.

\begin{lstlisting}[frame=single, language=c++]
std::cout << typeid(x).name() << '\n';  //use typeid 

template<typename T> // declaration only for TD;
class TD; // TD == "Type Displayer"

TD<decltype(x)> xType; //compiler errors containing decltype(x)'s type
\end{lstlisting}
		



\subsection{decltype deduction}
\subsubsection{basic deduction rule}
	 \texttt{decltype} has two different deducting rules when facing different kinds of expression.
	
	\begin{itemize}
		\item Expression whose type is to be determined is \textbf{a plain variable} or \textbf{function parameter}, like \texttt{x}, or a class member access, like \texttt{p->m\_x.} In that case, \texttt{decltype} lives up to its name: it determines the type of the expression to be the declared type.  Pay attention to the difference between \texttt{decltype} and \texttt{auto}.
\begin{lstlisting}[frame=single, language=c++]
vector<int> v; // decltype(v) is vector<int>
struct S {
	int m_x;
};

int x;
const int cx = 42;
const int& crx = x;
const S* p = new S();

decltype(x) a;  // a is int, as auto a =x

decltype(cx) b; // b is const int
auto b = cx;  //auto ignore const, b is int

decltype(crx) c;  // c is const int&.
auto c = crx; //ignore reference and const, c is int

decltype(p->m_x) d; // d is int although p points to const S
auto d = p->m_x; //auto ignore const, d is int
\end{lstlisting}
		
		\item If expr is not case 1, then it's case 2. There are three different rules for case 2:
		\begin{enumerate}
			\item If expr is an lvalue, then \texttt{decltype(expr)} is \texttt{T\&}. 
			\item If expr is an xvalue, then \texttt{decltype(expr)} is \texttt{T\&\&}. 
			\item Otherwise, expr is a prvalue, and \texttt{decltype(expr)} is \texttt{T}.
		\end{enumerate}
	\end{itemize}


	\par For case 2, some complex expression examples:
\begin{lstlisting}[frame=single, language=c++]
const S foo();
const int& foobar();
std::vector<int> vect = {42, 43};

typedef decltype(foo()) foo_type;   //const S
typedef decltype(foobar()) foobar_type; //const int&
decltype(vect[0]) first_element = vect[0]; //int&
double d1, d2;
typedef decltype(d1 < d2 ? d1 : d2) cond_type; //double &
int x = 0;
typedef decltype(x < d2 ? x : d2) cond_type_mixed;  //double
\end{lstlisting}

	\begin{description}
		\item[Line 5:] \texttt{foo()} is declared as returning \texttt{const S}. The type of \texttt{foo()}
is \texttt{const S}. Since \texttt{foo()} is a prvalue, decltype does not add a reference. Therefore, \texttt{foo\_type} is \texttt{const S}.
		
		\item[Line 6:] The type of \texttt{foobar()} is \texttt{const int\&}, and it is an lvalue. Therefore, decltype adds a reference. By the C++11 reference collapsing rules, that makes no difference. Therefore, \texttt{foobar\_type} is \texttt{const int\&}
		
		\item[Line 7:] \texttt{std::vector<int>}'s operator[] is declared to have return type \texttt{int\&}. Therefore, the type of the expression \texttt{vect[0]} is \texttt{int\&}. Since \texttt{vect[0]} is an lvalue, decltype adds a reference. By the C++11 reference collapsing rules, that makes no difference. Therefore, \texttt{first\_element} has type \texttt{int\&}.  
		
		\item[Line 9:]  The type of the expression is double, and the expression is an lvalue. Therefore, a reference is added, and \texttt{cond\_type} is \texttt{double\&}
		
		\item[Line 11:] The type of the expression is \texttt{double}, different with line 9. The expression is a prvalue, because in order to accommodate the promotion of x to a double, a temporary has to be created. Therefore, no reference is added, and \texttt{cond\_type\_mixed} is \texttt{double}.  For a conditional expression (?:) to be an lvalue (again, in broad and simple terms), the second and third operands must be lvalues of the same type. This is because the type and value category of a conditional expression is determined at compile time and must be appropriate whether or not the condition is true. If one of the operands must be converted to a different type to match the other then the conditional expression cannot be an lvalue as the result of this conversion would not be an lvalue.
	\end{description}


\subsubsection{decltype usage}
	
	 C++14 supports generic lambdas. Those are basically lambdas with a templated function call operator, but we don’t get to declare any template parameters. Actually working with the type of whatever was passed to the lambda requires decltype.
\begin{lstlisting}
auto make_vector = [](auto const& x, std::size_t n) { 
	return std::vector<std::decay_t<decltype(x)>>(n, x); 
};	
\end{lstlisting}
	
		
	\par \texttt{decltype} case 2 rule mainly used in deducting template function return value. 

%	\item When a function returns a lvalue reference, auto will not work here(skip reference), only decltype can keep reference properly.
%\begin{lstlisting}
%template<typename Container, typename Index>  //C++11 syntax
%auto authAndAccess(Container& c, Index i) -> decltype(c[i]){
%	authenticateUser();
%	return c[i];
%}
%
%template<typename Container, typename Index> // C++14 syntax
%decltype(auto) authAndAccess(Container& c, Index i) {  //decltype(auto) here
%	authenticateUser();                               
%	return c[i];
%}
%\end{lstlisting}

	\par An example of usage of \texttt{decltype(auto)}. \texttt{array[pos]} in below code is lvalue. \texttt{decltype(auto)} will make the return type is \texttt{int\&}, not \texttt{int}. So we can get the desired effect. 
\begin{lstlisting}
template <typename T>
//Must use decltype(auot) here, only auto is not correct, it deduces int, not int&
decltype(auto) array_access(T& array, size_t pos)  {
	return array[pos]; //return int& here, 
}

std::vector<int> vect = {42, 43, 44};
array_access(p, 2) = 46; //we can modify vect here. 44 is changed to 46.		
\end{lstlisting}


		\par When you use \texttt{decltype(auto)}, it tells the compiler to automatically perform type deduction, but to use \texttt{decltype} rules, not \texttt{auto} rule. This is the most useful when dealing with expressions that return an lvalue, such as \texttt{a[0]}. In this case, if you use \texttt{auto}, it will ignore any reference, but \texttt{decltype(auto)} will preserve it. Below is example about using \texttt{decltype(auto)}. The whole code need extra explanation here:
	\begin{itemize}
		\item \texttt{Container\&\& c} is forwarding reference, to accept both lvalue and rvalue.
		
		\item Inside function, \texttt{c} need to pass to \texttt{std::forward}. that is common rule for forwarding reference.
		
		\item If \texttt{c} is xvalue, forward return xvalue in line 4, then when we return this value, we also need keep it as xvalue. That is why decltype rule come from: "If expr is an xvalue, then \texttt{decltype(expr)} is \texttt{T\&\&}".
		
		\item Outside of function, return is xvalue, so we can move it efficiently. that is the whole story for the below code. 
	\end{itemize}
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
template<typename Container, typename Index> // final c++14
decltype(auto) authAndAccess(Container&& c, Index i) {
	authenticateUser();
	
	if constexpr(is_lvalue_reference_v<Container>){
		return std::forward<Container>(c)[i];  //return lvalue reference
	}
	else{
		std::move(std::forward<Container>(c)[i]); //return xvalue 
	}
}

auto s = authAndAccess(queue,5); //copy here.
auto s = authAndAccess(std::move(queue),5);  //move here
\end{lstlisting}


	\par The use of \texttt{decltype(auto)} is not limited to function return types. It can also be convenient for declaring variables when you want to apply the decltype type deduction rules to the initializing expression.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
Widget w;
const Widget& cw = w;
auto myWidget1 = cw;  //auto type deduction: myWidget1's type is Widget.
decltype(auto) myWidget2 = cw; //myWidget2's type is  const Widget&
\end{lstlisting}

	\par An important property of decltype is that its operand is not evaluated. For example, you can use an out-of-bounds element access to a vector as the operand of decltype without triggering a runtime error.
	
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
std::vector<int> vect;
assert(vect.empty());
typedef decltype(vect[0]) integer;  //work even vect is empty.
\end{lstlisting}
	
	\par Another property of decltype is that when \texttt{decltype(expr)} is the name of a plain user defined type (not a reference or pointer, not a basic or function type), then \texttt{decltype(expr)} is also a class type name. This means that you can access nested types directly:
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
template<typename R>
class SomeFunctor {
public:
	typedef R result_type;
	...
};

SomeFunctor<int> func;
typedef decltype(func)::result_type i; //i is int, You can access nested type
\end{lstlisting}
	
	\par You can also declaring variables by \texttt{decltype}. Note that you can't use \texttt{auto} in this case. This is because \texttt{decltype} doesn't actually execute the expression given as its argument; it is only used by the type checker to determine a type. This usage is similar to using \texttt{auto a = expression}, where we can automatically deduce the type of a from the expression.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
class A {
	std::vector<std::pair<int, std::string>> array;
	decltype(array.begin()) iter;  // no need initialization expression
	//Don't need to use: std::vector<std::pair<int, std::string>>::iterator iter 
};
\end{lstlisting}
	
	\par \texttt{std::declval} allows you to use \texttt{decltype} without constructing the object. The type doesn't even need a default constructor, and in fact, it can be used with an incomplete type. 
	
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
template <typename C>
decltype(std::declval<const C>().begin()) // return type of function template foo
foo(const C& c){
	return one iterator of c
}
\end{lstlisting}
	
	\par \texttt{declval} is commonly used in templates where acceptable template parameters may have no constructor in common, but have the same member function whose return type is needed.
	
\begin{lstlisting}[frame=single, language=c++]
struct Default {
	int foo() const { return 1; } 
};
struct NonDefault{
NonDefault(const NonDefault&) { }
int foo() const { return 1; }
};	
decltype(Default().foo()) n1 = 1;    //type of n1 is int
//decltype(NonDefault().foo()) n2 = n1;  //doesn't work, no default ctor
decltype(std::declval<NonDefault>().foo()) n2 = n1; //It's OK now, n2 is int
\end{lstlisting}
	
%	\item However, the reference that \texttt{decltype} adds is not always what you want. It happens frequently that you need to remove it with \texttt{remove\_reference}. 
%\begin{lstlisting}
%template<typename T, typename S>
%auto fpmin(T x, S y) -> decltype(x < y ? x : y) {
%	return x < y ? x : y;  //If x and y have same type, it return reference.
%}  						//Return reference of local object is always HORRIBLE!.
%
%template<typename T, typename S>
%auto fpmin(T x, S y) 
%	->typename std::remove_reference<decltype(x<y?x:y)>::type{
%	return x < y ? x : y;
%} //Correct implementation.
%\end{lstlisting}	
	
	\par Basic knowledge of decltype detail can be found "How decltype Deduces the Type of an Expression: Case 1"


\subsection{Type deduction summary}
	 \texttt{auto}, template \texttt{T} and \texttt{decltype} are three kinds of type deduction scenario in generic programming. \texttt{auto} and template T are almost same, except when we encounter \texttt{initilizaer\_list}.  

	\begin{center}
		\includegraphics[scale=0.6]{pics/type_deduct.png}
	\end{center}


	\par \texttt{decltype} is quite different from auto and template T. It can be used in a wider variety of contexts, such as typedefs, function return types. We can use \texttt{decltype(auto)} to maintain the reference type. \texttt{decltype} can also be used to declare variable type without initialization expression, which is slightly different from \texttt{auto}. It doesn't require executing the code and can be combined with \texttt{declval}.
	
	
	\begin{center}
		\includegraphics[scale=0.65]{pics/decltype.png}
	\end{center}
	
	 
	\par Why \texttt{decltype} has so complex definition about type deduction?  There are two different ways in which \texttt{decltype(expr)} can work, depending on the value of the category of the expression. The final specification of \texttt{decltype} represents a compromise between two different possible points of view. \texttt{decltype} rule 1 is for declaring a variable, and \texttt{decltype} rule 2 is for deducing the type for the return value from a function.
	\begin{enumerate}
		\item Rule 1 is that \texttt{decltype} should be a way to retrieve and reuse the type of a variable as declared in the source code: I declared a variable x of type T at some point in my code. Now I want to use that type for some other purpose, like making a typedef, or specify the return type of a function. I don't want to repeat myself, so give me a way to recover the declared type of my variable, exactly the way I originally wrote it. If that declared type has a reference and/or a const or volatile qualifier on it that I don't want, I'll remove that myself. This is what rule 1 of the specification of decltype does.
		
		\item Rule 2 originates in the needs of library writers. They often find themselves in a situation where the return type of a function needs to be the type of some expression, typically something that depends on template parameters. When the return expression is \texttt{T[]}, we need to return an lvalue reference because it's an lvalue. When the return expression is \texttt{std::move()}, we need to return \texttt{T\&\&} because it's an xvalue. For the remaining 99\% of expressions, such as T1+T2, they return prvalues, so we just return the type T for the prvalue, that is all!
	\end{enumerate} 
	

	

\section{Template specialization}
\subsection{class template specialization}
	 Class templates can be partially specialized, and the resulting class templates remains templates. Partial specialization allows template code to be customized for specific types in situations such as:

	\begin{itemize}
		\item A template has multiple types, and only some of them need to be specialized. The result is a template parameterized on the remaining types.

		\item A template has only one type, but a specialization is needed for pointer, reference, pointer to member, or function pointer types. The specialization itself is still a template on the type pointed to or referenced.
		
		\item There are three types of partial specialization. Please note that all partial specialization forms must have <> after the class name.
		\begin{enumerate}
			\item Specialize one or more of types.
\begin{lstlisting}[frame=single, language=c++]
template<class T1, class T2>
class A{
}

template<class T1>
class A<T1, int>{  // must have <> after class name
}		
\end{lstlisting}				
			
			\item Specialize to point or reference type.
\begin{lstlisting}[frame=single, language=c++]
template<class T>
class A{
}

template<class T>
class A<T*>{  // must have <> after class name
}		
\end{lstlisting}	
			\item Specialize to another template.
\begin{lstlisting}[frame=single, language=c++]
template<class T>
class A{
}

template<class T>
class A<vector<T> >{  // must have <> after class name
}			
\end{lstlisting}	

		\end{enumerate}
	
		\item Here's another example of class template specification. You can see that there are three levels which become narrower and narrower: 1) the base template, 2) partial specialization, and 3) explicit (full) specialization of the member.
\begin{lstlisting}[frame=single, language=c++]
template <class T>  // 1)base template
class Storage{
	T m_value;
public:
	Storage(T value){
	m_value = value;
}

template <class T> // 2)partial specialization
class Storage<T*>{ //There is <> after class name.
	T* m_value;
public:
Storage(T* value){
	m_value = new T(*value);  //To make deep copy
}

template <>  //3) explicit(full) specialization, empty <> after template
Storage<char*>::Storage(char* value){
	int length = 0; //Figure out how long the string in value is
	while (value[length] != '\0')
		++length;
}
\end{lstlisting}

\end{itemize}

    \par Always keep the design of a template in mind and avoid blind use. When you use a pointer as a typename, be on high alert. Pointer sometimes need to be deal with differently, at that time we need partial specialization of template class. A very good article is: \\ https://www.learncpp.com/cpp-tutorial/13-8-partial-template-specialization-for-pointers/. 

\begin{lstlisting}[frame=single, language=c++]
template <typename T>
class Foo{..} //general one

template <typename T>
class Foo<T*>{..} //partial specializations.
\end{lstlisting}

	\par Explicit specializations usually need define all the implementation in it. If there is a lot of repetition. There are two helpful options: 
\begin{enumerate}
	\item Add a special function which is just suitable for certain type. 
\begin{lstlisting}[numbers=none]
template <typename T>
class A{
	public:
	void onlyForInts(T t){
		static_assert(std::is_same<T, int>::value, "Only ints!");
	}
};

A<int> i;
i.onlyForInts(1); // works !
A<float> f;
//f.onlyForInts(3.14f); // does not compile !	
\end{lstlisting}	
	
	\item Use type trait and overload, select at the compile time. See \texttt{enable\_if} example below.
\end{enumerate}


\subsection{Function template specification}
\subsubsection{Basic knowledge about function template specification}

     In the case of a template function, there are options for overloading and full specialization. Template functions do not support partial specialization because they can use overloading to achieve the same result. In other words, if you want to have a custom implementation of a function with the same name, you should use an overloaded function. However, if you need a custom implementation of a class with the same name, you can use partial or full specialization.
    
	\par You can also explicit(full) specialization of member function in template class. 


    \par Because for \texttt{char *}, you can't use >, but you can use \texttt{strcmp}. Therefore, you need to build an explicit specialization version. The prototype and definition of an explicit specialization should be preceded by \texttt{template<>} and should mention the specialized type after function name.
    
\begin{lstlisting}[numbers=none]
Template<typename T>  //template function
void sortedArrary(T) {...};

template<> void sortedArray<const char *>(){...}
\end{lstlisting}

	\par Some explicit specification syntax. \textbf{When there is empty <> after template keyword, it's a explicit specification; When there is no empty <> after template keyword, it's a explicit instantiation.}
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
void foo(T param);

void foo(int param); //regular funciton, not a specialization. it is an overload
void foo<int>(int param); //ill-formed, not recommend, no template keyword at all

template <> void foo<int>(int param){...} //normal explicit specialization
template <> void foo(int param); {...} //same as above, skip<int>

template void foo<int>(int param); //explicit instantiation, normal 
template void foo<>(int param); //explicit instantiation, skip type
template void foo(int param);  //explicit instantiation, skip <type>
\end{lstlisting}


\subsubsection{overload or full specification of function template}

	  If you want to customize a function base template and want that customization to participate in overload resolution (or, to always be used in the case of exact match), make it a plain old function, not a specialization. And, if you do provide overloads, avoid also providing specializations. Detail you can google" Why Not Specialize Function Templates?" prefer to use overload than template function specification.

	\par For a function template, we pick which function to use in the following order: 1) Pick one from the overloaded function templates; 2) Pick the specialized version of the function template that was chosen in the first step.

\begin{lstlisting}[frame=single, language=c++]
template<typename T>
f(T t);  //#1

template< >f<int*>(int* t) #2

template<typename T>
f(T* t); //#3

template<> f<int> f( int* t) //#4

int * p;
f(p) // #4>#3>#2>#1
\end{lstlisting}
\begin{description}
	\item[Source code:] The First step, we picked \texttt{f(T* t)} function template \#3, then select a specialization of this funciton template \#4. The \#1 and \#2 are not considered at all. Please note here \#3 is not \#1 partial specialization, but overload version, there is not partial specialization in template function, only overload. 
\end{description}

%	\item For above example, If you omit type inside <> after function name f, it depends on location.
%\begin{lstlisting}[frame=single, language=c++]
%template<typename T>
%f(T t);  //#1
%
%template< > f<>(int* t) //#2 is specialization of #1
%
%template<typename T>
%f(T* t); //#3
%//template< > f<>(int* t) //If we put here, #2 is specialization of #3
%
%int *p; 
%f( p ); 
%\end{lstlisting}
%\begin{description}
%	
%	\item[Line 11:] If put specialization version(\#2) at line 4, it will call \#3. Although we have a very match specification, it's not be picked up and it's not what we want.  Why this happen? \textbf{because specification didn't join the overload processing, this will lead to a missing match specification.} The first, we only see two overload template functions: \texttt{f(T t)} and \texttt{f(T* t)}. In this way, \texttt{f(T* t)} is picked up. If we put specification version(\#2)  in line 4, then it is specification of \#1, that is why it's omitted. If put specialization version(\#2) at line 8, it will be called because compiler think that it's the full specialization of \#3	
%\end{description}

	\par Why do we need an overloaded template function? Because not all types support the same operations. For example, in your template function, you may use the = operator for assignment, but when you use an array as the type argument for this template function, arrays don't support assignment with the = operator.
\begin{lstlisting}[numbers=none]
template <typename T>
void swap(T a[], T b[], int n)

template <typename T> //overload previous functions
void swap(T &a, T &b )
\end{lstlisting}

	\par Overload is different with specializations, Overload means that you have different function signatures. Specialization have the same function signature.


    \par A good article about specialization is chapter 12 in "C++ template: The complete guide", you should read each sentence in this chapter. Other good articles are: "Why Argument Dependent Lookup doesn't work with function template dynamic\_pointer\_cast"; "C++ template function taking template class as parameter".


\section{Template instantiation}

\subsection{Difference between instantiation and specification}
     Implicit instantiation, explicit instantiation, and explicit specialization are all forms of specialization. Because they produce real function definitions that use specific types, the final result is not a function template, but a real function. On the contrary, partial specialization is different from explicit (full) specialization. Partial specialization makes the generic template more specific, but the result is still a template.
    
    \par For class templates, specialization includes explicit (full) specialization and partial specialization, both of which require new implementations. For function templates, there is no partial specialization, so explicit specialization is complete specialization.
\begin{lstlisting}[frame=single, language=c++]
template<> class Pair<int,int>{...}; // explicit/full specialization 
template<typename T1> class Pair<T1, int>{...}; //partial specialization 	
\end{lstlisting}    

	\par Instantiation occurs at compile time, not at runtime. When you declare a variable, it will be instantiated, which may increase the compile time, and all template definitions must be placed in a header file.
    
   	\par There seems to be considerable confusion regarding explicit instantiation and specialization. Instantiation does not include empty <> after template, and you do not need to provide a definition of the function or class. Explicit specialization, however, does have empty <> after template, and you need to provide a definition.
\begin{lstlisting}
template <typename T> void func(T param) {} // definition

template void func<int>(int param);  //explicit instantiation. no definition.
template <> void func<int>(int param){} 
// empty <> here, explicit specialization, has definition.
\end{lstlisting}    

   
	\par C++ uses implicit or explicit instantiation to generate a specialized class or function definition from a template. For implicit instantiation, you need to declare a variable, whereas for explicit instantiation, you do not need to declare an object. Instead, you can either declare a variable or use the template keyword. Both types of instantiation are based on an existing template implementation.
	
\begin{lstlisting}[frame=single, language=c++]
template<typename T, int n>
class ArrayTP...
	
ArrayTP<int, 100> stuff //implicit instantiation, define a variable, 	
template ArrayTP<string, 100>; //explicit instantiation, use template and< >, 

template<>      //explicit specialization, empty <> after template
ArrayTP<bool, 100>{...specific implementation} //there is implementation here.	
\end{lstlisting}

%	\item Non type argument and default type argument only define one template body(only one recipe). But specialization need to define a generic template body(one recipe), For another type, It need to define a different template body(another recipe), because the code will be different with generic one.
	 
%	 \textbf{Instantiation is different with specialization.  For instantiation, it will use template function to produce function body, but for specialization, you have to redefine you own function body }
%	 
%\begin{lstlisting}[frame=single, language=c++]
%Template<typename T>
%void sortedArrary (T t) {...};
%
%template void sortedArray<Person>(Person);
%
%template<> void sortedArray<Person>(Person t){  //it is full specialization.
%.... //give you own definition of template fun body.
%};
%.
%\end{lstlisting}

	

\subsection{Overload resolution rule}
\subsubsection{Name look up and resolution rule}
	 Given a function name, you can have regular functions, template functions, and explicitly specialized template functions. When selecting a function, the ranking from best to worst is:
\begin{enumerate}
	\item Exact math, regular function.
	\item Template if you have define the same template function name.
	\item Conversion by promotion.
	\item Conversion by standard conversion.
	\item User-defined conversion.
\end{enumerate}
	
	\par The below table shows what exact match is:
	
	\begin{center}
		\begin{tabular}{|c|c|}
			\tophline
			Actual argument & Formal argument \\
			\tophline
			type-name & type-name \& \\
			\tophline
			type-name \& & type-name \\ \tophline
			type-name [ ] &  type-name* \\ \tophline
			type-name ( argument-list ) & ( *type-name ) ( argument-list ) \\ \tophline
			type-name  & const(volatile) type-name \\ \tophline
			type-name*  & const(volatile) type-name*  \\ \tophline
		\end{tabular}
	\end{center}
	
	\par About exact match, there are three rules to follow:
	\begin{enumerate}
		\item If there are two exact matches, compiler can't distinguish them, then it will report error.
		
		\item For reference/pointer type, even there are two exact match, it picks up according to \texttt{const}.
\begin{lstlisting}[frame=single, language=c++]
f(const int& j); //#1
f(int& j);  //#2, 

int i = 2;
f(i)  //Here, #2 will be selected, because i isn't const.	
\end{lstlisting}		
		
		\item If there are exact match normal function, it will pick up before template, even template has EXACT specification version.
	\end{enumerate}
	
	
	\par You can explicitly tell compiler that you prefer template function over overload one.
	
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
void f(T t);  //#1
void f(int t) //#2
f<>(2); // force compiler to use #1 even there is exact non-template version.	
\end{lstlisting}	
	
	\par Compiler will parse the template definition before it instantiation, But Errors in the template itself will remain undetected as long as it is instantiated only with 'friendly' types that don’t trigger those errors. For example, if the template assumes that the type always has such-and-such a method.
	
	
%	\item C++ Coding standards 65 states customization of point. 
	
	\par You need to understand two basic conceptions: \textbf{"two phases lookup"} and \textbf{"dependent name"} in template name look up processing.  Two phases lookup can see "Dependent name lookup for C++ templates" and "Two-Phase or Not Two-Phase: The Story of Dependent Names in Templates". Just google them.
	
    \par A name is a qualified name if the scope to which it belongs is explicitly denoted using a scope-resolution operator (::). Qualified names are looked up in the scope implied by the qualifying construct. If that scope is a class, then base classes may also be searched. However, enclosing scopes are not considered when looking up qualified names. 

	\par In contrast, unqualified names are typically looked up in successively more enclosing scopes (although in member function definitions, the scope of the class and its base classes is searched before any other enclosing scopes). This process is called ordinary lookup. A more recent development in the lookup of unqualified names is that, in addition to ordinary lookup, they may sometimes undergo argument-dependent lookup (ADL).
	
	 \par  A name is a dependent name if it depends in some way on a template parameter. For example, \texttt{std::vector<T>::iterator} is usually a dependent name if \texttt{T} is a template parameter. Another dependent name is a member access operator (. or ->) on template parameter \texttt{T}. Inside of a template class, \texttt{this->count} is also qualified name.
\begin{lstlisting}
template<typename T>
struct X : B<T>{                 // "B<T>" is dependent on T
	typename T::A* pa;          // "T::A" is dependent on T
	void f(B<T>* pb) {
		static int i = B<T>::i; // "B<T>::i" is dependent on T
		pb->j++;                // "pb->j" is dependent on T
	}
};
\end{lstlisting}
	 
	
%    \item Overload resolution steps are introduced here. More explanation of this figure can be found below from code p1 to code p6:
%
%\begin{figure}[ht]
%	\centering 
%	\includegraphics[width=0.8\linewidth]{pics/template.png}
%	\caption{Template name look up}
%	\label{fig:command}
%\end{figure}

	\par In the below two examples, since both are dependent names, we have to add an extra \texttt{typename} and \texttt{template} keyword to help the parser resolve the ambiguity. 
\begin{enumerate}
	\item Use typename if the dependent name is a type. \texttt{MyType} is type in the code below.

\begin{lstlisting}[frame=single, language=c++]
template <typename T> 
struct Base {
	typedef int MyType;
};

template <typename T> 
struct Derived : Base<T> {
	void g() {
		// MyType k = 2;  //error: 'MyType' was not declared in this scope
		// Base<T>::MyType k = 2; //Error, MyType is a dependent name.	
		// Base<T>::MyType* k = 2; //Ambiguity here, * maybe a multiple operator.
		typename Base<T>::MyType k = 2; //work, 
	}
};
\end{lstlisting}
\begin{description}
		
	\item[Line 10:] When the compiler parses the template code in this line, no real instantiation is visible. Therefore, you should inform the compiler that \texttt{::MyType} is a type name, not a variable name or anything else. This will allow us to use it to declare a variable \texttt{k}.
\end{description}

	\item Use template if the dependent name is a template, here, \texttt{foo\_method} is a template, so we have to use template in line 10.

\begin{lstlisting}[frame=single, language=c++]
struct Foo {
	template<typename U>
	static void foo_method(){
	}
};

template<typename T> 
void func(T* p) {
	// T::foo_method<T>(); // error: expected primary-expression before '>' token	
	T::template foo_method<T>(); //work!. That is "template qualifier".
}
\end{lstlisting}

\end{enumerate}

	\par If some names are not dependent names, we don't perform a "two phase name lookup"; we just look for the name in the visible scope and all the previous source code.
\begin{lstlisting}[]
template <typename T> struct Base {
   void f() {...}
};

template <typename T> struct Derived : Base<T> {
 void g() {
  f();  //error happen here. 
  this->f(); //OK, for dependent name, delay the name lookup after instantiation.
 }
};
\end{lstlisting}
\begin{description}
	\item[Line 7:] \texttt{f()} is not a dependent name, so we begin to look for this name now, but the base class doesn't still exit (no instantiation yet), so report error.
\end{description}


	\par If some names are dependent name, we apply looking up has two phases.
\begin{enumerate}
	\item In the first phase, for both dependent names and non-dependent names, we perform non-concrete-type lookup in the visible scope and previous source code.
	
	\item In the second phase, for dependent names, once we reach the instantiation code, after we know the concrete type, we will perform concrete-type ADL (argument-dependent lookup) lookup. 
	
	\item Once we select a template function in the overload, we will look if we have a concrete-type specialization version for this template.
\end{enumerate}
	
	
	 \par Below is an example to demonstrate two phase name look up. There are two versions of below code, If you define \texttt{VERSION\_1} in line 14, then line 33 and 34 will output "master". The explanation is below:
\begin{enumerate}
	\item From \texttt{process} function in line 6, it looks for \texttt{f} function. It looks for 1)Current namespace. 2)Using namespace. 3)All previous declaration.
	At these time only \texttt{f(T)}(line 3) is visible, Then add it into overload options set.  
	
	\item Because \texttt{v} inside the \texttt{f(v)}(line 6) is dependent name. When T is knowing \\ (\texttt{optional<int>}), It will search the name \texttt{f} in the \texttt{boost} namespace again and found there are no any name \texttt{f} there.  At this time, it will not search framework namespace again.
	
\end{enumerate}	

	If you don't define \texttt{VERSION\_1} in line 14, then the line 33 and 34 will output  "optional<T>" and "optional<bool>" seperately. The explanation is below:
	
	\begin{enumerate}
		\item In line 6, we see the \texttt{f(v)}, then we just use \texttt{non-concrete-type} lookup. At this time only a \texttt{f} definition in line 3 is visible.
		
		\item In line 33, When you see \texttt{ob}, we can use \texttt{concrete-type} lookup, at this time, first, we extract concrete-type(\texttt{optional} type), then we look for boost namespace which optional type resides in. In this namespace, we found two other functions options(line 21 and line 23), then we add them to overload options. 
		
		\item In line 34, Once we finish overload resolution, If we select template function, then we use concrete-type specialization look up, looks all the options before line 34. That is why we select specialization in line 23.
	\end{enumerate}	

\begin{lstlisting}[]
namespace framework { // library 1
	template <typename T>
	void f(T) { puts("master");}
 
	template <typename T>
	void process(T v) { f(v); } //v is dependent name.
}
 
namespace boost {     // library 2
	template <typename T>
	struct optional {};
}

#ifdef VERSION_1 
namespace framework { 
#else
namespace boost {
#endif

	template <typename T>
	void f(boost::optional<T>) { puts("optional<T>"); }
    
	inline void f(boost::optional<bool>) 
	                { puts("optional<bool>"); }
}
 
int main(){
	int i = 0;
	boost::optional<int>  oi;
	boost::optional<bool> ob;
  
	framework::process(i); //output three "master"
	framework::process(oi);
	framework::process(ob);
}
\end{lstlisting}


%	\item p5, In instantiation, with help of ADL, boost namespace is searched and two other functions are added into overload options.
%\begin{enumerate}
%	\item In line 6, we see the \texttt{f(v)}, then we just use \texttt{non-concrete-type} lookup. At this time only a \texttt{f} definition in line 3 is visible.
%	
%	\item In line 28, When you see \texttt{ob}, we can use \texttt{concrete-type} lookup, at this time, first, we extract concrete-type(\texttt{optional} type), then we look for boost namespace which optional type resides in. In this namespace, we found two other functions options(line 15 and line 18). Add them to overload options. 
%	
%	\item In line 29, Once we finish overload resolution, If we select template function, then we use concrete-type specialization look up, looks all the options before line 29. That is why we select specialization in line 18.
%\end{enumerate}	
%
%\begin{lstlisting}[]
%namespace framework{  // library 1
%  template <typename T>
%  void f(T) { puts("master"); }
% 
%  template <typename T>
%  void process(T v) { f(v); } 
%}
% 
%namespace boost{      // library 2
%  template <typename T>
%  struct optional {};
%}
% 
%namespace boost {      // some glue between 1 and 2
%  template <typename T>
%  void f(optional<T>) { puts("optional<T>"); }
%    
%  inline
%  void f(optional<bool>) { puts("optional<bool>"); }
%}
% 
%int main(){
%  int i = 0;
%  boost::optional<int>  oi;
%  boost::optional<bool> ob;
%  
%  framework::process(i);
%  framework::process(oi); //output "optional<T>"
%  framework::process(ob); //output "optional<bool>"
%}
%\end{lstlisting}
%
%	\item p6, template specification happen in the end and after overload. 
%\begin{lstlisting}[]
%namespace framework{  // library 1
%  template <typename T>
%  void f(T) { puts("master"); }
% 
%  template <typename T>
%  void process(T v) { f(v); } 
%}
% 
%namespace boost{      // library 2
%  template <typename T>
%  struct optional {};
%}
% 
%namespace framework{  // some glue between 1 and 2
%  template <>
%  void f<boost::optional<bool>>(boost::optional<bool>)
%  { puts("optional<bool>"); }
%}
% 
%int main() {
%  int i = 0;
%  boost::optional<bool> ob;
%  
%  framework::process(i); //output master
%  framework::process(ob); //output "optional<bool>"
%}
%\end{lstlisting}
			
		\par Pay attention, you can't put the specialization after calling points, otherwise it will report error. 
\begin{lstlisting}
template <typename T>
void f(T) { cout<<"master"<<endl; }

int main(){
	int i = 2;
	f(i);
}

template<> void f<int>(int i){ //error
cout<<"specialization"<<endl;
}
\end{lstlisting}
\begin{description}
	\item[Source code:] In line 6, compiler will generate \texttt{f(int)}, when it processes to line 9 and see another \texttt{f(int)}, it reports a kind of "duplicate" error
\end{description}


	\par Another interesting example helps you to understand previous all the knowledge. You can copy this code and run it, try different combination and see the output. 
\begin{lstlisting}[frame=single, language=c++, numbers=left,
stepnumber=1,]
template<typename T>
void f(T i){
	cout<<"template "<<i<<endl;
}

//template<> void f<short>(short s);
void g(void){
	//int s = 5; //output template
	short s = 5; 
	//uncomment above specification, call specification version.

	//"Specification after initialization.
	f(s);
}

template<> void f<short>(short s){
	cout<<"specification" <<s <<endl;
}
void f(short s){
	cout<<"short " <<s<<endl;
}

int main(){
	g();
}
\end{lstlisting}

\begin{enumerate}
	\item Move line 19 and line 16 two functions before function \texttt{g}, it will call regular exact match function \texttt{void f(short)}. 
	
	\item Move \texttt{void f(short)} after function \texttt{g}, it will can full specification version.
	
	\item comment line 6 (specification declaration). report error:\\
	error: specialization of 'void f(T) [with T = short int]' after instantiation.
	Because it has instantiation f(short) version from generic template, you can't specialize it any more.
	 
	\item Although exact match and specification have higher order, but you you must make it visible by declaring them before the caller.
\end{enumerate}



    \par A good article is "Overload resolution" in Andrzej's C++ blog. It taught you 1) name lookup and 2)overload and 3)instantiation three conception very well.

\section{Common used template technologies}

\subsection{template parameter}

	 You should use templates if you need functions or container classes that apply the same algorithm to a variety of types. Templates are frequently used for container classes because the concept of type parameters matches well with the need to apply a common storage plan to a variety of types.
\begin{lstlisting}[numbers=none]
template<typename T> //good style, use typename and simple name, such as T
//template<class COMPLEX_T> //bad style, don't use class and complex name
swap(T& a, T&b){	
\end{lstlisting}
	\par You can have several kinds of template parameters.
	\begin{enumerate}
		\item  Type Parameters: 1)Types, 2) Templates (only classes and alias templates, no functions or variable templates. Because neither function nor variable templates are type.)
		
		
		\item Non-type Parameters: 1)Pointers, 2)References, 3)Integral constant expressions. (That is why \texttt{constexpr} is so important.)	
	\end{enumerate}

        \par You can use more than one type parameter, or default type template parameters.
\begin{lstlisting}[numbers=none]
template <typename T1,  typename T2> //two type parameters.
class Pair{...};
Pair<double, int> pair1; 

template <typename T1,  typename T2=int> //default type parameter
class Pair{...};
Pair<double> pair2;
\end{lstlisting}

    \par You can use Non-Type Argument in a template. But it causes code bloat problem. 
\begin{lstlisting}[numbers=none]
template <typename T, int n>
	class ArrayTP{
	T ar[n];
	......
}
\end{lstlisting}

    \par A type parameter can be another template class. It is different from a "template template parameter", which is introduced below. A famous example is \texttt{vector<vector...>}. 
\begin{lstlisting}[]
template<typename T> // T is int here
class A

template<typename T> //T is A<int> here
class B

B< A<int> > obj;
vector< vector<int> > matrix // 2D matrix
\end{lstlisting}

    \par What is template template parameter? An article is "Correct usage of C++ template template parameters". Another good one is "C++ Common Knowledge: Template Template Parameters". It gives a \texttt{Stack} class template example. Below is bad way to declare this class template.
\begin{lstlisting}[frame=single, language=c++]
template <typename T, typename Cont>
class Stack {
public:
	~Stack();
	void push( const T & );
	//...
private:
	Cont s_;
};

Stack<int, List<int> > aStack1; // OK
Stack<double, List<int> > aStack2; // legal, not OK           
Stack<std::string, Deque<char *> > aStack3; // error!   
\end{lstlisting}
    \par We use a template template parameter, as illustrated by the code below. 

\begin{lstlisting}[frame=single, language=c++]
template <typename T,  template <typename ELEM,  typename = std::allocator<ELEM> > 
								class Cont = std::deque > //default template parameter
class Stack {
//...
private:
	Cont<T> s_;
};

Stack<int> aStack1; // use default: Cont is Deque
Stack<std::string,std::list> aStack2; // Cont is List
\end{lstlisting}
\begin{description}
	\item[Line 1:] There is another \texttt{template} keyword inside of the out \texttt{template} arrow brackets. Why do you need \texttt{std::allocator} here? because \texttt{std::deque} is class template with two template parameters, and you can't skip it. 
	
	\item[Line 6:] You don't need to specify \texttt{ELEM} template parameter in \texttt{std::deque}, because \texttt{Cont<T>} in line 6 will help to deduct it.
	
\end{description}


%\subsection{member function templates}

%\begin{itemize}
	
%	\item First give an interesting example about template class. Given a container \texttt{c}, accumulate all the elements in it. Function 1 is more generic than Function 2, because it also support list. Here there are two \texttt{Sum} funciton, because we can overload template function. You also need to know, The second template function sum has ZERO relationship with vector template.
%\begin{lstlisting}
%template<typename T> //function 1
%typename T::value_type Sum(T& c){
%	typename T::value_type result{};
%	for(auto x : c){
%		result +=x;
%	}
%	return result;
%}
%
%template<typename T> //function 2
%T Sum(vector<T> & c){
%	T result{};
%	for(auto x :c){
%		result += x;
%	}
%	return result;
%}
%
%vector<int> vi = {1, 3, 5, 7};
%list<int> li = {1, 3, 4, 5};
%cout<< Sum(vi)<<endl;
%cout<< Sum(li)<<endl;
%\end{lstlisting}

%\end{itemize}

\subsection{Template features used in STL}
	 Variable template. A variable template is a template that defines a series of variables, based on one or more template parameters:
\begin{lstlisting}[]
template<class T>
constexpr T pi = T(3.1415926535897932385L);  // variable template	

template<typename T>
bool flag{true};

cout<<flag<int> <<endl; //flag<int> is variable
flag<float> = false;
cout<<flag<float><<endl; //flag<float> is also a variable. 
\end{lstlisting}


	\par In fact, the most often used of variable template is \texttt{*\_v} template to avoid slightly awkward ::value syntax.
\begin{lstlisting}
template< class T >
inline constexpr bool is_integral_v = is_integral<T>::value;
\end{lstlisting}

	\par Alias template. Detail can be found in "alias declaration" section of "Modern C++" chapter.
\begin{lstlisting}[]
template< bool B, class T = void >
using enable_if_t = typename enable_if<B,T>::type;
\end{lstlisting}

	\par \texttt{std::integral\_constant} template define a type, One of the usage examples is tag-dispatching. 
\begin{lstlisting}
template< class T, T v >
struct integral_constant;
	
true_type	std::integral_constant<bool, true> 
false_type	std::integral_constant<bool, false>

int foo_impl(T value, std::true_type) ...
double foo_impl(T value, std::false_type)...

template<typename T>
auto foo(T value)
	return foo_impl(value, std::is_arithmetic<T>{});
}

template<class T>
struct is_arithmetic : std::integral_constant<bool,
							std::is_integral<T>::value ||
							std::is_floating_point<T>::value> {};
\end{lstlisting}
	
	\par Difference between alias template, variable template and \texttt{std::integral\_constant.}
\begin{itemize}
	\item They are all template, template is an important component in metaprogramming, it manipulate type in compiling time. For example, you can input a type, template will return another type (\texttt{std::remove\_const}) or another constexpr (\texttt{std::is\_integral\_v}). Template also support input integer, so you can input integer into the template, then it return a type \\ \texttt{std::integral\_constant<bool, true>}.
	
	\item Input type T into variable template, it return a constexpr (T-->value).
	
	\item Input integer (true) into \texttt{std::integral\_constant}, it return a type (true\_type) (value-->T).
	
	\item In metaprogramming, you can think template as a function,  it only manipulate type and limited integer (such as true or false).
	
	\item Alias template is just a alias, it's still template essential. \texttt{remove\_const\_t} is still a template,  you need to use <> to input T.
	
%	 then it can be used as 1) define class, 2) define function, 3) get a new type, 4) get a new variable.
\begin{lstlisting}
template< class T >
using remove_const_t = typename remove_const<T>::type;
\end{lstlisting}


\end{itemize}

	\par In C++, you need to know about the "default argument applies to the specialization" rule. I will explain this rule in detail with the example code below. In below code, \texttt{test<int>} choose a template specialization happens in three steps: 
\begin{itemize}
	\item Although you only input one template parameter (\texttt{int}), base template provide default template parameter, so \texttt{test<int>} in line 18 will become \texttt{test<int, void>}.
	
	\item Base template is instantiated to \texttt{test<int,void>} implicitly, At the same time, "default argument applies to the specialization" is applied, the partial specialization in line 9 is also instantiated to \texttt{test<int, void>} explicitly. 
	
	\item Use the partial ordering algorithm to choose the best-matching specialization:\texttt{class test<int, void>} from line 9 to line 15, so output will be "sp". 
	
%	\item in line 18, if we change \texttt{test<int>} to \texttt{test<double>}, the specification \texttt<int, void> will also be instantiated. 
	
\end{itemize}
		
\begin{lstlisting}
template <class T, typename U = void> // base version.
class test {
public:
	test() {
		std::cout << "base" << std::endl;
	}
};

template <class U>   //specialization version.
class test<int, U> { 
	public:
	test() {
		std::cout << "sp" << std::endl;
	}	
};

int main() {
	test<int> t; // actually, you call test<int, void>, output "sp"
}	
\end{lstlisting}

	

    \par Based on previous idea, we can build our own type trait easier. Some explanation about below code:
\begin{itemize}
	\item Using \texttt{void\_t} makes it easier to build our own type traits in C++ template metaprogramming. \texttt{void\_t} is a template (metafunction) used to detect ill-formed types in a SFINAE (Substitution Failure Is Not An Error) context. In our type trait example, such as \texttt{has\_toString<OurType>}, we utilize \texttt{void} in the primary template because default template parameters are automatically propagated to specializations.
	
	\item For instance, when we evaluate \texttt{has\_toString<OurType>::value}, the default parameter plays a crucial role. Internally, this resolves to \texttt{has\_toString<OurType, void>::value}, which checks both the primary template and its specialization. If OurType has a \texttt{toString()} method that returns \texttt{std::string}, decltype is used successfully. Otherwise, the substitution fails.
	
	\item In case of partial specialization failure, the base template (\texttt{false\_type}) is matched, ensuring that the trait resolves to \texttt{false\_type} by default. This structured approach leverages \texttt{true\_type} and \texttt{false\_type} to determine type properties accurately within template metaprogramming.
	
	\item There are two points need to mention, one is usage of \texttt{void\_t} template to perform type check in line 8,  the second point is \texttt{true\_type} and \texttt{false\_type}. 
\end{itemize}
    
    
\begin{lstlisting}
template< class... >
using void_t = void;  //1) use void_t

template< class , class = void > // default template:
struct has_toString : false_type { };

template< class T> // specialized as has_member< T , void > or SFINAE
struct has_toString<T , void_t<std::is_same<std::string, decltype(declval<T>().toString()) >>> :true_type{ }

cout<<has_toString<MyClass>::value; //ture or false here.
\end{lstlisting}
	

%	\item 
%\begin{lstlisting}
%template <class T, typename U = void>
%class test {
%public:
%	test() {
%		std::cout << "base" << std::endl;
%	}
%};
%
%int main() {
%	test<int> t; //call specialization
%}
%\end{lstlisting}
	

%\end{enumerate}

	\par Specialization templates have default template arguments automatically provided. This feature makes it easier to use \texttt{enable\_if}, as shown in line 7 of the code below.
\begin{lstlisting}
template<bool B, class T = void>
struct enable_if {};

template<class T>
struct enable_if<true, T> { typedef T type; }; //T default is void

template <class T, typename = std::enable_if_t<std::is_integral<T>::value> >
void do_stuff(T& t) {  
	T sum = t+t; //we only provide bool value, T in enable_if is void already.
}	
\end{lstlisting}




\section{Class template}
\subsection{template class and inheritance}
	
	 Utilize member function templates to accept all compatible types, as detailed in Effective C++ Item 45. For instance, consider the following example where we define a template copy constructor member function that can be used as a generalized copy constructor.
	
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
class SmartPtr {
public:
	template<typename U> // member template
	SmartPtr(const SmartPtr<U>& other); 
	...
}		
\end{lstlisting}		
	
	\par Non-Template class derived from Template Base class specification.
\begin{lstlisting}[numbers=none]
struct less_than_7 : std::unary_function<int, bool>{
	bool operator()(int i) const { return i < 7; }
};

class u8toU16 : public std::codecvt<wchar_t, char, std::mbstate_t>{
	...
};	
\end{lstlisting}	
	
	\par Template class deriving from the non-template class.
\begin{lstlisting}[numbers=none]
class Base{...};

template<typename T>
class Derived: public Base{
	...
};
\end{lstlisting}		
	
	\par A template class can serve as both a base class and a component class, meaning that it can be inherited from or used as a component in another class.
	\begin{itemize}
		\item A basic example.
\begin{lstlisting}[numbers=none]
template< typename T>
class SpecialStack: public Stack<T>{
	Array<T> array;
	...
}	
\end{lstlisting}			
		
		\item You also can extend the derived class by adding another template parameter.
\begin{lstlisting}[numbers=none]
template< typename T>
class Base

template<typename T, typename U>
class Derived: public Base<T>	
\end{lstlisting}		
		
		
%		\item Factor parameter-independent code out of templates. Detail can be found in effective item 44. That is to avoid code bloating.
%\begin{lstlisting}[frame=single, language=c++]
%template<typename T> // size-independent base class for
%class SquareMatrixBase { // square matrices
%protected:
%	...
%	void invert(std::size_t matrixSize); //invert matrix of the given size.
%};
%
%template<typename T, std::size_t n>
%class SquareMatrix: private SquareMatrixBase<T> {
%public:
%	using SquareMatrixBase<T>::invert; //make this invert visible in child class
%	...
%	void invert() { invert(n); }  //make inline call to base class
%}; // version of invert	
%\end{lstlisting}		
				
%		\item We can derive from a specializing the base class.
%\begin{lstlisting}[numbers=none]
%template< typename T>
%class Base
%
%template<typename T>
%class Derived: public Base<int>	
%\end{lstlisting}		

	\end{itemize}
	
	\par Parameterized inheritance example. Two famous idioms are Mixin and Policy, can be found in below section.

\begin{lstlisting}[numbers=none]
template<typename T>
class Derived: public T	
\end{lstlisting}		
		

	
	\par Public inheritance is discussed in the first chapter of "Modern C++ Design" in the context of the creator template class. When a derived class publicly inherits from a base class, it indicates that the derived class intends to expose the public interface of the base class. Public inheritance allows the interface of the base class to be accessed from outside the class, such as through a Create() function. On the other hand, private inheritance is used when we want to inherit and use the implementation of the base class without exposing its interface to the outside world. Usually, private inheritance is not the first choice but the last choice. 
	
%	If a policy class has protected member functions that we want to use, then private inheritance is our last choice. 
	
\begin{lstlisting}[numbers=none]
template <class T>
struct OpNewCreator{
	static T* Create(){
		return new T;
	}
};
template <class T>
struct MallocCreator{
	static T* Create(){
		void* buf = std::malloc(sizeof(T));
		if (!buf) return 0;
		return new(buf) T;
	}
}; 
template <class CreationPolicy> // Library code
class WidgetManager : public CreationPolicy{
	...
}; 

typedef WidgetManager< OpNewCreator<Widget> > MyWidgetMgr; // Application code
\end{lstlisting}	
		

\subsection{Template and friend}
\subsubsection{Friend function in class template}
	 There are three types of friends in C++: 1) friend classes, 2) friend functions, and 3) friend templates. These friends can either be bound or non-bound. If the friend is bound, you can find the host class "\texttt{HostClass<T>}" in the friend declaration.
	
	\par  There are three different kinds friends function for a template class:
\begin{enumerate}
	\item Non-template friend: The \texttt{counts()} is not invoked by an \texttt{HasFriend} obj and has not object parameters. If \texttt{counts} want to access a \texttt{HasFriend} object, It can only access a global one, or use a global pointer to access non-global object.
\begin{lstlisting}
template<typename T>
class HasFriend{
	friend void counts();  //Non-template friend function
}		
\end{lstlisting}	
	
	\item Bound-template: You need to define explicit specialization for the friends you plan to use. Why, because in line 3, \texttt{reports} is not neither template function nor function definition. it is just function declaration. For instance, it assumes they are non-templates like this \texttt{reports(HasFriend<int> \&hf)}. In another word, it just look for this function definition, it will not instantiate this function from template class \texttt{HasFriend}, you must give the function definition by yourself. 
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
class HasFriend{
	friend void reports(HasFriend<T> &); //no template keyword around function.
}

void reports(HasFriend<int> &hf){...} //give function definition here. 
void reports(HasFriend<short> &hf){...}		
\end{lstlisting}		
	
	\item A better Bound-template, in line 8, \texttt{reports} has <> after it.  You don't need redefine reports many time like previous codes.  
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
void reports(T &hf){  //reports is a template function here.
	cout <<hf.item<<endl;
}

template<typename TT>
class HasFriend{
  friend void reports<>(HasFriend<TT> &);//has <>, implicit instantiation
}		
\end{lstlisting}		
	
	\item Unbound-template: An unbound-template friend function in C++ refers to a friend function declared within a template class without explicitly specifying the template parameters of the host class as part of its declaration.
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
class ManyFriend{
private:
	item;
	
	template<typename C, typename D>
	friend void show2(C& , D&);
};

template <typename C, typename D> 
void show2(c& c, D& d){
	cout<<c.item<<d.item<<endl;
}

ManyFriend<int> mi;
ManyFriend<double>md;
show2(mi,md);		
\end{lstlisting}		
	
\end{enumerate}

	\par Difference between bound and non-bound:
	
	\begin{itemize}
		\item Bound friend is specialization of template function, so it has <> after the function name.
		
		\item Non-bound template use different typename, such as C and D in previous example, and it also use template keyword.
		
%		\item Bound template will produce more function implementation , but non-bound template will only produce ONE function implementation.
	\end{itemize}

\subsubsection{A practical example}	
	
	\par An interesting example about bound friend template function is below: 
	\begin{enumerate}
			
	\item In line 13, we can't instantiate template \texttt{operator *} by expression \texttt{oneHalf*2}. Why? If we implicit convert 2 to \texttt{Rational<int>}, then we can deduct correct and instantiate template \texttt{operator *}. But, why we implicit convert?, we have a function to match. Right now, we don't have any function, Pay attention here, template function is still \textbf{NOT} a real function. So we never do implicit convert without any real function which need to be matched. The whole story is just like chicken and egg. That's why \texttt{oneHalf*2} fail here. 
\begin{lstlisting}
template<typename T>
class Rational {
public:
	Rational(const T& numerator = 0, const T& denominator = 1)
	...
}; 

template<T>
Rational<T> operator*(const Rational<T>& lsh, const Rational<T>& rhs){
	....
}

Rational<int> oneHalf{1, 2}; //create a Rational object
Rational<int> result = oneHalf*2; //Compile error		
\end{lstlisting}	

	\item Continue the previous example, If we have a function declaration existing, implicit conversion will occur. The code below compiles okay but results in a linker error.
\begin{lstlisting}
template<typename T>
class Rational {
public:
	Rational(const T& numerator = 0, const T& denominator = 1){...}
	friend Rational<T> operator*(const Rational<T>& lsh,  const Rational<T>& rhs);
}; 

template<typename T>
Rational<T> operator*(const Rational<T>& lsh, const Rational<T>& rhs){
	....
}

Rational<int> oneHalf(1,2);
Rational<int> result = oneHalf*2; //Compile OK, but Link error		
\end{lstlisting}	
	\begin{description}
		\item[Line 4:] Here, you can omit <T> after Rational. Inside class template, class\_name is just class\_name<T>.
		
		\item[Line 14:] By now, Compile OK. Because when we define \texttt{Rational<int>}, it declare a friend function in line 5, so we can implicit convert 2 to \texttt{Rational<int>} to match the function in line 5.
		
		\item[Source code:] Why link error?, there is \textbf{NO} relationship between Line 5 and the function defined in Line 8. Most people assume that they are in a declaration and definition relationship, but this is incorrect. In reality, the template function is not yet a real function. We need to instantiate the template to create a real function, either implicitly or explicitly. The code still generates a link error because we have failed to instantiate the template \texttt{operator *} on Line 8. This means that we don't have a real function for \texttt{operator *}. We have already discussed why this is the case in the previous example.
	\end{description}
	
	\item Last, How to resolve this problem, There are two ways: 1) You can give the definition inside the class directly and delete template operator* in the outside. 2) Another fix is to use the previous trick, put the <> after operator, and tell compiler explicitly that we want to use template function here.   
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
class Rational {
	public:
	...
	friend Rational operator*(const Rational& lhs, const Rational& rhs){ 
		return Rational(lhs.numerator() * rhs.numerator(), 
		lhs.denominator() * rhs.denominator());  
	} 	
//friend Rational operator* <> (const Rational<T>& lhs, const Rational<T>& rhs); 
};		
\end{lstlisting}	
	
	\item The syntax of templates in C++ can be tricky and complex, but there are ways to work around it. The principle of above example is: \textbf{for a friend function, both declaration and definition are required. Then next question is how to generate them from template}. If you find it confusing initially, approach it from the compiler's perspective to better understand how templates are processed.
	
\end{enumerate}
	

\section{Type traits}
\subsection{STL type traits}
	 Type traits in the STL are a set of template-based utilities that provide compile-time information about types. They are part of the <type\_traits> header in C++ and are extensively used for template metaprogramming, enabling developers to write more flexible and type-safe code.
\begin{lstlisting}
cout <<  boolalpha <<  '\n';

cout << std::is_void<void>::value << '\n';                               // true                           
cout << std::is_integral<short>::value << '\n';                          // true
cout << std::is_floating_point<double>::value << '\n';                   // true
cout << std::is_array<int []>::value << '\n';                            // true
cout << std::is_pointer<int*>::value << '\n';                            // true
cout << std::is_null_pointer<nullptr_t>::value << '\n';                  // true
cout << std::is_member_object_pointer<int A::*>::value <<  '\n';         // true
cout << std::is_member_function_pointer<int (A::*)(int)>::value << '\n'; // true
cout << std::is_enum<E>::value << '\n';                                  // true
cout << std::is_union<U>::value << '\n';                                 // true 
cout << std::is_class<string>::value << '\n';                            // true
cout << std::is_function<int * (double)>::value << '\n';                 // true	
cout << std::is_lvalue_reference<int&>::value << '\n';                   // true
cout << std::is_rvalue_reference<int&&>::value << '\n';                  // true	
\end{lstlisting}

	\par Comparing two types in C++ using type traits is often done to check if two types are the same or to evaluate type relationships such as inheritance or convertibility. The standard library provides several type traits for this purpose.
\begin{lstlisting}
std::cout << std::is_base_of<Base,Derived>::value << '\n'; //true
std::cout << std::is_base_of<Derived,Base>::value << '\n';
std::cout << std::is_base_of<Derived,Derived>::value << '\n'; //true

std::cout << std::is_convertible<Base*,Derived*>::value << '\n'; 
std::cout << std::is_convertible<Derived*,Base*>::value << '\n'; //true
std::cout << std::is_convertible<Derived*,Derived*>::value << '\n'; //true

std::cout << std::is_same<int, int32_t>::value << '\n'; //true
std::cout << std::is_same<int, int64_t>::value << '\n';
std::cout << std::is_same<long int, int64_t>::value << '\n'; //true
\end{lstlisting}

	\par Type modifications using type traits in C++ allow you to alter types by adding or removing qualifiers and changing the type structure. 
\begin{lstlisting}
// reference modifications:
remove_reference; add_lvalue_reference; add_rvalue_reference;

// sign modifications:
make_signed; make_unsigned;

// pointer modifications:
remove_pointer;  add_pointer;

// other transformations:
decay; enable_if; conditional; common_type; underlying_type;
\end{lstlisting}
	\par Type traits about \texttt{const} and \texttt{volatile}.
\begin{lstlisting}
remove_const; remove_volatile; remove_cv; // const-volatile modifications:
add_const; add_volatile; add_cv;
struct Foo{
	void m() { std::cout << "Non-cv\n"; }
	void m() const { std::cout << "Const\n"; }
	void m() volatile { std::cout << "Volatile\n"; }
	void m() const volatile { std::cout << "Const-volatile\n"; }
};

Foo{}.m();  //output "Non-cv"
std::add_const<Foo>::type{}.m(); //Const
std::add_volatile<Foo>::type{}.m(); //Volatile
std::add_cv<Foo>::type{}.m();  //output "Const-volatile"	
\end{lstlisting}

\subsection{How to build custom type traits?}
	 A type trait is a mechanism that allows you to obtain information about the types passed as template arguments at compile time, enabling you to make static decisions based on that information. A type trait can provide any information or customization about a type. For instance, the \texttt{is\_integer} trait simply returns a boolean value indicating whether the type is an integer or not, while the more complex \texttt{char\_traits} trait can return a set of functions. In this way, you can also view \texttt{char\_traits} as a policy.
	

\subsubsection{Class partial specialization implement trait}
	
	 The most common implementation approach for type traits is through template class specialization. This method is particularly useful for system-defined types. By default, the template returns false, and we create a template specialization that returns true to indicate a specific trait.
	 
\begin{lstlisting}[frame=single, language=c++]
template <typename T>
struct is_swapable {
	static const bool value = false;
};

template <> //class full specialization with short
struct is_swapable<short> {
	static const bool value = true;
};
template <>
struct is_swapable<int> {
	static const bool value = true;
};
\end{lstlisting}

	\par Another way is to build new trait based on existing traits.
\begin{lstlisting}[numbers=none]
template <typename T>
struct is_swapable {
	static const bool value = std::is_integral< T >::value && sizeof(T)>=2;
};
\end{lstlisting}

	\par Starting with C++11, a new type generator was introduced:  \texttt{std::integral\_constant}, along with its corresponding \texttt{std::true\_type} and \texttt{std::false\_type} types. 
\begin{lstlisting}[frame=single, language=c++]
template<class T, T v>
struct integral_constant {
	static constexpr T value = v;
	using value_type = T;
	using type = integral_constant; // using injected-class-name
	constexpr operator value_type() const noexcept { return value; }
	constexpr value_type operator()() const noexcept { return value; } //since c++14
};
	
typedef integral_constant<bool,true> true_type;
\end{lstlisting}


\par \texttt{std::true\_type} use \texttt{integral\_constant} (type generator)to define a new type. \texttt{is\_arithmetic} can be derived form \texttt{true\_type} or \texttt{false\_type}. It makes easier for us to build and use a new type trait. 
\begin{lstlisting}[numbers=none]
std::integral_constant<bool, true>

template< class T >
struct is_arithmetic : std::integral_constant<bool, std::is_integral<T>::value ||
							std::is_floating_point<T>::value> { };
\end{lstlisting}

	\par To build a type trait, you typically define a template structure named after the trait you need, such as \texttt{is\_integer}, \texttt{is\_pointer}, or \texttt{is\_void}. The structure contains a static constant boolean member named \texttt{value}, which is initialized to a sensible state by default. To query the value of a type trait, you can use the following syntax: \texttt{my\_type\_trait<T>::value}.
	
	\par Another kind of implementation is to use predefined type. 
	
	\begin{itemize}
		
	\item An example can be found the iterator in a container.

\begin{lstlisting}[frame=single, language=c++]
template < ... > // template params elided
class deque {
	class iterator {
	public:
		typedef random_access_iterator_tag iterator_category; // define category
	};		
\end{lstlisting}

	\item Then we can use \texttt{iterator\_traits} to get \texttt{iterator\_category} defined inside deque.
\begin{lstlisting}[frame=single, language=c++]
template<typename IterT>
struct iterator_traits {
	typedef typename IterT::iterator_category iterator_category;
};
\end{lstlisting}

	\item Why don't we use \texttt{iterator\_category} inside of \texttt{deque} directly? With help of \texttt{iterator\_traits}, we can build partial specification version for pointer, In this way, \texttt{iterator\_traits} also can deal with pointer. (array in C++)
\begin{lstlisting}[frame=single, language=c++]
template<typename T> // partial template specialization
struct iterator_traits<T*>{ // for built-in pointer types
	typedef random_access_iterator_tag iterator_category;
};
\end{lstlisting}

	\end{itemize}


\subsubsection{SFINAE(Type deduct) to build trait}

	
	 SFINAE stands for "Substitution Failure Is Not An Error". Compiler will try type deduct when it instantiate the template function or template class. when it can't deduct properly, compiler will search for another option instead of report error. 
	
	\par You can use the \texttt{sizeof} and \texttt{static\_cast} operators to perform compile-time evaluation. For instance, you can use this technique to test if a class is derived from another class. It was popular before C++11, but C++14/17 offer a better ways to achieve the same objective. Therefore, it's advisable to be aware of this technique, but there's no need to use it in your code.
	
\begin{lstlisting}[frame=single, language=c++]
template<typename D, typename B>
class IsDerivedFromHelper{
	class No { };
	class Yes { No no[3]; };
	
	static Yes Test( B* );
	static No Test( ... );
public:
	enum {Is = sizeof(Test(static_cast<D*>(0))) == sizeof(Yes) };
};
	
template <class C, class P> 
bool IsDerivedFrom() {
	return IsDerivedFromHelper<C, P>::Is;
}
\end{lstlisting}

	
	\par In C++14/17, you can use the \texttt{constexpr} operator instead of \texttt{sizeof}, and the \texttt{decltype} and \texttt{declval} operators to obtain type information at compile time. For example, the following code tests if a type has a "serialize" member function:
	
\begin{lstlisting}[frame=single, language=c++]
template <class T> 
struct hasSerialize{
	template <typename C>
	static constexpr decltype(std::declval<C>().serialize(), bool())
	test(int /* unused */){
		return true;
	}

	template <typename C>
	static constexpr bool test(...){
		return false;
	}
	
	// int is used to give the precedence!
	static constexpr bool value = test<T>(int());
};	
\end{lstlisting}
	
	\begin{itemize}
		\item template class \texttt{hasSerialize} accepts \texttt{T}, we usually use \texttt{hasSerialize<Foo>::value}.
		
		\item Two overloaded template \texttt{test} functions are used, with one returning true and the other, by default, returning false. However, we still need different template member function tests because SFINAE only occurs during template type deduction. As such, we create two template member functions with the typename C argument.
		
		\item In the function which return true, use \texttt{decltype} and \texttt{declval} to simulate call some functions you want to judge. make these type used in function parameter or return. 
		
		\item Pay attention to the usage of \texttt{static constexpr bool}. Use \texttt{test} function to initialized \textbf{constexpr value}.
		
		\item In line 4, the comma operator in C++ involving expressions where multiple expressions are evaluated, but only the value of the last expression is considered. 
		
\begin{lstlisting}[numbers=none]
int a = (1, 2, 3, 4);  //a is 4 after this statement.
\end{lstlisting}
	\end{itemize}

%	\item use \texttt{is\_valid}
%\begin{lstlisting}[frame=single, language=c++]
%#include <boost/hana.hpp>
%#include <type_traits>
%namespace hana = boost::hana;
%static auto has_length = hana::is_valid([](auto&& t)-> decltype(t.Length()) {});
%
%template <typename T>
%auto foo(T const& t) -> std::enable_if_t<decltype(has_length(t)){}, void>
%{...}
%\end{lstlisting}
%
%	\item Below are explanation about implementation of \texttt{is\_valid}. C++14 brings a small change to the lambdas but with a big impact! Lambdas accept auto parameters: the parameter type is deduced according the argument. Lambdas are implemented as an object having an newly created unnamed type, also called closure type. If a lambda has some auto parameters, its "Functor operator" operator() will be simply templated. Let's take a look:
%
%\begin{lstlisting}[numbers=none]
%auto l5 = [](auto& t) -> decltype(t.serialize()) { return t.serialize(); };
%struct l5UnamedType{
%	template <typename T> // This signature(template) is nice for a SFINAE,  
%	auto operator()(T& t) const -> decltype(t.serialize()){ 
%		return t.serialize();
%	}
%};	
%\end{lstlisting}
%
%	\item We can use generic lambda to build \texttt{is\_valid} template. If you understand previous example about hasSerialize, you can understand below \texttt{is\_valid} code. The basic idea is the same. You can even think that \texttt{is\_valid} is a kind of syntax sugar. 
%
%\begin{lstlisting}[numbers=none]
%template <typename UnnamedType> 
%struct container{ // Let's put the test in private.
%private:
%// We use std::declval to 'recreate' an object of 'UnnamedType'.
%// We use std::declval to also 'recreate' an object of type 'Param'.
%// We can use both of these recreated objects to test the validity!
%template <typename Param> 
%constexpr auto testValidity(int /* unused */)
%-> decltype(std::declval<UnnamedType>()(std::declval<Param>()), std::true_type()){
%	// If substitution didn't fail, we can return a true_type.
%	return std::true_type();
%}
%
%template <typename Param> 
%constexpr std::false_type testValidity(...){
%	return std::false_type(); // Our sink-hole returns a false_type.
%}
%public:
%// A public operator() that accept the argument to test onto the UnnamedType.
%template <typename Param> 
%constexpr auto operator()(const Param& p){ //return type is auto
%	// The argument is forwarded to one of the two overloads.
%	// The SFINAE on the 'true_type' will come into play to dispatch.
%	// Once again, we use the int for the precedence.
%	return testValidity<Param>(int());
%}
%};
%
%template <typename UnnamedType> 
%constexpr auto is_valid(const UnnamedType& t) {
%// We used auto for the return type: it will be deduced here.
%return container<UnnamedType>();
%}
%
%auto hasSerialize = is_valid([](auto&& x) -> decltype(x.serialize()) { });
%Foo foo; // Check if a type has a serialize method.
%hasSerialize(foo);
%\end{lstlisting}
%
%\begin{center}
%\includegraphics[scale=0.59]{pics/is_valid.png}
%\end{center}

	\par A better way in C++14/17 is to directly inherit from \texttt{std::true\_type}, which makes the source code simpler to read. At the same time, we can use \texttt{decltype} and \texttt{declval} directly to perform compile-time type evaluation.

\begin{lstlisting}[frame=single, language=c++]
// Primary template, inherit from std::false_type.
template <typename T, typename = std::string>
struct hasSerialize : std::false_type { };

// Partial template specialisation, inherit from std::true_type.
template <typename T>
struct hasSerialize<T, decltype(std::declval<T>().serialize())>:std::true_type {};
\end{lstlisting}

	\par We also introduced \texttt{void\_t} in C++17, which makes it easier for us to define new type traits. For example, the code below judges whether the type \texttt{T} has a \texttt{length} data member. When we use \texttt{void\_t}, we don't need care about type of \texttt{T::length}, it can be \texttt{int} or \texttt{float}, \texttt{void\_t} can help us to get more generic semantic. 
\begin{lstlisting}[frame=single, language=c++]
template< class , class = void >
struct has_member : std::false_type
{ };

// specialized as has_member< T , void > or discarded (SFINAE)
template< class T >
struct has_member< T , void_t< decltype( T::length ) > > : std::true_type
{ };
\end{lstlisting}

	\par There are two articles which are good.
"An introduction to C++'s SFINAE concept: compile-time introspection of a class member" and "checking expression validity in-place with C++17"
		
\subsubsection{ If T is function type? }

	 This is an example to test if T is function. The basic idea is: there is three types you can't use to declare array, 1) void, 2) reference and 3) function type.
\begin{lstlisting}[frame=single, language=c++]
template <class T>
struct IsFunction{
	// int (*p)[1]  pointer to array(int [1])
	// int *p[1], that is array of pointer .
	template <typename C> 
	static constexpr bool test(C (*)[1] ){
		return false;
	}
	
	template <typename C> 
	static constexpr bool test(...){
		return true;
	}
	//use 0 as pretend pointer.
	static constexpr bool value = test<T>(0);
};

int f();
IsFunction<decltype(f)>::value; //value is true 
\end{lstlisting}
\begin{description}
	\item[Line 6:] Why we need declare a pointer to array? it will make line 15 easier, we can just use 0 as pretend pointer.
\end{description}

	\par A little more explanation about above code.
	
\begin{itemize}
	\item What is a function type?
\begin{lstlisting}
typedef int FT(); //FT is function type
typedef int (*PFT)(); //PFT is function pointer type

int f();  //f is variable
FT* fp= f;  //Usage of FT : fp is variable and type is function pointer

FT fv; 
int fv(){...} 
\end{lstlisting}
	\begin{description}

		\item[Line 7:] just like \texttt{int fv();} declare a function. How to define this variable make it linkable? You need to give function definition in line 8.
	\end{description}

	\item \texttt{decltype(f)} is not a function pointer. In order to get a function pointer you either have to use \texttt{decltype} with the address of f \texttt{decltype(\&f)} or you can add a * to the end of the type to declare a pointer to the type of f \texttt{decltype(f) *}
	
	\item You can not define function type array.
\begin{lstlisting}[numbers=none]
typedef int FT(); //FT is type
FT fa[3]; //compile error, error: declaration of 'fa' as array of functions
\end{lstlisting}

\end{itemize}

\subsubsection{If T is member function type}
	 How to deal with member function pointer? Given an example code below, if you want to have member function pointer, its type should be: \texttt{int (A::*)() const \&} 
\begin{lstlisting}[frame=single, language=c++]
struct A {
	int fun() const&;
};
typedef int FunSignature() const&; //FunSignature is function type
FunSignature A::*p = &A::fun;
\end{lstlisting}

	\par When we want to use template class to deduct it, it can be used in \texttt{U T::*}.
\begin{lstlisting}[frame=single, language=c++]
struct A {
	int fun() const&;
};

template<class T, class U>
struct PM_traits<U T::*> { //U is FunSignature type, 	                        
	using member_type = U; //U equal typedef int FunSignature() const&;
};

int main() {
	using T = PM_traits<decltype(&A::fun)>::member_type; 
}
\end{lstlisting}

	\par Based on previous introduction, we can build below code to judge if it's a member function.
\begin{lstlisting}[frame=single, language=c++]
template< class T >
struct is_member_function_pointer_helper : std::false_type {};

template< class T, class U> //partial specialization has more parameter??? 
struct is_member_function_pointer_helper<T U::*> : std::is_function<T> {};

template< class T >
struct is_member_function_pointer : is_member_function_pointer_helper<
                        std::remove_cv_t<T> > {};

class A {
public:
	void member() { }
};

//&A::member is expression, decltype change it to a type.
cout<<std::is_member_function_pointer< decltype(&A::member) >::value
\end{lstlisting}

	\par A partial specialization can indeed have more template parameters than the primary template. A typical example of this use is \texttt{std::function}. You can write \texttt{std::function<int(double, char)>} (with a single type parameter), and not e.g. \texttt{std::function<int, double, char>}.
\begin{lstlisting}
template <class T>
struct function;

template <class R, class... A>
//R(A...) is specification and it's ONE template parameter.
struct function<R (A...)>{  
	....
	// std::function as we know it
};	
\end{lstlisting}	



\subsection{Applications of type trait}

\subsubsection{Tag dispatch}
	 There are \textbf{three} main usages of type traits:
\begin{enumerate}
	\item Using \texttt{static\_assert} in C++ allows you to perform compile-time assertions to check the correctness of conditions. This is particularly useful for ensuring certain conditions are met during compilation. 
\begin{lstlisting}
template<typename T>
T gcd(T a, T b) {
	static_assert(std::is_integral<T>::value, "T should be an integral"); 
	if( b == 0 ){ return a; }
	else{
		return gcd(b, a % b);
	}
}	
\end{lstlisting}
	\item For a template functor, you can obtain the value type from \texttt{iterator\_traits} of the container. This information is essential in creating a template function object that can be used with various types. The source code becomes particularly interesting as it integrates the container, algorithms, and template functions, supporting nearly any generic type.
\begin{lstlisting}[frame=single, language=c++]
template<typename T>
struct Half{
	T operator()(T t){return t/2;}
};

vector vv(10, 6);
std::transform(begin(vv), end(vv),  begin(vv), Half< std::iterator_traits<decltype(begin(vv))>::value_type >{});		
\end{lstlisting}	

 \item use \texttt{true\_type} or \texttt{flase\_type} for tag dispatch (static binding). An interesting aspect is that overloaded functions can return different types. For instance, the return type of \texttt{foo} is \texttt{int} if it calls the \texttt{std::true\_type} overload and \texttt{double} if it calls the \texttt{std::false\_type} overload. Therefore, we use \texttt{auto} as the function \texttt{foo} return type.
\begin{lstlisting}[numbers=none]
template <typename T>
int foo_impl(T value, std::true_type) {...}

template <typename T>
double foo_impl(T value, std::false_type) {...}

template <typename T>
auto foo(T value) {  //please note here, we use auto!
	return foo_impl(value, std::is_arithmetic<T>{});
}	
\end{lstlisting}
\end{enumerate}
	
	
	\par A famous application of tag dispatch is seen in iterators, particularly involving \texttt{iterator\_traits}. This template is specialized to support common pointer types, making it versatile across different client-side implementations, whether they are templated or not. In functions like \texttt{advance}, which requires the \texttt{InputIterator} template parameter, it is crucial to utilize tag types. These tags facilitate overload resolution at compile time, allowing functions to be dispatched appropriately based on the specified tags.

\begin{lstlisting}[numbers=none]
struct input_iterator_tag { };
struct random_access_iterator_tag { };

template <class InputIterator, class Distance>
void advance_dispatch(InputIterator& i,Distance n,input_iterator_tag) {
	while (n--) ++i;
}
	
template <class RandomAccessIterator, class Distance>
void advance_dispatch(RandomAccessIterator& i,Distance n, random_access_iterator_tag) {
	i += n;
}

template <class InputIterator, class Distance>
void advance(InputIterator& i, Distance n) {
	typename iterator_traits<InputIterator>::iterator_category category;
	advance_dispatch(i, n, category);
}	
\end{lstlisting}	

   


\subsubsection{enable\_if}
	
	 \texttt{enable\_if} is defined below. For \texttt{false}, \texttt{enable\_if} is empty; for \texttt{true}, it includes \texttt{type}.
\begin{lstlisting}[numbers=none]
template <bool, typename T = void>
struct enable_if {};

template <typename T>
struct enable_if<true, T> {
	typedef T type;
};	
\end{lstlisting}	

	\par When we call \texttt{do(6)}, the compiler selects the first overload because the condition \texttt{std::is\_integral<int>} is true. This causes the specialization of the \texttt{enable\_if} struct for true to be used, where its internal type is set to \texttt{int}. The second overload is omitted because without the true specialization (when \texttt{std::is\_class<int>} is false), the general form of the \texttt{enable\_if} struct is selected, which does not define a type. Therefore, the type substitution fails for the argument in the second overload function.

\begin{lstlisting}[numbers=none]
template <typename T>
void do(typename enable_if<std::is_integral<T>::value, T>::type &t){
	// an implementation for integral types, T is int
}

template <typename T>
void do(typename enable_if<std::is_class<T>::value, T>::type &t) {
	// an implementation for class types
}		
\end{lstlisting}	
	
	\par Another example which use \texttt{enable\_if}. \texttt{has\_serialize} trait has been introduced in the type trait section. 
	
\begin{lstlisting}[numbers=none]
template <class T>
enable_if<has_serialize<T>::value, std::string>::type
serialize(const T& obj){
	return obj.serialize();
}

// Contra-SFINAE to avoid ambiguity
template <class T>
enable_if<!has_serialize<T>::value, std::string>::type 
serialize(const T& obj){
	return to_string(obj);
}	
\end{lstlisting}	
	
%	\item This technology has been used widely inside of vector.
%\begin{lstlisting}[frame=single, language=c++]
%template <typename T>
%class vector {
%	vector(size_type n, const T val);
%	
%	template <class InputIterator>
%	vector(InputIterator first, InputIterator last);
%	...
%}
%
%template <class _InputIterator>
%vector(_InputIterator __first,
%typename enable_if<__is_input_iterator<_InputIterator>::value &&
%!__is_forward_iterator<_InputIterator>::value &&
%... more conditions ...
%_InputIterator>::type __last);
%\end{lstlisting}	

	
	\par An example of usage of \texttt{enable\_if}. We can also use \texttt{enable\_if} to "delete" a function for certain type. In line 6:
\begin{itemize}
	\item unname template parameter. There is no name after second typename. 
	
	\item  \texttt{enable\_if\_t} is alias template.
	
	\item  \texttt{is\_reference\_v} is variable template. 
	
	\item  Why do we need \texttt{T\_}? f must be a template function, although it's inside another template class. These two templates need to use different template parameter. 
	
\end{itemize}
\begin{lstlisting}
template<typename T>
class MyClass{
	public:
	void f(T const&  x){}
	
	template<typename T_ = T, typename=std::enable_if_t<!std::is_reference_v<T_> >>
	void f(T&& x){}  //T can't be reference 
};	
\end{lstlisting}


	\par The usage of \texttt{std::enable\_if} is very flexible, it can be used as 1) template function parameter, 2) template function return, 3) template parameter. If we just want to overload two functions, we should use \texttt{enable\_if} in template parameter. 
	
	 
	\par A common pattern to overload functions according to input type.
\begin{lstlisting}
template<typename T,
std::enable_if_t<std::is_same<int, T>::value >* = nullptr>
void f() { }

template<typename T,
std::enable_if_t<std::is_same<double, T>::value >* = nullptr>
void f() { }
//--------better method.
template<typename T, typename = std::enable_if_t<std::is_same_v<int, T> > >
void g() { }

template<typename T, typename = std::enable_if_t<std::is_same_v<double, T> > >
void g() { }
\end{lstlisting}


	\par In C++17, we can use if constexpr, which makes our code cleaner and simpler. However, the basic idea remains the same. If your compiler supports if constexpr or concepts, it's preferable to use them instead of \texttt{std::enable\_if}. There is concern that \texttt{std::enable\_if} may be deprecated in future versions of the C++ standard.

\begin{lstlisting}[numbers=none]
template <typename T>
auto get_value(T t){
	if constexpr (std::is_pointer_v<T>) {
		return *t;
	} else {
		return t;
	}
}	
\end{lstlisting}

	\par A good article is "SFINAE and enable\_if"

\subsubsection{An example of building and using type trait}

     If we want to add some items to a kind of "container". We need to check if a container has reserve method(for example, \texttt{std::vector}). If we have this method, use it to reserve space before we use push back. Otherwise, we use push back directly. Below code build a type trait, it uses \texttt{void\_t} and \texttt{true\_type}. 
\begin{lstlisting}
template <typename T, typename = void >
struct has_reserve : false_type {};
   
template <typename T>
struct has_reserve<T, void_t<decltype(declval<T&>().reserve(1U))>> : true_type {};   
\end{lstlisting}

	\par Why we use \texttt{T\&} in the above code? Below code demonstrate the difference with reference and without reference.
\begin{lstlisting}
	struct X {
	X() = delete;
	int func() &;
	double func() &&;
};

//declval --> typename std::add_rvalue_reference<T>::type

static_assert(std::is_same_v<decltype(std::declval<&X>().func()), int>);
static_assert(std::is_same_v<decltype(std::declval<X>().func()), double>);
\end{lstlisting}

    \par Use tag dispatching to select different implementations of functions or algorithms based on types or traits known at compile time. This can indeed improve efficiency by avoiding runtime checks or by specializing implementations for specific scenarios. 
\begin{lstlisting}
template <typename C, typename T>
void _append(C& container, T* ptr, size_t size, true_type) {
    container.reserve(container.size() + size);
    for (size_t i = 0; i < size; ++i){ 
        container.push_back(ptr[i]);
    }
}

template <typename C, typename T>
void _append(C& container, T* ptr, size_t size, false_type){
    for (size_t i = 0; i < size; ++i) {
        container.push_back(ptr[i]);
    }
}

template <typename C, typename T>
void append(C& container, T* ptr, size_t size) { 
    _append(container, ptr, size, has_reserve<C>{}); 
}
\end{lstlisting}

%    \item You can use \texttt{enable\_if} too. The syntax is little "bloat" compared with \texttt{true\_type} dispatch. But one advantage of \texttt{enable\_if} is that you can use it not only in dispatch to two different implementations, but also filter a valid type to generate valid code, for invalid type, if you don't provide \texttt{!has\_reserve<C>} match, it will generate compiling error directly.
%\begin{lstlisting}
%template <typename C, typename T>
%enable_if_t<has_reserve<C>::value> append(C& container, T* ptr, size_t size){
%    container.reserve(container.size() + size);
%    for (size_t i = 0; i < size; ++i) {
%    	container.push_back(ptr[i]);
%    }
%}
%
%template <typename C, typename T>
%enable_if_t<!has_reserve<C>::value> append(C& container, T* ptr, size_t size){
%	for (size_t i = 0; i < size;  ++i) {
%        container.push_back(ptr[i]); 
%    }
%}
%\end{lstlisting}
%
	\par If you don't want to "dispatch", just want to use one function if it match.  When the input type is not valid, you hope to have compile error. Under such context, you can use decltype and declval directly.

\begin{lstlisting}[numbers=none]
template <typename C, typename T>
auto append(C& container, T* ptr, size_t size)-> 
              =decltype( declval<C&>().reserve(1U), void()){
	container.reserve( container.size() + size);
	for (size_t i = 0; i < size; ++i) {
		container.push_back(ptr[i]);
	}
}
\end{lstlisting}

\par Use \texttt{if constexpr} after C++17.
\begin{lstlisting}
template <typename C, typename T>
void append(C& container, T* ptr, size_t size){
    if constexpr (has_reserve<C>::value) {
        container.reserve(container.size() + size);
    }
    for (size_t i = 0; i < size; ++i) {
        container.push_back(ptr[i]);
    }
}   
\end{lstlisting}

	\par In C++20, concepts can be used directly. Here, we directly build and utilize concept \texttt{HasReserve}. The code becomes clearer, which is why concepts are referred to as the "future of generic programming". 
\begin{lstlisting}
template<typename T>
concept HasReserve = requires(T a){
    a.reserve();
};

template <HasReserve C, typename T>
void append(C& container, T* ptr, size_t size){
    container.reserve(container.size() + size);
    for (size_t i = 0; i < size; ++i) {
        container.push_back(ptr[i]);
    }
} 
\end{lstlisting}



\subsection{Type traits Summary}

	 Common type traits implementation methods includes:
	\begin{itemize}
		\item Template partial specification: \texttt{is\_integer}
		\item Use basic trait to build more complex one: \texttt{is\_swap}
		\item Use template parameter deduction : \texttt{std::is\_function} and
		\texttt{is\_member\_function}, \texttt{is\_array}, \texttt{is\_class(T::*)}
		\item Define trait manually : \texttt{iterator\_trait}.
		\item SFINAE and template class partial specification. Recommend using \texttt{decltype}, \texttt{declval} and \texttt{void\_t}. A good example is \texttt{has\_serialize}.	
	\end{itemize}
	
	\par Use above ways to implement type traits, then use these type traits to achieve static polymorphism and increase efficiency. This is the basic idea of generic programming.
\begin{center}
	\includegraphics[scale=0.9]{pics/tag_dispatch.png}
\end{center}

%	\item For type\_trait side, we introduced two main methods. In "SFINAE(Type deduct) to build trait" section, we use these two methods to implement \texttt{hasSerialize}. After C++ 14, we recommend to use \texttt{void\_t} method. But after C++ 20, we strongly recommend to use \textbf{concept}. On the other side, as a client, we mainly use \texttt{enable\_if} and tag dispatch. But after C++17, we strongly recommend use \texttt{if constexpr} and concept. In one word, if you compiler supports concept, use it to define type trait and use it in the client code too. 
	
	 \par With the development of C++, we have had three major generations of technology for defining and using types in template metaprogramming.
	
	\begin{tabular}{|p{0.14\textwidth} |p{0.38\textwidth}|p{0.38\textwidth}|}
		\hline
		C++ version & build type traits  & use type traits \\
		\hline
		C++11& static and size of & enable\_if \\
		\hline
		C++14/17& \specialcell[t]{1) void\_t, true\_type \\  
			                      2) decltype and constexpr \\
		                          3) hasSerialize is example} & \specialcell[t]{1) constexpr\ if \\ 2)true\_type overload } \\
		\hline
		C++2x & requires expression to build concepts & requires clause to use concepts \\
		\hline
	\end{tabular}

	We should use the new generation technology if the compiler supports it, because it's easier to write and maintain. The requires expression and requires clause will be introduced in the "Modern C++" chapter. You can see how elegant the requires expression is when we want to check if T has a certain member function.
\begin{lstlisting}
template <typename T>
concept hasSerialize = requires (T t) {
	{t.Serialize()} -> std::convertible_to<string>;
}; 	
\end{lstlisting}	
	


\section{Template common idiom}
\subsection{meta-programming basic}
	
	 Basic component in meta-programming includes:
	\begin{itemize}
		\item enum, static, constexpr constant in compiling time.
		\item typedef and using to define meta data.
		\item template, you can think that is "meta function". All the logic are calculated inside it when the compiler analyze the template, it's core idea in meta-programming.
		
\begin{lstlisting}[numbers=none]
template<int N, int M>
struct meta_func{
	static constexpr int value = N+M;  //"calculation" happens here.
}

cout<<meta_func<10, 20>::value. 		
\end{lstlisting}		
		
	\end{itemize}
	
	\par Implement branch, based on template specification.
\begin{lstlisting}[numbers=none]
template<bool B>
struct IfElse{};

template<>
struct IfElse <true> {
	static inline void func(){
		cout<<"output true";
	}
};

template<>
struct IfElse <false>{
	static inline void func(){
		cout<<"output false";
	}
};

IfElse<(2+3 ==6)>::func(); //use IfElse in this way. 	
\end{lstlisting}	

	\par Implement loop, based on recursive. 
\begin{lstlisting}[numbers=none]
template<int Number>
struct Fibo{
	enum{
		value = Fibo<Number-1>::value+Fibo<Number-2>::value
	};
};

template<>
struct Fibo<0>{
	enum{
		value = 0
	};
};

template<>
struct Fibo<1>{
	enum{
		value = 1
	};
};
\end{lstlisting}		
	
	


\subsection{policy, mixin and CRTP}
These three patterns are associated, so I put them together. 

\subsubsection{policy}
	
	 The Policy class can be viewed as employing a form of multiple inheritance, akin to an optional inheritance approach. We use private inheritance to encapsulate the print and message methods, preventing their exposure. This way, we can utilize them internally without making them accessible externally.
	
\begin{lstlisting}[numbers=none]
class OutputPolicyWriteToCout{
protected:
	template<typename MessageType>
	void print(MessageType const &message) const{
		std::cout << message << std::endl;
	}
};

class LanguagePolicyEnglish{
protected:
	std::string message() const{
		return "Hello, World!";
	}
};

class LanguagePolicyGerman{
protected:
	std::string message() const{
		return "Hallo Welt!";
	}
};

template <typename OutputPolicy, typename LanguagePolicy>
class HelloWorld : private OutputPolicy, private LanguagePolicy{
public:
	void run() const{
		print(message()); // Two policy methods
	}
};
\end{lstlisting}


	\par With previous class definition, client code looks like below:
\begin{lstlisting}[numbers=none]
typedef HelloWorld<OutputPolicyWriteToCout,LanguagePolicyEnglish> HelloWorldEng;
HelloWorldEng hello_world;
hello_world.run(); // prints "Hello, World!"


typedef HelloWorld<OutputPolicyWriteToCout,LanguagePolicyGerman> HelloWorldGerman;
HelloWorldGerman hello_world2; 
hello_world2.run(); // prints "Hallo Welt!"
\end{lstlisting}
	
	\par When polymorphism can be resolved at compile time, we can leverage "static polymorphism" by employing a class with static methods injected via template parameters. These methods can be inlined, resulting in no runtime overhead. This approach is commonly seen in the STL, often implemented using functors. Despite the implementation specifics, the fundamental idea remains consistent.
	
\begin{lstlisting}[frame=single, language=c++]
// char_traits::eq, traits with case-insensitive eq:
struct custom_traits: std::char_traits<char> {
	static bool eq (char c, char d) { 
	return std::tolower(c)==std::tolower(d); 
}
		
std::basic_string<char,custom_traits> str ("Test"); //input your own policy here. 
std::cout<< "found at position" <<str.find('t') ;

static const char* find (const char* s, std::size_t n, char c){ 
	while( n-- && (!eq(*s,c)) ) ++s; return s; } // call your eq here
};

\end{lstlisting}

	
	\par A good example of this is found in the book "Modern C++ Design", where the first chapter introduces the policy pattern and the second chapter introduces several techniques for managing type information at compile time. 
	

\subsubsection{Mixin}
	
	 How can we understand Mixin? At semantic level, it's the idea of adding new code (new functions) to an existing class. At syntactic level, there are different ways to achieve this goal. For example, the following three different approaches are all considered "Mixin", and each has its own unique application scenarios.
	
	\begin{enumerate}
		\item Method 1 involves creating a base (Mixin) class that includes the functions you want to add, and then having your own existing class inherit from it. This method is introduced in the "Memory" chapter's "Operator new overload" section. In this scenario, the Mixin class doesn't depend on the existing class; it simply adds some common functions.
		
		\item Method 2 involves using CRTP, such as \texttt{enable\_from\_this}. The key point here is that CRTP generates a new base class specific to each child class. In the next section, we provide an example of how to calculate the number of objects generated. The CRTP pattern works for this example, but method 1 does not. A similar concept applies to \texttt{enable\_from\_this}, as they require different \texttt{weak\_ptr} points for different classes.
		
		\item Method 3 is a template class parameterized on its base class. An example is RepeatPrint, which I will introduce next.
	\end{enumerate}
	In one word, please understand Mixin in semantic way, not in syntax way.
	
	\par Method 3 involves using template classes that define generic behavior and are designed to inherit from the type you wish to plug their functionality onto. 
	
	\begin{itemize}
		
	\item Supposing that we have an existing type which has a \texttt{print} method.
\begin{lstlisting}[numbers=none]
class Name{
public:
	Name(std::string firstName, std::string lastName)
	: firstName_(std::move(firstName)), lastName_(std::move(lastName)) {}
	
	void print() const{
		std::cout << lastName_ << ", " << firstName_ << '\n';
	}
private:
	std::string firstName_, lastname;
};	
\end{lstlisting}	
	\item RepeatPrint is a Mixin class, where T is the type you wish to plug the functionality onto.
	
\begin{lstlisting}[numbers=none]
template<typename T>
class RepeatPrint : T{
	explicit RepeatPrint(T const& printable) : T(printable) {}
	void repeat(unsigned int n) const{
		while (n-- > 0){
			this->print(); //Make sure printable has print method
		}
	}
};
\end{lstlisting}
	
	\item Client side can use \texttt{RepeatPrint} class by two ways:
\begin{lstlisting}[numbers=none]
RepeatPrint<Name> rp{"Eddard", "Stark"}; //method 1, specify type explicitly
rp.repeat(10)

template<typename T>             //method 2, we use object generator pattern
RepeatPrint<T> rpGen(T const& printable){
	return RepeatPrint<T>(printable);
}
Name ned{"Eddard", "Stark"};    
rpGen(ned).repeat(10);
\end{lstlisting}

\end{itemize}



\subsubsection{CRTP}
	 The basic syntax is templates parameterised by a derived class.
	
\begin{lstlisting}[numbers=none]
template <class T> 
struct Base{
	void interface(){
		static_cast<T*>(this)->implementation();
		// ...
	}
	
	static void static_func(){
		T::static_sub_func();
		// ...
	}
};
	
struct Derived : Base<Derived>{ //That is CRTP pattern
	void implementation();
	static void static_sub_func();
};
\end{lstlisting}
	
	
	\par There are two common usages from CRTP:
	\begin{enumerate}
		\item Static polymorphism avoids the cost of runtime polymorphism. An easy way to implement a 'callback' is through a function pointer, but it cannot be used inline, resulting in an efficiency problem. Another option is to use inheritance, which involves runtime polymorphism and has some associated overhead.
\begin{lstlisting}[numbers=none]
template<typename specific_animal>
struct animal {
	void speak() { static_cast<specific_animal*>(this)->speak(); }
};
struct dog : animal<dog> {
	void speak() { cout << "bark!" << endl; }
};
struct cat : animal<cat> {
	void speak() { cout << "miao!" << endl; }
};

template<typename specific_animal>
void speakFun(animal<specific_animal> &animal) {
	animal.speak();
}
cat c;
speakFun(c); // output bark
dog d;
speakFun(d); // output miao
\end{lstlisting}

	\item Adding functionality to existing class, that is a kind of "Mixin". The code below calculates the number of objects that have been generated.

\begin{lstlisting}[]
template <typename T>
struct counter{
	static int objects_created;
	counter(){ ++objects_created;}
};
template <typename T> 
int counter<T>::objects_created{0}; //initializing statement.

class X : counter<X>{
	// ...
};

X x;
cout<<X::objects_created<<endl;
\end{lstlisting}

	\end{enumerate}

	\par Below is another example of a template class that uses CRTP. In the source code below, the class \texttt{yan\_vect} is a template class. In comparison with class \texttt{X} from the previous source code, the previous example is a non-template class.
\begin{lstlisting}
template<typename T>
class Base{
public:
	int DoubleSum(){
		return static_cast <T &>(*this).sum()*2;
	}    
};

template<typename T>
struct yan_vect :public Base<yan_vect<T> >{
	yan_vect(int num, T v){...}
	T sum(){
		//add all elements and assign it to result.
		return result;
	}
T a[10];
int num_;
};

template<typename T>
void fun(Base<T>& bt){
	cout<<bt.DoubleSum()<<endl;
}

int main(){
	yan_vect<int> vi = {5,2};
	yan_vect<float> vf = {5,1.2};
	fun(vi);
	fun(vf);
}
\end{lstlisting}

%	\item CRTP pattern with template template class, you can see the \texttt{class Base} has template template argument. The below is syntax demo. This pattern doesn't use very widely, I just found on practical usage. please google "An Implementation Helper For The Curiously Recurring Template Pattern"

%\begin{lstlisting}
%template<typename T, template< typename > class child>
%class Base{
%	public:
%	int DoubleSum(){
%		return static_cast <child<T> &>(*this).sum()*2;
%	}    
%};
%
%template<typename T>
%struct yan_vect :public Base<T, yan_vect>{
%	yan_vect(int num, T v){...}
%	T sum(){
%		T result{};
%		for (int i = 0 ;i<num_; i++)
%			result += a[i];
%		return result;
%	}
%T a[10];
%int num_;
%};
%
%template<typename T >
%void fun(Base<T, yan_vect >& bt){
%	cout<<bt.DoubleSum()<<endl;
%}
%
%int main(){
%	yan_vect<int> vi = {5,2};
%	yan_vect<float> vf = {5,1.2};
%	fun(vi);
%	fun(vf);
%}
%\end{lstlisting}

%	\item Another interesting example is CRTP on CRTP. How to understand below code? \texttt{Scale} add functionality to \texttt{Sensitivity}, \texttt{crtp} add functionality to \texttt{Scale} and \texttt{Square}.
%\begin{lstlisting}
%template <typename T, template<typename> class crtpType>
%struct crtp{
%	T& underlying() { return static_cast<T&>(*this); }
%	T const& underlying() const { return static_cast<T const&>(*this); }
%private:
%	crtp(){}
%	friend crtpType<T>;
%};
%
%template <typename T>
%struct Scale : crtp<T, Scale>{
%	void scale(double multiplicator){
%		this->underlying().setValue(this->underlying().getValue() * multiplicator);
%	}
%};
%template <typename T>
%struct Square : crtp<T, Square>{
%	void square(){
%		this->underlying().setValue(this->underlying().getValue() * this->underlying().getValue());
%	}
%};
%
%class Sensitivity : public Scale<Sensitivity>, public Square<Sensitivity>{
%public:
%	double getValue() const { return value_; }
%	void setValue(double value) { value_ = value; }	
%private:
%	double value_{3.3};
%};
%
%Sensitivity s;
%s.scale(2);
%cout<<s.getValue()<<endl;  //output 6.6 here. 
%\end{lstlisting}
	
	\par Considering adding functionality to an existing class, CRTP (as seen in the previous counter example) and a template class parameterized on its base class (as seen in the previous RepeatPrint example) have some differences:
\begin{itemize}
	\item For counter example: 
	\begin{enumerate}
		\item Impacts the definition of the existing class because it has to inherit from the CRTP.
		\item Client code uses the original class directly and benefits from its augmented functionalities.
	\end{enumerate}
	
	
	\item For RepeatPrint example: 
	\begin{enumerate}
		\item Leaves the original class unchanged.
		
		\item Client code doesn’t use the original class directly; it needs to wrap it into the mixin to use the augmented functionality.
		
		\item Inherits from the original class even if it doesn’t have a virtual destructor. This is okay unless the Mixin class is deleted polymorphically through a pointer to the original class.
	\end{enumerate}
\end{itemize}
	




\subsubsection{A practical example}
	 In the context of the Task Manager framework, certain functionalities need to be shared among task implementations. For example, task execution timing and logging of start and completion messages are common features. In this context, we have explored six different approaches to implementing these features.
	\begin{itemize}
		
	\item  Method 1, template class parameterized on its base class.
	\begin{enumerate}
		
		\item The function name (Execute) can be different. Here, we use the same name because we can recursive use it. such as: \texttt{LoggingTask< TimingTask< MyTask > > Task;}
		
		\item A detail can be found "C++ Mixins - Reuse through inheritance is good... when done the right way" and "Mixin Classes: The Yang of the CRTP"
		
\begin{lstlisting}[numbers=none]
struct MyTask{
void Execute(){
		std::cout << "task is executed" << std::endl;
	}
};
		
template<typename T >
class LoggingTask : public T{
public:
	explicit LoggingTask(T const& t) : T(t) {}
			
	void Execute(){
		std::cout << "LOG: The task is starting - " ;
		T::Execute(); 
		std::cout << "LOG: The task has completed - " ;
	}
};
		
LoggingTask< MyTask > task;
task.Execute();
\end{lstlisting}
		
		\item If you have a \texttt{MyTask} variable, you can build a helper function to build Mixin class 
\begin{lstlisting}[numbers=none]
template<typename Task>
LogTask<Task> getLogTask(Task const& task){
	//Call the below explicit constructor in LogTask class
	return LogTask<Task>(task);
}

MyTask myTask;		
getLogTask(myTask).Execute //with log functions
\end{lstlisting}
		
	\end{enumerate}
	
	\item Method 2, use CRTP. Use base class extend and reuse function (\texttt{Execute\_imp}). Expose Execute interface to client by base class. Client can directly use MyTask.
	
\begin{lstlisting}[numbers=none]
template< class Task >
class LoggingTask {
public:
	void Execute(){
		std::cout << "LOG: The task is starting - " ;
		static_cast<Task const&>(*this).Execute_imp();
		std::cout << "LOG: The task has completed - " ;
	}
};
	
class MyTask:public LoggingTask<MyTask> {
public:
	void Execute_imp(){
		std::cout << ".task is executed..." ;
	}
};
	
MyTask task; // use MyTask variable directly.
task.Execute();
\end{lstlisting}
	
	\item Method 3, template Method. Just use run time polymorphism. Base class define a basic flow of action, some part of action is override in the child class, That is typical "Template Method pattern" in design pattern.

\begin{lstlisting}[numbers=none]
class BaseLoggingTask{
public:
	void Execute(){
		std::cout << "LOG: The task is starting - " ;
		OnExecute();
		std::cout << "LOG: The task has completed - ";
	}
	virtual void OnExecute() = 0;
};
	
// Concrete Task implementation that reuses the logging code of BaseLoggingTask
class MyTask : public BaseLoggingTask{
public:
	virtual void OnExecute(){
		std::cout << "task is executed..." << std::endl;
	}
};
	\end{lstlisting}
	
	\item Method 4, command pattern. For Logging Task, you can see the class \textbf{includes and derived from ITask at the same time}, That is typical pattern for command design pattern.

\begin{lstlisting}[numbers=none]
class LoggingTask : public ITask{ 
	ITask* task_;         
public:
	LoggingTask( ITask* task ) : task_( task ){ }
	
	~LoggingTask(){
	delete task_;
}
	
	virtual void Execute(){
		std::cout << "LOG: The task is starting - " << GetName().c_str();
		if( task_ ) task_->Execute();
		std::cout << "LOG: The task has completed - "<< GetName().c_str();
	}
};
	
class MyTask : public ITask{
public:
	virtual void Execute(){
		std::cout << ".task is executed..." ;
	}
};
	
ITask* t = new LoggingTask(new MyTask()) ;
t->Execute();
\end{lstlisting}
	
	\begin{center}
		\includegraphics[scale=0.9]{pics/command.png}
	\end{center}
	
	
	\par Method 5, mixin many mixin.

\begin{lstlisting}[numbers=none]
template< class T >
class LoggingTask : public T{
public:
	void Execute(){
		std::cout << "LOG: The task is starting - " 
		         << GetName().c_str() << std::endl;
		T::Execute();
		std::cout << "LOG: The task has completed - " 
		         << GetName().c_str() << std::endl;
	}
};
	
template< class T >
class TimingTask : public T{
	Timer timer_;
public:
	void Execute(){
		timer_.Reset();
		T::Execute();
		double t = timer_.GetElapsedTimeSecs();
		std::cout << "Task Duration: " << t <<;
	}
};
	
class MyTask{
	public:
	void Execute(){
		std::cout << "task is executed..." ;
	}
};
	
tyedef LoggingTask< TimingTask< MyTask > > Task;
Task t4;
t4.Execute();
\end{lstlisting}

		\item Method 6, policy base.
\begin{lstlisting}[numbers=none]
class coutLog{
	void beginLog(){
		cout<< "LOG: The task is starting - " <<endl
	}
	
	void endLog(){
		cout << "LOG: The task has completed - "
	}
}
	
template<typename LogPolicy, typename TimePolicy>
class Task: private LogPolicy, TimePolicy{
	void Execute(){
		beginLog();
		beginTime();
		std::cout << "This is where the task is executed";
		endTime();
		endLog();}
\end{lstlisting}

\end{itemize}
	
	\par Comparison of above methods.
	\begin{itemize}
		\item The Policy pattern can be useful when there are frequent changes in logging and timing functions.
		\item Both Mixin and Command patterns can combine themselves to perform multiple actions.
		\item Templates are more efficient than inheritance.
		\item The Command pattern has a structure similar to the Composite pattern.
		\item Mixins do not modify the current class, while CRTP changes the interface of the current class.
	\end{itemize}
	

\subsubsection{Summary}
	
	
	 Below figure is important and is worth exploring to gain a deeper understanding. For example, considering the class \texttt{class Foo: public T}, we can refer to it as the "Policy Idiom" if we focus on \texttt{Foo}, or as the "Mixin Idiom" if we focus on \texttt{T}. In the Mixin Idiom, \texttt{Foo} is intended solely to add functionality to \texttt{T}. CRTP follows a similar concept, leveraging static polymorphism when focusing on the parent class and augmenting functionality in the child class. For augmenting functionality, a common application of this concept is seen with \texttt{std::enable\_shared\_from\_this}.

		\includegraphics[width=0.9\linewidth]{pics/template1.drawio.png}
		
	\par For Contain pattern, we can use template template parameter. A good example is using a container to implement stack code in  "common used template technologies" section.
	
		%\includegraphics[width=0.9\linewidth]{pics/mixin_tt.png}
		\includegraphics[width=0.9\linewidth]{pics/template2.drawio.png}
		
%	\item For CRTP pattern, there are two advanced usage. 1)we can use template class as child class, an example is \texttt{yan\_vect} code in CRTP section.  2)we can use template template parameter too. A goog example is adding scale and square to sensitivity code in CRTP section. 
%	
%		%\includegraphics[width=0.9\linewidth]{pics/crtp_tt.png}
%		\includegraphics[width=0.9\linewidth]{pics/template3.drawio.png}



\subsection{Type erasure technology}

	
	 When you implement type erasure, it always starts with making a list of the things you want to be able to do with your type-erased object - call it, destroy it, copy it, and so on. For example, A \texttt{std::function} affords copying and calling. A \texttt{std::any} affords copying, but not calling. A \texttt{std::move\_only\_function} affords calling and moving, but not copying.

	
	\par Each item in your requirement list becomes a virtual member function of \texttt{AbstractWhatever}, which will then be appropriately overridden by \texttt{WrappingWhatever<T>} for T. At the top-level, \texttt{Whatever} stores a \texttt{unique\_ptr<AbstractWhatever> ptr\_} (and/or an SBO buffer) and provides a clean non-virtual interface that is implemented entirely by calling virtual member functions on \texttt{*ptr\_}. An example implementation is illustrated in the code and picture below. The core idea is: \textbf{Use a template class to hold different types and inherit this template class from a base class that exposes interfaces to clients}.

\begin{center}
	\includegraphics[scale=0.98]{pics/function1.png}
\end{center}

\begin{lstlisting}[frame=single, language=c++]
struct Plus1 {
	int operator()(int x) const { return x+1; }
};

struct AbstractCallback {
	virtual int call(int) const = 0;
	virtual ~AbstractCallback() = default;
};

template<class T>
struct WrappingCallback : AbstractCallback {
	T cb_;
	explicit WrappingCallback(T &&cb) : cb_(std::move(cb)) {}	                
	int call(int x) const override  { return cb_(x); }
};

struct Callback { //type erase class Callback
	std::unique_ptr<AbstractCallback> ptr_; // abstract interface
	
	template<class T> // use template class to includes different types. 
	Callback(T t) {
		ptr_ = std::make_unique<WrappingCallback<T>>(std::move(t));
	}
	int operator()(int x) const { return ptr_->call(x);}
};

int run_twice(const Callback& callback1, const Callback& callback2) {
	return callback1(1) + callback2(1);
}

int y = run_twice([](int x) { return x+1; }, Plus1{}); 
assert(y == 4);
//we can pass lambda and functor (two different types) to Callback, that is a 
//typical type erase technology. 
\end{lstlisting}

	\par A good article is "What is Type Erasure" A detail implementation can be found in:\\ \verb|http://blog.bitfoc.us/p/525|
	
%		\par Most compilers treat all member function pointers identically, regardless of the class. For many of them, a straightforward \texttt{reinterpret\_cast<>} from one member function pointer to another would work. This technology is widely used as a form of member function type erasure method. The detail can be found in this link:
	
%	https://www.codeproject.com/Articles/7150/Member-Function-Pointers-and-the-Fastest-Possible
%\begin{lstlisting}
%class A{
%	public:
%	int f(){cout<<"222"<<endl;; return 0;}
%};
%
%class B{
%};
%
%typedef int (B::*PMB)();
%typedef int (A::*PMA)();	
%PMA pma = &A::f;
%A a;
%
%B* pb = reinterpret_cast<B*>(&a); //to an unrelated class.
%PMB pmb =(PMB)(pma); //to an unrelated member function pointer.
%(pb->*pmb)();	
%\end{lstlisting}	
	 



\chapter{STL}
\section{Four components and design idioms in STL}
	 The main design principle of the STL library is to use \textbf{functors} to customize \textbf{algorithms}, which are then applied to \textbf{containers} by using \textbf{iterators}. For instance, algorithms like \texttt{std::for\_each} operate on two iterators and are agnostic to the specific container they are applied to. This design promotes flexibility and reusability across different data structures and operations.
	
\begin{lstlisting}[frame=single, language=c++, numbers=none]
struct Sum{ //functors are usually struct, not class
	Sum(): sum{0} { }
	void operator()(int n) { sum += n; }
	int sum;
};

std::vector<int> nums_v{3, 4, 2, 8, 15, 267};
std::list<int> nums_l{3, 4, 2, 8, 15, 267};
std::for_each(nums_v.begin(), nums_v.end(), [](int &n){ n++; }) //lambda syntax
Sum s = std::for_each(nums_l.begin(), nums_l.end(), Sum());  //return Sum struct
cout<<s.sum<<endl;	
\end{lstlisting}	
	
	\par Including the correct headers is crucial when using the STL (Standard Template Library) in C++. Each container, algorithm, or functionality provided by the STL requires its specific header file to be included for proper usage. This practice ensures that all necessary declarations, definitions, and template instantiations are available to the compiler.
\begin{itemize}

	\item All the algorithms are declared in <algorithm>. \texttt{std::inner\_product}, \texttt{std::partial\_sum}, \texttt{std::adjacent\_difference}, and \texttt{std::accumulate} are in the <numeric>.

	\item Special kinds of iterators, including \texttt{std::istream\_iterators}, are found in the <iterator> header file.

	\item Standard functors, such as \texttt{less<T>} and functor adapters like \texttt{not1} and \texttt{bind2nd}, are declared in <functional>. However, it is not recommended to use these functor adapters in C++11 because C++11 introduced the \texttt{function} and \texttt{bind} templates.

	\item Most of time, you need <algorithm>, <numeric>, <ranges>, <iostream>, <format>, <iterator>, <functional>, <utility> eight header files, besides the corresponding container header file. If you need template metaprogramming, you should also includes <type\_traits>, <concepts>.  
\end{itemize}

	\par Below are some commonly used idioms (design pattern) in STL:
\textbf{
1) concept,
2) type traits, 
3) tag dispatching,
4) adapters,
5) type generators,
6) object generators,
7) policy classes.
}

\begin{itemize}
	
	\item Concept is a set of requirements consisting of valid expressions, associated types, invariant, and complexity guarantees. A type that satisfies the requirements is said to \textbf{model} the concept. A concept can extend the requirements of another concept, which is called \textbf{refinement}.
	\begin{enumerate}
		\item Valid expressions are C++ expressions which must compile successfully for the objects involved in the expression to be considered models of the concept. For example, an \texttt{Iterator x} is expected to support the expressions \texttt{++x} and \texttt{*x}.
		
		\item Associated types are types that are related to the modeling type in that they participate in one or more of the valid expressions. Typically associated types can be accessed either through typedefs nested within a class definition for the modeling type, or they are accessed through a traits class. For example, an iterator's value type is associated with the iterator through \texttt{std::iterator\_traits}
\begin{lstlisting}
template<class BidirIt>
void my_reverse(BidirIt first, BidirIt last){
	typename std::iterator_traits<BidirIt>::difference_type n = std::distance(first, last);
	for (--n; n > 0; n -= 2){
		typename std::iterator_traits<BidirIt>::value_type tmp = *first;
		*first++ = *--last; *last = tmp;
	}
}
std::vector<int> v{1, 2, 3, 4, 5};  //int type behind iterator
my_reverse(v.begin(), v.end());
std::list<float> v{1.0, 2.0, 3.0, 4.0, 5.0};  //float type behind iterator
my_reverse(v.begin(), v.end());
\end{lstlisting}
		
		\item Invariants are run-time characteristics of the objects that must always be true, that is, the functions involving the objects must preserve these characteristics. The invariants often take the form of pre-conditions and post-conditions. For example, forward iterator is copied, the copy and original must compare equal.
		
		\item Complexity Guarantees are maximum limits on how long the execution of one of the valid expressions will take, or how much of various resources its computation will use.
	\end{enumerate}

	\item A type generator in C++ is a template that synthesizes new types based on its template arguments. These templates typically define a nested type alias (type) that represents the generated type. One of the most notable examples of a type generator in C++ is \texttt{std::integral\_constant}, which is used to represent compile-time constant values of integral types.
\begin{lstlisting}[numbers=none]
template <typename Value>
struct Directory{
	typedef std::map <std::string, Value, std::less<std::string>, 
	__gnu_cxx::malloc_allocator<std::string> > type;
};

Directory<int>::type var_d1;   // gives a map of string to integers.

//Better method in C++11, use alias template
template <typename Value> 
using Directory = std::map <std::string, Value, std::less<std::string>, 
	__gnu_cxx::malloc_allocator<std::string> > ;
	
Directory<int> var_d1;
\end{lstlisting} 
	
	\item An object generator is a function template whose only purpose is to construct a new object out of its arguments. Think of it as a kind of \textbf{generic constructor}. An object generator may be more useful than a plain constructor when the exact type to be generated is difficult or impossible to express and the result of the generator can be passed directly to a function rather than stored in a variable. Most Boost object generators are named with the prefix "make\_", after \texttt{std::make\_pair(const T\&, const U\&)}.
	
	\item An adapter is a class template which builds on another type or types to provide a new interface or behavioral variant. Examples of standard adapters are \texttt{std::reverse\_iterator}, which adapts an iterator type by reversing its motion upon increment/decrement, and \texttt{std::stack}, which adapts a container to provide a simple stack interface.
	\end{itemize}


\section{Container}

\subsection{Basic classifications}
\subsubsection{Structure classification}

	 STL has four kinds of containers: sequence container, associative container, unordered associative container and container adaptor. 
	
\begin{itemize}
\item Sequence: \texttt{std::array}, \texttt{std::vector}, \texttt{std::list}, \texttt{std::forward\_list}, \texttt{std::string}, \texttt{std::deque}.

\item Ordered associative: \texttt{std::map}, \texttt{std::set}, \texttt{std::multiset} and \texttt{std::multimap}.

\item Unordered associative: \texttt{std::unordered\_map}, \texttt{std::unordered\_set}, \texttt{std::unordered\_multimap} and \texttt{std::unordered\_multiset}.

\item Adaptor: \texttt{std::stack}, \texttt{std::queue} and \texttt{std::priority\_queue}.
\end{itemize}

\begin{center}
	\includegraphics[width=0.9\linewidth]{pics/container.drawio.png}
\end{center}
	


	\par Based on the previous figure, I will introduce main API inside these container below: 

\begin{itemize}
	\item \texttt{operator >, >=, ==...} is non member function, They must be the same container.  \\ \texttt{std::lexicographical\_compare} can compare different containers. The size of container can be different.
\begin{lstlisting}
std::vector<int> alice{1, 2, 3};
std::vector<int> bob{7, 8, 9, 10};
bool result = alice > bob;

std::vector<char> v1{'a', 'b', 'c', 'd'};
std::list<char> v2{'b', 'b', 'c'};
cout<<lexicographical_compare(v1.begin(), v1.end(), v2.begin(), v2.end());
\end{lstlisting}	

	\item All containers contain 4 member functions: \texttt{empty()}, \texttt{size()}, \texttt{max\_size()} and \texttt{swap()}. \texttt{max\_size() }is just theoretical value.  \texttt{std::forward\_list} has no \texttt{size()} member function.

	\item First-class container includes \texttt{begin()}, \texttt{end()}, \texttt{rbegin()}, \texttt{rend()}. \texttt{insert()/emplace()} ,\texttt{erase()}, \texttt{clear()}. There are no such 7 functions in container adapter. These 7 functions exist in both sequenced and associative containers. \texttt{insert()} and \texttt{emplace()} can be thought as the same "add" semantic. Try to use \texttt{emplace()} first if it's applicable.   

	\item Sequence containers support \texttt{pop\_back()}, \texttt{push\_back()}, \texttt{front()}, \texttt{back()} and \texttt{resize()}. There are no these 5 functions in associative containers.
 
	\item \texttt{std::vector} supports \texttt{operator[]}, \texttt{std::list} supports \texttt{push\_front()} and \texttt{pop\_front()}. \\ \texttt{std::deque} supports all (3 functions).  By now \texttt{std::deque} supports (4+7+5+3 = 19 functions) \textbf{container(4)--> first container(7)-->sequence container(5)-->deque(3)}. 
	
	\item \texttt{insert()}, \texttt{push\_back()} and \texttt{push\_front()} all follow "copy in" rule, they have corresponding "construct in directly" version: \texttt{emplace()}, \texttt{emplace\_back()} and \texttt{emplace\_front()}. 
	
	\item Associate containers have 7 functions for both ordered associative and unordered associative. They are \texttt{count()}, \texttt{contains()}, \texttt{equal\_range()} and \texttt{find()} (four lookup semantic). Another three functions are \texttt{emplace\_hint()}, \texttt{extract()} and \texttt{merge()}. 
\begin{lstlisting}
std::map<int, std::string> m{{1, "mango"}, {2, "papaya"}, {3, "guava"}};
auto nh = m.extract(2);  //1) use auto to get return value  
nh.key() = 4;            //2) change the key
m.insert(std::move(nh)); //3) use std::move insert it back. 
// m == {{1, "mango"}, {3, "guava"}, {4, "papaya"}}

std::map<int, std::string> ma{{1, "apple"}, {5, "pear"}, {10, "banana"}};
std::map<int, std::string> mb{{4, "batman"}, {5, "X"}, {8, "alpaca"}};
std::map<int, std::string> u;
u.merge(ma);
std::cout << "ma.size(): " << ma.size() << '\n'; //ma.size is 0
u.merge(mb);                                     
std::cout << "mb.size(): " << mb.size() << '\n'; //mb.size is 1 
std::cout << "mb.at(5): " << mb.at(5) << '\n';   //output "X"
\end{lstlisting}
	
	\item For ordered associative, they support \texttt{lower\_bound} and \texttt{upper\_bound}. Only \texttt{std::map} supports \texttt{operator[]}, \texttt{insert\_or\_assign()} and \texttt{try\_emplace()}. You can use (4+7+7+4+3) to remember these API. 
	
	\item For unordered associative, they don't support \texttt{lower\_bound} and \texttt{upper\_bound}, but have some hash related functions. Only \texttt{std::unorded\_map} supports \texttt{operator[]}, \texttt{insert\_or\_assign()} and \texttt{try\_emplace()}. You can also use (4+7+7+4+3) to remember these API (I have already labeled the numbers on the above figure). 
	

	\item Associate containers don't support \texttt{push\_back()} and \texttt{pop\_back()}, use \texttt{insert()/emplace()}, \texttt{emplace\_hint()} and \texttt{erase()} to add or delete an element. Although we can't \texttt{push\_back()}, we can use \texttt{begin()} and \texttt{end()} on associate container to get iterators. For \texttt{std::forward\_lists} and unordered set or map, no backward-iteration interface (\texttt{rbegin()}, \texttt{rend()}, etc.) is provided. The reason is that the implementation requires only singly linked lists to go through the elements.

	\item Only \texttt{std::vector} and \texttt{std::string} supports \texttt{reserve()} and \texttt{capacity()}.

	\item \texttt{std::list} supports it's own version \texttt{merge()}, \texttt{remove()/unique()}, \texttt{reverse()}, \texttt{splice()} and \texttt{sort()}, it can be simply remembered as \textbf{MRRSS}. For other container, you can use the generic algorithm, Why \texttt{std::list} has its own \texttt{sort()}? \texttt{list} doesn't support random access iterator. For \texttt{merge(), remove()} and \texttt{unique()}, generic algorithms just use copy method, but \texttt{list} has high efficient pointer implementation, so \texttt{std::list} offer its own version algorithms.
\begin{lstlisting}
list<int> list1{1, 2, 3, 4, 5};//use splice to implement std::rotate on std::list
auto it = list1.begin();
advance(it, 2); //have to use advance, std::list doesn't support it+2;
list1.splice(list1.begin(), list1, it, list1.end()); //3, 4, 5, 1, 2
\end{lstlisting}
	
	\item There are three \texttt{merge()} functions: 
	\begin{enumerate}
		\item Member function \texttt{merge} in \texttt{std::list}, need sorted range inputs.
		
		\item Member function merge for order and unordered associative container.
		
		\item Generic algorithm \texttt{std::merge()} and \texttt{std::inplace\_merge()}, need sorted range inputs.
		
	\end{enumerate}
	  
	
	\item  If you can find same name member functions in container, prefer to use member function than generic algorithm. Such as \texttt{sort(), merge(), remove(unique)(), reverse()} in \texttt{std::list}, and \texttt{find(), count(), equal\_range()} in associative containers.

	\item All first class containers support member function \texttt{begin()} and \texttt{end()}. Only sequence containers support \texttt{push\_front()} or \texttt{push\_back()}. 
	
\begin{enumerate}
	\item \texttt{begin()} and \texttt{end()} return iterators, and all first container support them. adaptors container don't have them.

	\item \texttt{front()} and \texttt{back()} are \textbf{element access} functions, just like operator [] and \texttt{at} function.  They return reference, for a container \texttt{c}, the expression \texttt{c.front()} is equivalent to \texttt{*c.begin()} or \texttt{c[0]}. 
	
	\item \texttt{begin()} can be used for all first class containers (such as \texttt{std::vector}, \texttt{std::map}), but \texttt{front()} and \texttt{back()} only be used for sequential containers (such as \texttt{std::vector}).

	\item \texttt{push\_front()} and \texttt{push\_back()} add element to a sequenced container, and \texttt{std::vector} only support \texttt{push\_back()}. \texttt{std::deque} and \texttt{std::list} support both.
\end{enumerate}

	\item Associative containers support their own \texttt{find()}, \texttt{count()},  \texttt{lower\_bound()}, \texttt{upper\_bound()} , \texttt{equal\_range()}. They share the same name with generic algorithm, Don't confuse them. When you deal with associative container, just use container member function, don't use generic algorithms. \texttt{equal\_range()} return two iterators, you can use struct binding (C++17) to simplify your code like below:
\begin{lstlisting}
auto [fi, si] = map1.equal_range(1); // struct binding, fi is first iterator
for(auto p = fi; p!= si; ++p){
	auto &[key, value] = *p;  //struct bind, key is first element
                          //p.first is const key, key is const & key, 
                          // you don't need specify key as const auto &
	cout<<key <<" "<<value<<endl;
}
\end{lstlisting}

	\item In C++23, we also add some \texttt{insert\_range}, \texttt{append\_range(prepend\_range)} and \texttt{assign\_range} for sequence container and \texttt{insert\_range} for associative container.

	\item All the container adapters support \texttt{push()}, \texttt{pop()}. \texttt{std::stack} and \texttt{std::priority\_queue} support \texttt{top()}. \texttt{std::queue} has \texttt{front()} and \texttt{back()}. They are not first-class container, so they don't support iterator, no \texttt{begin()} and \texttt{end()} member function. 
	
	\item It is important to understand these APIs in the context of each container's characteristics. For example, why is there no \texttt{resize()} function in \texttt{std::map}? The \texttt{resize()} function uses the default constructor to create objects within a container, but \texttt{std::map} needs to keep all objects sorted. Therefore, using the default constructor is not practical in this case.
	

\end{itemize}

	
	\par \texttt{std::deque} is the data structure of choice when most insertions and deletions take place at the beginning or end of the sequence at the same time. However, it does not guarantee continuity within memory and has a higher constant factor cost than a vector. One possible memory layout for a deque is shown in Fig. 9.2. Although both offer random access to elements and linear-time insertion and removal from the middle of a sequence, a \texttt{std::vector} is maybe faster.
	
	\begin{figure}[ht]
		\centering
		\includegraphics[width=0.25\linewidth]{pics/queue.png}
		\caption{Implementation of deque}
		\label{fig:queue}
	\end{figure}
	
	
	\par Difference between \texttt{std::vector} and \texttt{std::deque}:
	\begin{itemize}
		\item \texttt{std::vector} has relocation problem. If it has 1000 elements, it probably need $log(1000) = 10$ times relocation and that is a little costly. On the contrary, \texttt{std::deque} just allocate a new place then insert pointer of new place to pointer map. It's relatively cheaper.
		
		
		\item Elements in a \texttt{std::deque} are not contiguous in memory; \texttt{std::vector} elements are guaranteed to be. So if you need to interact with a plain C library that needs contiguous arrays, or if you care (a lot) about spatial locality, then you might prefer \texttt{std::vector}.
		
		\item For stack and queue default use \texttt{std::deque} as container inside. Why? because for a large amount of element, \texttt{std::vector} has relocation problem.
	\end{itemize}
	
		\par Using a \texttt{std::vector} for a small number of items is almost always superior to using a \texttt{std::list}. Even though insertion in the middle of the sequence is a linear-time operation for \texttt{std::vector} and a constant-time operation for \texttt{std::list}, \texttt{std::vector} usually outperforms \texttt{std::list} because of its better constant factor and cache friendliness. The \texttt{std::list}'s Big-O advantage doesn't come into play until data sizes become significantly larger. The same idea also applies to associative containers. The standard associative containers are implemented as balanced binary search trees and are optimized for a mix of insertions, deletions, and lookups. For example, if the container is used as a dictionary, it may go through three distinct phases: setup, lookup, and modify. Modify operations are infrequent, whereas lookups are very frequent. In such cases, the associative container may not be the best option. A sorted \texttt{std::vector} also supports logarithmic search time and has two advantages: 1) it uses less space, and 2) more space can cause page faults in memory, making the sorted \texttt{std::vector} faster than the associative container. Therefore, for a medium size dictionary, it is better to use a sorted \texttt{std::vector}.
	


\subsubsection{Memory classification}

	 Another classification of container : \textbf{contiguous-base and node-base.} \texttt{std::vector}, \texttt{std::string}, and \texttt{std::deque} are contiguous-base. \texttt{std::list} and \texttt{std::forward\_list}(linked list), \texttt{std::set} and \texttt{std::map}(balanced trees) are node-base. Why do we have such classification? 
\begin{itemize}
	\item All the contiguous-base container has invalidation of iterator (pointer, reference) problem. 

	\item All the node-based containers only support bidirectional iterators, and none of them have a \texttt{reserve()} function, so there's no need to worry about reallocation issues. \texttt{std::deque} also lacks a \texttt{reserve()} function.
\end{itemize}

	\par About the iterator invalidation problem, you need to know the invalidation rules based on below 5 operations: 

\begin{description}
	
\item[Insertion] operation on different containers:

	 Sequence containers
	\begin{description}
		\item [vector:] All iterators and references before the point of insertion are unaffected, unless the new container size is greater than the previous capacity (in which case all iterators and references are invalidated). 
		
		\item [deque:] All iterators and references are invalidated, unless the inserted member is at an end (front or back) of the \texttt{deque} (in which case all iterators are invalidated, but references to elements are unaffected). Sound a little strange, article "How can references be valid while iterators become invalidated in a deque" give more detail, The basic idea is the iterator in \texttt{std::queue} is not pointer type.
		
		\item [list:] all iterators and references unaffected
	\end{description}
	
	\par Associative containers: \texttt{[multi]\{set,map\}} all iterators and references unaffected
	
	\par Container adapters:  \texttt{stack}, \texttt{queue} and \texttt{priority\_queue}: inherited from underlying container. (Usually, we don't use iterator in \texttt{stack}, \texttt{queue} and \texttt{priority\_queue}. Maybe you don't need to worry about it. )

%\begin{lstlisting}[frame=single, language=c++, mathescape=true]	
%vecArr.insert ( it + 2, 1 , 200 ); //iterator invalid.
%it = vecArr.begin(); //Reinitialize the invalidated iterator to %beginning.
%\end{lstlisting}

\item[Erasure] operation on different containers: 
	 Sequence containers
	\begin{description}
		\item [vector:] every iterator and reference after the point of erase is invalidated
		
		\item [deque:] all iterators and references are invalidated, unless the erased members are at an end (front or back) of the \texttt{deque} (in which case only iterators and references to the erased members are invalidated). You can see here it is different with inserting in the front. Because deque maybe has a array of pointer as a index table, insert in the front maybe need add a new pointer in the beginning of array of pointer, so it will invalid all the iterator. 
		
		\item [list:] only the iterators and references to the erased element is invalidated
	\end{description}
	
	\par Associative containers: \texttt{[multi]\{set,map\}}: only iterators and references to the erased elements are invalidated
	
	\par Container adaptors: \texttt{std::stack}, \texttt{std::queue} and \texttt{std::priority\_queue}: inherited from underlying container. 

\begin{lstlisting}[]
auto it = std::find(vecArr.begin(), vecArr.end(), 5);
if(it != vecArr.end())
vecArr.erase(it);   //error, we should use it = vecArr.erase(it);
for(; it != vecArr.end(); it++)//error, Unpredicted Behavior
std::cout<<(*it)<<"  "; //error, Unpredicted Behavior	
\end{lstlisting}
	
	\item[push, pop]
\texttt{push\_back()} and \texttt{push\_front()} are defined in terms of \texttt{insert()}. Similarly, \texttt{pop\_back()} and \texttt{pop\_front()} are defined in terms of \texttt{erase()}.

	\item[Resizing]
\texttt{vector}, \texttt{deque} and \texttt{list} as per insert/erase

	\item[swap]
	Every iterator referring to an element in one container before the swap shall refer to the same element in the other container after the swap. No \texttt{swap()} function invalidates any references, pointers, or iterators referring to the elements of the containers being swapped.
	
\end{description}

	\par If you want strongly error-safe code, such as transnational semantics for inserting and erasing, or need to minimize iterator invalidation, prefer a node-based container.



\subsection{Container Practical Usages}
\subsubsection{Container and value semantic}
	
	 For all containers in the STL, the general principle is "Copy in, Copy out". 
\begin{lstlisting}[numbers=none]
int j = 10;
vector<int> vc;
vc.push_back(j); // not j, but copy of j to vc

int i = vc.pop_back(); 
i = -99 // when you modify i, not effect on vc	
\end{lstlisting}	
	
	\par Because containers follow "Copy in, Copy out" policy, it should store only values or smart pointers (\texttt{unique\_ptr} or \texttt{shared\_ptr}) in container, because smart pointer is also kind of value semantic, not object (reference) semantic. 
	
	\begin{itemize}
		\item If you need to store objects that are not copyable or not value-like (such as DatabaseLocks and TcpConnections), it is recommended to store them indirectly using smart pointers, such as container of \texttt{shared\_ptr<DatabaseLock>} or \texttt{shared\_ptr<TcpConnection>}.
		
		\item Optional values. When you want a\texttt{ map<Thing, Widget>}, but some things have no associated Widget, prefer to use \texttt{map<Thing, shared\_ptr<Widget> >}.
		
		\item Index containers. To have a main container hold the objects and access them using different sort orders without resorting the main container, you can set up secondary containers that "point into" the main one and sort the secondary containers in different ways using dereferenced compare predicates. Prefer a container of \texttt{MainContainer::iterators} instead of a container of pointers, because most of STL algorithm support iterators. 
		
	\end{itemize}
	
	\par \texttt{std::vector} is more flexible than arrays in C++ because it utilizes heap memory. If you prefer to use stack memory instead, you can opt for \texttt{std::array}.
\begin{lstlisting}[numbers=none]
Foo farray[50]; //default constructor has been called 50 times.
Foo *parray = new Foo[50]; //Same, constructor will be called 50 times.

vector<Foo> fvc; // NO default constructor has been called.
fvc.reserve(50);	
\end{lstlisting}	
	
	\par Copy-in and copy-out operations can potentially cause efficiency problems. When you want to save an object into a container, you have to build the object first, then copy it into the container. In C++11 and beyond, using \texttt{emplace\_back()} (like \texttt{push\_back()}), \texttt{emplace} (like \texttt{insert(pos, value)}), or \texttt{try\_emplace} in \texttt{std::map} allows you to construct objects directly within containers. This approach avoids the overhead of unnecessary copying by constructing the objects in place inside a container, which can be more efficient, especially for complex or not move-cheap types.
	
\begin{lstlisting}
struct A{
	std::string name;
	int age;
};
vector<A> va;
A a("aa",1); //call constructor
va.push_back(a);  //call copy constructor.

va.push_back(A("aa",1)); //call constructor and move constructor.
va.emplace_back("aa",1); //only call constructor, the most efficient.
\end{lstlisting}			
	
	\par Attempting to insert a derived class object into a container of base class objects will result in a slicing error. To overcome this issue, using a container of pointers is a common approach. However, this approach can lead to resource leakage if memory deallocation is forgotten or if an exception is thrown. A better alternative is to utilize smart pointers, such as types derived from a common base class, prefer \texttt{container< shared\_ptr<Base> >}.
	
	
	\par It's important to note that using \texttt{std::auto\_ptr} in any container is prohibited in C++ and will result in a compiler error. For more detailed information on this topic, refer to "Effective STL," item 8.
	
	
	\par With the assistance of an allocator, a container can optimize its behavior. For example, Plain Old Data (POD) types may not require calling constructors, and small objects can be efficiently stored in a memory pool. More detailed information on these topics can be found in the book "The C++ Standard Library: A Tutorial and Reference." Allocators can be customized, as demonstrated in "Effective STL" with two examples. However, in many cases, replacing the default allocator is unnecessary. It's worth noting that the design of allocators can sometimes lead to instances where types like \texttt{vector<int, allocA>} and \texttt{vector<int, allocB>} are treated as distinct types, which might not always be optimal.

\subsubsection{Create and initialize a container }
	
	You can build a container directly with some initialization value.
\begin{lstlisting}
vector<vector<int> > vv{{1,2,3},{4, 5, 6}};
vector<vector<int> > ww{vv}; //copy initialization directly from existing one

vector<vector<int> > ww(2, vector<int>(10, 0));
\end{lstlisting} 

	\par You can also build a container from a different kind of container.
\begin{lstlisting}
set<int> s {1, 2, 3};
vector<int> v2{s.begin(), s.end()}; //from a std::set to std::vector

vector<int> v2{1, 2, 3, 3, 3,4};
set<int> s {v2.begin(), v2.end()}; //from std::vector to std::set

map<int, int> m {{1, 2}, {2, 4}};
vector<pair<int, int> > v1{m.begin(), m.end()}; //from std::map to std::vector

vector<pair<int, int> > v1{{1, 2}, {2, 4}};
map<int, int> m {v1.begin(), v1.end()};	 //from std::vector to std::map
\end{lstlisting} 

	\par You can use some algorithms to initialize the containers:
	
\begin{itemize}
	\item \texttt{std::fill} and \texttt{std::fill\_n}
\begin{lstlisting}
std::vector<int> v1(10, 0);
std::fill(v1.begin(), v1.end(), 6);

std::fill_n(v1.begin(), 5, 3); // 3 3 3 3 3 6 6 6 6 6
\end{lstlisting} 	

	\item  Below code snippet illustrates \texttt{std::iota} and constrained algorithms. Use \texttt{ostream\_iterator} and \texttt{ranges::copy} to output a container.
\begin{lstlisting}
vector<int> vi2;
vi2.resize(10);  //initialize vi2 to 10 element with default value 0.
iota(vi2.begin(), vi2.end(), 0); //iota just assign, need resize container first. 
range::copy_if(vi2, ostream_iterator<int>(cout, " "), [](const auto &e){
																return e%2 ==0;
															});		
\end{lstlisting}			
	
	\item \texttt{std::generate} and \texttt{std::generate\_n}. Need to know \texttt{std::generate\_n} and \texttt{std::generate} difference. Both \texttt{std::generate} and \texttt{std::fill} use a pair of input iterators. \texttt{std::generate} use functor, \texttt{std::fill} use value. \texttt{std::generate\_n} and \texttt{std::fill\_n} use one output iterator. Why we use \texttt{std::ref} here? because \texttt{rng} is not empty object, so we should avoid copying it. It is correct to pass the generator around by reference. The mt19937 has internal state that needs to be modified to get the next random number. If you were to pass the generator by value then you would make a copy of that state and then multiple functions would wind up getting the same random number. This is also why you cannot pass it by const\& since it would not be able to modify that internal state if it was const.
	
\begin{lstlisting}[numbers=none]
random_device rd;
std::mt19937 rng{rd()}; //std::mt19937 and std::random_device should use together
vector<std::mt19937::result_type> v(10);
std::generate(v.begin(), v.end(), std::ref(rng) );   			
\end{lstlisting}


	
	\item We can use \texttt{std::mt19937} in \texttt{std::sample}, \texttt{std::shuffle} and distribution. The basic step is: 
	\begin{enumerate}
		\item Generate \texttt{random\_device rd;}  
		\item Call \texttt{rd}'s \texttt{operator()}, aka, \texttt{rd()} generate a real random value from hardware, and use this real random value to build \texttt{mt19937} object: \texttt{mt19937 mt\{rd()\};}.
		\item Pass this \texttt{mt} object into \texttt{std::shuffle()}, \texttt{std::sample()}, or distribute object operator(mt).
	\end{enumerate}
	
\begin{lstlisting}
vector<int> v1(10, 0); //both fill and generate need resize the vector

uniform_int_distribution<int> dist{1, 100}; //1) distribution.
random_device rd;
mt19937 mt{rd()}; //2) rd is functor, rd() return a real random value.

ranges::generate(v1,  [&](){
	return dist(mt); //3) pass mt into dist's operator() to generate random value.
});

mt19937 mt{rd()};
ranges::shuffle(v1, mt);  //shuffle need to use mt19937.
ranges::sample(vi, std::back_inserter(out), 4, mt); //sample also need to use mt	
\end{lstlisting}	
	
\end{itemize}
		

\subsubsection{Size and capacity of vector}

	 Using \texttt{std::vector} or \texttt{std::string} instead of dynamically allocating arrays with \texttt{new[]} is generally recommended for better memory management and safety in C++. Using \texttt{reserve()} in \texttt{std::vector} or \texttt{std::string} can indeed help in optimizing memory usage when dealing with large data sets.
	
	\par When checking if a container is empty, it is recommended to use the \texttt{empty()} function instead of comparing \texttt{size()} to zero. This is easier to understand. For a vector, the \texttt{size()}, \texttt{capacity()}, and \texttt{max\_size()} functions can be used as follows: \texttt{capacity()} is always equal to or greater than \texttt{size()}.
\begin{lstlisting}[frame=single, language=c++]
std::vector<int> myvector;
for (int i=0; i<100; i++)
	myvector.push_back(i);

std::cout << myvector.size() <<" "<<myvector.capacity()<<" "<<myvector.max_size();
// 100  128  1073741823
\end{lstlisting}

	\par \texttt{reserve()} will not change size of vector. 
\begin{lstlisting}
vector<int> vi;
vi.reserve(10); //vi.size() is 0
\end{lstlisting}
		
	\par \texttt{resize()} and \texttt{reserve()} serve different purposes. \texttt{resize(n)} adjusts the container's size to \texttt{n}. If \texttt{n} is less than the current size, elements at the end are removed. If \texttt{n} is greater, default-constructed elements are added. After \texttt{resize(n)}, \texttt{size()} will return \texttt{n}. Note that \texttt{resize()} invokes the default constructor, which can impact performance.
\begin{lstlisting}[frame=single, language=c++]
capacity() //how many CAN hold
size()   //how many are in NOW
resize(n) //initial or fill with default constructor.
reserve(n) //cause the container's capacity() to at lease n.

vector<Foo> vcFoo;
vcFoo.reserve(10); // just allocate space, don't construct object.
//vcFoo[2] = foo;  // Fail here. 
vcFoo.resize(10);  // beside allocate space, also construct object.
vcFoo[2] = foo;    // OK here.		
\end{lstlisting}	
	
	\par To minimize unnecessary allocations, follow these guidelines:
\begin{itemize}
	\item If you know the expected number of elements, use \texttt{reserve()} to preallocate memory.
	
	\item If the exact number is unknown but maximum efficiency is desired, reserve more space than initially needed, and later trim any excess capacity by using \texttt{shrink\_to\_fit()}. This ensures optimal memory usage. \texttt{std::vector}, \texttt{std::string} and \texttt{std::deque} support \texttt{shrink\_to\_fit()}. In the above three containers, \texttt{pop\_back()} function will not free memory.  
	


\begin{lstlisting}[frame=single, language=c++]
vector<Foo>(v1).swap(v1); //Before C++11, use this trick. vector<class>(v1) is
                          // temporary vector, it copy existing Foo object inside
                          // v1. After swap, v1 size will be reduce to fit size. 
                          
v1.shrink_to_fit(); //new feature in C++11
\end{lstlisting}
	
	\item For \texttt{std::iota()}, \texttt{std::fill()}, and \texttt{std::generate()} algorithms, the target range is specified by a pair of iterators. You need to ensure that the target range has been initialized. You can use the \texttt{resize()} member function, or you can use the default constructor with a size parameter, such as \texttt{std::vector<int> v(3)}, to meet this requirement.
	
\end{itemize}
	
\subsubsection{Add, delete and update}
	
	 Although both associative and sequential containers support common interfaces within the STL, such as \texttt{insert()}, \texttt{erase()}, the primary modification member functions for sequential containers are \texttt{push\_back/front()} and \texttt{pop\_back/front()} operations. For associative containers, the primary modification member functions are \texttt{insert()} and \texttt{erase()} operations.  After C++11, you can also use \texttt{emplace()} group member functions to build object in container directly. 
	
	\par \texttt{clear()} only changes the size to 0; it doesn't affect the capacity. \texttt{insert()} usually returns an iterator to the inserted element, or to the element that prevented the insertion (in the case of \texttt{std::map} or \texttt{std::set}). \texttt{erase()} usually returns an iterator to the element \textbf{following} the last removed element.
	
	\par Note that \texttt{std::forward\_list} lacks \texttt{push\_back()}, \texttt{pop\_back()}, and \texttt{size()} functions. Instead of \texttt{insert()}, \texttt{std::forward\_list} uses \texttt{insert\_after()}. Below is an example of how to append an element to the end of \texttt{std::forward\_list}.
\begin{lstlisting}
auto before_end = forward_list.before_begin(); 
for (auto& _ : forward_list)
	++ before_end;    //above code move iterator to the last non-null element.
	
forward_list.insert_after(before_end, 1234); //use insert_after instead of insert. 
\end{lstlisting}
		
	\par In associative containers such as \texttt{std::map} or \texttt{std::set}, you do not need to use \texttt{find} before calling \texttt{insert}. If the element already exists, \texttt{insert} will simply do nothing. There are three versions of the \texttt{insert} function: 
\begin{lstlisting}[]
std::pair<iterator, bool> insert( P& value );  // direct insert
iterator insert( iterator hint, const value_type& value ); //hint insert
void insert( InputIt first, InputIt last );  // range insert.	
\end{lstlisting}	
	\begin{description}
		\item[Line 1:] If you insert a value directly using \texttt{insert()}, it will return a pair where the second element is a boolean value that indicates whether the insertion was successful or not.
		
		\item[Line 2:] When you insert a value by using a hint iterator, the \texttt{insert()} function returns an iterator pointing to either the element that was successfully inserted or the equivalent element that already existed in the container. Unlike the direct value insertion method, this version of \texttt{insert()} does not return a boolean value to indicate success. This design choice ensures compatibility with positional insertions in sequential containers like \texttt{std::vector::insert}, allowing for the creation of generic inserters such as \texttt{std::inserter}. To verify the success of a hinted insertion, one can compare the container's size before and after the operation. In \texttt{std::unordered\_map}, you can find the same version insert function. It is an just for interface compatibility. In other words, for \texttt{std::unordered\_map} it does not differ a hint is provided or not.
	\end{description}
	
	\par For sequential containers, after performing an \texttt{insert()} or \texttt{erase()} operation, it is crucial \textbf{not} to continue using the same iterator. Instead, you should use the new valid iterator returned by the \texttt{insert()} or \texttt{erase()} function.
\begin{lstlisting}
v.insert(i, 8);
cout<<*i; // dangerous, i is maybe invalidated.

i = v.insert(i, 8);
cout<<*i ; //good	
\end{lstlisting}	
	
	\par Because we want to use \texttt{std::inserter}, the insert member functions in all sequential and associative containers have the same API format. Adaptor containers do not support \texttt{insert} at all. 
\begin{lstlisting}[numbers=none]
iterator insert( const_iterator pos, const value_type& value ); //common API 

std::multiset<int> s {1, 2, 3};  //inserter usage for associative container
std::fill_n(std::inserter(s, s.end()), 5, 2);	

std::vector<int> d {100, 200, 300}; //inserter usage for sequential container
std::vector<int> v {1, 2, 3, 4, 5};
std::copy(d.begin(), d.end(), std::inserter(v, std::next(v.begin())));
//output 1 100 200 300 2 3 4 5	
\end{lstlisting}
	
	\par About inserting point:
	\begin{itemize}
		\item \texttt{lower\_bound} always return a iterator, which point to the element which equal or greater than the value? why, because you can use this iterator with insert function directly.
		
		\item \texttt{insert(const\_iterator pos, ..)} member function in a container inserts a value before the iterator \texttt{pos}. 
		
		\item For \texttt{std::forward\_list()}, insert member funciton will be low efficiency, that is why it provides \texttt{insert\_after()} function.
	\end{itemize}
	
	
	\par For an associative container, you don't have to use \texttt{find()} before using \texttt{erase()}. The \texttt{erase()} function has three versions:
\begin{lstlisting}[numbers=none]
size_t erase( P& value );   //return number of you have deleted.
iterator erase ( iterator pos ); // return the next iterator.
void erase( InputIt first, InputIt last ); //range erase.	
\end{lstlisting}
	
	\par In sequential containers, \texttt{erase()} has only two versions and accepts only iterators, not values. If you want to delete a value, you need to use a generic remove algorithm for \texttt{std::vector} or the \texttt{remove} member function for \texttt{std::list}, which differs from how associative containers handle deletions. A mnemonics is: \texttt{std::map/std::set} uses erase+value, \texttt{std::list} use remove+value, \texttt{std::vector} use erase+remove+value.
	
%\begin{lstlisting}
%size_type erase( const Key& key );  //map API
%size_type remove( const T& value ); //list API
%iterator erase( const_iterator first, const_iterator last ); //vector API
%\end{lstlisting}
%	
%	
%	\par Choose carefully among erasing options: To eliminate all objects in a container that have a particular value.
	\begin{itemize}
		\item For a \texttt{std::vector}, \texttt{std::string} or \texttt{std::deque}: use \texttt{erase-remove} idiom. Don't use for loop, it will invalid the iterators.
		
		\item For a \texttt{std::list}: use it's own \texttt{remove} member function.
		
		\item For an associative container: use its \texttt{erase} member function.		
	\end{itemize}
	
\begin{lstlisting}[numbers=none]
vect.erase(remove(vect.begin(), vect.end(),1963), vect.end());
list.remove(1963);
map.erase(1963);	
\end{lstlisting}	
	
	\par  To eliminate all objects in a container that satisfy a particular predicate.
	\begin{itemize}
		\item For a \texttt{std::vector}, \texttt{std::string} or \texttt{std::deque}: use erase-remove\_if idiom, Don't use for loop, it will invalid the iterator.
		
		\item For a \texttt{std::list}: use \texttt{remove\_if}.
		
		\item For an associative container: write loop, make sure to post increment your iterator. Detail can be seen in effective STL item 9.
	\end{itemize}
\begin{lstlisting}[numbers=none]
bool badValue(int x);
vc.erase(remove_if(vc.begin(), vc.end(), badValue), vc.end()); // 1) vector

lsit.remove_if(badValue);                                   // 2) list

for(auto i = map.begin();i!=map.end(); /* no ++i here*/) {  // 3) map
	if(badVaue(*i)) 
		i = map.erase(i);  //post increment here! or map.erase(i++);
	else  
		++i;
}	
\end{lstlisting}	
	
	\par To perform additional actions inside the loop while erasing objects, you can't use the erase-remove idiom; instead, you should explicitly write a loop.
\begin{lstlisting}[numbers=none]
bool badValue(int x);
for(auto i = vect.begin(); i!=vect.end(); ){
	if(badVaue(*i)) {
		i = vect.erase(i); // use erase return value update i here.
		...do something else 
	}
	else  ++i;
}			
\end{lstlisting}

	\par Generally, it is not advisable to delete items from a container while iterating through it, as this action can invalidate the iterator and potentially lead to program crashes. However, if you are absolutely certain that the items being deleted are not the values referenced by any of the iterators used at the moment of deletion, it is safe to proceed with the deletion. It's important to note that for other STL containers such as \texttt{std::vectors}, the constraint is even stricter: deleting items from the container not only invalidates iterators pointing to the deleted item but can also affect other iterators. Therefore, deleting from these containers while iterating through them is even more problematic.

	\par Effective STL item 22: Avoid in-place key modification in \texttt{std::set} and \texttt{std::map}.
\begin{itemize}
	\item you can't change key in map because it's const default.
\begin{lstlisting}[numbers=none]
map.begin()->first = 10; //compile error here
\end{lstlisting}	
	
	\item For \texttt{std::set} or \texttt{std::map}, you can modify non-key part. In line 3, \texttt{set.find} returns a const iterator, and you cannot change the value through it. To modify the value, you must first change it to a reference. Using \texttt{const\_cast<Employee>} alone is not correct as it creates a temporary object and modifies it, which is not what you want.
\begin{lstlisting}[frame=single, language=c++]
auto i = set.find(Yan); //i is const_iterator
if( i != set.end())
	const_cast<Employee &> (*i).setTitle("manager");
\end{lstlisting}	
	
	\item If you want to modify the key part in \texttt{std::set} or \texttt{std::map}, erase it first, modify, then insert it back.
\begin{lstlisting}[frame=single, language=c++]
iterator i = se.find(employee); 
if(i ! = se.end()){   // 1) find the one
	Employee e(*i);    //2) create temp one.
	e.setKey("new key") //3) modify
	se.erase(i++);  //4) delete the old one and keep iterator i;
	se.insert(i,e); //5) insert new one
}	
\end{lstlisting}	
	
	\item C++ 17 provide a easier way to modify the key in associate container, use extract to transfer node without copying or moving.
\begin{lstlisting}
map<int,string> m {{2,"a"},{3,"x"}};
auto n2 = m.extract(2);  //1) extract, no delete any memory here. 
n2.key() = 5;            //2) modify key, 
m.insert(std::move(n2)); //3) use insert and move to add node back. 
\end{lstlisting}	
	
\end{itemize}
		



\subsubsection{Search in a container}
	
%	\ref{fig:search}.
%	\begin{figure}[ht]
%		\centering
%		\includegraphics[scale=0.6]{pics/distinguish.png}
%		\caption{Search algorithms}
%		\label{fig:search}
%	\end{figure}


	 \texttt{std::set} and \texttt{std::map} use \texttt{operator<} for ordering, whereas \texttt{std::unordered\_set} and  \\ \texttt{std::unordered\_map} use \texttt{operator==} for equality. Equality (\textit{equal}) refers to items being identical and fully interchangeable, such as two instances of the string 'hello'. In contrast, equivalence (\textit{equivalent}) indicates items are not interchangeable but serve a similar purpose. For example, two individuals with the same security clearance are equivalent because they have access to the same resources, though they are not identical.
	
	\par To determine if an element is present in a container, you can use the following methods:
\begin{itemize}
	\item For sequential containers like \texttt{std::vector} or \texttt{std::list}, employ the generic \texttt{std::find()} and \texttt{std::find\_if()} algorithm. Check if the returned iterator is not equal to \texttt{container.end()} to confirm element presence. Additionally, \texttt{std::count()} reveals the number of occurrences.
	
	\item For associative containers such as \texttt{std::map} or \texttt{std::set}, use \texttt{contains()} (from C++20) to directly check existence (returns a boolean). \texttt{count()} indicates occurrence count (0 or 1 for map/set, any non-negative for multimap/multiset). Use \texttt{find()}, \texttt{lower\_bound()}, \texttt{upper\_bound()} and \texttt{equal\_range()} to locate the element or its position.
	
	\item Consider \texttt{std::any\_of}, \texttt{std::all\_of} and \texttt{std::none\_of} algorithms for complex lookups, requiring a predicate functor.
\begin{lstlisting}
std::vector<int> v = {1, 2, 3, 4, 5};
bool anygt = std::any_of(v.begin(), v.end(), [](int i) { return i > 10; });
bool ap = all_of(v.begin(), v.end(),[](int i) {return i > 0; });						
bool nn = none_of(v.begin(), v.end(), [](int i) {return i >= 0; });	
\end{lstlisting} 	
	
\end{itemize}

	\par Distinguish among the following algorithms: \texttt{count}, \texttt{find}, \texttt{binary\_search}, \texttt{lower\_bound}, \\ \texttt{upper\_bound}, and \texttt{equal\_range}.


	\begin{itemize}
	\item For an unsorted range, the generic \texttt{find()} or \texttt{find\_if()} algorithms, or the \texttt{count()} algorithm, can be used. If the element is not found in the range, the \texttt{find()} algorithms return the \texttt{end()} iterator.
	
	\item Don't use generic \texttt{find()} algorithm on a sorted range,  use \texttt{binary\_search()}. \texttt{binary\_search} just return bool, not position. Beside \texttt{binary\_search}, \texttt{lower\_bound}, \texttt{upper\_bound}, and \texttt{equal\_range} are also used on a sorted range. 
	
	\item For \texttt{std::set} or \texttt{std::map}, It has own version, \texttt{find()}, \texttt{count()} and \texttt{lower\_bound()}, \texttt{upper\_bound()}, and \texttt{equal\_range()}. You should not use \texttt{binary\_search} generic algorithm on the \texttt{std::map} and \texttt{std::set}, but use its own \texttt{find()}.
	
	\item  \texttt{find()} returns a match iterator, if no match, it will return the last iterator. \texttt{lower\_bound()}  returns a position anyway, it can be either match position or insert position(no match).
	
	\item \texttt{std::lower\_bound} returns first element that is greater-or-equal. \texttt{std::upper\_bound} returns first element that is strictly greater. \texttt{std::equal\_range} return a pair of (\texttt{lower\_bound}, \texttt{upper\_bound}).
	
	\begin{center}
		\includegraphics[scale=0.5]{pics/lowerupper.png}
	\end{center}
	
	
	\item In the case of \texttt{equal\_range()}, if the two returned iterators are equal, it means that the element was not found in the range. If the distance between the two iterators is greater than or equal to one, it indicates the presence of one or more matching elements. This function can be used as a substitute for the \texttt{find()} or \texttt{count()} functions.
\begin{lstlisting}[frame=single, language=c++]
std::sort (v.begin(), v.end());// 10 10 10 20 20 20 30 30
auto [f, s] =std::equal_range (v.begin(), v.end(), 20);
for ( auto i = f; i != s; ++i )
	cout<<*i<<endl;   //output 20 20 20

if(distance(f, s)  >=1)
	cout<<" found match"<<endl;
\end{lstlisting}	
	
	\end{itemize}
	
		\par The main search functions in STL can be illustrated below:
	
	\begin{tabular}{|p{0.3\textwidth}|p{0.15\textwidth}|p{0.13\textwidth}|p{0.13\textwidth}|p{0.13\textwidth}|}
		\hline
		&  \multicolumn{2}{c|}{\textbf{Algorithm to use}}  &  \multicolumn{2}{c|}{\textbf{Member function to use}} \\
		\hline
		& unsorted range & sorted range  & set or map & multiset or multimap \\
		
		\hline
		Does the desired value exist?& find  &  binary\_search  & count & find  \\
		\hline
		Dose the desired value exist? \newline If so, where is the first \newline  object with that value?& find & equal\_range & find  & find or lower\_bount  \\
		\hline
		Where is the first object with \newline a value not preceding \newline the desired value?& find\_if & lower\_bound & lower\_bound & lower\_bound \\
		\hline
		Where is the first object with \newline  a value succeeding the \newline  desired value?& find\_if  & upper\_bound  & upper\_bound & upper\_bound \\
		\hline
		How many objects have \newline  the desired value?& count & equal\_range & count  & count \\
		\hline
		Where are all the objects with \newline  the desired value? & find  & equal\_range & equal\_range  & equal\_range \\
		
		\hline
	\end{tabular}
	
	\par Summary of find function:

\begin{itemize}
	\item \texttt{find(\_if)(\_not)} , \texttt{find\_first\_of}, and \texttt{adjacent\_find} are three main algorithms in stl. 
	
	\item In C++23, we add \texttt{find\_last(\_if)(\_not)}. 
	
	\item For \texttt{std::string}, we have \texttt{rfind}, \texttt{find\_last(\_not)\_of} and \texttt{find\_first(\_not)\_of} member function. Why do we have such member functions, because for \texttt{std::string}, we can input \texttt{std::string} or \texttt{char* s} directly into these member function. 
\end{itemize}

\subsubsection{Range member functions}

	 Prefer range member functions to their single-element counterparts, Detail can be found in "Effective STL Item 5".
	
\begin{lstlisting}[numbers=none]
container::container(inputIterator1, inputIterator2); //Range construction
container::insert(insertPosition, inputIt1, inputIt2); //Range insertion
container::erase(inputIterator1, inputIterator2); //Range erasure
container::assign(inputIterator1, inputIterator2); //Range assignment	
\end{lstlisting}	
	

	\par Although \texttt{std::copy} and \texttt{container::insert} has the same semantic, the copy algorithm uses a loop internally. In almost all cases where the source range is specified by using a pair of iterators, it is better to replace the \texttt{std::copy} algorithm with \texttt{container::insert} range member function.

\begin{lstlisting}[numbers=none]
v1.clear();
copy(v2.begin(), v2.end(), back_inserter(v1) ); //don't use copy here

v1.insert(v1.end(), v2.begin(),v2.end() ); //use below 4 range function
v1.assign(v2.begin(), v2.end() )
vector<int> v1( v2.begin(), v2.end() );  //build from scratch. (build range)
v1.erase( v1.begin(), v1.begin()+5);   //erase range.
\end{lstlisting}

	\par Here's a good example to explain why you should use range member functions. When you use insert, the STL internally calculates the distance (n elements) between \texttt{v2.begin()} and \texttt{v2.end()}. Then it reserves space in \texttt{v1} and moves all the elements from \texttt{v2} into \texttt{v1} just once based on the calculated distance. On the other hand, if you use copy, it inserts one element at a time using a loop, which means it moves all the elements in \texttt{v1} n times. If there's not enough space, it will reallocate and copy old elements, just like a common \texttt{vector} does. Therefore, using range member functions can save you a lot of time in this example.

\begin{lstlisting}[frame=single, language=c++]
copy(v2,begin() , v2.end(), inserter(v, v.begin() ) ); //insert in the beginning.
//don't use front_inserter() above, because vector don't support push_front
v1.insert(v1.begin(),  v2,begin() , v2.end()); // a better method is here.
\end{lstlisting}

	\par The main reason to use the \texttt{assign} member function is to copy data from one container to another of a different type.
\begin{itemize}
	
	\item If you want to migrate the contents of an \texttt{std::set<int>} to an \texttt{std::vector<int>}, you can't use the assignment operator \texttt{vector = set}, but you can use \texttt{vector.assign(set.begin(), set.end())}.

	\item Another example would be copying the contents of two containers holding different types that are convertible to one or the other; If you try to assign texttt{vector<Derived*>} to an \texttt{vector<Base*>}, the assignment operator is insufficient.

\end{itemize}


\par From \texttt{std::vector} to construct \texttt{std::map}, you can use \texttt{std::copy} or range construction. Range construction is better than \texttt{std::copy} here.

\begin{lstlisting}
std::vector<std::pair<std::string, int> > values {   
	{"Jerry", 1},
	{ "Jim", 2},
	{ "Bill", 3} };
std::map<std::string, int> mapped_values;

std::copy(values.begin(), values.end(), 
std::inserter(mapped_values, mapped_values.begin()));

//or, you could initialize the map from the vector by using range construction.
std::map<std::string, int> m2( values.begin(), values.end() );	
\end{lstlisting}



\subsubsection{Other usage suggestions}
		
	 All container is not thread-safe. It's your duty to make it thread-safe. 
\begin{lstlisting}[numbers=none]
getMutexFor(container); 
...// do something on container.
releaseMutexFor(container);	
\end{lstlisting}	
	
	\par When you use STL containers, you should know that both \texttt{typedef} and \texttt{auto} are your best friends. 1) For a complex type, it can save typing. 2) keep good maintainable for future change. In modern C++, we recommend using type alias more. 
\begin{lstlisting}
typedef vector< pair<int, string> > ComVec;
ComVec::value_type aaa;  //save a lot of typing 
using ComVec = vector< pair<int, string> > // use type alias more in modern C++

typedef std::vector< std::pair<int,std::string> > Record_t;
//typedef std::vector< std::pair<float,std::string> > Record_t; 

int find_it(std::string value, Record_t const& stuff){
	auto fit = std::find_if(stuff.begin(), stuff.end(),  //use auto here. 
			[value](Record_t::value_type const& vt){ 
				return vt.second == value; 
			});
}	
\end{lstlisting}
\begin{description}
	\item[Line 5-6:] change \texttt{int} to \texttt{float}, code below line 5 don't need to change at all.
\end{description}

	\par Use :: to access the type defined inside a container.
\begin{lstlisting}[numbers=none]
vector<uint> vecs;
cout << sizeof(vecs.value_type)  //error usage
cout<<sizeof(vector<uint>::value_type); //it's static class member.	
\end{lstlisting}	
	
	\par You can use a type definition of a container inside a template function to achieve a more generic purpose. Alternatively, you can use an unknown container in a template class or support multiple containers at the same time to achieve greater flexibility and generality.
	
	\begin{itemize}
		
		\item Having the commonly-used types available as a type inside the container is useful when the container's type itself is unknown. For example, someone may want to write library code that works equally well with \texttt{std::map} and \texttt{std::unordered\_map}:
\begin{lstlisting}[numbers=none]
template<typename TDict>
void insert_default_pair(TDict& dict){
	dict.emplace(typename TDict::key_type{}, typename TDict::mapped_type{});
}	
\end{lstlisting}		
		
		\item When using container types inside template code, it is important to use the \texttt{typename} keyword before it. This has been introduced before in the "generic programming" chapter. The reason for this is that it can sometimes be unclear whether an identifier designates a type or a variable. For example, \texttt{T * p} may be interpreted as a multiplication or a pointer declaration. By explicitly marking it as a type with the prefix \texttt{typename}, we can avoid any ambiguity and ensure that the code is interpreted correctly.
		
\begin{lstlisting}[numbers=none]
template <typename T>
class TSContainer {
  T container;
  void push(typename T::value_type& item){//use typename before T::value_type
    container.push_back(item);
 }	
\end{lstlisting}		
		
		\end{itemize}
		
%	\item Never try to expect all the container has the same interface. Even a generic erase(), for sequence, It return next iterator,(because it will invalid the iterator).   But for associative, it return void(c++ 98) and return next iterator(C++ 11). If you just want to change a container in the future, you should put a container into a class: CustomCollection. then hide it from the class client. The detail can be seen in Effective STL item 2.


	\par Note the difference between equality and equivalence in associative Containers.
	
  \begin{itemize}
	  \item \textbf{equality} is based on \texttt{operator ==}. \textbf{equivalence} is based on \texttt{operator <}. Because associate containers, such as \texttt{std::set} and \texttt{std::map}, they must sort their elements, so they must use \texttt{operator <}. Then it use \texttt{!if(a<b)\&\&!if(b<a)} to define equivalence, and associate container use equivalence to decide if a object exist in a container, while unordered (hash) containers, such as \texttt{std::unordered\_set} and \texttt{std::unordered\_map} use equality \texttt{operator ==}. 
	  
	  \item If you don't have custom compare function, most of time equivalence is equal to equality, but if you define your specific comparison function, you need to know below:
 
	\begin{enumerate}
		
		\item It is important to always have comparison functions return false for equal values, to ensure strict weak ordering, as introduced in item 21 in \textit{"Effective STL"}.

  		\item The generic algorithm \texttt{std::find} uses \texttt{operator==} by default.
\begin{lstlisting}[frame=single, language=c++, numbers=none]
set<string,  case_insensitive_compare> ss; //ss has "AA";
ss.find("aa"); //return true; 
find(ss.begin(),ss.end() , "aa") //false, find algorithm use operator ==
\end{lstlisting}

  		\item For associative container of pointers, You need to specify comparison types, You want to order by pointers or want to order by objects pointed by pointer. (Most of time, the second option is what we want), as introduced in item 20 in \texttt{"Effective STL"}.
\begin{lstlisting}[frame=single, language=c++, numbers=none]
struct stringLess{
   bool operator()(const string* s1 , const string * s2){
        return *s1<*s2;
	}
}
set<*string,  stringLess> ss;
\end{lstlisting}

   \end{enumerate}


	\item To support user-defined key types in \texttt{std::unordered\_set<Key>} and \texttt{std::unordered\_map<Key, Value>} one has to provide \texttt{operator==(Key, Key)} and a hash function(or functor).
\begin{lstlisting}[numbers=none]
struct X { int id; /* ... */ };
	bool operator==(const & X a, const & X b) { return a.id == b.id; }
	struct MyHash { //define MyHash inside struct X
		size_t operator()(const X& x) const { 
			return std::hash<int>()(x.id); }
	};
}

std::unordered_set<X, MyHash> s;
\end{lstlisting}	
	
	\item Just like the \texttt{swap} function introduced earlier (you can find details in the previous OOP chapter), you are expressly allowed and encouraged to add specializations to the \texttt{std::} namespace. The correct (and basically only) way to add a \texttt{hash} function is like this:
\begin{lstlisting}[frame=single, language=c++]
namespace std {
	template <> struct hash<Foo>{
		size_t operator()(const Foo & x) const{
			//your hash function code here
		}
	};
}
std::unordered_set<Foo> s;	
\end{lstlisting}	
	\end{itemize}
	
 	\par New containers introduced after C++11 are \texttt{std::forward\_list}, \texttt{std::array}, \texttt{std::unordered\_map}, and \texttt{std::unordered\_set}. The latter two support the implementation of hash tables, and the standard library provides basic hash functions for fundamental types like \texttt{int} and \texttt{string}. If you have your own class, you can use \texttt{boost::hash\_combine} to implement a hash function (or functor).
	
	\par \texttt{std::unordered\_map} has several properties related to its internal structure, including \texttt{bucket\_count} and \texttt{bucket\_size}. These properties help manage and understand the distribution of elements within the hash table. \texttt{bucket\_count} returns the number of buckets in the \texttt{unordered\_map} and \texttt{bucket\_size} returns the number of elements in a specific bucket.
\begin{lstlisting}
unordered_set<int> us;  
for(size_t i = 0; i<us.bucket_count(); ++i){ //bucket number
	cout<<us.bucket_size(i)  //element number in each bucket
}
us.rehash(200) // use 200 bucket.
us.max_load_factor() //usually is 1, don't change it.
\end{lstlisting}	

	
	
	
	\par \texttt{std::array} is a class-based version of the classic C array, distinguished by its fixed size at compile time and allocation on the stack. In contrast, \texttt{std::vector} is a small class that holds a pointer to heap-allocated memory. This means that when you create a \texttt{std::vector}, it allocates memory using \texttt{new}. Accessing elements in a \texttt{std::vector} may involve slightly slower performance due to indirection through pointers to access the arrayed data. However, vectors can be resized dynamically, and they consume only a trivial amount of stack space regardless of their size.
	
\begin{lstlisting}
array<string, 3> arr_str = {"hello", "world", "!"}; //need specify size, 3 here.
array arr_i = {1, 2, 3}; //std::array supports CTAD in c++ 17. 
	\end{lstlisting}	
	
	\par \texttt{std::array} supports copying and assignment between arrays of the same size. The \texttt{at()} method is slower (but safer) than \texttt{operator[]}, as it performs bounds checking. Unlike other containers, \texttt{std::array} does not have a constructor for initializing elements individually; you specify its size using a template parameter. Since \texttt{std::array} is fixed in size, it does not provide a \texttt{push\_back} member function like \texttt{std::vector}.
\begin{lstlisting}[numbers=none]
array<int, 10> a2 = {0};
auto a3 = a2; // making a new array via copy
auto a4(a2);  // same
a5 = a2 // a2 and a5 must have the same size and type.	  
\end{lstlisting}		
	
	
	\par Fixed-size C arrays decay into pointers when passed to a function, losing the array length information. Unlike C arrays, \texttt{std::array} and \texttt{std::vector} do not implicitly decay into a raw pointer. To obtain the underlying pointer of an \texttt{std::array}, you must use the \texttt{data()} member function, especially when interfacing with APIs that require a C-style buffer interface. Using an \texttt{std::array\&} as a function parameter ensures that the array length information is preserved.
	
\begin{lstlisting}[numbers=none]
void carr_func(int * arr, size_t size){
	std::cout << "carr_func - arr: " << arr << std::endl;
}
carr_func(a2, a2.size()); //Error:
carr_func(a2.data(), a2.size()); //OK		
\end{lstlisting}		
	
	%	\item For most cases, you should use \texttt{std::array} and \texttt{std::forward\_list} first if you don't have any strong reason against using them.
	%\begin{lstlisting}[numbers=none]
	%void printLength(const std::array<double, 5> &myarray){
		%	std::cout << "length: " << myarray.size();
		%}
	%
	%std::array<double, 5> myarray { 9.0, 7.2, 5.4, 3.6, 1.8 };
	%printLength(myarray);	
	%\end{lstlisting}	
	
		
	\par Usage of \texttt{emplace} in \texttt{std::map}. Pay attention here, \texttt{insert} only accept one parameter(\texttt{std::pair}); However, \texttt{emplace} can accept two parameters, because it constructs \texttt{std::pair} inside the \texttt{std::map}.

\begin{lstlisting}
auto m = std::map<int, A> {};

m.insert({1, A("Ann", 63)});  //constructor, move
m.insert(std::make_pair(1, A("Ann", 63))); //construct, move
m.emplace(1, A("Ann", 63));   //only construct, no move

// m.emplace(1, "Ann", 63);   //compile fail.
m.try_emplace(1, "Ann", 63);  //Work, only construct, no move 
\end{lstlisting}
	
	\par Another addition is \texttt{insert\_or\_assign} in \texttt{std::map} in C++ 17. \texttt{insert\_or\_assign()} is a “smarter” successor of \texttt{operator[]}. Just like \texttt{operator[]},  it modifies values if supplied with a key that is already present in the map. However, unlike \texttt{operator[]}, \texttt{insert\_or\_assign()} doesn’t require default constructibility of the value\_type. On top of that, it returns a \texttt{pair<iterator, bool>}. The bool is true when insertion took place and false in case of assignment. 
	
\begin{lstlisting}
auto m = std::map<int, A> {};

auto[it, ins] = m.insert_or_assign(1, A("Ann", 63));
if (ins){ cout<<"insert happen"; }	
\end{lstlisting}		
	
	\par \texttt{try\_emplace()} is a safer successor of \texttt{insert()} or \texttt{emplace()}. In line with \texttt{insert()} and \texttt{emplace()}, \texttt{try\_emplace()} doesn’t modify values for already inserted elements. However, on top of that, it prevents stealing from original arguments that happens both with \texttt{insert()} and \texttt{emplace()} in case of a failed insertion.
	
\begin{lstlisting}
auto p = std::make_unique<A>("John",47);
m.emplace(1, std::move(p)); // p won't be inserted
assert(p != nullptr); // this will most likely fail

m.try_emplace(1, std::move(p));
assert(p != nullptr); //no plundering in case insertion failed
\end{lstlisting}	
	
	\begin{center}
		\includegraphics[width=0.8\linewidth]{pics/try_emplace.drawio.png}
	\end{center}
	
	\par Detail can be found in the articles: "Overview of std::map’s Insertion / Emplacement Methods in C++17" 
	


\subsection{String}
\subsubsection{std::string class basic knowledge}
	 The string class is a template specialization of \texttt{basic\_string<char>}. Understanding this will enable you to construct a string of type \texttt{w\_char}.

	\par There are a lot of ways that can be used construct a string object, you can see these methods in the cpp reference website, such as:
\begin{lstlisting}[numbers=none]
string(size_type count, CharT ch);  //1) single character
string(const char*, size_type n);   //2) character pointer 
string(const string& str, size_type pos, size_type n = npos) //3) std::string
template< class InputIt > //4) iterator, comes from sequential container.
basic_string( InputIt first, InputIt last, const Allocator& alloc=Allocator());	
\end{lstlisting}

	\par When it comes to the real size of a string, the string class usually manages its own memory. Just like \texttt{std::vector}, you can use the \texttt{string::capacity()} and \texttt{string::reserve()} functions to manipulate the memory allocation. For example, if you call \texttt{str.reserve(50)}, \texttt{str.capacity()} will return 63. This is because 63 is the largest block size that can fit 50 characters, plus one extra character for the null terminator (\verb='\0'=) that marks the end of the string.
	
	\par In C++, we encourage you to use the string class more often, instead of \texttt{char[]} and \texttt{char *p = new}. Essentially, a \texttt{std::string} is just a sequential container, like \texttt{std::vector}. Therefore, it supports all the functionalities that \texttt{std::vector} provides. However, being a string, it also has additional interfaces specifically tailored for string operations, such as \texttt{find()}, \texttt{replace()}, \texttt{compare()}, \texttt{length()}, and \texttt{substr()}, among others. A list of string methods is below:
	
	\begin{tabular}{| p{0.2\textwidth} |p{0.7\textwidth}|}
	\tophline
	length(), size()  & Returns the current number of elements in a string. \\
	
	\tophline
	find(), rfind() & Search a string in a forward/backward direction for the first occurrence of a substring that matches a specified sequence of characters.\\
	
	\tophline
	substr() & Copies a substring of at most some number of characters from a string beginning from a specified position. \\		
	\tophline
	find\_first\_not\_of() find\_first\_of() find\_last\_not\_of() find\_last\_of() & Search through a string for the first character that is not any element of a specified string.\\
	\tophline
	append() & Adds characters to the end of a string.\\
	\tophline
	c\_str(), data() & Return pointer. \\
	\tophline
	compare()& Compares two character sequences. \\
	\tophline
	copy() & Copies at most a specified number of characters from an indexed position in a source string to a target character array.The function does not append a null character at the end of the copied content.
	\\
	\tophline
	replace() & Replaces the characters in the string.
	\\
	\tophline
	contains()  starts\_with() ends\_with() & Checks if the string begins with the given prefix and suffix. C++20 supports them.
	\bottomhline
\end{tabular}

	\par The \texttt{std::string} interface has a bad reputation due to its extensive API, but there are some clues to help you remember and use them effectively: 
\begin{itemize}
	
	\item First, member functions need to meet the corresponding functional requirements, which usually require an \textbf{operation position} or an \textbf{operation object}, or both. For example, the insert function needs to determine where to \texttt{insert} (operation position) and what to insert (operation object). The \texttt{find} function requires specifying what to search for (operation object) and where to search (operation position). The \texttt{replace} function needs to identify the position to be replaced (operation position) and the content to replace it with (operation object).
\begin{lstlisting}
basic_string& insert( size_type index, size_type count, CharT ch ); 
//index is operation position, count and ch are operation object
iterator insert( const_iterator pos, CharT ch );

size_type find( const CharT* s, size_type pos = 0 ) const;
//pos is operation position, s is operation object.

basic_string& replace( size_type pos, size_type count, const basic_string& str );
//pos and count denote operation position (range), str is operation object.
\end{lstlisting}
	
	\item \texttt{std::string} is also a sequential container, like \texttt{std::vector}; For each member function, When talking about \textbf{operation position}, it usually supports both position (string semantic, size\_type) and iterator (container semantic). 

\begin{lstlisting}
string& replace( const_iterator first, const_iterator last, const string& str);
string& replace( size_type pos, size_type count, const string& str);	
\end{lstlisting}
	
	\item For \textbf{operation object}, it usually supports three different objects.
	
	\begin{enumerate}
		\item A single character. 
\begin{lstlisting}
size_type find( CharT ch, size_type pos = 0 ) const;
\end{lstlisting}

		\item \texttt{CharT* s} pointer, for \texttt{CharT*} pointer, usually it support another overload version, which you can input \texttt{size\_type count} to specify the length of \texttt{s}.
\begin{lstlisting}
size_type find( const CharT* s, size_type pos, size_type count ) const;
//Finds the first substring equal to the range [s, s + count).
size_type find( const CharT* s, size_type pos = 0 ) const;
\end{lstlisting}
		\item A \texttt{std::string} and \texttt{std::string\_view} parameter. For \texttt{std::string}, sometimes we can also provide extra \texttt{s\_index} and \texttt{count} to specify a range inside the \texttt{std::string} parameter \texttt{str}, such as \texttt{insert} function below.
\begin{lstlisting}
size_type find( const basic_string& str, size_type pos = 0 ) const;

template< class StringViewLike >
size_type find( const StringViewLike& t, size_type pos = 0 ) const noexcept

basic_string& insert( size_type index, const basic_string& str,
size_type s_index, size_type count );
//use s_index and count to specify range inside str.
\end{lstlisting}
		
	
	\end{enumerate}
	
	

	\item The \texttt{replace()} function has a complex interface, but our previous discussion of \textbf{operation objects} and \textbf{operation positions} clarifies its structure. There are two main categories: the first is based on position, while the second is based on iterators. It accepts both \texttt{std::string} and \texttt{char*} as inputs and also supports custom ranges for \texttt{str} and \texttt{cstr}. That is all!
	
\begin{lstlisting}[numbers=none, basicstyle=\scriptsize]
1)replace( size_type pos, size_type count, const basic_string& str ); 
2)replace( size_type pos, size_type count, const CharT* cstr );

//for 3) and 4), you can also control str or cstr length. 
3)replace(size_t pos, size_t count, const string& str, size_t pos2, size_t count2);
4)replace( size_type pos, size_type count, const CharT* cstr, size_type count2 );

//5) can control how many single character you want to input.
5)basic_string& replace(size_type pos,size_type count, size_type count2, CharT ch );

//6) For above position verison, it also supports iterator version. 
6) replace( const_iterator first, const_iterator last, const basic_string& str ); 	
\end{lstlisting}

\begin{lstlisting}
std::string base="this is a test string.";
std::string str2="n example";
std::string str3="sample phrase";

// Using positions:                 0123456789*123456789*12345
std::string str=base;           // "this is a test string."
str.replace(9,5,str2);          // "this is an example string." (1)
str.replace(19,6,str3,7,6);     // "this is an example phrase." (2)

// Using iterators:                                  0123456789*123456789*
str.replace(str.begin(),str.end()-3,str3);       // "sample phrase!!!"    (1)
str.replace(str.begin(),str.begin()+6,"replace");// "replace phrase!!!"   (2)	
\end{lstlisting}
	

\end{itemize}
		

		
	\par There are a few \texttt{find()} name inside STL library, don't confused with below names: 
	\begin{itemize}
		\item \texttt{std::find/find\_if}, \texttt{std::search/find\_end} are generic algorithms based on iterators. \texttt{std::find} look for a value in a container, and \texttt{std::search} look for a sub range. \texttt{vector} doesn't have \texttt{find} member function, you should use \texttt{std::find} for it.
		
		\item In \texttt{std::string}, we use \texttt{find()} and \texttt{rfind()} two member functions, the names are more clearly. \texttt{find} member function in the string return position. If there is no match, it will return \texttt{String::npos}, it is the maximum possible length of the string. Equal the maximum value of an unsigned int.
		
		\item \texttt{find()} in \texttt{std::map} look for a specific value in the map. If there is no match, it will return \texttt{end()} iterator.
	\end{itemize}
	 	
\begin{lstlisting}[frame=single, language=c++]
size_t found;
found=str.find("haystack"); // or found=str.find('.');
if (found!=std::string::npos)
	std::cout << "'haystack' also found at: " << found << '\n';
	
vector<int> myints = { 10, 20, 30, 40 };
auto  it = std::find (myints.begin(), myints.end(), 30);
if(it!=myints.end())
	cout<< "find 30"<<endl;
\end{lstlisting}

	\par The position returned by the \texttt{find()} can be used in a loop. This is a useful string pattern to remember.
\begin{lstlisting}[numbers=none]
std::string str ("Please, replace the vowels with asterisks.");
size_t pos = 0;
while ((pos=str.find_first_of("aeiou", pos)) !=std::string::npos){
	str[pos]='*';
	pos++;
}	
\end{lstlisting}




	\par The standard containers define \texttt{size\_type} as a typedef to \texttt{Allocator::size\_type} (where \texttt{Allocator} is a template parameter). For the default allocator (\texttt{std::allocator}), \texttt{size\_type} is defined to be \texttt{size\_t}. Therefore, in the standard case, they are the same. However, if you use a custom allocator, a different underlying type could be used. Thus, using \texttt{container::size\_type} is preferable for maximum portability.




\par If you are using a string with some legacy C function, you should use the \texttt{std::string.c\_str()} function for read-only operations. This function returns a \texttt{const char*}, so you can't modify the string using this pointer. If your legacy C function needs to modify the string, you should follow the steps below: 	 

\begin{lstlisting}[frame=single, language=c++]
Old_c(const char* p); 
Old_c(str.c_str());  // legacy C function read a string

size_t Old_c(char *pArray, size_t arraySize);  // legacy C write a string.

vector<char> vc(maxNumChars); // 1) create vector char, better than char* p
size_t charsWritten = Old_c(&vc[0], vc.size()); //2) write result to vc.
string s(vc.begin(), vc.begin()+charsWritten);  //3) copy vc to string.
\end{lstlisting}

\par Another interesting topic regarding strings is SBO(small buffer optimization), which is used in the string implementation of all compilers. For short strings (less than 16 characters), we can save them in \_local memory instead of on the heap, which saves on heap allocation costs.
\begin{lstlisting}
class string{
	union Buffer{
		char*    _begin;
		char[16] _local;
	};
	
	Buffer _buffer;
	size_t _size;
	size_t _capacity;
};	
\end{lstlisting}


\subsubsection{std::string examples}


	 The common usage pattern about strings: 1) case conversion, 2) number conversion, 3) predicate and category, 4) trim, 5) find and search  6)replace and erase 7) split and join.

	\par Upper case and lower case conversion code. \texttt{::toupper} and \texttt{::tolower} are C language function which is not in \texttt{std} namespace, so we use :: to access it. 
\begin{lstlisting}
std::string str = "Hello World";
std::transform(str.begin(), str.end(), str.begin(), ::toupper);	
\end{lstlisting}

	\par Number conversion. Pay attention to \texttt{std::stoi}, \texttt{stol}, \texttt{stof} and \texttt{std::to\_string}.
\begin{lstlisting}
std::string str_dec = "2001, A Space Odyssey";
std::string str_hex = "40c3";
std::string::size_type sz;   // alias of size_t
int i_dec = std::stoi (str_dec, &sz);
int i_hex = std::stoi (str_hex, nullptr, 16);
std::cout << str_dec << ": " << i_dec << " and [" << str_dec.substr(sz) << "]\n";

float f{123.456};
string str = std::to_string(f);	
\end{lstlisting}

	\par Predicate and category. 
\begin{lstlisting}
isspace	isprint	iscntrl	isupper	islower	isalpha
isdigit	ispunct	isxdigit isalnum isgraph isblank

unsigned char c = '\xdf'; //German letter B in ISO-8859-1
if (std::setlocale(LC_ALL, "de_DE.iso88591")) //change from default_C_locale to de_DE.
	cout<< static_cast<bool>(std::isalnum(c)) << '\n';	//return true
\end{lstlisting}	

	\par Below illustrates two methods to trim a string:
\begin{enumerate}
	\item \texttt{ltrim}: Uses \texttt{find\_first\_not\_of()} to determine the position to trim from and returns that position. The substr function is then used with the determined position and length parameters.
	
	\item \texttt{rtrim}: Uses the generic STL algorithm \texttt{find\_if} and returns an iterator. When assigning an iterator, use the auto type. It's important to learn how to write lambda functions for this purpose. The erase function is then used to modify the string in place.
\end{enumerate}
	 
	
\begin{lstlisting}[]
const std::string WHITESPACE = " \n\r\t\f\v";
string ltrim(const string& str){
	size_t pos = str.find_first_not_of(WHITESPACE);
	if (pos == string::npos){
		return "";
	}
	else{
		return str.substr(pos); // left side use substr
	}
}
string rtrim(string& str){
	auto pos = find_if(str.rbegin(),str.rend(), [](char c){ 
		return !isspace(c, locale::classic());}
	);
	str.erase(pos.base(), str.end()); //right side use erase.
	return str;
}		
\end{lstlisting}

	\par If you use iterator based API, just continue to use iterator based API if it can finish your task. 
\begin{lstlisting}[]
string s = "  abc  ";
auto ii = find_if_not(s.begin(), s.end(), [](auto e) { return ::isspace(e); });
s.erase(s.begin(), ii); //use iterator based version erase here.
cout << std::quoted(s) << endl;

auto iir = find_if_not(s.rbegin(), s.rend(), [](auto e) {return ::isspace(e); });
s.erase(iir.base(), s.end());
\end{lstlisting}

	\par Modify a \texttt{std::string}. 
\begin{lstlisting}[numbers=none]
string str = "123456";
str.erase(0,1) //delete the first letter
str.pop_back() //delete the last letter	
std::erase(str, '3');  //C++20 support std::erase(std::string, char) directly;

std::string base="this is a test string.";
std::string str2="n example";
str.replace(9,5,str2);  // "this is an example string." 
\end{lstlisting}

	\par How to token? In C++, we usually use \texttt{stringstream} and \texttt{getline} to make token much easier. In C++20, you can use \texttt{std::views::split}. 
\begin{lstlisting}[numbers=none]
stringstream s1(str1);  //str1="zhao,yao,c++";
string str_part;
while(getline(s1, str_part, ',')){
	cout<<str_part;
}		

auto ints = str1 | views::split(',') //c++20, use views::split
fmt::print("{}\n", std::views::join_with(ints,'#')); //output "zhao#yan#c++"
\end{lstlisting}
	

\subsection{Summary of containers}
		 
	\textbf{Adding:}
	 
	\begin{itemize}
		\item For adding elements, in sequenced containers, the main operations are using \texttt{push\_back/front()} and \texttt{pop\_back/front()} at the front or back, you can also use \texttt{emplace\_back/front()}.
		
		\item In associative containers, the main function is \texttt{insert()}. For \texttt{std::map} and \texttt{std::unordered\_map}, you can also use \texttt{operator[]}, \texttt{insert\_or\_assign} and \texttt{try\_emplace}.
		
		\item Understanding the usage of \texttt{emplace} and \texttt{emplace\_hint} for direct construction, avoiding copying. 
		
	\end{itemize}
	
	\textbf{Deleting:}
	\begin{itemize}
		
		\item For deleting elements, All first class containers support \texttt{clear()}. 
		
		\item In \texttt{vector} containers, the combination of erase and remove is commonly used. 
		
		\item For linked lists, you can use \texttt{remove()} member function directly. 
		
		\item For associative containers, \texttt{erase()} is used directly, and it is important to update the iterator using the return value of \texttt{erase()}.
		
	\end{itemize}
	
	\textbf{Searching:}
	\begin{itemize}
		
		
		\item For searching, the basic distinction is whether the container is sorted. For unordered sequenced container, the main methods used are \texttt{std::find()} and \texttt{std::count()}, you also need to know the difference between \texttt{std::find()}, \texttt{std::search()}/\texttt{std::find\_end()} and \texttt{std::find\_first\_of()}. 
		
		\item For sorted sequenced containers, you can use \texttt{std::binary\_search()}, \texttt{std::lower\_bound()}, \texttt{std::upper\_bound()} and \texttt{std::equal\_range()}.
		
		\item Associate container use its own member function, such as \texttt{find()}, \texttt{count()}, \texttt{contains()} and \texttt{lower\_bound()}, \texttt{upper\_bound()} and \texttt{equal\_range()}.
		
		
		\item \texttt{std::string} has some special member functions, such as \texttt{find\_first\_not\_of()}, \texttt{rfind()} and \texttt{starts\_with()}.
		
	\end{itemize}
	
	\textbf{Updating:}
	\begin{itemize}
		
		\item For associate container, you can use extract member function to modify key. If compiler doesn't support extract, erase it first, then insert it back again. 
		
	
		\item For \texttt{std::map} and \texttt{std::unordered\_map}, you can use \texttt{operator []} and \texttt{insert\_or\_assign} to update non-key value.
		
		\item For set associate container, you can update non-key value, find the element, then remove constness by using \texttt{const\_cast<Employee \&> (*iterator).setTitle("manager");}.
		
	\end{itemize}
	
	
	\par For \texttt{std::string}, the STL provides some special interfaces specifically designed for \texttt{std::string}, such as \texttt{replace()}, \texttt{substr()}, \texttt{find\_last\_of()}, \texttt{append()}, \texttt{length()}. 
	
	\par Pay attention to range insertions, erasures, constructions, and assignments. Additionally, understand the distinction between \textbf{equality} and \textbf{equivalence}: \texttt{std::map} operates on equivalence, while \texttt{std::unordered\_map} operates on equality.
	
\section{Iterator}
\subsection{Normal iterator}
	 	
	
	There are 5 classification iterators 1)input, 2)output, 3)forward, 4)bi-direction, 5)random access. With below figure, you can see which operations each iterator supports.
	\begin{center}
		\includegraphics[scale=0.46]{pics/iterator.png}
	\end{center}

	\par What kind of iterator can be used in specific container and algorithm?
	\begin{center}
		\includegraphics[scale=0.50]{pics/container_it.png}
	\end{center}


	
%	All member functions of the vector container are familiar with its iterators and use the \texttt{T*} directly inside. 
%	\begin{lstlisting}[frame=single, language=c++]
%		push_back(T x){
%			*end++ = x;
%		}  
%	\end{lstlisting}
%	
	
	\par Each container class defines a class scope typedef name called iterator. For example, the \texttt{vector<int>} has iterators of type \texttt{vector<int>::iterator}. Vector's iterators are random access iterators. For a vector, the iterator maybe is defined as follows:
		
\begin{lstlisting}[frame=single, language=c++]
template<type T>
vector{	
	typedef T* iterator;
};	
\end{lstlisting}

	\par When examining the algorithms used with iterators, you may notice that they are based on templates rather than inheritance. This means that there is no need to worry about whether a type can be cast or not. The algorithm simply requires that each iterator be capable of supporting the necessary operations, regardless of its specific type.
\begin{lstlisting}[frame=single, language=c++]
template <class InputIterator, class OutputIterator>
OutputIterator copy (InputIterator first, InputIterator last, OutputIterator result);	
\end{lstlisting}

\par Common four iterator errors are below:
\begin{description}

	\item [Valid values:] Is the iterator dereferenceable? For example, writing "\texttt{*(v.end())}" is always a programming error, because \texttt{v.end()} is nullptr.

	\item [Valid lifetimes:] Is the iterator still valid when it's being used? Or has it been invalidated by some operation since we obtained it?

	\item [Valid ranges:] Is a pair of iterators a valid range? Is first really before (or equal to) last? Do both really point into the same container?

	\item [Illegal builtin manipulation:] For example, \texttt{e.insert( --e.end(), TodaysDate() )} try to modify a temporary of builtin type \texttt{--e.end()}, (Fortunately, the compiler can often catch this kind of mistake for you). 
	
%	For iterators of class type, the library author will often choose to allow this sort of thing for syntactic convenience.

\end{description}


%	\item You can inherit your own iterator from \texttt{std::iterator}: yes, that's what it's for. If you mean anything else: no, because none of the STL iterators have virtual destructors. They're not meant for inheritance and a class inheriting from them might not clean up properly. A Good example can be seen link: http://www.cplusplus.com/reference/iterator/iterator/

	\par Two common iterator operations are \texttt{std::advance()} and \texttt{std::distance()}. Both \texttt{std::next()} and \texttt{std::prev()} are based on \texttt{std::advance()}. \texttt{std::next()} and \texttt{std::prev()} returns a new iterator, \texttt{std::advance()} just change the input iterator. 
\begin{lstlisting}[frame=single, language=c++, numbers=none]
std::list<int>::iterator first = mylist.begin();
std::list<int>::iterator last = mylist.end();

std::advance(first, 3) //Increments given iterator first by 3.
std::cout  << std::distance(first,last) //distance
auto iter = std::next(first, 2); //return the 2th successor iterator after first.
\end{lstlisting}

	\par That is an example of \texttt{istream} and \texttt{ostream} iterators. In this way, you can think of iostream as a container.
\begin{lstlisting}[frame=single, language=c++, numbers=none]
ifstream fin("input.txt");  //From IO to container with format
istream_iterator<T> first(cin/fin), last; //need two iterators
vector<T> vs(first, last);

ofstream fout("output.txt"); //From contain to IO with format
ostream_iterator<T> first(cout/fout, " "); //need only one iterator
copy(vs.begin(), vs.end(), first);
\end{lstlisting}

%\begin{center}
%	\includegraphics[width=0.8\linewidth]{pics/stream_iterator}
%\end{center}
	
	\par Another example is \texttt{istreambuf\_iterator}. It supports character-by-character input(raw data, without format). Detail can be found in effective STL item 29.
\begin{lstlisting}[frame=single, language=c++, basicstyle=\scriptsize]
std::ostream_iterator<int> out_it (std::cout, " ");
std::copy ( myvector.begin(), myvector.end(), out_it );

ifstream inputFile("aa.dat");
string fileData(istreambuf_iterator<char>{inputFile}, istreambuf_iterator<char>{});

ifstream inputFile("aa.txt");
list<int> data(istream_iterator<int>{inputFile}, istream_iterator<int>{});
\end{lstlisting}
\begin{description}
	\item[Line 5:] It will just read all the character. (including white character) I don't need format data.
	\item[Line 8:] It wil  read format data, and use whitespace as delimiter.
\end{description}

	\par I/O streams use streambufs as their source/target for input/output. Effectively, the streambuf-family handles all the work regarding I/O, while the I/O stream-family is only used for formatting and to-string/from-string transformations. Now, \texttt{istream\_iterator} takes a template argument that specifies how the unformatted string sequence from the streambuf should be formatted. For example, \texttt{istream\_iterator<int>} will interpret all incoming text as ints, delimited by whitespace. On the other hand, \texttt{istreambuf\_iterator} only deals with raw characters and iterates directly over the associated streambuf of the istream it is passed. Generally, if you're only interested in the raw characters, use an \texttt{istreambuf\_iterator}. If you're interested in the formatted input, use an \texttt{istream\_iterator}.


\subsection{Insert iterator and reverse iterator}
	
	 Three common iterator generators: 1) \texttt{inserter()}, 2) \texttt{back\_inserter()}, and 3)  \texttt{front\_inserter()}; They will produce three corresponding insert iterators: 1) \texttt{insert\_iterator}, 2) \texttt{back\_insert\_iterator}, 3) \texttt{front\_insert\_iterator}. When you use \texttt{insert\_iterator} in an assignment, \texttt{insert\_iterator} will call the \texttt{insert()} function. \texttt{back\_insert\_iterator} will call \texttt{push\_back()}.

%	\item  \texttt{std::inserter} is commonly used with sets.
%
%	\item You can use the random access iterators (or any output iterator) in algorithms like \texttt{std::copy}, as third argument, but that assumes the iterator is referencing to existing range — \texttt{*it} and \texttt{++it} are well-defined for the value you passed. You pass them to overwrite the existing elements of the range, whereas \texttt{std::back\_insert\_iterator} adds new elements to the container.


	\par Insert iterators are useful in certain algorithms, such as \texttt{std::copy} and \texttt{std::generate}, where you need to write to a container. With a regular iterator, you must ensure that it remains valid while writing to the container. One way to accomplish this is by using \texttt{resize} before writing to the container. Another way is to use a \texttt{back\_insert\_iterator}.
\begin{lstlisting}[frame=single, language=c++]
std::list<int> foo, bar;
for (int i=1; i<=5; i++){ 
	foo.push_back(i); 
	bar.push_back(i*10); 
}
std::copy (bar.begin(),bar.end(),back_inserter(foo));
std::copy (bar.begin(),bar.end(),front_inserter(foo));
\end{lstlisting}


%	\item For copy algorithm, pass \texttt{vect.end()} is not meaningful, because It's not a valid iterator to support \texttt{*it = new\_obj}.

	\par Sometimes you need a back-to-front traversal instead of front-to-back traversal. The reason for reverse iterators is that the standard algorithms do not know how to iterate over a collection backward.
\begin{lstlisting}[frame=single, language=c++]
std::find(foo.begin(), foo.end(), L'a');  //find first 'a'
std::find(foo.rbegin(), foo.rend(), L'a').base()-1; //find last 'a', why -1?
std::find(foo.end(), foo.begin(), L'a'); //WRONG!! (Buffer overrun)
\end{lstlisting}

	\par You can change \texttt{reverse\_iterator} to base iterator by using \texttt{base()} member function. The relationship between \texttt{reverse\_iterator} and base iterator is illustrated by below figure. 
\begin{figure}[ht]
	\centering
	\includegraphics[width=0.26\linewidth]{pics/ri.png}
	\caption{reverse\_iterator }
	\label{fig:ri}
\end{figure}
	

	\par Container's member functions like \texttt{insert()} and \texttt{erase()} only expect base iterators, not reversed one. Using \texttt{ri.base()} allows you to adjust for this difference and use the iterator correctly with such functions. You can refer to \textit{"Effective STL"} item 28.


\begin{lstlisting}[frame=single, language=c++]
reverse_iterator ri = find(foo.rbegin(), foo.rend(), L'a');
foo.insert(ri.base(), value);  //use br.base() when you want to insert a value.
foo.erase((++ri).base()); //++ri before you want to erase too.
\end{lstlisting}
\begin{description}
	\item[Line 3:] you can't use \texttt{ri.base()} directly here. Why? when you want to erase, you just erase current iterator. When you want to insert, insert happen before the iterator. For insertion, you want to insert a value before 'a', but for erase, you want to erase 'a', please notice this difference. 
\end{description}

	\par Use \texttt{std::make\_reverse\_iterator()} to cast iterator to reverse iterator.
\begin{lstlisting}
std::vector<int> v{1, 3, 10, 8, 22};

copy(std::make_reverse_iterator(v.end()), std::make_reverse_iterator(v.begin()),
std::ostream_iterator<int>(std::cout, ", ")); //output is 22, 8, 10, 3, 1	
\end{lstlisting}

\par There are some points that you need to remember about iterator:
\begin{itemize}
	\item The five classifications and associated supported operations.
	
	\item The common container iterator classifications. Only \texttt{std::vector}, \texttt{std::deque} and \texttt{std::string} support random access iterator. 
	
	\item The types of iterators that common algorithms can accept. For example, \texttt{std::sort} only accepts random access iterator, \texttt{insert} doesn't accept \texttt{reverse\_iterator}.
\end{itemize}


\subsection{const\_iterator}
	 \texttt{vector<int>::const\_iterator} and \texttt{const vector<int>::iterator} is like low-level and top-level const. 
\begin{lstlisting}[numbers=none]
vector<int>::const_iterator cvi;
*cvi = 12; //ERROR, can't change
cvi++;     //OK, it's like low-level const

const vector<int>::iterator vi;
*vi = 12; //OK, 
vi++;     //ERROR, it's like top-level const
\end{lstlisting}	
	
	
	\par A const \texttt{vector} obj only can call const member function, and const member function just return const reference or pointer.
	
\begin{lstlisting}
iterator begin() noexcept;
const_iterator begin() const noexcept;

const vector<int> cvi;
vector<int>::iterator vi = cvi.begin(); //Compile error
auto vi = cvi.begin(); //use auto to resolve this error		
\end{lstlisting}	
	
	\begin{description}
		\item[Line 5:] \texttt{cvi} will call the second overload function anyway. but second just return \texttt{const\_iterator}. and \texttt{const\_iterator} can NOT be converted to non-const iterator implicitly and automatically.
	\end{description}
	
	\par Continue with previous item. If you define a const obj, all the member variable inside const obj are const. For example, because \texttt{getArea} is const funciton, when it is called by a const obj, \texttt{points} inside this function becomes a const member variable, so error will happen below: 
	
\begin{lstlisting}[frame=single, language=c++]
class A{
	getArea() const{ //getArea has const specifier,  so points is const implicit
		vector<int>::iterator vi = points.begin();  //Error, compile fail
		//How to fix, use 1) vector<int>::const_iterator vi or 2) auto vi
	}
	
	calArea(){
		vector<int>::iterator vi = points.begin();
	}
	vector<int> points
};

const A ca;
ca.calArea(); // not compile, const obj can't call non-const member	
ca.getArea(); // Not compile, points is const implicit.

A a;
a.calArea(); // non-const obj can access non-const member fun
a.getArea(); // non-const obj can also access const member fun.		
\end{lstlisting}
	

	
	\par In C++11/14, we add \texttt{cbegin()} to STL container, Some interfaces of container has changed from non-const iterator to const iterator, so we should use const iterator more. 
\begin{lstlisting}
iterator insert(iterator position, const value_type& val);//c++98 interface
iterator insert(const_iterator position, const value_type& val);//c++11 interface, use const_iterator

vector<int> values:
auto it = std::find(values.cbegin(),values.cend(), 1983);
values.insert(it, 1998);		
\end{lstlisting}
	\begin{description}
		
		\item[Line 2:] In C++11, \texttt{insert} interface has changed. Because insert will not change the input iterator (it only insert a new element before input iterator, but not change input iterator directly). So it should be \texttt{const\_iterator}.
		
		\item[Line 5:] \texttt{std::find} is generic algorithm, it just receive a template parameter, you should provide \texttt{const\_iterator} to it, but how can you get \texttt{const\_iterator} from a non const container. After C++11, you can use \texttt{cbegin()} and \texttt{cend()} to get \texttt{const\_iterator} easily.
	\end{description}
	
%	\item We can't remove constness from \texttt{const\_iterator} by using \texttt{const\_cast}. If they are vector or string, maybe it's OK, because they just use pointer behind the scene. Usually, \texttt{const\_iterator} and \texttt{iterator} are two different classes. A good way is to . Detail can be found in effective STL. 
%\begin{lstlisting}[]
%std::vector<int>::iterator it = v.begin();
%std::vector<int>::const_iterator cit = it; //ok to get cit from it directly.
%
%advance(i, distance<const_iterator>(i, ci)); //change ci to i.		 
%\end{lstlisting}


	\par In C++, containers are required to provide an iterator type that is convertible to \texttt{const\_iterator}. This allows you to implicitly convert an iterator to a\texttt{ const\_iterator} when necessary. But you can't remove \texttt{const} from \texttt{const\_iterator} by using \texttt{const\_cast} because \texttt{const\_iterator} and \texttt{iterator} are usually two different classes. There are two ways to remove const: 1) use container's erase member function; 2) use \texttt{std::advance} and \texttt{std::distance}
\begin{lstlisting}	
Container::iterator it = 
Container::const_iterator cit = it; //work here, it can be converted directly

vector v = {1, 2, 3};
auto ci = v.cbegin();
std::vector<int>::iterator i = v.erase(ci, ci);	//1) range erase function. 
advance(i, distance<const_iterator>(i, ci));    //2) distance and advance.
\end{lstlisting}	

	\par Another interesting thing is erase member function receive a \texttt{const\_iterator}, instead of normal iterator. The passed iterator is just used as the \textbf{position} where the element would be deleted, not for modifying the element through it. That means \texttt{const\_iterator} would be fine. Before C++11, the support for \texttt{const\_iterator} was not very good, but the situation has changed from C++11. You should use \texttt{const\_iterator} instead of iterator when possible now.
	
\begin{lstlisting}
iterator erase (const_iterator first, const_iterator last);
\end{lstlisting}


	
	\par Different iterators can also be transformed according arrow direction in blow figure. A good article is "effective modern C++" item 13. It introduce the basic idea about \texttt{const\_iterator.}
	\begin{center}
		\includegraphics[width=0.45\linewidth]{pics/Iterators.png}
	\end{center}
	
	\par Summary of iterators is illustrated below:	

	\begin{center}
	\includegraphics[width=0.8\linewidth]{pics/cs.drawio.png}
	\end{center}



\section{Algorithms}

\subsection{STL algorithms list}
\subsubsection{Basic notation}

Iterator:  \\
\begin{tabular}{| p{0.2\textwidth} |p{0.75\textwidth}|}
\tophline b, f &	a bidirectional, forward iterator \\
\tophline i, o, a 	&an input, output, random iterator  \\
\tophline(?, ?)	&a pair of iterators as a return value, as in (f,f) \bottomhline
\end{tabular} \\

Parameter:  \\
\begin{tabular}{| p{0.2\textwidth} |p{0.75\textwidth}|}
	\tophline n, v, \&  & 	n: a quantity (or size); v:a value; \&: reference to a value \bottomhline
\end{tabular}

functor:  \\
\begin{tabular}{| p{0.2\textwidth} |p{0.75\textwidth}|}
\tophline upred, bpred	& a unary or binary predicate (boolean function or function object)
(generally used to test a single value from a container) \\
\tophline ufunc, bfunc	&  a unary or binary  (value-returning) function or functor \\
\tophline pfunc	& a "parameterless" (value-returning) function (or function object)
(often used to "generate" a value of some kind) \\
\tophline uproc, bproc	& a unary or binary  procedure (void function or function object) \\
\tophline pproc	&  a "parameterless" procedure (void function or functor) \bottomhline
\end{tabular}



\subsubsection{Nonmutating algorithms}
There are five sub-groups inside this Nonmutating group, you can remember them as \texttt{ACCMFS} (a CC makes friends) They are \textbf{all(any,none)\_of, count, compare, max, find and search}.


\textbf{all\_of, none\_of, any\_of } \\
\begin{tabular}{| p{0.4\textwidth} |p{0.55\textwidth}|}
	\tophline 
	\specialcell[t]{ bool all\_of(i,i,upred ) \\ bool none\_of(i,i,upred ) \\ bool any\_of(i,i,upred ) } & need upred, not value.
	\bottomhline
\end{tabular}


\textbf{count} \\
\begin{tabular}{| p{0.25\textwidth} |p{0.4\textwidth}|p{0.3\textwidth}|}
\tophline 
\specialcell[t]{ n count(i,i,\& ) \\ n count\_if(i,i,upred)} & Count the items in a range that match a value or satisfy a predicate and return that count.& count will not stop when it find match.
 \bottomhline
\end{tabular}


\textbf{Comparing} \\
\begin{tabular}{| p{0.55\textwidth} |p{0.4\textwidth}|}
	\tophline \specialcell[t]{bool equal(i1,i1last, i2) \\
		bool equal(i1,i1last,i2,bpred) } &  Check if the values in two ranges match. \\
	
	\tophline
	\specialcell[t]{bool lexicographical\_compare (i1,i1last,i2,i2last) \\
		bool lexicographical\_compare (i1,i1last,i2,i2last,bpred) }  & Compare two ranges lexicographically, and return true if the first range is less than the second; otherwise return false. \\
	
	\tophline
	\specialcell[t]{ (i1,i2) mismatch(i1,i1last,i2) \\ (i1,i2) mismatch(i1,i1last,i2, bpred) }
	& Search two ranges for the first two items in corresponding positions that don't match, and return a pair of iterators pointing to those two items.
	\bottomhline
\end{tabular}

\begin{lstlisting}[numbers=none]
bool is_palindrome(const std::string& s){ //an example of std::equal
	return std::equal(s.begin(), s.begin() + s.size()/2, s.rbegin()); //rbegin here.
} //return true for "abcdcba"
std::string mirror_ends(const std::string& in){
	return std::string(in.begin(), 
	       std::mismatch(in.begin(), in.end(), in.rbegin()).first);
}
\end{lstlisting}

\textbf{find-linear time searching} \\
\begin{tabular}{| p{0.28\textwidth} |p{0.67\textwidth}|}
	\tophline i find(i,i,\&)  & return an iterator pointing to the value or end  \\
	
	\tophline i find\_if(i,i,upred)  & satisfies a predicate and return an iterator pointing to the first such value, or to the end \\
	\tophline \specialcell[t]{f adjacent\_find(f,f) \\
		f adjacent\_find(f,f, bpred)
	}&  the first pair of equal adjacent values in a range and return an iterator pointing to the first value of the pair.  
	\bottomhline
\end{tabular}

\textbf{find-search for a single element from a range} \\
\begin{tabular}{| p{0.32\textwidth} |p{0.63\textwidth}|}
	
	\tophline \specialcell[t]{ f1 find\_first\_of(f1,f1,f2,f2) \\
		f1 find\_first\_of(f1,f1,f2,f2,upred) } & std::find\_first\_of searches for a single element from a range within another range.
	\bottomhline
\end{tabular}


\textbf{Min/Max} \\
\begin{tabular}{| p{0.28\textwidth} |p{0.67\textwidth}|}
	\tophline \specialcell[t]{\& min(\&,\&)  \\
		\& min(\&,\&,bpred)   }&  Find the minimum of two values and return a reference to that value.
	\\
	
	\tophline  \specialcell[t]{
		\& max(\&,\&) \\
		\& max(\&,\&,bpred)     } & Find the maximum of two values and return a reference to that value.    \\
	
	\tophline \specialcell[t]{
		f min\_element(f,f)  \\
		f min\_element(f,f,bpred)  } & Find the minimum value in a range and return an iterator pointing to that value.   \\
	
	\tophline  \specialcell[t]{
		f max\_element(f,f)  \\
		f max\_element(f,f,bpred)   } & Find the maximum value in a range and return an iterator pointing to that value.   \bottomhline
\end{tabular}





%
%\textbf{search-sorted range Searching}  \\
%\begin{tabular}{| p{0.35\textwidth} |p{0.6\textwidth}|}
%
%\tophline bool binary\_search(f,f,\&)&  sorted range of values and return bool.
%\bottomhline
%\end{tabular}


\textbf{search-search for a whole range of elements within another range }\\
\begin{tabular}{| p{0.3\textwidth} |p{0.65\textwidth}|}
\tophline \specialcell[t]{f1 search(f1,f1,f2,f2) \\
f1 search(f1,f1,f2,f2,bpred) } &
first occurrence of a second range of values within a first range . return an iterator pointing to the first value of that first match. or end of the first range  \\

\tophline \specialcell[t]{ f1 find\_end(f1,f1,f2,f2) \\
f1 find\_end(f1,f1,f2,f2,bpred) } &
the last occurrence of a second range of values in a first range of values and return an iterator pointing to the first value of that last match within the first range, or the end of the first range(not find) \\

\tophline  \specialcell[t]{f search\_n(f,f,n,\&) \\
f search\_n(f,f,n,\&,bpred) }  &
For a contiguous sequence of n values each equal to \&, return iterator to the first of those values, or  the end of the range \bottomhline
\end{tabular}

\begin{center}
	\includegraphics[width=1.0\linewidth]{pics/stl1.png}
\end{center}


\subsubsection{Mutating algorithms}

	In this group, remember \textbf{RRRRSSSSFFPPCMT} (RRRRSSSSFFPP copy many time). They are replace, remove (unique), reverse, rotate, shift, swap, sample, shuffle,  fill (generate), for\_each, partition, permuting, copy, math (accumulate, inner\_product, partial\_sum, adjacent\_difference), transform. 

\textbf{for\_each} \\
\begin{tabular}{| p{0.3\textwidth} |p{0.43\textwidth}|p{0.18\textwidth}|}
	\tophline ufunc for\_each(i,i,ufunc) &Apply a function to every item in a range and return the function. &  ufunc may not return value. 
	\bottomhline
\end{tabular}
\newline 

\begin{lstlisting}[numbers=none]
void fun(int n){
	cout<<" "<<n;
} //all function definition end no semicolon
struct Sum{
	int sumEven;
	Sum(): sumEven{0} { }  //no semicolon here
	void operator()(int n) {if(n%2 ==0) ; sumEven += n;}
}; // type definition need semicolon
	
vector<int> nums{3, 4, 2, 8, 15, 267};
for_each(nums.begin(), nums.end(), fun);
Sum s = for_each(nums.begin(), nums.end(), Sum());
\end{lstlisting}
				
	There are three kinds of for-loop container syntax; \texttt{std::for\_each} is a tool for raising the level of abstraction of a range-based for loop. \texttt{std::for\_each} requires a functor as input, using lambda within the call to \texttt{std::for\_each} is not good style. An informative article on the topic can be found by searching " Why You Should Use \texttt{std::for\_each} over Range-based For Loops".
\begin{lstlisting}
for(auto it = con.begin(), itend = con.end();it !=itend ; ++it){ //method 1
	foo(*it);
}

for(auto & e : con){ //method 2, range-based for loop.
	foo(e);
}

for_each(begin(c),end(c), fun1); //method 3, good style.
ranges::for_each(c, fun1);  //best style, supported by in C++20 standard.
\end{lstlisting}
	
			
%			\item You also can use bind on a name lambda. If lambda is easy, just rewrite it. 
%\begin{lstlisting}[numbers=none]
%auto f = [](int x, int y){if(y>x) return true; return false;} ;
%auto f1 = bind(f, 3, placeholders::_1) // GreatThanX(3);
%if(f1(8)) cout<<"8>3"<<endl;
%\end{lstlisting}			
		

	\textbf{Transforming}  \\
	\begin{tabular}{| p{0.35\textwidth} |p{0.3\textwidth}|p{0.25\textwidth}|}
		\tophline \specialcell[t]{ o transform(i1,i1end,o,ufunc) \\o transform(i1,i1end,i2, o, bfunc) }
		&Transform one range of values into another.
		& Ret of ufunc or bfunc writed to o. 
		\bottomhline
	\end{tabular}
	

	If the output is a new container, you need to use the inserter() function to obtain an inserter iterator, enabling in-place modifications. Common operations such as \texttt{plus, minus, multiplies, divides, modulus, negate, and equal\_to} are frequently used in transform algorithms.
\begin{lstlisting}[frame=single, language=c++, mathescape=true]
std::transform(a.begin(), a.end(), std::inserter(set, set.begin()), modify);
std::transform(a.begin(), a.end(), b.begin(), a.begin(), plus{}); //CATD with c++17	
\end{lstlisting}		


\textbf{swapping} \\
\begin{tabular}{| p{0.35\textwidth} |p{0.6\textwidth}|}
\tophline iter\_swap(f,f) &
Swap the values pointed to by the two iterators.  \\
\tophline swap(\&,\&) &
Swap the two values.  \\
\tophline f2 swap\_ranges(f1,f1end,f2) &
Swap two ranges of values and return an iterator pointing to the end of the second range.  \bottomhline
\end{tabular}

\begin{lstlisting}
void swap_adjacent_pairs (std::vector<int>& v) {
	if (v.size() < 2) return;
	for (auto i=begin(v), j=i+1, e=end(v); j < e; i+=2, j+=2) {
		std::swap(*i,*j);
	}
}
\end{lstlisting}

\textbf{copy} \\
\begin{tabular}{| p{0.35\textwidth} |p{0.6\textwidth}|}
\tophline o copy(i,i,o) & Copy a range of items to a destination and return an iterator pointing to the end of the copied range.   \\
\tophline b2 copy\_backward(b1,b1last, b2)  & Copy a range of items backwards to a destination and return an iterator pointing to the end of the copied range.    \bottomhline
\end{tabular} \\

Different with \texttt{std::copy}, for \texttt{\texttt{std::copy\_backward}}, copies the elements from the range [first, last) to another range ending at \texttt{d\_last}. Any range is left close, right open range, so \texttt{d\_last} will not be modified, that is different with \texttt{std::copy}. 

\begin{lstlisting}[frame=single, language=c++]
template< class BidirIt1, class BidirIt2 >
BidirIt2 copy_backward( BidirIt1 first, BidirIt1 last, BidirIt2 d_last ){
	while (first != last)
		*(--d_last) = *(--last); //d_last need --first. 
	return d_last;
}	
\end{lstlisting}

\begin{lstlisting}[frame=single, language=c++]
vector<int> myvector{1, 2, 3, 4, 5};
myvector.resize(myvector.size()+3) //1, 2, 3, 4, 5, 0, 0, 0
copy(myvector.begin(), myvector.begin()+5, myvector.begin()+3)  //overlap here. 
// the result is 1, 2, 3, 1, 2, the result is not correct
copy_backward(myvector.begin(), myvector.begin()+5, myvector.end())
// the result is 1, 2, 3, 1, 2, 3, 4, 5, correct

std::vector<int> source(6);
std::iota(source.begin(), source.end(), 1);   //1 2 3 4 5 6
std::copy_backward(source.begin()+1, source.begin()+4, source.begin()+5);
//1 2 2 3 4 6
\end{lstlisting}
\begin{description}
	\item[Line 1:] Error, when source and targe is overlap, you have to use backward copy
	\item[Line 4:] You can input \texttt{vector.end()} as target for \texttt{std::copy\_backward}, but for copy, you can't input \texttt{vector.end()}. 
\end{description} 

\textbf{Filling} \\
\begin{tabular}{| p{0.3\textwidth} |p{0.6\textwidth}|}
\tophline fill(f,f,\& ) & Set every item in a range to a particular value.  \\
\tophline fill\_n(o,n,\& )  & Set n items to a particular value.   \bottomhline
\end{tabular} \\


\textbf{Generating} \\
\begin{tabular}{| p{0.3\textwidth} |p{0.6\textwidth}|}
\tophline generate(f,f,pfunc)  & Fill a range with generated values.   \\
\tophline generate\_n(o,n,pfunc)  & Generate a specified number of values.   \bottomhline
\end{tabular} \\

\begin{lstlisting}[numbers=none]
std::vector<int> v(5); //there are 5 default value inside v, 0 0 0 0 0
std::generate(v.begin(), v.end(), std::rand); // Using the C function rand()
int n = {0};
std::generate(v.begin(), v.end(), [&n]{ return n++; });
\end{lstlisting}

\textbf{Math} \\
\begin{tabular}{| p{0.45\textwidth} |p{0.5\textwidth}|}
\tophline \specialcell[t]{v accumulate(i,i,v) \\
v accumulate(i,i,v,bfunc)  }&  Add an initial value and the values in a range, return sum.
\\

\tophline \specialcell[t]{
o adjacent\_difference(i,i,o) \\
o adjacent\_difference(i,i, o, bfunc)   } & Calculate the difference between adjacent pairs of values, write the differences to an o, and return the end of that output range.    \\

\tophline
\specialcell[t]{ v inner\_product(i1,i1last,i2,vInitial) \\
v inner\_product(i1,i1last,i2,v,bfunc1,bfunc2)}  & Calculate the inner product of two ranges and return that value plus vInitial.  \\

\tophline  \specialcell[t]{
o partial\_sum(i,i,o)  \\
o partial\_sum(i,i,o, bfunc)   } & Fill a range with running totals and return an iterator pointing to.   \bottomhline
\end{tabular} \\


\begin{lstlisting}[numbers=none]
std::vector<int>v(10, 2); // partial\_sum example, v is {2, 2, 2, 2, ..}
partial_sum(v.begin(), v.end(), ostream_iterator<int>(std::cout, " "));//2 4 6 8..  
partial_sum(v.begin(), v.end(), v.begin(), std::multiplies{}); //2 4 8 16..
\end{lstlisting}


\begin{lstlisting}[numbers=none]
std::vector<int> v{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; //accumulate example
int sum = std::accumulate(v.begin(), v.end(), 0); 
int product = std::accumulate(v.begin(), v.end(), 1, multiplies{});
string s=accumulate(v.begin(), v.end(),std::string{}, [](string a, int b) {
    	return a.empty() ? to_string(b): std::move(a) + '-' + to_string(b); 
    });
\end{lstlisting}

An example about \texttt{adjacency\_difference}. Notice usage of \texttt{std::prev} and \texttt{std::next} here. 
\begin{lstlisting}[numbers=none]
vector v(10 , 1);   //1 1 1 1 1 1 1 1 1 1
std::adjacent_difference(std::begin(a), std::prev(std::end(a)), 
                 std::next(std::begin(a)), std::plus<>{}); //produces fibonacci.  
\end{lstlisting}

Difference between these math algorithms.
\begin{itemize}
\item For \texttt{std::accumulate}, input a init, -->calculate(init, element)-->return it to init.
\item For \texttt{std::adjacent\_difference}:   first -> dfirst,  f(first+1, first)-->dfirst+1; Pay attention, for first element, assign it directly.

\item For \texttt{std::partial\_sum} function, you can think it as \texttt{std::accumulate}, accumulate just return one value, but \texttt{std::partial\_sum} return many value, and write them back to target iterators one by one. 

\item \texttt{std::accumulate} and \texttt{std::inner\_product} return one value, both \texttt{adjacent\_difference} and \texttt{partial\_sum} return a range.
\end{itemize}


\textbf{Partitioning} \\
\begin{tabular}{| p{0.3\textwidth} |p{0.65\textwidth}|}
\tophline \specialcell[t]{nth\_element(r,r,r) \\
nth\_element(r,r,r,bpred)   }&  Partition a range of values so that the value pointed to by the middle r in the parameter list is in its correct sorted position, and no element to its left is greater than any element to its right. \\

\tophline  \specialcell[t]{
b partition(b,b,upred)    } & Partition a range of values using a predicate, and return an iterator pointing to the first value for which upred returns false.   \\

\tophline  \specialcell[t]{
b stable\_partition(b,b,upred)     } & Partition a range using a predicate without altering the relative order of the values, and return an iterator pointing to the first value for which upred returns false.  \bottomhline
\end{tabular}

An example of \texttt{std::partition}. Partition return: Iterator to the first element of the second group.
\begin{lstlisting}[numbers=none]
std::vector<int> v = {0,1,2,3,4,5,6,7,8,9};
auto it = std::partition(v.begin(), v.end(), [](int i){return i % 2 == 0;});                     
copy(std::begin(v), it, std::ostream_iterator<int>(std::cout, " ")); //0 8 2 6 4      
copy(it, std::end(v), std::ostream_iterator<int>(std::cout, " ")); //5 3 7 1 9
\end{lstlisting}

An example of \texttt{std::nth\_element}, how to get median value of vector? 
\begin{lstlisting}
std::vector<int> v{5, 10, 6, 4, 3, 2, 6, 7, 9, 3};
auto m = v.begin() + v.size() / 2;
std::nth_element(v.begin(), m, v.end());
std::cout << "\nThe median is " << v[v.size() / 2] << '\n';

//note here, we use greater{} below, 
std::nth_element(v.begin(), v.begin() + 1, v.end(), std::greater{});
std::cout << "The second largest element is " << v[1] << '\n';
std::cout << "The largest element is " << v[0] << '\n';
\end{lstlisting}


\textbf{Permutation} \\
\begin{tabular}{| p{0.37\textwidth} |p{0.58\textwidth}|}
\tophline \specialcell[t]{bool next\_permutation(b,b) \\
bool next\_permutation(b,b,bpred)    }&  Change a range of values to the next lexicographic permutation of those values, and return true, or false if no next permutation exists.
 \\
\tophline  \specialcell[t]{
bool prev\_permutation (b,b)  \\
bool prev\_permutation(b,b, bpred)     } & Change a range of values to the previous lexicographic permutation of those values, and return true, or return false if no previous permutation exists.  \bottomhline
\end{tabular} \\


\begin{lstlisting}[numbers=none]
int a[] = {1,2,3}; // print out all the possible permutation.
sort(begin(a), a+3); //need to sort before permutation.
do {
    cout << a[0] << ' ' << a[1] << ' ' << a[2] << '\n';
} while ( std::next_permutation(a,a+3) );  //1 2 3, 1 3 2, 2 1 3, 2 3 1, 3 1 2...
\end{lstlisting}



\begin{center}
	\includegraphics[width=1.0\linewidth]{pics/stl2.png}
\end{center}


\textbf{Rotate}\\
\begin{tabular}{| p{0.35\textwidth} |p{0.6\textwidth}|}
\tophline rotate(f,f,f)  & Rotate a range of values by n positions.  \\
\tophline rotate\_copy(f,f,f,o) &   Copy and rotating it by n position.  
\bottomhline
\end{tabular}


Rotates the order of the elements in the range [first,last), in such a way that the element pointed by middle becomes the new first element.


\begin{lstlisting}[numbers=none]
for (int i=1; i<10; ++i) myvector.push_back(i); // 1 2 3 4 5 6 7 8 9
rotate(myvector.begin(), myvector.begin()+3,myvector.end()); // 4 5 6 7 8 9 1 2 3
\end{lstlisting}


\textbf{Reverse}\\
\begin{tabular}{| p{0.3\textwidth} |p{0.6\textwidth}|}
\tophline reverse(b,b) &  Reverse the order of all values in a range of values. \\
\tophline reverse\_copy(b,b,o) &  Reverse and copy  \\ \tophline
\end{tabular}



\textbf{Shuffle} \\
\begin{tabular}{| p{0.3\textwidth} |p{0.65\textwidth}|}
\tophline \specialcell[t]{shuffle(r,r)  \\
shuffle(r,r,ranGen)    }&  Randomize a range of values, and use the random generator function ranGen, if supplied, rather than an internal random generator. \bottomhline
\end{tabular}


\textbf{Remove} \\
\begin{tabular}{| p{0.3\textwidth} |p{0.65\textwidth}|}
\tophline \specialcell[t]{remove(f,f,\&)  \\
remove\_if(f,f,upred)    } &  Remove from a range of values all values that match a give value or satisfy a predicate \\

\tophline \specialcell[t]{ remove\_copy(i,i,o,\&) \\
remove\_copy\_if(i,i,o,upred)}  & Copy a range of values, removing all values that match a given value. \bottomhline
\end{tabular}


Remove algorithms can't be used with associative containers such as \texttt{std::set} and \texttt{std::map} because ForwardIt does not dereference to a MoveAssignable type (the keys in these containers are not modifiable). \texttt{std::remove} only can be used in remove-erase idiom in \texttt{std::vector} and \texttt{std::string}.


\textbf{Unique is another kind of remove, should used on sorted container} \\
\begin{tabular}{| p{0.35\textwidth} |p{0.6\textwidth}|}
\tophline \specialcell[t]{f unique(f,f) \\
f unique(f,f,bpred) }&  Collapse each group of consecutive duplicate values to a single value, and return an iterator pointing to the end of the modified range.
\\

\tophline \specialcell[t]{
o unique\_copy(i,i,o)  \\
o unique\_copy(i,i,o,bpred)  } & Copy a range of values, performing the same action as unique above, and return an iterator pointing to the end of the new range.   \bottomhline

\end{tabular}

	unique need to be sort first. Just like remove, unique need erase unique idiom. You can think unique has three steps. sort, unique, erase.

\begin{lstlisting}[numbers=none]
int myints[] = {10,20,20,20,30,30,20,20,10};
std::vector<int> myvector (myints,myints+9);
auto it = std::unique (myvector.begin(), myvector.end()); // 10 20 30 20 10 ?  ?  ?  ?
	
std::sort(v.begin(), v.end()); // {1 1 2 3 4 4 5}
auto last = std::unique(v.begin(), v.end());
v.erase(last, v.end());  // Above shows three steps, 
\end{lstlisting}


\textbf{Replace} \\
\begin{tabular}{| p{0.35\textwidth} |p{0.6\textwidth}|}
\tophline \specialcell[t]{  replace(f,f,\&,\&) \\
 replace\_if(f,f,upred,\&) } &
Replace, within a range of values, one specified value(satisfies a predicate) with another value.  \\

\tophline \specialcell[t]{ replace\_copy(i,i,o,\&,\&)  \\
 replace\_copy\_if(i,i,o,upred,\&)} &
Copy  replacing one specified value with another value.  \\
\tophline
\end{tabular}


	\begin{center}
	\includegraphics[width=0.9\linewidth]{pics/std3.png}
	\end{center}
	


\subsubsection{Sorting}
In this group, you need to remember \textbf{HMSSS}. They are \textbf{heap, merge, sort, search and set}. All algorithms only apply to sorted range. \\

\textbf{Merging} \\
\begin{tabular}{| p{0.35\textwidth} |p{0.6\textwidth}|}
	\tophline \specialcell[t]{inplace\_merge(b,b,b) \\
		inplace\_merge(b,b,b,bpred)   }&  Merge two sorted ranges, in place, into a single sorted range.
	\\
	\tophline  \specialcell[t]{
		o merge(i1,i1,i2,i2,o)  \\
		o merge(i1,i1,i2,i2,o,bpred)    } & Merge two sorted ranges into a single sorted range.   \\
	\tophline
\end{tabular}

\textbf{Heap} \\
Working with a \texttt{std::priority\_queue} is similar to managing a heap in some \textbf{random access container}, with the added benefit of not accidentally invalidating the heap.  \\
\begin{tabular}{| p{0.28\textwidth} |p{0.4\textwidth}|p{0.2\textwidth}|}
	\tophline \specialcell[t]{make\_heap(r,r)  \\
		make\_heap(r,r,bpred) }&  Make a range of values into a heap.
	& \multirow{4}{*}{ \parbox{0.2\textwidth}{It nees random iterator. priority\_queue use them inside. You don't use them directly } } \\
	
	\ifdefined\pdfbook  \cline{1-2} \fi  \specialcell[t]{
		o pop\_heap(r,r) \\
		o pop\_heap(r,r,bpred)   } & Delete the first value from a heap.  &  \\
	
	\ifdefined\pdfbook  \cline{1-2} \fi  \specialcell[t]{
		push\_heap(r,r) \\
		push\_heap(r,r,bpred)  } & Insert the last value of a range into a heap. &  \\
	
	\ifdefined\pdfbook  \cline{1-2} \fi \specialcell[t]{
		sort\_heap(r,r) \\
		sort\_heap(r,r,bpred)   } & Sort a heap.  &  \\
	\tophline
\end{tabular}

\begin{lstlisting}[frame=single, language=c++, mathescape=true]
vector<int> vi = {2, 4, 1, 3, 5,6,7};
make_heap(begin(vi),end(vi)); // inspace modify
//after pop_heap, need to use v.pop_back() to make begin(vi), end(vi) is still heap. 
v.pop_heap(begin(vi),end(vi));
v.pop_back();  //pop_back and pop_heap must appear together.
//if you want to use push_heap, you have to call push_back first. 
v.push_back(10);  //push_back and push_heap must appear together
v.push_heap(v.begin(vi) ,end(vi));
sort_heap(v.begin(vi) ,end(vi)); //still inspace modify, 1, 2, 3, 4, 5, 6, 7	
\end{lstlisting}





\textbf{binary search} \\
\begin{tabular}{| p{0.3\textwidth} |p{0.45\textwidth}|p{0.2\textwidth}|}
\tophline \specialcell[t]{(f,f) equal\_range(f,f,\&) \\
(f,f) equal\_range(f,f,\&,bpred) }& Find the lower bound and upper bound of a value, return a pair of iterators  .
& \multirow{3}{*}{ \parbox{0.2\textwidth}{1)container should be sorted firstly,  2) order by default < or bpred. 3) Sorted by bpred, find by bpred. } } \\

\ifdefined\pdfbook \cline{1-2} \fi  \specialcell[t]{f lower\_bound(f,f,\&) \\
f lower\_bound(f,f,\&,bpred)} & Find the lower bound of a value within a range and return an iterator pointing to it.
 &  \\

\ifdefined\pdfbook  \cline{1-2} \fi \specialcell[t]{f upper\_bound(f,f,\&) \\ f upper\_bound(f,f,\&,bpred) }
& Find the upper bound of a value within a range and return an iterator pointing to it.
&  \bottomhline
\end{tabular}


\textbf{sort} \\
\begin{tabular}{| p{0.33\textwidth} |p{0.6\textwidth}|}
\tophline \specialcell[t]{partial\_sort(r,r,r) \\
partial\_sort(r,r,r,bpred) } &
Sort all values till first part of range is in sorted order. \\

\tophline \specialcell[t]{r partial\_sort\_copy(i,i,r,r) \\
r partial\_sort\_copy(i,i,r,r,bpred) } &
Partially sort a range of values (as above) and copy \textbf{as many values as will fit into an output range.}\\

\tophline \specialcell[t]{sort(r,r) \\
sort(r,r,bpred) } &
Sort a range of values.\\

\tophline \specialcell[t]{ stable\_sort(r,r) \\
stable\_sort(r,r,bpred) } &
Sort and maintaining the same relative order of duplicate values.\bottomhline
\end{tabular}


Case insensitive sort.

\begin{lstlisting}[numbers=none]
sort(begin(vs),end(vs), [](const string& str1, const string& str2){
     return lexicographical_compare(begin(str1), end(str1), begin(str2), end(str2),[](auto ch1, auto ch2){
            return tolower(ch1)<tolower(ch2);
        });
    } );
\end{lstlisting}

	
It makes no sense to sort elements in standard associative containers because such containers use their comparison functions to remain sorted all the time. For other sequence containers, the sorting options are as follows: (1-3) require random access iterators; (4) only requires bidirectional iterators (e.g., \texttt{std::list}).
\begin{itemize}
	\item Full sort on \texttt{std::vector}, \texttt{std::string}, \texttt{std::deque}, or \texttt{std::array}.  use \texttt{sort} or \texttt{stable\_sort}
	
	\item Put only the top n elements in order, \texttt{partial\_sort}. 
	
	\item Identify the elements at position n , you need \texttt{nth\_element}.
	 All of the elements before this new nth element are less than or equal to the elements after the new nth element. A example is: who are my top 20 salespeople? \texttt{std::nth\_element( s.begin(), s.begin()+19, s.end(), SalesRating );} puts the 20 best elements at
	the front. If you use \texttt{nth\_element} on most of the range, It may be slower than a full sort.
	
	\item Separate the elements of a standard sequence container, do satisfy some criterion, you use \texttt{std::partition} or \texttt{std::stable\_partition.}
	
	\item For \texttt{std::list}, you should use \texttt{list.sort()} instead \texttt{std::sort()}.
\end{itemize}

\begin{lstlisting}[numbers=none]
bool compare(const Foo& f1, constFoo& f2) {...};
nth_element(vf.begin(),vf.begin()+19, vf.end(), compare);
bool good(const Foo &f1)
partition(vf.begin(), vf.end(), good);		
\end{lstlisting}


\textbf{Set:} \\

\begin{tabular}{| p{0.45\textwidth} |p{0.45\textwidth}|}
	\tophline \specialcell[t]{ bool includes(i1,i1,i2,i2) \\
		bool includes(i1,i1,i2,i2,bpred) }  &
	Search for \textbf{all values from the second range in the first range} and return true if found, or false  \\
	\tophline \specialcell[t]{o set\_difference(i1,i1,i2,i2,o) \\
		o set\_difference(i1,i1,i2,i2,o,bpred) } &
	in the first range but not in the second range and return the end of that output range. \\
	
	\tophline \specialcell[t]{o set\_intersection(i1,i1,i2,i2,o)  \\
		o set\_intersection(i1,i1,i2,i2,o,bpred) } &
	in the first range and also in the second range and return the end of that output range. \\
	
	\tophline \specialcell[t]{o set\_union(i1,i1,i2,i2,o) \\
		o set\_union(i1,i1,i2,i2,o,bpred) } &
	either in the first range or in the second range and return the end of that output range. \\
	
	\tophline \specialcell[t]{o set\_symmetric\_difference(i1,i1,i2,i2,o)  \\
		o set\_symmetric\_difference(i1,i1,i2,i2,o,bpred) } &
	not common to both ranges and return the end of that output range.  \bottomhline
\end{tabular}

\par All set related algorithms are all based on "equivalence", not on "equality".
\begin{lstlisting}
const auto
v1 = {'a', 'b', 'c', 'f', 'h', 'x'},
v2 = {'A', 'B', 'C'};

auto no_case = [](char a, char b) { return std::tolower(a) < std::tolower(b); };

cout<<std::includes(v1.begin(), v1.end(), v2.begin(), v2.end(), no_case); //true	
\end{lstlisting}



\begin{center}
	\includegraphics[width=0.18\linewidth]{pics/set_diff.png}
	\includegraphics[width=0.19\linewidth]{pics/set_sys_diff.png}
\end{center}


%\begin{lstlisting}[numbers=none]
%vector<Foo> vf;
%bool compare(const Foo& f1, constFoo& f2) {...};
%partial_sort(vf.begin(),vf.begin()+20, vf.end(),  compare);
%sort(vf.begin(),vf.end(), compare);
%nth_element(vf.begin(),vf.begin()+20,vf.end(), compare);
%
%bool good(const Foo &f1)
%partition(vf.begin(), vf.end(), good);		
%\end{lstlisting}	

\begin{center}
	\includegraphics[width=0.9\linewidth]{pics/std4.png}
\end{center}

\subsection{Usage suggestions}

	
	 Effective STL item 43: Prefer algorithm calls to hand-written loops, unless you need a loop that performs complex operations or if using a lambda function is difficult or impractical.
	
	\begin{itemize}
		\item  Handing writing loop is prone to bugs.
\begin{lstlisting}
int data[3] ={1,2, 3};
int max = 3;
vector<int> d;
auto current = d.begin();
for( size_t i = 0; i < max; ++i )
  d.insert( current++, data[i]+41 );//bug!, insert may invalid the current iter
\end{lstlisting}		
		
		\item You can fix it but with careful design.
\begin{lstlisting}
for( size_t i = 0; i < max; ++i ) {
	current = d.insert( current, data[i] + 41 ); 
	++current;    
} //Be careful to keep current valid, then increment it when it's safe	
\end{lstlisting}		
		
		\item A better way is to use STL algorithms.
\begin{lstlisting}[numbers=none]
transform(data, data + max, inserter(d, d.begin()), [](auto e){ //front of d
                                                          return e+41;
                                                     }); 	
\end{lstlisting}		
		
		\item Here's another example of using STL algorithms and lambdas instead of a for loop.
\begin{lstlisting}[numbers=none]
for( vector<int>::iterator i = v.begin(); i != v.end(); ++i ){
	if( *i > x && *i < y ) 
	  break;
}
//better method is below. 	
auto i = std::find_if(v.begin(), v.end(), [x, y](int &i){i>x && i<y}); 
\end{lstlisting}		
	\end{itemize}
	
	
	%	 fairly simpler, but would require a confusing tangle of binders and adapters, just use loop.
	%\begin{lstlisting}[numbers=none]
	%list<Widget> lw;
	%type list<Widget>::iterator WI;
	%for_each(lw.begin(),lw.end(), mem_fun_ref(&Widget::redraw) );
	%\end{lstlisting}

	
	\par When using remove-like algorithms on containers of pointers, it's important to be careful. Deleting a pointer and freeing the memory it points to are two separate actions. To avoid errors, it's a good idea to use smart pointers.
\begin{lstlisting}[numbers=none]
void delAndNULL(Foo*& pf){ // use pointer reference here.
	if(!pf->isCertified(){ delete pf; pf = nullptr}
}
for_each(v.begin(),v.end(), delAndNULL); //1) delete pointer points
v.erase(remove(v.begin(),v.end(), static_cast<Foo *>(0) ), v.end()); //2) delete pointer itself.
\end{lstlisting}	
	
	\par When you use algorithms in STL, you need to pay attention to some pre-requirements: 
	\begin{itemize}
		\item Default algorithms writes its result by making \textbf{assignment}, not \textbf{insert}. So you need to 1) use \texttt{resize()} or 2) use \texttt{reserve()} in \texttt{std::vector} or \texttt{std::string} + \texttt{inserter()} in the algorithms when you want to write elements to target range.
\begin{lstlisting}[numbers=none]
vector<int> values, result;
int doSth(int x); // function
result.reserve(result.size()+values.size()); // make destination big enough

transform(values.begin(), values.end(), result.end(), doSth ); //error 
transform(values.begin(), values.end(), back_inserter(result), doSth) //OK
transform(values.rbegin(), values.rend(), front_insert(result), doSth) //Ok
\end{lstlisting}		
		
		\item What kind of parameters does it accept? 
		
		\item Note below algorithms expect sorted ranges:
\begin{lstlisting}[numbers=none]
binary_search, lower_bound, upper_bound, equal_range, set_union, 
set_intersection, set_difference, merge, inplace_merge, includes, unique	
\end{lstlisting}			
	\end{itemize}
	

	
	%	\item RRRRSSSSPPCFMT(RRRRSSSSPP copy frinds many time). rotate, remove(unique), replace, reverse, sample, shuffle, swap, shift, partition, permutation, copy, fill(generate), math(accumulate/reduce, inner\_product, partial\_sum, adjacent\_difference), transform. 
	
	\par \texttt{std::accumulate} has \textbf{"fold"} semantics. I will introduce this concept in the "Functional Programming" chapter, where more examples on how to use \texttt{std::accumulate} will be provided.
\begin{lstlisting}
std::vector nums {1, 2, 3, 4};
std::cout << std::accumulate(nums.begin(), nums.end(), std::string{},  
   [] (std::string previousResult, int item) {
     return previousResult + '-' + std::to_string(item);
   });// Init result, the first parameter and return of lambda have the same type.
\end{lstlisting} 	
	
		\par Three differences between \texttt{std::reduce()} and \texttt{std::accumulate()}:
	\begin{itemize}	
		\item Use \texttt{std::reduce()} when you want your accumulation to run execution policies. Execution policies are a C++17 feature which allows programmers to ask for algorithms to be parallelised. There are three execution policies in C++17: \texttt{std::execution::seq}, \texttt{std::execution::par} and 
		\texttt{std::execution::par\_unseq}, which is parallelise and vectorise (requires that the operation can be interleaved, so no acquiring mutexes and such).
\begin{lstlisting}
auto sum3 = std::reduce(std::execution::par, begin(vec), end(vec)); //parallel
\end{lstlisting}
		
		\item Ensure that the operation you want to use is both associative and commutative.
		
		\item Remember that the default initial value is produced by default construction, and that this may not be correct for your operation.
	\end{itemize}	
		
	\par \texttt{std::transform()} has \textbf{"map"} semantic. Another important semantic in functional programming is \textbf{"filter"}, you can use \texttt{std::copy\_if()} or \texttt{std::remove\_if()} to implement it.
	

	\par \texttt{std::remove()} just keep good one, \texttt{std::partition()} put good one in front, bad one in back. \\ \texttt{std::nth\_element} is a strong version of partition.
	
	\par \texttt{std::unique()} can be thought of as a kind of \texttt{std::remove()}. All algorithms do not change the container's size but only change its contents. \texttt{std::rotate()} is also an important algorithm. For example, you can use it to easily implement insertion sort.
	
	
	\par Some algorithms has \_if suffix, Why we need these \_if version? beside normal version with value, we also need \_if version to input UnaryPredicate functor. 
\begin{lstlisting}
find_if and find, count_if and count
copy_if and copy, replace_if and replace,  remove_if and remove		
\end{lstlisting}	
	
	\par Some algorithm has \_copy suffix. They can be divided into three groups. They are all in-place modification, if you don't want to modify inplace, you can copy it to another range.
\begin{lstlisting}
partial_sort and partial_sort_copy, partition and partition_copy
remove and remove_copy , unique and unique_copy
replace and replace_copy, reverse and reverse_copy, rotate and rotate_copy		
\end{lstlisting}	
	
	\par Regarding \texttt{std::shift\_left()} and \texttt{std::shift\_right()}, it is important to keep in mind that if you shift left by one, you essentially lose the first element (at position 0) in your input. Therefore, shifting by one to the left and then by one to the right will not maintain your range identical to the original one.
\begin{lstlisting}
vector<int> numbers {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
shift_left(numbers.begin(), numbers.end(), 1); // {1, 2, 3, 4, 5, 6, 7, 8, 9, 9}
shift_right(numbers.begin(), numbers.end(), 1); // {1, 1, 2, 3, 4, 5, 6, 7, 8, 9}	
\end{lstlisting}	
	That’s the different with \texttt{std::rotate}. What is taken from the beginning of the end is not put to the other end of the container, but it’s just discarded.
	
	
	\par For algorithms in STL, standard introduced the ExecutionPolicy in C++14; In C++20, standard mainly introduce three new characteristics: 1) range support,  2) sentinel and 3) projection. 
\begin{lstlisting}
template< class InputIt, class OutputIt, class UnaryOperation >
OutputIt transform( InputIt first1, InputIt last1,   //C++14
OutputIt d_first, UnaryOperation unary_op );

template<class ExecutionPolicy, class FI1, class FI2, class UnaryOperation >
ForwardIt2 transform( ExecutionPolicy&& policy, FI1 first1,  
FI1 last1, FI2 d_first, UnaryOperation unary_op ); //C++17

template<input_iterator I, std::sentinel_for<I> S, std::weakly_incrementable O,
std::copy_constructible F, class Proj = std::identity >
constexpr unary_transform_result<I, O>   
transform( I first1, S last1, O result, F op, Proj proj = {} ); //C++20
\end{lstlisting}	
		
	\par You need to input default template argument if you want to use projection in constrained algorithms.
\begin{lstlisting}
vector v = {-1, -3, 2, 4};
ranges::sort(v, {}/* here */, [](int){return abs(i);} )  // output -1, 2, -3, 4.
//{} is less<int>{}, the lambda is proj. Need to input three parameter to sort
\end{lstlisting}	
	


\section{Function object}
\subsection{Basic knowledge of callable object}

	
	  In the C language, we use function pointers to pass callback functions.
\begin{lstlisting}[numbers=none]
void call_back(int x, int y, int(*pf)(int, int));
int sum(int i,int j);
call_bakc(2, 3, sum); //pass function name here, sum is variable. 
\end{lstlisting}

	\par In C++, when using generic algorithms like \texttt{std::for\_each}, you can pass function names directly as arguments. The compiler deduces these function names to function pointers, allowing you to use them as callbacks within the algorithm. It's a powerful feature that enhances the flexibility and reusability of generic algorithms. 
\begin{lstlisting}[]
void fun(int i) {
	...//do stuff
}
for_each(a.begin(), a.end(), fun); //fun is function pointer, a variable
\end{lstlisting}

	\par Passing function pointers has some shortcomings: 1) They can't be inlined. 2) Sometimes, they can't be compiled due to differences in compiler implementations. 3) They can't be adapted or customized. Therefore, the STL introduced functors (function objects), which are class or structure types that overload the \texttt{operator()}.

\begin{lstlisting}
struct functor { // also call function objects
  void operator()(int i) {..} //overload operator(), two () here.
};

for_each(a.begin(), a.end(), functor{}); //need a value, not type.
\end{lstlisting}

	\par You can use a struct to create a functor. However, if you need to have a private customized value, you should use a class. For instance, you can customize by changing value when you build a \texttt{less\_than\_value} functor in the following code:
\begin{lstlisting}[frame=single, language=c++]
struct less_than_7 {  //in struct, default is public, so struct is better!
    bool operator()(int i) const { return i < 7; }
};

class less_than_value {
    less_than_value(int x) : value(x) {};
    bool operator()(int i) const { return i < value; }
private:
    int value;
};

count_if(v.begin(),v.end(), less_than_7{} );
count_if(v.begin(),v.end(), less_than_value{7} );
\end{lstlisting}
%\begin{description}
%	\item[Line 2:] you can use class instead struct, but you need to make operator() public, in struct, default is public, so struct is better!
%\end{description}


   \par \texttt{std::set} and \texttt{std::map} are template classes that accept types as template parameters, not variables. If you want to provide a customized comparison function to a \texttt{std::set} or \texttt{std::map}, you must define a functor to encapsulate this functionality as a type.
\begin{lstlisting}[frame=single, language=c++]
class YanCompare{
    bool operator()(string &s1, string &s2){....;}
};

set<string, YanCompare> setDic;  //set is a class, need a type here
std::sort(...YanComare{}); //sort function needs a variable, temporary is OK
\end{lstlisting}

	\par Make predicates pure functions as per Effective STL item 39. This means they should have no side effects: 1) no I/O operations, and 2) no changes to any state.

%\begin{lstlisting}[numbers=none]
%class Predicate: public unary_function<Foo, bool>{
%public:
%	bool operator()(const Foo& f) const{ // two const
%		cutoff++; // this statement will not compile.
%}
%private:
%	int cutoff;
%\end{lstlisting}

	\par More effective STL item 42 states that we should make sure \texttt{less<T>} means \texttt{operator<}. Don't specialization of \texttt{std::less}. If you need to another compare, just define your own compare function.


	\par Based on previous example, I would like to say something about \textbf{type, variable, expression, value}.
\begin{itemize}
	\item Types encompass built-in types, custom types (classes, structs), and compound types (pointers, reference), etc.
	
	\item A variable has a name, type, and value associated with it.
		
	\item An expression lacks a name but possesses a value and type.
	
	\item Values fall into three categories: lvalues, rvalues, and xvalues.
	
	\item To deduce the type of a variable or expression, tools like auto, T in templates, or \texttt{decltype} are used. Further details can be explored in the "Type Inference" section.
	
	\item Within a container, the \texttt{value\_type }can be accessed through the container's predefined type information.
	
	\item When defining a variable with a specific type, typedef or using aliases are used to simplify complex types in C++, such as \texttt{vector<pair<string, int> >}. 

\end{itemize}

	\par Sometimes, you may not want to reuse a functor, which can lead to writing cluttered code. In C++14, lambdas were introduced as a more concise alternative. Compared to functors, lambdas excel at creating simple function objects for specific situations. However, they are less suitable for more complex scenarios where functors might be more appropriate.
\begin{lstlisting}[frame=single, language=c++]
std::count_if(v.begin(), v.end(), [](int x){return x<7;} );
\end{lstlisting}


\subsection{std::function template}

	
	 \texttt{std::function} exemplifies type erasure effectively. Another example, \texttt{std::shared\_ptr}, employs type erasure to manage its deleter. As demonstrated in the code below, \texttt{std::function} allows any callable object to be passed to it.
	
\begin{lstlisting}
struct Foo {
	Foo(int num) : num_(num) {}
	void print_add(int i) const { std::cout << num_+i << '\n'; }
	int num_;
};
void print_num(int i){
	std::cout << i << '\n';
}
struct PrintNum {
	void operator()(int i) const{
		std::cout << i << '\n';
	}
};

std::function<void(int)> f_display = print_num;
std::function<void()> f_display_42 = []() { print_num(42); };	
std::function<void(const Foo&, int)> f_add_display = &Foo::print_add;
const Foo foo(314159);
f_add_display(foo, 1);    //need a foo object here.
f_add_display(314159, 1); //you can also use a temporary foo object.
std::function<void(int)> f_display_obj = PrintNum();	
\end{lstlisting}	
	
	
	\par \texttt{std::function} templates support objects that are both copyable and callable. They accommodate various callable entities such as function pointer, functors, and lambdas. Moreover, they can be copied, allowing function values to be stored in a \texttt{std::map}, as illustrated below.
	
\begin{lstlisting}[numbers=none]
double add(double a, double b){
	return a + b;
}	
struct Sub{
	double operator()(double a, double b){
		return a - b;
	}
};	//Sub is type, so need ; here.

double multThree(double a, double b, double c){
	return a * b * c;
}
	
using namespace std::placeholders;
map<const char,std::function<double(double, double)> > disTable{
	{'+', add },                                         
	{'-', Sub() },                                      
	{'*', std::bind(multThree, 1, _1, _2) },             
	{'/',[](double a, double b){ return a / b; }}};      
	
cout<<dispTable['+'](3.5, 4.5) <<dispTable['-'](3.5, 4.5) 
<< dispTable['*'](3.5, 4.5) << dispTable['/'](3.5, 4.5);
\end{lstlisting}
	
	\par If you want to check if a variable of type \texttt{std::function} is currently holding a valid function, you can always treat it like a bool value:
\begin{lstlisting}[numbers=none]
std::function<int ()> func;
	.......
if ( func ) { // if we did have a function, call it
	func();
}
\end{lstlisting}
	
	\par \texttt{std::function} can be used \textbf{CALL BACK} as a function parameter. 
	
\begin{lstlisting}[numbers=none]
void run_within_for_each(std::function<void (int)> func){
	vector<int> numbers{ 1, 2, 3, 4, 5, 10, 15, 20, 25 };
	for_each(numbers.begin(), numbers.end(), func);
}
	
void fun(int x){   //1) function pointer
	cout<<x<<endl;
}
	
auto lambda1 = [](int y){  //2) lamba
	cout << y <<endl;
};	
run_within_for_each(fun);
run_within_for_each(lambda1);
\end{lstlisting}
	
	\par One significant advantage of \texttt{std::function} over templates is that when using templates, the entire function implementation typically needs to be placed in a header file. In contrast, \texttt{std::function} does not have this requirement. This can be advantageous, especially when working on code that undergoes frequent changes and is included in multiple source files.
	
	\par A good article: Google "Should I use \texttt{std::function} or a function pointer in C++?" another is "How is std::function implemented?" We use type-erased wrapper for any whatever callbacks, counters, output streams, input generators.
	

\subsection{Use lambda as adaptable}


%\begin{itemize}
%	\item Why we need \texttt{std::mem\_fn}? Because it makes member function can work with STL generic algorithm better. For example, if you called \texttt{for\_each()} with \texttt{\&Item::Foo}, the code try to call \texttt{(\&Item::Foo)(x)}, which is ill-formed since for pointers to members you have to write \texttt{(x.*\&Item::Foo)()}. It's that syntactical difference that \texttt{mem\_fn} is meant to solve: \texttt{mem\_fn} deals with the invocation syntax of pointers to members so that you can use all the algorithms with pointers to members as well as functions and function objects. You cannot have \texttt{for\_each(v.begin(), v.end(), \&Item::Foo)} but you can have \texttt{for\_each(v.begin(), v.end(), mem\_fn(\&Item::Foo))}.
%\begin{lstlisting}
%template<class InputIt, class UnaryFunction>
%UnaryFunction for_each(InputIt first, InputIt last, UnaryFunction f){
%	for (; first != last; ++first) {
%		f(*first); // <== N.B. f(*first)
%	}
%}
%\end{lstlisting}
%
%\begin{lstlisting}
%struct A{
%	public:
%	A(int i, int j):i_(i), j_(j){}
%	void show(){
%		cout<<"i, j = "<<i_, j_ <<endl;
%	}
%	int i_, j_;
%};
%
%vector<A> va  = {{1,1},{2,2}, {3,3}};
%for_each(va.begin(), va.end(), mem_fn(&A::show));
%\end{lstlisting}
%
%	\item \texttt{mem\_fn} can be use to access member data too.
%\begin{lstlisting}
%struct Foo {
%	int data = 7;
%};
%
%Foo f;   //use & here to get address
%auto access_data = std::mem_fn(&Foo::data); // use mem_fn to get member
%std::cout << "data: " << access_data(f) << '\n';
%\end{lstlisting}
%
%
%	\item Besides \texttt{mem\_fn}, you also can use \texttt{bind} to call member function. Only syntax difference lies in between \texttt{bind} and \texttt{mem\_fn}.
%
%\begin{lstlisting}
%struct A { 
%	int x;
%	int add(int y) { return x+y; }
%};
%
%A a;
%auto add1 = std::mem_fn(&A::add); //mem_fn is clear
%auto add2 = std::bind(&A::add, _1, _2); 
%auto add3 = std::bind(&A::add, &a, -1);
%
%add1(a, 5); // yields 7
%add2(a, 5); // same
%add3(5);    // same
%\end{lstlisting}
%\begin{description}
%	\item[Line 8 and 9:] When you use bind with member function, The first function parameter has to be the object pointer.
%\end{description}
%
%%\item For access member function, you can also use \texttt{std::function}.
%
%%\begin{lstlisting}[numbers=none]
%%struct Foo {
%%	Foo(int num) : num_(num) {}
%%	void print_add(int i) const{
%%		std::cout << num_+i << '\n'; }
%%	int num_;
%%};
%%
%%std::function<void(const Foo&, int)> 
%%f_add_display = &Foo::print_add;
%%
%%const Foo foo(3);
%%f_add_display(foo, 1); 	
%%\end{lstlisting}		
%
%	\item For access member function, you can also use \texttt{std::function}. You can find the code in type erasure section in the Generic programming chapter. You can't really compare \texttt{std::function} with \texttt{std::mem\_fn}. The former is a class template whose type you specify, and the latter is a function template with unspecified return type. There really isn't a situation in which you'd actually consider one versus the other.
%
%	\item For call member function \textbf{Prefer \texttt{mem\_fn} than \texttt{bind} because it's verbose, Perfer \texttt{bind}  than \texttt{std::function}, because it lightweight.}
%
%\begin{enumerate}
%	\item \texttt{mem\_fn} is faster than \texttt{std::bind}.  so prefer \texttt{mem\_fn} first.
%	
%	\item You also need to pick between\texttt{ std::mem\_fun} and \texttt{std::mem\_fun\_ref} depending on whether you want to deal with pointers or references for the class object (respectively). \texttt{std::mem\_fn} alone can deal with either, and even provides support for smart pointers.
%\end{enumerate}
%
%
%
%\subsubsection{std::bind}
%
%	\item \textbf{std::bind will be deprecated in C++ 17.} Contents here is just helpful for you to understand some old code.  Understand placeholder by an example below. \_2 means position in the \texttt{bind\_fun}. 
%\begin{lstlisting}
%void fun(int a, int b, int c){
%	cout<<"a="<<a<<endl;
%	cout<<"b="<<b<<endl;
%	cout<<"c="<<c<<endl;
%}
%
%using namespace std::placeholders; // have to introduce std::placeholders first
%auto bind_fun = bind(fun, _2, 10, _1);
%bind_fun(15,5);  //output 5, 10, 15
%\end{lstlisting}
%\begin{description}
%	\item[Line 8:] You should use \_2, not -2, otherwise it will output real number -2.
%\end{description}
%	

%\subsubsection{}
	 \texttt{std::mem\_fn} and \texttt{std::bind} were introduced in C++11, but they are generally considered inferior to lambdas for several reasons and should be avoided in modern C++ code. For more details, refer to \textit{"Effective Modern C++"} Item 34. Using lambdas often results in cleaner, clearer, and more efficient source code.
	
\begin{lstlisting}
struct Foo{ 
	int _x = 0;
	void print() { std::cout << _x << "\n"; }
};
auto foo_print = std::mem_fn(&Foo::print); //mem_fn implementation
foo_print(foo{});   // prints '0'
foo_print(foo{5});  // prints '5'

auto foo_print = [](auto&& this_foo){ //lambda implementation, better.
	this_foo.print();
};
foo_print(foo{});   // prints '0'
foo_print(foo{5});  // prints '5'
\end{lstlisting}	


\begin{lstlisting}
int add(int a, int b) { return a + b; }
auto add10 = std::bind(add, 10, std::placeholders::_1); // bind implementation
std::cout << add10(10) << "\n";  // prints `20`

auto add10 = [](auto x){
	return add(static_cast<decltype(x)>(10), x); //lambda implementation, better.
};
\end{lstlisting}	


	\par Lambda provides more flexibility when work with \texttt{std::function} or work with member function in C++. 
\begin{lstlisting}[numbers=none]
typedef std::function<void(int)> fp;
void test(fp my_func){
	my_func(100);
}

Foo foo;
test([&foo](int i){ foo.print_add(i); }); //100 is input here.
\end{lstlisting}
	
%\begin{lstlisting}
%struct A{
%public:
%	void output(int i, int j){
%		cout<<"i, j = "<<i,j<<endl;
%	}
%};
%vector<int> vi  = {1,2,3};
%A a;
%//below is bind, very complicated.
%using namespace std::placeholders;
%auto bind_mem_fn = bind(&A::output, &a, 5, _1);
%bind_mem_fn(10);
%for_each(vi.begin(), vi.end(), bind_mem_fn );
%
%//below is lambda, very clear and easy
%for_each(vi.begin(), vi.end(), [&a](auto item){a.output(5, item);} );	
%\end{lstlisting}


	\par Lambdas allow to store state easily.
\begin{lstlisting}
std::vector<int> vec { 0, 5, 2, 9, 7, 6, 1, 3, 4, 8 };
size_t compCounter = 0;
std::sort(vec.begin(), vec.end(), [&compCounter](int a, int b) {
	++compCounter;
	return a < b;
});
\end{lstlisting}
	\par A lambda is also a functor, but it is an unnamed type. \texttt{std::function} acts as a callable container and supports invocation. It's important to note that the type of a lambda object is not \texttt{std::function}; instead, it has a unique unnamed non-union non-aggregate class type known as a closure type. Consequently, creating a \texttt{std::function} from a lambda isn't free: \texttt{std::function} has a non-trivial constructor and destructor.



%\subsection{functor tips}
%\subsubsection{Basic rules}

%\begin{itemize}


%\end{itemize}

\subsection{Callback interface design}
	 As we have demonstrated before, we have three callback ways: 
	1) function pointer, 
	2) \texttt{std::function},
	3) template parameter,
I will introduce and compare them in this section.	
\begin{lstlisting} 
host(fp*){fp();}  //1) funciton pointer 
host(std::function<void ()> fo){fo();} //2) std::function

template<typename T>  //3) template, T must be callable.
host(T v){v();}
\end{lstlisting}


	
	
	%\begin{center}
	%	\includegraphics[scale=0.9]{pics/function.png} 
	%\end{center}
	

	
		
\begin{center}
	\includegraphics[width=0.95\linewidth]{pics/callable.png}
\end{center}

\par In the figure above, the central concepts are Function, Functor, Lambda, and Member Function, which represent concrete callable objects. The top part of the figure depicts the callback interface, while the bottom part shows adapters. Both templates and \texttt{std::function} can accept all types of callable objects, but \texttt{std::function} introduces some overhead. Adapters like \texttt{std::bind} and \texttt{std::mem\_fn} modify the signature or invoking syntax of callable objects. While \texttt{std::bind} is still usable, it's somewhat obsolete; lambdas are generally clearer and more readable for achieving the same effects. \texttt{std::mem\_fn} is less commonly used since lambdas can also invoke member functions on objects.

\begin{center}
	\begin{tabular}{| p{0.35\textwidth}| c | c| c |}
		\hline
		& function pointer  & std::function  & template param  \\
		\hline
		can capture context variable & no  & yes  & yes  \\
		\hline
		no call overhead & yes & no  & yes \\
		\hline
		can be inline& no &  no & yes \\
		\hline
		can store in class& yes & yes & no \\
		\hline
		can be implemented outside header& yes  & yes & no \\
		\hline
		supported without C++11& yes & no  & yes \\
		\hline
		readable & no(ugly) & yes  & yes  \\
		\hline
	\end{tabular}
\end{center}

	\par If you are faced with a design decision, prefer using templates. This choice is an instance of a broader principle: strive to specify as many constraints as possible at compile-time. There are three main advantages:
\begin{itemize}
	\item The rationale is simple: by catching errors or type mismatches before your program is generated, you can prevent shipping buggy software to your customers.
	
	\item Calls to template functions are resolved statically (i.e., at compile time), allowing the compiler to have all necessary information to optimize and potentially inline the code. This optimization wouldn't be feasible if the call were made through a vtable.
	
	\item Templates allow you to use a template parameter that can be any callable object: a function pointer, a functor, a lambda, \texttt{std::function}, and more. This provides the advantage that calls to the callback can be inlined, as the client code of your function 'sees' the call with exact type information available."
\end{itemize}

Drawback here is that your (outer) function becomes a template and hence needs to be implemented in the header.

\par Use \texttt{std::function} when you need to dynamically resolve a call at run-time by invoking a callable object that conforms to a specific signature, but whose concrete type is unknown at compile-time. This scenario commonly arises when managing a collection of callbacks with potentially different types that need to be invoked uniformly. The types and number of registered callbacks are determined dynamically at run-time based on the state of your program and application logic. These callbacks can include functors, plain functions, or functions bound to specific arguments. \texttt{std::function} can also be used to store a function for later invocation, making it convenient for scenarios where callbacks need to be stored in member variables. However, it introduces a slight overhead during invocation, which is usually negligible except in very performance-critical scenarios. For those prioritizing consistent and readable code without micromanaging every choice, \texttt{std::function} simplifies passing around functions

\par Last, let's say function pointer, Function pointers have the disadvantage of not being able to capture some context. You won't be able to pass a lambda function to function pointer. 

%\par There are two articles "Should I use \texttt{std::function} or a function pointer in C++?" and "std::function vs template", You can search them in the stackoverflow.



\section{Code examples}

\subsection{Bit operations}

Avoid using \texttt{vector<bool>}, detail can be found in the "Auto initialization(Almost Always Auto)" in the chapter 4. In order to resolve \texttt{vector<bool>} problem, you can use \texttt{std::deque<bool>} it has normal container behavior. C++11 also introduces the \texttt{std::bitset} for fixed number bool bit. Boost library also provides \texttt{dynamic\_bitset}.
\begin{lstlisting}
std::bitset<8> a, b;
b.to_ulong()  //change it to ulong type
std::cout << b.set() << '\n'; //set to 1 all
std::cout << b.reset() << '\n';  //set to 0 all
std::cout << b.set(0); //from 0, from least significant to most significant
b.test(0);  b.flip(0);
a &= b; //Note &=, |=, and ^= are only defined for bitsets of the same size N.			
\end{lstlisting}


\par set, clear and toggle a bit
\begin{lstlisting}
number |= 1 << bit_position;
number &= ~(1 << bit_position);
number ^= 1 << bit_position;
\end{lstlisting}


\par C++20 introduces several new bit manipulation functions, such as \texttt{std::rotl}, \texttt{std::rotr}, and  \\ \texttt{std::bit\_ceil}, which are defined in the <bit> header file. They accept unsigned integer types as input.

\begin{lstlisting}
const std::uint8_t i = 0b00011101;
std::cout << "i          = " << std::bitset<8>(i) << '\n';
std::cout << "rotr(i,1)  = " << std::bitset<8>(std::rotr(i, 1)) << '\n';		
\end{lstlisting}	


	 \par Change the right most set bit (1) to 0. Pay attention to the usage of \texttt{n\&(n-1)}.
\begin{lstlisting}[frame=single, language=c++]	
n&(n-1);  // change the right most bit to 0. change 110100 to 110000
//when we n-1: 110100, the right most 1 will become 0,
//all zero after right most 1 will become 1. 
110100  //n
110011  //n-1	
\end{lstlisting}
	
	\par Following from the previous discussion, a number can be tested to see if it is a power of two by examining its binary representation. Specifically, a number is a power of two if and only if it has exactly one '1' in its binary form.
\begin{lstlisting}[frame=single, language=c++]	
bool isPowerOfTwo(int n) {
	if (n <= 0) return false;
	return (n & (n - 1)) == 0;
}			
\end{lstlisting}

	\par Find the leftmost and rightmost set bit. You should remember this code snippet.
\begin{lstlisting}
int position = 1; //find the rightmost set bit
int m = 1;
while ((n & m) == 0) {
	m = m << 1;
	position++;
}

while (n > 0) { //find the leftmost set bit.
	n = n >> 1;
	position++
}
\end{lstlisting}
	
	\par The Hamming weight of an integer refers to the count of '1' bits (set bits) in its binary representation. It's a useful concept in computer science and is often used in algorithms that involves bit manipulation and binary operations.
\begin{lstlisting}[frame=single, language=c++]	
int hammingWeight(uint32_t n) {
	int res = 0;
	while (n != 0) {
		n = n & (n - 1); //change n, you need to assign new value back to n. 
		res++;
	}
	return res;
}	
\end{lstlisting}	

	\par When we use the left shift operator \texttt{<<} in C++ the number will be shifted and 0 will be placed at the right of number, below code place 1(not 0) at the right. 
\begin{lstlisting}[frame=single, language=c++]	
int one_shift(int val, int n) {
	return ~(-1 << n) | (val << n); //-1 is all set bit.
}	
\end{lstlisting}

	
	\par Array has a lot of duplicated numbers, but has only one single numbers, how to find it? When you use the XOR (exclusive OR) operation on a series of numbers where every number except one appears in pairs, the XOR operation will cancel out the paired numbers because \texttt{x\^{}x = 0}. The number that does not have a pair will remain after all XOR operations are completed. This property makes XOR a very efficient way to find the single number in such an array. 
\begin{lstlisting}[frame=single, language=c++]	
int res = 0; //[1, 2, 3, 2, 1], how to find 3 in this array? 
for (int n : nums) {
	res ^= n;  //a^a = 0;   a^0 = a;
}
return res;
\end{lstlisting}
	
	\par Change number to bits: 
\begin{lstlisting}[frame=single, language=c++]	
int temp = i;
int base = 10; //base can be 10 or 2;
while (temp) {
	int b = temp % base;
	temp = temp / base;
	cout << b << endl;
}		
\end{lstlisting}		
	
	\par Change bits to num. \texttt{std::accumulate} can be used in "folding" way, not "accumulating" way. The detail has been introduced in "Functional programming" chapter. 
\begin{lstlisting}[frame=single, language=c++]	
int i = 1001011;
string str = std::to_string(i); // you can use to_string directly.

int base = 1;
int result = accumulate(rbegin(str), rend(str), 0, [&](int result, char a) {
	if (a == '1')
		result += base;
	base = base << 1;
	return result;
});			
\end{lstlisting}
	
	\par Determining endianness of your machine. Here is one quick way:
\begin{lstlisting}
unsigned int i = 1;
char *c = (char*)&i;
if (*c)   
	printf("Little endian");
else
	printf("Big endian");
\end{lstlisting} 
	

\subsection{Algorithm}
	
	 There are a few famous algorithms examples to remember. 
\begin{itemize}
	\item quick sort(\texttt{std::partition}) and merge sort(\texttt{std::inplace\_merge}) 
	\item insert sort(\texttt{std::rotate}) and selection sort(\texttt{std::iter\_swap}) 
	\item palindrome(\texttt{std::equal}) 
	\item fibonacci(\texttt{std::adjacent\_difference}) 
	\item trim\_string (\texttt{std::erase+std::find}) 
	\item gather(\texttt{std::partition}) 
	\item slide(\texttt{std::rotate}) 
\end{itemize}


	

	\par Filter and transform example. A container, filter some items and get the name in the class \texttt{person\_t}. In below code, you can change \texttt{is\_female()} and \texttt{name()} function to lambda. 
\begin{lstlisting}
std::string name(const person_t &person) {
	return person.name();
}
bool is_female(const person_t &person) {
	return person.gender() == person_t::female;
}
std::vector<person_t> people {
	{ "David"  , person_t::male   },	{ "Jane"   , person_t::female },
	{ "Martha" , person_t::female },
};

std::vector<person_t> females; // Filtering the collection by copying
females.reserve(people.size()); 
std::copy_if(people.cbegin(), people.cend(), std::back_inserter(females), is_female);

std::vector<std::string> names(females.size());
std::transform(females.cbegin(), females.cend(), names.begin(), name);	
\end{lstlisting}


	\par For \texttt{std::accumulate}, the init value, the first parameter of op and the return the result, they are all the same type.
\begin{lstlisting}
vector<int> vi(10,1);
long long sum = 0; //use long long here to avoid overflow.
sum = std::accumulate(begin(vi),end(vi), sum);
\end{lstlisting}


	\par You can simulate zip function with \texttt{std::transform}. In C++20, you can use \texttt{std::views::zip} to do the same thing.
\begin{lstlisting}
vector<int> vi(10,1); // 1, 1, 1...
vector<int> vi1(10,2);// 2, 2, 2....
vector<pair<int, int> > result; //{1,2}, {1,2}, {1,2}...

std::transform(begin(vi),end(vi),begin(vi1), back_inserter(result),
        [](auto &a, auto &b){return make_pair(a, b); } );
        
std::views::zip(vi, vi1);  //C++20 supports.
\end{lstlisting}

	\par Produce a number serial. 
\begin{lstlisting}
vector<int> vi(10, 2);
partial_sum(begin(vi),end(vi), begin(vi)); //2 4 6 8 10...
partial_sum(begin(vi),end(vi), begin(vi),multiplies<int>{}); //2 4 8 16 32..
adjacent_difference(begin(vi),end(vi), begin(vi), divides<int>{} );
//2 2 2 2 2...

vector<int> vi(10,1);
adjacent_difference(begin(vi), prev( end(vi) ), next(begin(vi)), plus<int>());
//1 1 2 3 5 8 13 21...  Fibonacci number, pay attention to the prev and next
\end{lstlisting}

	\par  Example of \texttt{std::inner\_product}. It is just like \texttt{std::accumulate}, \texttt{std::inner\_product} is also a "fold" algorithm.

\begin{lstlisting}
std::vector<int> a{0, 1, 2, 3, 4};
std::vector<int> b{5, 4, 2, 3, 1};
int r1 = std::inner_product(a.begin(), a.end(), b.begin(), 0);
std::cout << "Inner product of a and b: " << r1 << '\n'; //output 21

int r2 = std::inner_product(a.begin(), a.end(), b.begin(), 0,
       std::plus<>(), std::equal_to<>());
std::cout << "Number of pairwise matches between a and b: " <<  r2; //output 2
//init = op1(std::move(init), op2(*first1, *first2)); 
\end{lstlisting}

	\par Get rid of duplicate space in a string.
\begin{lstlisting}
string str{"abc    de    f"};
str.erase(unique(begin(str), end(str)), end(str));
cout<<str<<endl; //output "abc de f"
\end{lstlisting}


	\par Code snippet for k-max frequency problem. 
\begin{lstlisting}
map<int, int> map1;
for(auto e: v1){  //count 
	++map1[e];  //you can use [] directly here, 
}	           //will insert default value if it doesn't exist

vector< pair<int, int> > v2{map1.begin(), map1.end()};  //range construct
           //don't use template deduct, otherwise it will be pair<const int, int>
           
ranges::partial_sort(v2, v2.begin()+3, greater{}, &pair<int,int>::second);
          //pay attention projection here. 

for(auto& [k,v]: v2){ //auto binding.
	cout<<k<<" "<<v<<endl;
}

//The second method to avoid copy real object, just copy iterator. 
std::map<int, int> m1{{1, 3}, {2, 5}, {3, 0}, {4, 2}};
std::vector<decltype(m1)::iterator> v1(m1.size()); //declare a vector of iterator, 
std::iota(v1.begin(),v1.end(), m1.begin() );   //just copy iterator, good example.

ranges::sort(v1, std::greater{}, &pair<const int,int>::second);//from big to small
//projection can also be used on iterator by std::invoke(); 
ranges::sort(vd, {}, &remove_reference_t<decltype(*dict.begin())>::second);//same

for(auto e: v1){
	cout<<e->first<<" "<<e->second<<'\n';  //cout<<*e.first<<" "<<*e.second<<'\n';
}
\end{lstlisting}

	\par Behind projection in constraint algorithms is \texttt{std::invoke}. It supports:
\begin{itemize}
	\item regular call - no dereferencing needed.
	
	\item via reference wrapper - so we have to call \texttt{.get()} to get the object.
	
	\item in other cases we assume it’s a pointer and then we need to dereference it. This also supports smart pointers.
\end{itemize}
	You can find more details by google "C++20 Ranges, Projections, std::invoke and if constexpr".
\begin{lstlisting}
struct S{
	void do_something(int);
	int v;
};	
S s;
std::invoke(&S::do_something, std::ref(s), 42); //use std::ref here.
std::invoke(&S::v, s) = 42; // same as s.v = 42
auto x = std::invoke(&S::v, s); // same as "auto x = s.v;"

S* p = &s;
std::invoke(&S::v, p) = 42; // same as p->v = 42, support pointer
\end{lstlisting}

	\par Implement quick sort by using \texttt{std::partition}.
\begin{lstlisting}
template<class ForwardIt>
void quicksort(ForwardIt first, ForwardIt last){
	if (distance(first,last)<=1)
		return;
	
	auto pivot = *std::next(first, std::distance(first, last) / 2);
	auto middle1 = std::partition(first, last, [pivot](const auto& em){
		return em < pivot;
	});
	auto middle2 = std::partition(middle1, last, [pivot](const auto& em){
		return !(pivot < em);
	});
	
	quicksort(first, middle1);
	quicksort(middle2, last);
}
\end{lstlisting}
	\par Implement selection sort by using \texttt{std::min\_element()} and \texttt{std::iter\_swap()}.
\begin{lstlisting}
template<class ForwardIt>
void selection_sort(ForwardIt begin, ForwardIt end){
	for (ForwardIt i = begin; i != end; ++i)
	std::iter_swap(i, std::min_element(i, end));
}
\end{lstlisting}

	\par Implement insert sort by using \texttt{std::rotate}. rotate(a, b, c) is [a,b) and [b,c) scope. they are all left close, right open scope. In this way, you can understand why we need \texttt{std::next(i)} here.
\begin{lstlisting}[frame=single, language=c++]	
for (auto i = start; i != end; ++i)
//          | i positon here
// 1 2  5 6 4 ***** //(5 6) (4) rotate. 
//      | upper_bound return here 

std::rotate(std::upper_bound(start, i, *i), i, std::next(i) );		
\end{lstlisting}

	\par Implement merge sort by using \texttt{std::inplace\_merge}.
\begin{lstlisting}
template<class Iter>
void merge_sort(Iter first, Iter last){
	if (distance(first,last)<=1)
		return;
	
	auto middle = next(first, distance(first, last) / 2);
	merge_sort(first, middle);
	merge_sort(middle, last);
	std::inplace_merge(first, middle, last); //using std::inplace_merge
}
\end{lstlisting}




\subsubsection{Partition and rotate}
	
	  Both \texttt{std::remove\_if} and \texttt{std::partition} put the "good" elements first. \texttt{std::partition} puts the "bad" elements after that, whereas \texttt{remove\_if} does not specify what comes after it. It might be the bad elements, but it might also be copies of any (either good or bad) elements. For example, if you \texttt{std::partition} 1 2 3 4 5 on even, you might get 2 4 5 3 1 (note that each element occurs exactly once), whereas if you \texttt{remove\_if} the odd elements, you might get 2 4 3 4 5 (note the duplicates).	
	
%	\par Implementation of \texttt{std::partition}. That is a common method.  In line 21, j must point \textbf{the last element which is smaller than pivot}, so we can swap it with pivot. 
%\begin{lstlisting}[frame=single, language=c++]	
%int partition(int nums[], int lo, int hi) {
%	if (lo == hi) return lo;
%	// nums[lo] as default pivot
%	int pivot = nums[lo];
%	// j = hi + 1, because -- will be run in while first.
%	int i = lo, j = hi + 1;
%	while (true) {
%		while (nums[++i] < pivot) { //assert nums[lo..i] less than pivot
%			if (i == hi) break;
%		}
%		while (nums[--j] > pivot) { //assert nums[j..hi] greater than pivot.
%			if (j == lo) break;
%		}
%		if (i >= j) break;
%		
%		//when we reach here, we must have:nums[i] > pivot && nums[j] < pivot
%		//so need swap nums[i] and nums[j], assert nums[lo..i]<pivot< nums[j..hi]
%		swap(nums, i, j);
%	}
%	//put pivot swap to right position
%	swap(nums, j, lo);
%	return j;
%}	
%\end{lstlisting}	
	
%	\par We can use \texttt{std::partition} to implement common \texttt{partition}, you can see the code is much easier than the previous one. That is the advantage of using STL algorithms. It also demonstrate "NO Raw for Loop" idea. 
%\begin{lstlisting}[frame=single, language=c++]	
%auto pivot = *next(first, distance(first, end1) / 2);  //get pivot value
%auto m1 = partition(first, end1, [pivot](const auto& em) { return em < pivot; });
%auto m2 = partition(m1, end1, [pivot](const auto& em) { return !(pivot < em); });	
%//The first step move smaller to m1, then move equal to m2. 		
%\end{lstlisting}
	
	\par With help of \texttt{std::partition}, we can use it to implement Kth largest element. 
\begin{lstlisting}[frame=single, language=c++]	
int findKthLargest(int[] nums, int k) {
	int lo = 0, hi = nums.length - 1;	
	k = nums.length - k; //index transition.
	while (lo <= hi) {
		int p = partition(nums, lo, hi); // select a pivot from nums[lo..hi] 
		if (p < k) {
			lo = p + 1; // kth element is in nums[p+1..hi].
		} else if (p > k) {
			hi = p - 1; // kth element is in nums[lo..p-1]
		} else {
			return nums[p]; // found the kth element.
		}
	}
	return -1;
}	
\end{lstlisting}		
	
	\par Pay attention to difference between \texttt{std::nth\_element()}, \texttt{std::partition()} and \texttt{std::remove()}. We can build \texttt{quick\_sort} from \texttt{std::nth\_element} and build quick\_select (kth element) from partition. Use \texttt{std::nth\_element()} to implement quick sort.
\begin{lstlisting}[frame=single, language=c++]	
template<class FwdIt, class Compare = std::less<>>
void quickSort(FwdIt first, FwdIt last, Compare cmp = Compare{}){
	auto const N = std::distance(first, last);
	if (N <= 1) return; 
	auto const pivot = std::next(first, N / 2);
	std::nth_element(first, pivot, last, cmp);
	quickSort(first, pivot, cmp); 
	quickSort(pivot, last, cmp); 
}		
\end{lstlisting}		
	
	\par \texttt{std::rotate} is used to implement "slide". Detail can be found in "Top 5 Beautiful C++ std Algorithms Examples". Pay attention here: rotate returns iterator to the new location of the element pointed by first. 

\begin{lstlisting}[breaklines, basicstyle=\scriptsize]
template <typename It> 
auto slide(It f, It l, randIter p) -> std::pair<It, It>{
	if (p < f) return { p, std::rotate(p, f, l) };
	if (l < p) return { std::rotate(f, l, p), p };
	return { f, l };
}			
\end{lstlisting}	
\begin{description}		
	\item[Source code] when p <f, p is the first element position, when p>l, p is the last element position. That will help you to understand slide algorithm. 
\end{description}	
	

\subsubsection{Other code examples}

	The range-based version is used when you want to iterate over every element in a container without mutating the container itself (i.e., without inserting or erasing elements). If you need to modify elements in a sequential container, you can use a range-based function to iterate and make changes. However, for associative containers, you should only visit each element. If you need to modify a key in an associative container, delete it first, then modify it, and finally insert the modified key again. The following patterns are highly recommended when using STL containers:
	
	\begin{itemize}
		\item When iterating through elements in generic code, since we cannot assume that the generic type \texttt{T} is cheap to copy, it is safe to always use \texttt{(const auto\& elem : container)} in for loops. This approach avoids potentially expensive and unnecessary copies, works well for cheap-to-copy types like \texttt{int}, and also handles containers using proxy-iterators, such as \texttt{std::vector<bool>}.
\begin{lstlisting}[numbers=none]
for (const auto& elem : container)  // capture by const reference, just for read
\end{lstlisting}			
		
		\item If the objects are cheap to copy (like \texttt{int}, \texttt{double}, etc.), it is possible to use a slightly simplified form. If there is a need to make a local copy of the element inside the loop body, capturing by value is a good choice.
		
\begin{lstlisting}[numbers=none]
for (const auto elem : container)  // capture by value
for (auto& elem : container) // by (non-const) reference, for modify element
\end{lstlisting}            		
		
		
		\item Although you don't need to use the star symbol explicitly, it can provide more clarity about the variable, especially when dealing with pointers inside a container. Therefore, I recommend using this style for pointer-type elements.
\begin{lstlisting}[numbers=none]
for(auto *ptr: Container){ ptr->change();} 
for(const auto *ptr: Container){ ptr->read();} //Container contain pointer
\end{lstlisting}		
		
	\end{itemize}

	 To move all zero elements to the end of a \texttt{std::vector}, you can't directly use \texttt{std::remove} because it only shifts non-zero elements forward, leaving the remaining elements unchanged (which might not be zeros). After using \texttt{std::remove}, you can then use \texttt{std::fill} to set all elements from the position of the last non-zero element to the end of the vector to 0. This strategy is analogous to techniques used in interview questions where you might need to delete a specific node. Instead of removing the node directly, you can overwrite its value with the value of the next node and then delete the next node, achieving the desired outcome without rearranging the entire structure. Using \texttt{std::fill} after \texttt{std::remove} is not only efficient but also ensures that the vector maintains its size and all elements are correctly positioned as required.
\begin{lstlisting}[frame=single, language=c++]	
void moveZeroes(vector<int>& nums) {
	auto i = remove(begin(nums),end(nums), 0);
	fill(i, end(nums), 0);
}			
\end{lstlisting}
	
	\par Find the first unique character in a string. For example, "abcabef" is string, return position 2, because letter 'c' is the first unique character in the string. Here mainly demonstrate how to use \texttt{std::unordered\_map}.
\begin{lstlisting}[frame=single, language=c++]	
int firstUniqChar(string s) {
	unordered_map<char, pair<int, int> > dic; //<occurrence, position>
	for(int i = 0;i<s.length();++i){
		if(dic.find(s[i]) != dic.end()){
			dic[s[i]].second++;
		}
		else{
			dic[s[i]] = {i, 1};
		}
	}	
	int pos = INT_MAX;
	for(auto &e :dic){
		if(e.second.second == 1 && e.second.first <pos){
			pos = e.second.first;
		}
	}
	return pos ==INT_MAX? -1: pos;
	
	//below is C++ 20 version. we use two different views. It's more clear. 
	auto vv = dic | views::values | views::filter( [](auto p){ return p.second == 1; });
	auto rr = ranges::min_element(vv, {}, &pair<int, int>::first ) ;
	cout<<(*rr).first;
}		
\end{lstlisting}
	
	\par Unigram statistic, use \texttt{max\_element} with customized comparison function. 
\begin{lstlisting}[frame=single, language=c++]
vector nums	= {1, 1, 1,  2, 2, 3};
unordered_map<int, int> dic;
for(auto e : nums){ 
	++dic[e]; //If e is not in dic, dic[e] insert default value automatically.
}
auto i = max_element(begin(dic),end(dic), [](auto &e, auto &e1){  //C++11 
	                            				return e.second< e1.second;
	                           		      });	                          
	                           		       		      
//C++20, it's more clear, decltype(dic)::value_type is good style here.
auto i = ranges::max_element(begin(dic),end(dic), {}, 
                                   &decltype(dic)::value_type::second);

return i->first; // return 1, 1 occurs three times.		
\end{lstlisting}	
	
	%\item Find a single number. 
	%\begin{lstlisting}[frame=single, language=c++]	
	%int first = nums[0];
	%int result = accumulate(next(begin(nums)), end(nums), first, [](auto e, auto e1){ return e^e1; });
	%return result;	
	%\end{lstlisting}	
	
	\par Useful code to print variable. 
\begin{lstlisting}[frame=single, language=c++]
#define watch(x) cout << (#x) << " is " << (x) << endl; //# is command inside #define
\end{lstlisting}
	
		

	
	\par Find all digit occurrences in a collection. Below is a useful code pattern: three steps about \texttt{p}. 
\begin{lstlisting}[]
auto ll = [](char c){ //define lambda, because we will resue it
	return ::isdigit(c); 
};
auto p = str.begin();                                        //1) init p
while( (p = std::find_if(p, str.end(), ll)) != str.end()){   //2) test p inside while
	cout<<distance(str.begin(),p)<<endl; 
	p+=1;                                                    //3) update p.
}	
\end{lstlisting}
\begin{description}
	\item[line 5] For string, there are two ways to index a position: index (size\_t) and iterator (auto). If you use common algorithm \texttt{std::find\_if}, then later you have to use \texttt{str.end()}, you can't use \texttt{string::npos} here.
	
\end{description}	
	
	%	\item Usage of \texttt{std::generate\_n}.
	%\begin{lstlisting}[numbers=none]
	%srand(time(NULL));  //#include} ctime and cstdlib, then srand(time(NULL))
%vector<int> v1;
%generate_n(back_inserter(v1, begin(v1)) , 5, [](){return rand()%10;} );			
%\end{lstlisting}



\chapter{Functional programming}

\section{Introduction}
	
	 Functional programming introduces algebraic data types: \texttt{std::optional} and \texttt{std::variant}. It aligns closely with generic programming in C++, encouraging programmers to focus on higher-level abstractions rather than hardware-specific details. Ideally, mutable state (such as stack or global variables) and imperative loops should be avoided, replaced instead with direct use of STL algorithms. An example can be illustrated as shown below: in this code, \texttt{open\_file} and \texttt{count\_lines} are two functions. The C++20 ranges library enhances readability and expressiveness by replacing traditional loop constructs with more functional-style algorithms, promoting clearer, more maintainable code.
	
\begin{lstlisting}[frame=single, language=c++]
std::vector<int> count_line_in_files(const vector<string> file_names){
	return file_names|transform(open_file)|transform(count_lines)
}
\end{lstlisting}	
		
	\par Functions that accept other functions as arguments or return new functions are known as higher-order functions, a fundamental concept in functional programming. There are four primary types of higher-order functions: fold, map, filter, and lift. Let's explore each concept:
\begin{itemize}
	\item \textbf{Fold}: Also known as reduce, this function applies a binary operation to an initial value and all elements of a list, returning a single aggregated result.
	
	\item \textbf{Map}: This function transforms each element of a list using a given function, producing a new list of transformed elements.
	
	\item \textbf{Filter}: It selectively removes elements from a list based on a predicate function, returning a new list containing only those elements that satisfy the predicate.
	
	\item \textbf{Lift}: Often used in the context of lifting a function from operating on simple values to operating on values wrapped in a wrapper class (like \texttt{std::optional}, \texttt{std::variant}, etc.) or container, allowing operations to be performed in a more generalized manner.
	
\end{itemize}
	
	These higher-order functions promote a declarative style of programming, emphasizing composition and immutability, which are core principles of functional programming.
		
	
	\par In general, folding, also known as reduction, does not mandate that the arguments and the result of the binary function passed to it must have the same type. In C++, we utilize \texttt{std::accumulate()} to implement folding. This function aggregates the elements of a sequence using a specified binary operation, starting with an initial value.
	
\begin{lstlisting}[frame=single, language=c++]
int f(int previous_count, char c){
   	return c!='\n'? previous_count: previous_count+1;
}
   
int count_lines(const string &s){
   	return accumulate(begin(s), end(s), 0, f); //0 is init value of R
}                                        //f: (R, T) -->R R is int, T is char here.
\end{lstlisting} 
		


	\par The erase-remove idiom and erase-find idiom are common examples of filtering in C++. The erase function is a container operation, while \texttt{find\_if} and \texttt{remove\_if} are STL algorithms used for filtering elements based on specific criteria.
	
\begin{lstlisting}
people.erase(remove_if(people.begin(), people.end(), is_not_female), people.end()); 
//erase+remove idiom

std::string trim_left{std::string s){  // erase+find idiom
		s.erase(s.begin(), std::find_if(s.begin(), s.end(), is_not_space));
		return s;
	}
\end{lstlisting}


	\par \texttt{std::transform} is an example of mapping in C++. It applies a function to each element of the input container and returns a value for each element in the output container. \texttt{std::for\_each} is essentially a range-based for loop. While using a lambda with \texttt{std::for\_each} is syntactically valid and useful in certain cases, a range-based for loop often provides cleaner and more readable code. However, \texttt{std::for\_each} can simplify syntax when a function is used instead of a lambda.
	
	
\begin{lstlisting}
int op_increase (int i) { return ++i; }
std::vector<int> foo;
std::vector<int> bar;

for (int i=1; i<6; i++)
  foo.push_back (i*10);                         // foo: 10 20 30 40 50

bar.resize(foo.size());                         // allocate space
std::transform(begin(foo),end(foo),begin(foo),op_increase); //11 21 31 41 51
                                                  
// std::plus adds together its two arguments: foo: 21 41 61 81 101
std::transform(foo.begin(),foo.end(),bar.begin(),foo.begin(), std::plus<int>{});
\end{lstlisting}


\section{Lambda}
\subsection{Lambda basic syntax}

	 
	 
	 Here is the basic syntax for a lambda expression and an example. Pay attention here: \texttt{divisor} is passed by copy. If you modify \texttt{divisor} inside the lambda, it does not affect \texttt{divisor} outside and this is different from \texttt{sum}.

\begin{lstlisting}
[ captures ] (parameters) -> returnTypesDeclaration { ..; }

int sum = 0, divisor = 3; //An example
vector<int> vc { 1, 2, 3, 4, 5, 10, 15, 20, 25, 35, 45 };
for_each(vc.begin(), vc.end(), [divisor, &sum] (int y){
	if (y % divisor == 0){
		sum += y;
	}
});
\end{lstlisting}

	\par Generalized capture(C++14). Adding new member variables to closures or moving objects into closures. 
\begin{lstlisting}
auto myfun1 = [i = 5](int x){return x+i;} //add int i into the closure.
ExpensiveToCopyType f{} ....  //move object into the closure
auto myfun2 = [ cf = std::move(f) ](int x) {return cf(x);}
\end{lstlisting}

	\par You need to add mutable if you want to change the value captured by copy because the \texttt{operator()} inside a lambda is implicitly \texttt{const} by default. A by-value capture cannot be modified in a non-mutable lambda.
\begin{lstlisting}
int n = 1;
auto l1 = [&](){n = 10;}();             // OK
auto l2 = [=]() mutable {n = 20;}();    // OK
//auto l3 =  [=](){n = 10;}();          // Error: 

\end{lstlisting}

%	\item When lambda is used on complex type container. You can use typedef to save typing, remember, typedef is your good friend. This code is an example of Old C++, not modern one. In modern C++, you can use \texttt{using} alias to replace typedef. A better way is to use "generic lambda" with auto parameter. 
%\begin{lstlisting}[frame=single, language=c++, mathescape=true]
%typedef std::vector< std::pair<int,std::string> > Record_t;
%Record_t k1;
%
%int find_it(std::string value, Record_t const& stuff){
%  auto fit = std::find_if(stuff.begin(), stuff.end(),
%            [value](Record_t::value_type const& vt) -> bool 
%                 { return vt.second == value; });
%  if (fit != stuff.end())
%           return fit->first;
%}
%\end{lstlisting}

	\par This auto-declaration defines a closure type variable \texttt{factorial} that you can call later instead of typing out the entire lambda expression. (A closure type is actually a compiler-generated, unnamed functor class.)
\begin{lstlisting}[numbers=none]
auto factorial = [](int i, int j) {return i * j;};

int arr{1,2,3,4,5,6,7,8,9,10,11,12};
long res = std::accumulate(arr, arr+12, 1, factorial);
cout<<"12!="<<res<<endl; // 479001600 = 1*2*3....
\end{lstlisting}

	\par Under the final C++11 specification, if you have a lambda with an empty capture specification [], it can be treated like a regular function and assigned to a function pointer. Here's an example of using a function pointer with a capture-less lambda:

\begin{lstlisting}[numbers=none]
typedef int (*func)();
func f = [] () -> int { return 2; }; //assign it to a function pointer. 
f(); // call this lambda by function pointer
\end{lstlisting}


	\par A delegate idea. \texttt{std::for\_each} accept a normal function, but we can delegate this function to a object's member function. 
	
\begin{lstlisting}[numbers=none]
class MessageSizeStore{
public:
    MessageSizeStore () : _max_size( 0 ) {}
    void checkMaxMessage (const std::string& message ) {...}
    int getSize (){...}
private:
    int _max_size;
};

// lambda is like a glue to combine for_each and class MessageSizeStore.
MessageSizeStore size_store;
for_each(s.begin(),s.end(), [&] (const std::string& message){
	size_store.checkMessage( message );
});
\end{lstlisting}

	\par A functor is often preferred over a function pointer because it can be inlined. Similarly, a lambda is preferred over a functor because it creates an unnamed functor class, avoiding namespace pollution. Additionally, lambdas can be inlined, access automatic variables, and are less verbose, enhancing code clarity by keeping the code closer to where it's called.



\subsection{Generic lambda and auto return}
	
		 Generic lambda was introduced in C++14. They use \texttt{auto} as a parameter, allowing the lambda to accept arguments of any type. Behind the scenes, this generates a templated member operator(), enabling the lambda to work with various types.
\begin{lstlisting}
auto glambda = [] (auto a) { return a; };

class /* unnamed */ {
public:
    template<typename T>
    T operator () (T a) const { return a; }
};
\end{lstlisting}

		\par With the help of generic lambda, you can see that the code has become very clear and short compared to C++11. Please remember the examples below; they are very good.

\begin{lstlisting}
// C++11: have to state the parameter type
for_each( begin(v), end(v), [](decltype(*cbegin(v)) x) { cout << x; } );
sort( begin(w), end(w), [](const shared_ptr<some_type>& a, 
                           const shared_ptr<some_type>& b) { return *a<*b; } );

// C++14: just deduce the type
for_each( begin(v), end(v), [](const auto& x) { cout << x; } );
sort( begin(w), end(w), [](const auto& a, const auto& b) { return *a<*b; } );
\end{lstlisting}

		\par Another example of a generic lambda is shown below. Note that this new version of \texttt{getSize} is not limited to any specific type; it can be invoked with any type that has a \texttt{size()} member function. Furthermore, because it implicitly deduces the return type, the return type will be whatever \texttt{m.size()} returns, which can vary depending on the input. This demonstrates the flexibility and power of generic lambdas. This is a good example of how generic lambdas can simplify code and enhance reusability by allowing functions to operate on a wide range of types.

\begin{lstlisting}
auto getSize=[](const unordered_map<string, vector<string>>& m){return m.size();};

auto getSize = [](const auto& m) { return m.size(); }; // C++14: expressive power
\end{lstlisting}

		\par C++14 supports return type deduction by using \texttt{auto}. The restriction is: All returned values must be of the same type.

\begin{lstlisting}
auto f() { return foo() * 42; } // ok, deduces "-> some_type"

auto g() {         // ok, deduces "-> some_type"
    while( something() ) {
        if( expr ) {
            return foo() * 42;   // with arbitrary control flow
        }
    }
    return bar.baz(84);        // & multiple returns
}              
\end{lstlisting}

		\par In C++14, we also support auto return type deduction in lambda. 

\begin{lstlisting}
template <typename A, typename B> //C++ 11
auto do_something(const A& a, const B& b) -> decltype(a.do_something(b)){
  return a.do_something(b);
}

template <typename A, typename B> //C++ 14
auto do_something(const A& a, const B& b){
  return a.do_something(b);
}// We don't need to follow trailing type.
\end{lstlisting}

		\par \texttt{decltype(auto)} is primarily useful for deducing the return type of forwarding functions and similar wrappers, where you want the type to exactly “track” some expression you’re invoking. More details can be found in the "Generic Programming" chapter under the "decltype" section. Here’s a brief example to illustrate its use. 
		
\begin{lstlisting}
string  lookup1();
string& lookup2();
string  look_up_a_string_1(){ return lookup1(); }
string& look_up_a_string_2(){return lookup2();} //hope to return reference here

decltype(auto) look_up_a_string_1() { return lookup1(); } //same as previous 
decltype(auto) look_up_a_string_2() { return lookup2(); } //C++ 14 idiom
\end{lstlisting}


\section{Range}
	In the range library: There are three components:
\begin{enumerate}
	\item Concepts: these concepts are basic building block of range library. You can also use them when you building your own range container. 
	
	\item Constrained algorithms: these algorithms accept an range or a sentinel, don't need to input two same type iterators. It also supports projection. 
	
	\item The views: This is a range that doesn’t own the elements that the begin/end points to. A view is cheap to create, copy and move. There are three characteristics with view: 1) it will not affect original input data range, 2) it uses "evaluated lazily" 3) it can be combined, you can use pipe operator to combine different view together.  
	
\end{enumerate}

\subsection{range concept and sentinel}

	 Basic range concepts definition and list.

\begin{lstlisting}
template <typename R> //core concept: range
concept range = requires(R &r) {
	std::ranges::begin(r);
	std::ranges::end(r);
};

template< class T > //input_range
concept input_range =
ranges::range<T> && std::input_iterator<ranges::iterator_t<T>>;

template< class T > //forward_range
concept forward_range =
ranges::input_range<T> && std::forward_iterator<ranges::iterator_t<T>>;				
\end{lstlisting}


	\par There are two special range concept in C++20, one is sized\_range, the other is borrowed\_range. The sized\_range concept in C++20 is part of the Ranges library, which introduces a new way to work with sequences of elements. The sized\_range concept specifically applies to ranges that have a known size, meaning that it provides a constant-time \texttt{size()} member function or can otherwise be queried for its size in constant time. 

	\par In the following code, the reason for the extra \texttt{ !disable\_sized\_range<remove\_cvref\_t<T> >} check is that some types can meet the syntactic requirements of \texttt{ranges::size} without meeting the semantic requirement that this call must have constant time. For instance, \texttt{MyLinkedList} had O(N) size(), but this wouldn’t be detectable, so the type trait exists to allow for such containers to opt out of being considered sized\_ranges.
\begin{lstlisting}
namespace std{
	// MyLinkedList has O(n) size.
	template <typename T>
	constexpr bool disable_sized_range<MyLinkedList<T> > = true;
}	

template<class T>
concept sized_range = range<T> && !disable_sized_range<remove_cvref_t<T>> &&
requires(T& t) { ranges::size(t); };	
\end{lstlisting}
	
\begin{center}
	\begin{tabular}{|c|c|}
		\hline
		\textbf{concept} & \textbf{model}  \\
		\hline
		ranges::input\_range & \texttt{std::istream\_iterator} \\
		\hline
		ranges::output\_range & \texttt{std::back\_insert\_iterator} \\
		\hline
		ranges::forward\_range & \texttt{std::forward\_list} \\
		\hline
		ranges::bidirectional\_range & \texttt{std::list} \\
		\hline
		ranges::random\_access\_range & \texttt{std::deque} \\
		\hline
		ranges::contiguous\_range & \texttt{std::vector} \\
		\hline
		common\_range & sentinel is same type as iterator, \texttt{views::common} \\
		\hline
		
		borrowed\_range & \texttt{std::string\_view}, \texttt{std::span} \\
		\hline
		
		sized\_range & size is constant time \\
		\hline
		
		view & copy is constant time \\
		\hline
	\end{tabular}	
\end{center}
	
%	ranges::distance, get size of range( linear complexity);  ranges::empty, ranges::data. 
	
	\par The temporary returned by \texttt{get\_vector()} will be destroyed at the end of the statement, meaning that it will be unsafe to use – it is a dangling iterator. The solution in C++20 is to have a special type, \texttt{std::ranges::dangling}, which algorithms use in their return types instead of potentially-dangling iterators when passed an rvalue range. This type does not provide any operations, so if you try to use it like an iterator you’ll get a handy error message involving the dangling type. Detail can be found in the article "Rvalue Ranges and Views in C++20".
\begin{lstlisting}
vector<int> get_vector(){...}

auto min_val = ranges::min_element(get_vector()); //return a dangling iterator
cout<< *min_val; // Error, no operator* in std::ranges::dangling
\end{lstlisting}

	\par Dangling iterators are a potential problem for most kinds of ranges – we need to be careful to make sure that we do not use a \texttt{std::vector} iterator after the parent object has been destroyed. However, this is not the case for all ranges though. A \texttt{std::string\_view}’s iterators for example actually point into some other character array – so we can safely use a \texttt{string\_view::iterator} after the \texttt{string\_view} itself has been destroyed. Types like \texttt{std::string\_view} are called borrowed ranges in the new C++20 terminology. A borrowed range is one whose iterators can safely outlive their parent object. So an rvalue \texttt{std::vector} is not a borrowed range, but an rvalue \texttt{std::string\_view} is.
\begin{lstlisting}
std::string str = "Hello world";
auto iter = std::string_view{str}.begin(); //iter's parent object is string_view.
*iter = 'h'; // Weird, but okay:

auto iter = std::ranges::min_element(get_span());
// iter is an iterator, *not* ranges::dangling
\end{lstlisting}

	\par By default, all rvalue ranges are assumed to be non-borrowing. If we have a custom type whose iterators can safely “dangle” (say, a custom StringRef type) then we can opt in to allowing the ranges machinery to consider it borrowed by specialising the \texttt{enable\_borrowed\_range} trait. \texttt{std::enable\_borrowed\_range} is a opt-in idea, detail can be seen in a a good article is "C++20 concepts are structural: What, why, and how to change it?".
\begin{lstlisting}
template <>
inline constexpr bool std::ranges::enable_borrowed_range<my::StringRef> = true;

template< class R >
concept borrowed_range = ranges::range<R> &&(std::is_lvalue_reference_v<R> || 
                         ranges::enable_borrowed_range<std::remove_cvref_t<R>>);
\end{lstlisting}

%	\par The following example uses the \texttt{sentinel\_for} concept to show that \texttt{vector<int>::iterator} is a sentinel for \texttt{vector<int>}.
%\begin{lstlisting}
%std::vector<int> v = {0, 1, 2};
%std::vector<int>::iterator i = v.begin();
%// show that vector<int>::iterator is a sentinel for vector<int>
%cout<< std::sentinel_for<std::vector<int>::iterator, decltype(i)>; //true
%\end{lstlisting}
	


\subsection{Constrained algorithms}
		
	C++20 provides constrained versions of algorithms in the namespace \texttt{std::ranges}. The \texttt{std::ranges} namespace includes many of the algorithms from the traditional <algorithm> header, but with added constraints to ensure better compile-time checking and improved generic programming support. The main differences lie in the parameter they can received and the return type.
		 
		
	\par In these constrained algorithms, a range can be specified as either a iterator-sentinel pair or as a single range argument. These algorithms work seamlessly with the new range concepts, such as sized\_range, view, and common\_range.
\begin{lstlisting}
std::string s("hello");
namespace ranges = std::ranges;
ranges::transform(s.begin(), s.end(), s.begin(),    // support two iterator
[](unsigned char c) -> unsigned char { return std::toupper(c); });

std::vector<std::size_t> ordinals;  
ranges::transform(s, back_inserter(ordinals), [](unsigned char c) -> size_t 
                                                 { return c; });
\end{lstlisting}

		\par The basic idea of a sentinel is as follows:
	\begin{itemize}
		\item Whenever you have a range where the end is determined by a dynamic condition rather than a fixed position, use an iterator and sentinel pair instead. Here are a few scenarios:
		\begin{enumerate}		
			\item Stop never (get an infinite range).
			\item Stop after N increments (to get a counted range).
			\item Stop when a '$\backslash$0' is encountered (for looping over C-strings).
			\item Stop when it's 12 o'clock (for having lunch), and so on.
		\end{enumerate}
		
		\item To support this, existing algorithms only need to change their signatures to accommodate the sentinel.
		
		\item We can solve any problem by introducing an extra level of indirection, except for the problem of too many levels of indirection :). 
	\end{itemize}
	
	
	%\begin{lstlisting}
	%struct Sentinel {}; // Empty tag type.
	%// Check whether the associated iterator is done.
	%bool operator==(iterator iter, Sentinel s);
	%
	%template <typename I, typename S>
	%void algorithm(I begin, S end); //constrained algorithms	
	%\end{lstlisting}
	
	
%	\par Based on the previous introduction, we can provide a code example to illustrate the use of a sentinel. In this example, you can implement any check you want in the is\_at\_end function. 
	
	
	%\begin{lstlisting}
	%struct My_iterator;    //some iterator
	%struct My_sentinel{
		%	bool is_at_end(My_iterator it) const{
			%		//here implement the logic when the iterator is at the end
			%	}
		%};
	%
	%auto operator==(My_iterator it, My_sentinel s)  { 
		%	//also for (my_sentinel s, My_iterator it)
		%	return s.is_at_end(it); 
		%}		
	%\end{lstlisting}	
	
	\par An sentinel example when using char pointer, in this context, we only need to build a sentinel class and overload its \texttt{== operator}, one of parameter can be \texttt{auto} type.  Another thing need to know, you have to use \texttt{std::ranges::copy}, not \texttt{std::copy}. Only \texttt{std::ranges::copy} supports sentinel concept. 
	
\begin{lstlisting}
struct Zstring_sentinel { // Empty type.
	bool operator==(auto iter) const{ // you must put const here. 
		return *iter == '\0';         // otherwise compile fails!!
	}
};

std::vector<char> buffer;
std::ranges::copy(str, Zstring_sentinel{}, std::back_inserter(buffer));	
\end{lstlisting}		
			
		\par Projections and pointer-to-member callables (pointer to member function and pointer to member data) are supported. This is because \texttt{std::invoke} is used inside constrained algorithms. For more details, refer to "C++20 Ranges, Projections, \texttt{std::invoke} and if constexpr".
\begin{lstlisting}
std::vector vec { -1, 2, -3, 4, -5, 6 };
auto print = [](int i) { std::cout << i << ", "; };

std::ranges::sort(vec, {}, [](int i) { return std::abs(i); }); //projections
std::ranges::for_each(vec, print);	
\end{lstlisting}

\begin{lstlisting}
struct Employee {
	string _name;
	void printName(void) {cout<<_name<<endl;}
};

vector<Employee> v = {{"a1"}, {"a2"}, {"a2"} };	
ranges::for_each(v, &Employee::printName); //pointer member function here.
\end{lstlisting}

	 \par Behind the projection in the constrained algorithms is \texttt{std::invoke}, \texttt{std::invoke} brings to the table is that you can use it for other things beyond just functors.
\begin{lstlisting}
struct S{
	void do_something(int);
	int v;
};

S s;
std::invoke(&S::do_something, s, 42); // same as s.do_something(42)
std::invoke(&S::do_something, std::ref(s), 42);

S* p = &s;
std::invoke(&S::do_something, p, 42);//p is pointer, invoke means p->do_something(42)	
\end{lstlisting}

	\par You can also use \texttt{std::invoke} with pointers to non-static data members.
\begin{lstlisting}
struct S{
	std::function<void()> do_something;
	int v;
};
S s;
s.do_something = []() { std::cout << "hello"; };

std::invoke(&S::v, s) = 42; // same as s.v = 42
auto x = std::invoke(&S::v, s); // same as "auto x = s.v;"
std::invoke(&S::do_something, s); //do_something is data member pointer, no output
std::invoke(&S::do_something, s)();            //output "hello"
std::invoke(std::invoke(&S::do_something, s)); //output "hello" too	
\end{lstlisting}

	\par The return types of some constrained algorithms have been changed to include all potentially useful information computed during the execution of the algorithm:
	
	\begin{itemize}
		
		\item ranges::in\_in\_result and ranges::min\_max\_result have better descriptive name compared with pair when we use \textbf{ranges::mismatch} and \textbf{ranges::minmax}.

\begin{tabular}{| p{0.26\textwidth} |p{0.3\textwidth}|p{0.3\textwidth}|}
	\tophline 
	ranges::in\_in\_result & \specialcell[t]{  ranges::mismatch \\ ranges::swap\_ranges} &  
	\\ \hline
	ranges::min\_max\_result & \specialcell[t]{  ranges::minmax \\ ranges::minmax\_element} &  
	
	\bottomhline
\end{tabular}

%\begin{lstlisting}
%auto res1 = std::ranges::for_each_n(v, std::size(v),
%[](int& x) { return x = -x; } // negating lambda
%);
%assert(res1.in == std::end(v));	
%ranges::for_each(v, res1.fun); 	
%\end{lstlisting}


		
		\item unlike the traditional std algorithms, the ranges ones take an iterator and a sentinel. The only thing you can do with a sentinel (that is not itself an iterator) is to compare it with an iterator. If they compare equal, it means the end of range is reached. Since a sentinel is less useful that an iterator, and these algorithms need to get an end iterator anyway, they return extra iterator to not lose valuable information. For example, in the table below, \textbf{std::copy} only return one iterator to the end of destination, but \textbf{ranges::copy} need to another in to the end of source. All ranges::in\_* result type have this semantic. 
		
\begin{tabular}{| p{0.26\textwidth} |p{0.34\textwidth}|p{0.27\textwidth}|}
	\tophline 

	ranges::in\_out\_result & \specialcell[t]{  ranges::copy(\_if)(\_n)(\_backward) \\ ranges::move(\_backward) \\
		ranges::transform \\
		ranges::replace\_copy(\_if) \\
		ranges::unique\_copy \\
		ranges::reverse\_copy \\
		ranges::rotate\_copy \\
		ranges::partial\_sort\_copy \\
		ranges::set\_difference \\
		
	} & in is an iterator to the end of the source range, and out is an iterator to the end of the destination range. They all related two ranges and one is for input, the other is for output. 
	
	\\ \hline
	ranges::in\_in\_out\_result & \specialcell[t]{  ranges::transform \\ ranges::merge \\
		ranges::set\_union \\
		ranges::set\_intersection \\
		ranges::set\_symmetric\_difference \\
	} &  std::merge only return one OutputIt iterator.
	
	\\ \hline
	ranges::in\_out\_out\_result & \specialcell[t]{  ranges::ranges::partition\_copy 
	} &  std::partition\_copy only return pair two outs
	
	\\ \hline
	ranges::in\_found\_result & \specialcell[t]{  ranges::ranges::next\_permutation \\ ranges::ranges::next\_permutation} &  
	
	\\ \hline
	ranges::in\_fun\_result & \specialcell[t]{  ranges::ranges::for\_each \\ ranges::ranges::for\_each\_n} &  The \texttt{in} component is an iterator to the end of the source range.
	

	
	\\ \hline
	ranges::out\_value\_result & \specialcell[t]{  ranges::iota } &
	

	
	\bottomhline
\end{tabular}

\begin{lstlisting}
constexpr char in[] = "transform" "\n"; 
//Compiler automatically concatenates two string literals during compilation
std::array<char, sizeof(in)> out;
const auto result = std::ranges::transform(in, out.begin(), [](char c){ 
	return std::toupper(c); 
});

auto print = [](char c) { std::cout << c; };
std::ranges::for_each(std::cbegin(in), result.in, print);//cbegin non member function.
std::ranges::for_each(out.cbegin(), result.out, print);	 //cbegin member function.	
\end{lstlisting}


\begin{lstlisting}
std::array<int, 4> a{};
constexpr std::array expected{2, 3, 4, 5};
const auto result = std::ranges::iota(a, 2);
assert(std::ranges::distance(a.cbegin(), result.out) == 4);
assert(result.value == 6);
assert(a == expected);	
\end{lstlisting}
		
		
	\item \texttt{std::ranges::fill} and \texttt{std::ranges::generate} return an iterator to the end of the destination range. (The std algorithms return nothing.)
	
	\item For \texttt{std::ranges::find\_last\_if}, it returns an iterator to the element it finds and an end iterator. They naturally form a subrange. If you don't need the end iterator, you can extract the first iterator using \texttt{subrange::begin()}. \texttt{ranges::search} also return subrange, while \texttt{std::search} return iterator.

\begin{tabular}{| p{0.26\textwidth} |p{0.34\textwidth}|p{0.27\textwidth}|}
	\tophline 
	

	subrange & \specialcell[t]{  ranges::search(find\_end) \\
		ranges::search\_n \\
		ranges::find\_last(\_if) \\
		ranges::remove/unique \\
		ranges::rotate \\
		ranges::partition \\
		ranges::shift\_left(right) \\
		
	} & std::find only returns iterator
	
	\bottomhline
\end{tabular}
	

\begin{lstlisting}
const auto it = std::ranges::find_last_if(data, func).begin(); //it is subrange

auto [it, end] = ranges::search(haystack, needle); //found is subrange.
std::distance(haystack.begin(), it);

\end{lstlisting}

	
%	\item Return subrange is easier for better for continuous operation than return single iterator. For example,
		
	
	\end{itemize}
	
\par Summary: 
\begin{itemize}
	\item If std:: version return bool or count, then ranges:: version also return the same value. 
	
	\item If std:: version has no return value, then ranges:: version will return one iterator points to the ends. such as std::fill, std::generate, std::replace, std::shuffle.
	
	\item If std:: version return out iterator, then ranges:: version will return ranges::in\_(*), detail can be found in the above table. 
	
	\item Some ranges:: return subrange. 1) search 2) remove/unique 3) rotate, shift and partition. 
\end{itemize}

%\begin{center}
%	\includegraphics[width=0.90\linewidth]{pics/ca.png}
%\end{center}
	

	

\subsection{View}

\subsubsection{Basic views usage}
	
	 Views are simply ranges that are cheap to copy and move (in constant time). Due to this, a view does not own the elements it is viewing. An exception to this rule is \texttt{std::views::single}, which owns the single element it is viewing. Creating a view prepares for future work but does not execute any operations immediately; work occurs only when accessing an element within the view.
	
\begin{lstlisting}
//'string::substr' returns a new string, it's memory-instensive.
std::cout << str.substr(5, 15) << '\n';

//better style, no dynamic allocation, no new memory.
cout<<string_view(str|views::drop(5)|views::take(15))<<endl;
\end{lstlisting}


	\par Instead of using two iterators to specify a subrange, we can achieve similar functionality by using different views. Let's compare the iterator-based version with the view-based version.
\begin{lstlisting}
std::sort(v.begin() + 5, v.end())
std::sort(v.rbegin(), v.rend());
std::sort(v.rbegin() + 5, v.rend());

std::ranges::sort(std::views::drop(v, 5)); // more clear
std::ranges::sort(std::views::reverse(v));
std::ranges::sort(std::views::drop(std::views::reverse(v), 5));		
\end{lstlisting}		
	
	\par Elements of a view are usually the actual elements of the range used to create the view. The view usually doesn't own the elements; it just refers to them, with the exception of \texttt{owning\_view}. Changing an element in views will changes that element in the range that the view was created from. The following example shows this behavior:
	
\begin{lstlisting}
int input[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
auto even = [](const int n) { return n % 2 == 0; };
auto x = input | std::views::filter(even); //create a view of the even elements.

std::ranges::fill(x, 42); // changes the even in input[] to 42
					//  input is 42 1 42 3 42 5 42 7 42 9 42 now.
\end{lstlisting}

	\par Views in C++20 ranges are non-owning, which means they don't store their own data. Instead, they provide a different way of accessing the elements of an underlying range (e.g., a \texttt{std::vector}, \texttt{std::array}, or another view). Therefore, if the underlying range changes, the view will reflect those changes.
	
\begin{lstlisting}
 std::vector Nums{3, 1, 5, 2, 4};
std::ranges::subrange View{Nums};
std::ranges::for_each(View, Log); //3, 1, 5, 2, 4
std::ranges::sort(Nums);
std::ranges::for_each(View, Log); //1, 2, 3, 4, 5
\end{lstlisting}

	\par Pay attention to view and adapter, usually we use adapter more. Three different ways to use views. We recommend to use the first and the second method.
\begin{lstlisting}
std::ranges::views::stride //this is an adaptor, change input range to stride_view
std::ranges::stride_view   // this is a view class. that is class name
	
std::vector<int> v {0,1,2,3,4,5,6,7,8};

print("{}\n", std::views::stride(v,3));   //1) using functor notation, [0, 3, 6]
print("{}\n", v | std::views::stride(3)); //2) using pipeline notation.

std::ranges::stride_view sv2 {v,3};       //3) using an explicit view object.
// stride_view is in ranges:: namespace, but stride is in views:: namespace.
print("{}\n", sv2);  
\end{lstlisting}
	
	\par We can use pipeline operator \texttt{|} to combine a serials of view adapters together. \texttt{view::take} is an adapter, it input a number, then return an anonymous view. 
\begin{lstlisting}
std::vector<int> v{0,1,2,3,4,5,6,7,8};
for(int n : v | std::views::take(6) | std::views::drop(2)
  | std::views::filter( [](auto& e){return e%2 == 0;} )
  | std::views::transform( [](auto& e){return e*e; } ) ) {
	std::cout << n << ' ';  //output 4 and 16
}	
\end{lstlisting}

	\par \texttt{views::reverse} represents a view of underlying view with reversed order.
\begin{lstlisting}
vector v {3, 1, 4, 1, 5, 9};	
for (auto i : il | std::views::reverse)
std::cout << i << ' ';	
\end{lstlisting}		

	\par Projections views: \texttt{views::keys}, \texttt{views::values}, \texttt{views::elements}. \texttt{views::keys} applies a projection to extract keys from elements. It is typically used with associative containers or ranges of pairs or tuples where the first element represents a key. \texttt{views::elements} allows you to extract a specific element from a range of tuples or pairs, making it a concise way to access individual elements. \texttt{std::views::elements<0>} extracts the first element (e.g., first from a \texttt{std::pair} or the 0th element from a \texttt{std::tuple}).
\begin{lstlisting}
std::vector<std::pair<char,int>> v {{'b',3},{'a',4},{'z',2},{'k',9}};
print("{}\n", v | std::views::keys); // [b,a,z,k]
print("{}\n", v | std::views::values); // [3,4,2,9]

std::vector<std::tuple<char,int,std::string>> v {
	{'b',3,"hearts"}, {'a',4,"clubs"}, {'z',2,"spades"}, {'k',9,"diamonds"} };
print("{}\n", v | std::views::elements<2>);	

std::map<std::string, int> m{{"CPU", 10}, {"GPU", 15}, {"RAM", 20}};
for(auto &e: m|views::keys){
	cout<<e<<endl; //e ="abc" error, because e is const string &
}
for(auto &e: m|views::values){
	e =40; //ok, because e is not const
}
for(auto &[f, s] : m){
	cout<<f<<" "<<s<<endl; //output CPU 40,  GPU 40 and RAM 40.
}
\end{lstlisting}

	\par The ranges library provides three views where all elements have the same value. \texttt{std::views::empty} represents a view with zero elements. \texttt{std::views::single} represents a view with one element. \texttt{std::views::repeat} can represent both finite and infinite views of the same value. Another range factory is \texttt{std::views::iota}. 
\begin{lstlisting}
auto empty = std::views::empty<int>;
// View of a single instance of 42 (int)
auto single = std::views::single(42);
	
auto const r51 = std::views::repeat(1, 5); // 1 1 1 1 1 
auto const r4a = std::views::repeat('a') | std::views::take(4); // a a a a			
	
for (int i : std::ranges::iota_view{1, 10}) //use view object
for (int i : std::views::iota(1, 10))   //use view functor
for (int i : std::views::iota(1) | std::views::take(9))
\end{lstlisting}

\par Element selector views are: \texttt{views::filter}, \texttt{views::stride}.
\begin{lstlisting}
std::vector<int> v {0,1,2,3,4,5,6,7,8};
auto const is_even = [] (int x) { return !(x & 1); };
print("{}\n", v | std::views::filter(is_even)); // [0,2,4,6,8]
print("{}\n", v | std::views::stride(2)); // [0,2,4,6,8]		
\end{lstlisting}	

\par Subrange selector views are: \texttt{views::counted}, \texttt{views::take}, \texttt{views::take\_while}, \texttt{views::drop}, \\ \texttt{views::drop\_while}. Note that \texttt{std::views::counted} is not pipelinable and that there's also no \texttt{std::ranges::counted\_view} type. \texttt{std::ranges::counted\_view} returns \texttt{std::span} if its underlying models contiguous\_iterator, otherwise it returns \texttt{ranges::subrange}.
\begin{lstlisting}
std::vector<int> v {0,1,2,3,4};
print("{}\n", std::views::counted(v.begin()+1, 2)); // [1, 2]
print("{}\n", v | std::views::take(3)); // [0,1,2]
print("{}\n", v | std::views::drop(2)); // [2,3,4]

std::vector<int> v {2,6,7,6,5};
auto const is_even = [] (int x) { return !(x & 1); };
print("{}\n", v | std::views::drop_while(is_even)); // [7,6,5]			
\end{lstlisting}

 \par We can use \texttt{ranges::find} return value directly for next \texttt{views::counted} view. 
\begin{lstlisting}
std::vector<int> v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
auto pos5 = std::ranges::find(v, 5);
auto countedView = std::views::counted(pos5, 5); //5 6 7 8 9	
\end{lstlisting}		

	\par Function application call are \texttt{transform, adjacent\_transform} and \texttt{pairwise\_transform}. They all need to input a functor.
\begin{lstlisting}
auto const to_upper = [] (char c) { 
	return static_cast<char>(std::toupper(static_cast<unsigned char>(c))); 
};	
auto vw = s | std::views::transform(to_upper);
	
std::string s = "abcde";
auto const f3 = [] (char x, char y, char z) { return std::string{'<',x,y,z,'>'}; };
for (auto p : std::views::adjacent_transform<3>(s,f3)) {
	print("{} ",p);  //output is: <abc> <bcd> <cde>
}
\end{lstlisting}
	
	\par Tokenization view are \texttt{split, lazy\_split, chunk}, and \texttt{chunk\_by}.
\begin{lstlisting}
constexpr auto words{"Hello^_^C++^_^20^_^!"sv};
constexpr auto delim{"^_^"sv};

for (const auto word : std::views::split(words, delim)) //word is std::subrange type
// with string_view's C++23 range constructor:
std::cout << std::quoted(std::string_view(word)) << ' ';

std::vector<int> v {1,2,0,2,4,5,8,4,6,3,5,2,4};
for (auto x : std::views::chunk_by(v,std::ranges::less{})){
	print("{} ",x); 
}// [1,2] [0,2,4,5,8] [4,6] [3,5] [2,4]
\end{lstlisting}

	\par Multiple ranges to single range: \texttt{zip, join, join\_with, zip\_transform, cartesian\_product}.
\begin{lstlisting}
std::vector<std::string> v = {"I","am","here","now"};
fmt::print("{}\n", v | std::views::join); // Iamherenow

std::array a {0,1};
std::string s2 = "AB";
std::string s3 = "-+";
fmt::print("{}\n", std::views::zip(a,s2,s3)); // (0,A,-) (1,B,+)
\end{lstlisting}

		\par Another interesting view is \texttt{views::enumerate}, similar with \texttt{views::zip.}
\begin{lstlisting}
std::string s = "ABCD";
for (auto const& [index, value] : std::views::enumerate(s)) {
	std::cout << "@" << index << ":" << value << '\n';
}  // @0:A @1:B @2:C @3:D		
\end{lstlisting}		


	\par Sliding window view returns a range of either tuples or contiguous subranges of the input range. \texttt{views::slide, views::adjacent, views::pairwise}. 

\begin{lstlisting}
std::vector<int> v {0,1,2,3,4};
for (auto x : v | std::views::slide(3)) { fmt::print("{} ",x); } 
// [0,1,2] [1,2,3] [2,3,4]

std::string s = "abcde";
for (auto p : s | std::views::adjacent<3>) {fmt::print("{} ",p); } // abc bcd cde
for (auto p : s | std::views::pairwise) {fmt::print("{} ",p); } // ab bc cd de

for (auto [first, second, third] : v | std::views::adjacent<3>) {
	// iterate over {1,2,3}, {2,3,4}, {3,4,5}
}

for (auto [left, right] : data | std::views::pairwise) {
	// iterate over {1,2}, {2,3}, {3,4}, {4,5}
}	
\end{lstlisting}
	
	\par \texttt{views::split}, \texttt{views::chunk(chun\_by)},  \texttt{views::slide}, \texttt{views::adjacent}, \texttt{views::pairwise}, \\ \texttt{views::zip} all produce a view and element inside the view is a "range" like type. 
	\begin{itemize}
	\item \texttt{views::adjacent} is similar to \texttt{views::slide}, producing a sliding window over the input range. However, where \texttt{views::slide} produces \texttt{std::subrange} (for \texttt{std::list}) or \texttt{std::span} (for \texttt{std::vector}), \texttt{views::adjacent} produces tuples of references to elements. \texttt{views::pairwise} is just alias name of \texttt{views::adjacent<2>}.
	
	\item Element in \texttt{views::split} and \texttt{views::chunk} are \texttt{ranges::subrange}. 
\begin{lstlisting}
vector v{1, 2, 3, 4, 5, 6};
auto wt1 = v|views::slide(3); //[[1 2 3], [2 3 4], ...]  //wt1[0] is ranges::span

auto wt2 = v|views::chunk(2); //[ [1 2], [3 4], [5 6] ]
//wt2[0] is ranges::subrange, not std::pair, because std::pair is not range. 	
\end{lstlisting}	
		
	\item Element in \texttt{views::zip} is \texttt{std::tuple}.  
	\end{itemize}
	
	\par An interesting example is Trigram. 
\begin{lstlisting}
//text is "my name is Yan Zhao"
auto vw = text| views::split(' ') | views::slide(3);
for(auto e : vw){ //e is subrange.
	auto it = e.begin(); //subrange includes counter\_iterator
	auto e1 = string_view{*it}; //*it is subrange, it can input string_view
	++it;                       //counter_iterator only supports ++
	auto e2 = string_view{*it};
	++it;                
	auto e3 = string( (*it).begin(), (*it).end() ); //build string from subrange
	cout<<e1<<" "<<e2<<" "<<e3<<endl;
}

//another method 
auto vw = text| views::split(' ') | views::adjacent(3);
for(auto [e1, e2, e3] : vw){ //views::adjacent return tuple
	....
}
 
//output:
my name is
name is Yan
is Yan Zhao
\end{lstlisting}


	\par \texttt{std::ranges::subrange} combines an iterator and a sentinel (or two iterators) into a view. One use case for \texttt{std::ranges::subrange} is to adapt algorithms and methods that return a pair of iterators. Most of time, we define it directly or it is generated by other views, such as \texttt{views::chunk}. We usually don't use it with pipeline syntax. \texttt{std::ranges::subrange} is class template.
\begin{lstlisting}
std::multiset<int> sorted{1,2,2,3,4,5,5,5,6,7,8,9};
// multiset::equal_range() returns a pair of iterators:
auto [left, right] = sorted.equal_range(5);

for (auto v : ranges::subrange(left, right)){// use subrange to turn it into a range
	// Iterate over {5,5,5}
}

std::vector<int> v {9,1,3,7,4,5,3,8};
auto const srv = std::ranges::subrange(v.begin()+2, v.begin()+6);
for (int x : srv) { std::cout << x << ' '; } // 3 7 4 5
\end{lstlisting}
	


%	\item Below are some range::views defined in STL.  \\
%\begin{tabular}{| p{0.4\textwidth} |p{0.5\textwidth}|}
%	\tophline \specialcell[t]{std::all\_view, std::views::all } &  takes all elements. \\
%	
%	\tophline
%	\specialcell[t]{std::ref\_view }  & takes all elements of another view \\
%	
%	\tophline
%	\specialcell[t]{ std::filter\_view, std::views::filter }
%	& takes the elements which satisfies the predicate \\
%	
%	\tophline
%	\specialcell[t]{ std::transform\_view \\ std::views::transform }
%	& transforms each element \\
%	
%	\tophline
%\specialcell[t]{ std::take\_view, std::views::take  }
%& takes the first N elements of another view \\
%
%
%	\tophline
%\specialcell[t]{ std::take\_while\_view \\ std::views::take\_while }
%& takes the elements of another view as long as the predicate returns true \\
%
%
%	\tophline
%\specialcell[t]{ std::drop\_view, std::views::drop }
%& skips the first N elements of another view \\
%
%	\tophline
%\specialcell[t]{
%std::drop\_while\_view \\ std::views::drop\_while } & 
%skips the initial elements of another view until the predicate returns false \\
%
%	\tophline
%\specialcell[t]{
%std::join\_view, std::views::join} & joins a view of ranges \\
%
%	\tophline
%\specialcell[t]{
%std::split\_view, std::views::split  } &  splits a view by using a delimiter \\
%
%	\tophline
%\specialcell[t]{
%std::common\_view, std::views::common } & converts a view into a std::common\_range \\
%
%	\tophline
%\specialcell[t]{
%std::reverse\_view, std::views::reverse } & iterates in reverse order \\
%
%	\tophline
%\specialcell[t]{
%std::basic\_istream\_view \\ std::istream\_view  } & applies operator>> on the view \\
%
%	\tophline
%\specialcell[t]{
%std::elements\_view, std::views::elements    } & creates a view on the N-th element of tuples \\
%
%	\tophline
%\specialcell[t]{
%std::keys\_view, std::views::keys     } & a view on the first element of a pair-like values \\
%
%	\tophline
%\specialcell[t]{
%std::values\_view, std::views::values  } & a view on the second elements of a pair-like values
%
%	\bottomhline
%\end{tabular}

	\par The views can be remembered by (\textbf{GPTSSSRZS}): \textbf{G}enerate, \textbf{P}rojection, \textbf{T}ransform, \textbf{S}tride(filter), \textbf{S}lide(adjacent), \textbf{S}ubrange(drop, take, count), \textbf{R}everse, \textbf{Z}ip(join), \textbf{S}plit(chunk). 
\begin{center}
	\includegraphics[width=0.8\linewidth]{pics/view.drawio.png}
\end{center}


	\par The main ideas about views and ranges, you can see code example of how to input a view to different algorithms. 

\begin{lstlisting}
struct MySentinel {}; // Empty type.	
bool operator==(const auto i, MySentinel) { // Are we done?
	return *i == 2;
}

std::list<int> lst{1, 2, 3, 4, 5, 6, 7, 8, 9};
auto firstFive = std::views::take(lst, 5); 
auto common = std::views::common(firstFive); 
// create a common_view that has the same begin/end iterator types

auto output = std::ostream_iterator<int>(std::cout, " ");
std::copy(common.begin(), common.end(), output); //1) to traditional algorithm
std::ranges::copy(firstFive, output);            //2) to constraint algorithm
std::ranges::copy(firstFive.begin(), MySentinel{}, output); //3) sentinel.		
\end{lstlisting}
\begin{center}
	\includegraphics[width=0.8\linewidth]{pics/range.drawio.png}
\end{center}




\subsubsection{View constraints}
	
	 When you inputs views to algorithm, there are two points need to be considered:
	\begin{itemize}
		\item What concept do views model? The basic concepts are size\_range, common\_range and random\_access\_range etc. Concept can arise from the embedded container, as seen in the example below with \texttt{std::forward\_list}, or they can stem from the views themselves. For instance, \texttt{std::views::filter} is not considered a random\_access\_range at all.
		
		\item What concept do algorithms can received? For example, \texttt{std::sort} only accepts range which models random\_access\_range concept.
	\end{itemize}
		
	
	\begin{center}
		\includegraphics[width=0.6\linewidth]{pics/view_algorithm.drawio.png}
	\end{center}

\begin{lstlisting}
//below comes from cpp conference website.
// filter_view models the concepts bidirectional_range, forward_range, input_range, and common_range when the underlying view V models respective concepts.

// take_view models the concepts contiguous_range, random_access_range, bidirectional_range, forward_range, input_range, and sized_range when the underlying view V models respective concepts. It models common_range when the underlying view V models both random_access_range and sized_range.

sort(v|views::take(3)); //OK, because views::take can model random range
sort(v|views::filter(...)) //Error, views::filter only model bidirection range	
\end{lstlisting}
	
	
	\par common\_range is also an important concept when we want to use algorithms. For example, different with \texttt{std::views::filter}, \texttt{std::views::take\_while} isn't a common\_range. Common ranges require that \texttt{ranges::begin()} and \texttt{ranges::end()} return the same type. If it's not common range, we can't input this view to traditional algorithms.
\begin{lstlisting}
auto v = std::vector{8,7,3};
auto rng = v | std::views::filter([](int x){return x > 5 ;});
auto res = std::accumulate(rng.begin(),rng.end(),0); //OK here.

//auto rng = v | views::take_while([](int x){return x > 5 ;}) ; //error
auto rng = v | views::take_while([](int x){return x > 5 ;})|views::common;//ok
auto res = std::accumulate(rng.begin(),rng.end(),0);  // not range version.		
\end{lstlisting}

		\par You can also use \texttt{views::common} on you own range. 
\begin{lstlisting}
#include <ranges>
class Gadget_Range {
	std::array<int,6> a_ {5,4,3,2,1,0};
	public:
	auto begin () const { // exclude last element
		return std::counted_iterator{a_.begin(),5};
	}
	auto end () const { // counting_iterator already knows size	
		return std::default_sentinel;
	}
};
Gadget_Range g;

fmt::print("{}\n", g);
// accumulate requires same type for 'begin' and 'end'
// ERROR: std::accumulate(g.begin(), g.end(), 0);
auto cv = g | std::views::common;
auto sum = std::accumulate(cv.begin(), cv.end(), 0);
fmt::print("sum: {}\n", sum);				
\end{lstlisting}			

	\par \texttt{views::transform} doesn't store element, the elements are generated one at a time as the view is iterated, so each element all are r-value (return by a function). In the below loop, you have to use \texttt{auto} or \texttt{const auto \&} to catch rvalue from \texttt{view::transform}. 

\begin{lstlisting}
for(auto & e: dic|views::values<0>|views::transform(....)){//auto &e is not OK
	
for(auto & e: dic|views::values<0>|views::stride(2)){ //with -std=c++23
	cout<<e;        //using auto &e is OK here, because stride return lvalue. 
}		
\end{lstlisting}

	\par  If we want to sort a \texttt{views::transform}, a correct solution is to store the transformed elements in a vector and then sort them. \texttt{ranges::to} provides a way to implement this. 
\begin{lstlisting}
std::vector ints{ 6, 5, 2, 8 };
auto even = [](int i) {return 0 == i % 2;};

auto rr = ints  | std::views::filter(even) | std::views::transform([](auto i) {
											return i * i;
										}) | std::views::reverse;

auto ints = rr | ranges::to<vector<int> >(); //need () here for pipeline syntax.
//or auto ints = ranges::to<vector<int> >(rr); //call to function directly.
//or auto ints = std::vector(std::ranges::begin(rr), std::ranges::end(rr));
std::ranges::sort(ints); // output 4, 36, 64.		
\end{lstlisting}		
	
	\par If algorithm return a iterator, you need to pay attention to the input temporary view. If input temporary view is borrow range, the return iterator is safe to use. Detail can be seen in the next section "Borrowed range". 
\begin{lstlisting}
map<int, pair<int,int> > dic {{1, {2, 1}}, {2, {3, 1}}, {3,{4, 2}} };
auto rr = ranges::min_element(dic | views::values | views::filter( [](auto p){
									return p.second == 1;
								}));
cout<<(*rr).first<<endl;  //Error, rr is ranges::dangling.

//below is correct version.
auto vw = dic | views::values | views::filter( [](auto p){
									return p.second == 1;
								});
auto rr = ranges::min_element(vw);
cout<<(*rr).first<<endl;  //rr->first doesn't work here. 
\end{lstlisting}

	\par why \texttt{rr->first} doesn't work? Simplifying, the prototype for the operator-> is: \texttt{T* operator->();} In order to create this operator, you must be able to return a pointer to T and this pointer must be valid after you return from the operator. So, the iterator must store a temporary object for that pointer and control its life cycle. This would create some problems:
	\begin{itemize}
		\item Iterators are assumed to be cheap to store, but now they may contain a hidden copy of T. 
		
		\item It goes against one of the design rationales: ranges cannot own elements. 
		
		\item One of the design guidelines for ranges is that adaptors are lazy evaluated, so the object would be created when the operator-> is called. Every call to the operator should destroy the internal object and return a new pointer. If we decide to keep the object as a cache, we must add more logic to the iterator to control the life cycle and invalidation of the object. 
	\end{itemize}
	\texttt{operator->} was not added because it makes the implementation more difficult, but it does not add any improvement: you can use operator* to achieve the same behaviour. However, this operator returns a copy of T, so the owner of the object and its life cycle is clear.
	
	%	\item An basic \texttt{std::view} example. You can compiled by "g++ a.cpp -std=c++20"
	%\begin{lstlisting}
	%using namespace std;
	%int main() {
		%	std::vector<uint64_t> in{1, 2, 3, 4, 5};
		%	for (auto && i : in | views::drop(2) | views::transform([]( auto &e ){
			%		e+=2; return e*2;}))
		%	std::cout << i << ' '; //should print: 6, 8, 10		 
		%	
		%	for(auto e :in){
			%		std::cout<<e << ' '; //should print 1,2,5,6,7
			%	} 
		%}		
	%\end{lstlisting}	
	
	\par Another example of common view. We can use \texttt{views::take\_while} and \texttt{views::drop\_while} to trim left and right space from string.  It returns non common view. Below code demonstrate how to build a string from views. 
\begin{lstlisting}
string word = "  abc  ";  //trim left and right space
auto vv = word|views::drop_while([](char c){return isspace(c);})|
               views::take_while([](char c){return !isspace(c);});

auto vc = views::common(vv);
string result1(vc.begin(), vc.end());     //OK, vc is common views;
string result1 = vv|ranges::to<string>(); // ok
//string result1{vv.begin(), vv.end()};     //error, vv is not common views;
//string result1{vc};    //error, can't build string object from view directly. 
             //vc doesn't have data() and size(), which string constructor need.
\end{lstlisting}
	
	\par If a view requires a functor, it will not satisfy the concepts of \textbf{sized\_range}, \textbf{common\_range}, or \textbf{borrowed\_range}. Some common views that require an additional functor include \texttt{views::take\_while}, \texttt{views::drop\_while}, \texttt{views::transform}, \texttt{views::filter} and \texttt{views::chuck\_by}.
\begin{lstlisting}
vector v2{2, 4, 2, 3, 4, 5};
auto l = [](auto e){ return e%2 == 0;};
auto vv = std::span{v2}|std::views::take_while(l);
auto vv1 = std::span{v2}|std::views::take(3);
cout<<ranges::borrowed_range<decltype(vv)><<endl; //return false;
cout<<ranges::borrowed_range<decltype(vv1)><<endl; //return true;
\end{lstlisting}
	
	\par Special adaptor are \texttt{views::ref\_view}, \texttt{views::owning\_view}, \texttt{views::all} and \texttt{views::common}. \\
	\texttt{std::views::all} returns a suitable view(\texttt{std::views::ref\_view}, \texttt{std::views::owning\_view}, etc) depending on the input range type. If parameter of \texttt{views::all} is a non-view rvalue such as a temporary object, or is the result of passing the range to \texttt{std::move}, it will return an \texttt{owning\_view}. Use \texttt{std::views::all\_t<decltype((rg))>} to get the type of the returned view. Usually, we don't use it directly in our code. 
\begin{lstlisting}
#include <ranges>
std::vector<int> v {9,1,3,7,4};
auto vw1 = std::views::all(v); //return std::views::ref_view.
fmt::print("{}\n", vw1); // [9,1,3,7,4]
v.pop_back();
fmt::print("{}\n", vw1); // [9,1,3,7] //vw1 will change according to v

// move 'v' into a new view:
auto vw2 = std::views::all(std::move(v)); //return std::views::owning_view.
v = std::vector<int>{8}; //change v to another vector, 
//vw2 is an owning_view, which stores the elements, not change according to v.
fmt::print("{}\n", vw2); // [9,1,3,7] 
fmt::print("{}\n", v); // [8]			
\end{lstlisting}		
	
	
\subsubsection{View implementation}
	
	  From a syntax point of view, \texttt{std::ranges::SquareView} is a class with a special iterator, where the \texttt{operator*()} of the iterator is redefined. It also defines basic \texttt{begin()} and \texttt{end()} functions. Here’s a simple implementation: 
\begin{lstlisting}
//More detail can be found here: "An Introduction to the Range-v3 Library".
template<typename T>
using IteratorBase = decltype( std::begin( std::declval<T&>( ) ) );
template <typename Rng>
class SquareView : public ranges::view_base{
	class IteratorType : public IteratorBase<Rng>
	{
		public:
		using Base = IteratorBase<Rng>;
		using value_type = typename std::iterator_traits<Base>::value_type;
		IteratorType& operator++( ){ ..}
		value_type operator*( ) const{ // Where the magic happens
			value_type value = *static_cast<Base>( *this );
			return value * value;
		}
	};
	...
	iterator begin( ) const { return ranges::begin( range_ ); }	
	auto end( ) const { return ranges::end( range_ ); }
}	
\end{lstlisting}	
	
	\par With SquareView, we need to adapter to return this view. The basic idea of range adaptor is inline instance of functor. The functor \texttt{operator()} or \texttt{operator |} return the anonymous \texttt{SquareView}. 
\begin{lstlisting}
struct SquareFn{
	template <typename Rng>
	auto operator()( Rng&& range ) const{
		return SquareView( std::forward<Rng>( range ) );
	}	
	template <typename Rng>
	friend auto operator|( Rng&& range, const SquareFn& ){
		return SquareView( std::forward<Rng>( range ) );
	}
};
namespace Views{
	constexpr SquareFn Square;
}

auto view = Views::Square( inputValues ); //method1, use operator()
auto view = inputValues | Views::Square;  //method2, use operator pipeline	
\end{lstlisting}	
	
	
	\par Such as \texttt{views::take} has one argument, you can use below method to implement it. 
\begin{lstlisting}
struct custom_take_range_adaptor_closure{
	std::size_t count_;
	constexpr custom_take_range_adaptor_closure(std::size_t count): count_(count)
	{}
	
	template <rg::viewable_range R>
	constexpr auto operator()(R && r) const{
		return custom_take_view(std::forward<R>(r), count_);
	}
} ;

struct custom_take_range_adaptor{
  template<rg::viewable_range R>
  constexpr auto operator()(R&& r, iter_difference_t<rg::iterator_t<R>> count){
    return custom_take_view( std::forward<R>(r), count ) ;
  }
	
  constexpr auto operator () (std::size_t count){
    return custom_take_range_adaptor_closure(count);
  }   
};

template <rg::viewable_range R>
constexpr auto operator | (R&& r, custom_take_range_adaptor_closure const & a){
	return a(std::forward<R>(r)) ;
}		
\end{lstlisting}	

	

\subsubsection{Borrowed range}
		In C++20, a borrowed range is a range whose iterators remain valid even after the lifetime of the range object itself ends. This is in contrast to most standard library containers, where destroying the container invalidates its iterators. For example, An rvalue \texttt{std::vector} is not a borrowed range, but an rvalue \texttt{std::span} is.
	
\begin{lstlisting}
auto iter = std::ranges::min_element(get_vector());
cout<<*iter;  // Error,iter is std::ranges::dangling	
auto iter = std::ranges::min_element(get_span());
cout<<*iter; // iter is an solid iterator, *not* ranges::dangling	
\end{lstlisting}	
	
	\par Any views need extra functor, such as \texttt{views::filter} and \texttt{views::transform} are not borrowed ranges, because it involves some functor. 
\begin{lstlisting}
auto odd = [](int i) { return bool(i % 2); };
auto iter = std::ranges::min_element(v|views::filter(odd));
cout<<*iter;  // Error,iter is std::ranges::dangling			
\end{lstlisting}	
	
	\par Types like \texttt{std::string\_view} and \texttt{std::span} are called borrowed ranges in the new C++20 terminology. A borrowed range is one whose iterators can safely outlive their parent object. \\
\begin{center}
	

	\begin{tabular}{|p{0.25\textwidth}|p{0.33\textwidth}|p{0.32\textwidth}|}
		\hline
		 \textbf{borrowed range} & \textbf{borrowed range only if underlying view is borrowed range} & \textbf{non-borrowed range no matter what underlying view} \\
		\hline
		\specialcell[t]{ std::basic\_string\_view \\
		std::span \\
		std::ranges::subrange \\
		std::ranges::ref\_view \\
		std::ranges::empty\_view \\
		std::ranges::iota\_view } & \specialcell[t]{ std::ranges::owning\_view \\
		std::ranges::take\_view \\
		std::ranges::drop\_view \\
		std::ranges::common\_view \\
		std::ranges::reverse\_view \\
		std::ranges::elements\_view \\
		std::ranges::adjacent\_view }  
		
		& \specialcell[t]{ std::ranges::filter \\
		std::ranges::take\_while\_view \\	
		std::ranges::drop\_while\_view \\
		std::ranges::transform\_view }  \\
		\hline
	\end{tabular}
\end{center}	
	

\subsubsection{Sequence View}
	 Two main sequence views are \texttt{std::string\_view} and \texttt{std::span} in C++20. \texttt{std::string\_view} is a non-owning, \textbf{read-only} view of a sequence of characters. It is useful for working with substrings and passing strings around without the overhead of copying. \texttt{std::span} is a non-owning view over a contiguous sequence of objects, providing a safe way to work with arrays and other contiguous data structures.
	 
	 \par Although \texttt{std::string\_view} and \texttt{std::span} are called "sequence view", but they are not real view, because they are not in the <ranges> header file. \texttt{std::string\_view} is in <string> header file, and \texttt{std::span} is in <span> header file, they are not lazy evaluate either, see code below:
\begin{lstlisting}
vector v {1, 2, 3, 4};
std::span sp{v};
auto vw = v| views::reverse;
v.clear();

for (auto e: sp){
	cout<<e<<endl; //output 1, 2, 3, 4, in fact, it's undefine behavior.
}

for (auto e: vw){
	cout<<e<<endl; //output nothing 
}
\end{lstlisting}
	 
	
	\par How to build \texttt{std::string\_view}? You can use either a string literal, a \texttt{std::string}, a pointer to a character array along with its length or a range (C++ 20).
\begin{lstlisting}
using namespace std::string_view_literals; //method 1, use literals. 
auto literal_view = "C-String Literal"sv;

std::string s = "Some Text";  // method 2, use string 
std::string_view sv1 { s };  

const char* cstr = "Hello, World!"; //method3, character pointer
std::string_view sv(cstr, 5); 

std::string_view sv2 {begin(s)+2, begin(s)+5}; //method 4, use range.
std::string_view sv3 {begin(s)+2, end(s)}; 
\end{lstlisting}

	\par For read-only string parameter, difference between const reference and \texttt{std::string\_view} is: If we pass an object as function argument that is not a string itself, but something that can be used to construct a string, e.g., a string literal or an iterator range, a new temporary string object will be allocated and bound to the const reference, and it's not very efficient. 

\begin{lstlisting}
void f_cref (std::string const& s) { ... }
void f_view (std::string_view s) { ... }

std::string stdStr = "Standard String";
auto const cStr = "C-String";  //cStr is const char* 
std::vector<char> v {'c','h','a','r','s','\0'};
f_cref(stdStr);     // no copy
f_cref(cStr);       //  temporary string, bad
f_cref("Literal");  //  temporary string, bad
f_cref({begin(v),end(v)});  //  temporary string, bad

f_view(stdStr);     //  no temporary string
f_view(cStr);       //  no temporary string
f_view("Literal");  //  no temporary string
f_view({begin(v), end(v)});  //  no temporary string
\end{lstlisting}

	\par Based on previous introduction, functions that accept a \texttt{const char*} or \texttt{const string\&} (of any string type) parameter, consider replacing with \texttt{string\_view} unless:
	
\begin{itemize}
    \item You’re passing the argument to a function requiring \texttt{const string\&} or other null-terminated string (e.g., fopen or printf)
    
	\item You’re copying the data to a new string object
\end{itemize}
\begin{lstlisting}
void fun(string_view sv){ //don't use const string_viw & 
	//just read inside fun. 
}

void copy_fun(const string & s){
	v.push_back(s)  //copy here, so we should use const string&
}
void fun(const char* p){
	fopen(p)      //const char* p is convenient for calling fopen. 
}
\end{lstlisting}

	\par Standard associative containers using strings as keys will accept \texttt{string\_view} in their lookup functions. Support for unordered containers was added in C++20. A \texttt{string\_view} can be stored in a container, where a normal reference cannot. Be aware of the lifetime of the underlying character sequence.

	\par \texttt{std::string\_view} is a borrowed range, it means that if a \texttt{std::string\_view} is temporary, the iterator from it is OK, but if the embedded container is temporary, it still has dangling problem. So you should use \texttt{std::string\_view} mainly as function parameter!
\begin{lstlisting}
std::string_view sv2 {std::string{"abc"}}; // an temporary string object.
cout<<sv2 //dangling string_view, temporary string object has been destroyed. 

std::string str = "Hello world";  //string_view itself is temporary.
auto iter = std::string_view{str}.begin(); //iter's parent object is string_view.
*iter = 'h'; // Weird, but okay:	
\end{lstlisting}

	\par The typical issues of \texttt{std::span} are two fold. First, a \texttt{std::span} should not act on a temporary and second, the size of the underlying contiguous range of a \texttt{std::span} should not be modified.
\begin{lstlisting}
std::vector<int> getVector() {                         
	return {1, 2, 3, 4, 5};
}

std::span<int, 5> mySpan2{getVector().begin(), 5};  //don't do that
\end{lstlisting}

	\par Why do we mainly use \texttt{std::string\_view} and \texttt{std::span} as function parameters:
	
\begin{itemize}
	\item Dangling reference problem for \texttt{std::span}. That is explain why we should use these two sequences view in function parameter most of time. 
\begin{lstlisting}
std::vector<int> w {1,2,3,4,5};
std::span s {w};
w.push_back({6,7,8,9});
cout << s[0]; //  w might hold new memory, bad			
\end{lstlisting}	
	
	\item \texttt{some\_function(std::string{"hello, world"});} in line 5 is completely safe. The temporary \texttt{std::string} is destroyed at the end of this full-expression (roughly speaking, at this ;), so it's destroyed after the function returns.
\begin{lstlisting}
void some_function(std::string_view view) {
	std::cout << view << '\n'; //temporary string is still alive here.
}

some_function(std::string{"hello, world"}); 
\end{lstlisting}

	\item An example of using \texttt{std::string\_view} as parameter. The code will converts string to \texttt{int} if possible, otherwise it will return \texttt{std::nullopt}.  
\begin{lstlisting}
std::optional<int> asInt(std::string_view sv){
	int val;
	auto [ptr, ec] = std::from_chars(sv.data(), sv.data()+sv.size(), val);
	if (ec != std::errc{}) { 	// if we have an error code, return no value:
		return std::nullopt;
	}
	return val;
}			
\end{lstlisting}	

\item Use \texttt{std::span} as function parameter. You can think that \texttt{std::span} is also a view type.
\begin{lstlisting}
void printMe(std::span<int> container) {	
	std::cout << "container.size(): " << container.size() << '\n';  
	for(auto e : container) std::cout << e << ' ';
}

int arr[]{1, 2, 3, 4};              // (1) input C array 
printMe(arr);  //output container.size(): 4 it can deduct size information.

std::vector vec{1, 2, 3, 4, 5};     // (2) input C++ std::vector
printMe(vec);  //same as arr example.

std::array arr2{1, 2, 3, 4, 5, 6}; //  (3) input C++ std::array
printMe(arr2);	

printMe({begin(vec)+2, end(v)})  //    (4) input range.	
\end{lstlisting}	

\end{itemize}

	\par Here are the advantages of using \texttt{std::string\_view} and \texttt{std::span} as function parameters:
	
\begin{itemize}
	\item Decouple function implementations from Data Representation/Container Type. By using \\ \texttt{std::string\_view} or \texttt{std::span}, functions are not tied to a specific container type like \texttt{std::string} or \texttt{std::vector}. This flexibility allows the same function to operate on different types of string-like or span-like data structures without modification.
	
	\item Clearly communicate the intent of only reading/altering elements in a sequence, but not modifying the underlying memory/data structure.
	
	\item Make it easy to apply functions to sequence subranges. Both \texttt{std::string\_view} and \texttt{std::span} allow easy creation of subranges without copying the data, making it efficient to work with parts of the data.
	
	\item Can almost never be dangling, i.e., refer to memory that has already been destroyed (because parameters outlive all function-local variables).
	
	\item Views can speed up accesses by avoiding a level of indirection.

\end{itemize}

\subsubsection{Summary of view}
The section on views is extensive and somewhat disorganized, so here is a summary:
\begin{itemize}
	\item Remember the main views objects (\textbf{GPTSSSRZS}). The three most useful views are transform(transform\_adjacent/pairwise); split (chunk or chunk\_by), and slide (adjacent or pairwise).
	
	\item The element in the previous three views are \texttt{std::span}, \texttt{sub::subrange} or \texttt{std::tuple}. You need to know what type they return on the corresponding view and underlying range.
	
	\item When used view externally, different views may be common\_range, size\_range, random\_range, or borrow\_range. Know each range constraints and characteristics.
	
	
	\item To convert a view into a real container, you can use the container's range constructor or \texttt{ranges::to()} if supported by your compiler. 
	
	\item \texttt{std::string\_view} and \texttt{std::span} do not inherit from views\_interface, so they are used primarily as function parameters, differing from regular usage like \texttt{views::drop}.
	
\end{itemize}


\section{Algebraic data types}

\subsection{vocabulary type, product type and generic view type}
	
	 A "vocabulary" type is very loose defined conception. It is a type that purports to provide a common language, for dealing with its domain. Notice that even before C++ existed, the C programming language had already made a decent shot at the vocabulary of some areas, providing standard types or type aliases for integer math (\texttt{int}), floating-point math (\texttt{double}), timepoints expressed in the Unix epoch (\texttt{time\_t}), and byte counts (\texttt{size\_t}). A good book about vocabulary type is "Mastering C++ 17 STL" chapter 5. 
	
	\par  A product of two types A and B is a new type that contains an instance of A \textbf{AND} an instance of B (it will be Cartesian product of the set all values of type A and the set of all values of B). The sum type aren't as prominent in C++ as product type. The sum type of types A and B is a type that can hold an instance of A \textbf{OR} an instance of B. but not both at the same time. In C++, enum are special kind of sum type. unions and \texttt{std::variant} are common sum type. \texttt{std::option} is special type of \texttt{std::variant}.  
	
	\par Beside the "vocabulary type" generic definition in C, In C++, the Standard Template Library (STL) provides a vocabulary of container classes, algorithms, and iterators that are used to manipulate collections of data. The STL also provides a vocabulary of numeric types and mathematical functions, as well as facilities for working with strings, streams, and other common tasks. At the same time, vocabulary type also includes: 
	\begin{itemize}
		\item Algebraic data type:
		 \begin{enumerate}
		 	
		 	\item (sum type/tagged union/variant) - \texttt{std::variant}, \texttt{std::optional} \texttt{std::any} (the ultimate in sum types--it can store almost anything).
		 	
		 	\item (product type/record/tuple) - \texttt{std::tuple}, \texttt{std::pair}.
		 	
		 \end{enumerate}
		 
		\item Generic type erase type (container). \texttt{std::function}, \texttt{std::any}.
		
		\item Generic adapter, such as smart pointer.
		
		\item Generic view type, such as \texttt{std::string\_view} and \texttt{std::span}
		
	\end{itemize}
	
	\par The most common product type is \texttt{std::tuple}. The implementation detail of \texttt{std::tuple} can be found in "Variadic Templates" in Modern C++ chapter. The \texttt{std::tuple} is a lot more flexible in how it can be used in conjunction with the standard <algorithm> library.
	
	\par Be cautious and avoid overusing \texttt{std::tuple} and \texttt{std::variant} as return types in every function. Instead, named class types remain the most effective way to ensure code readability.
	
	\par To signal a possible lack of a value or the "not-yet-ness" of a data member, use \texttt{std::optional}. For querying the type of a variant, use \texttt{std::get\_if<T>(\&v)}, and for querying the type of an any, use \texttt{std::any\_cast<T>(\&a)}. Keep in mind that the type you provide must be an exact match; otherwise, you will receive a nullptr.
	
%	\item Be aware that \texttt{std::variant} always has the possibility of being in a "valueless by exception" state; but know that you don't have to worry about that case unless you write classes with throwing move-constructors. Separately: don't write classes with throwing move-constructors! 
	
%	\item Be aware that the type-erased types \texttt{std::any} and \texttt{std::function} implicitly use the heap. Third-party libraries provide non-standard inplace\_ versions of these types. Be aware that \texttt{std::any} and \texttt{std::function} require copyability of their contained types. Use "capture by shared\_ptr" to deal with this case if it arises.
		
	\par Be aware that \texttt{std::make\_tuple} and \texttt{std::make\_pair} do more than construct \texttt{std::tuple} and \texttt{std::pair} objects; they also decay reference\_wrapper objects into native references. Use \texttt{std::tie} and \\ \texttt{std::forward\_as\_tuple} to create tuples of references. \texttt{std::tie} is particularly useful for multiple assignment and for writing comparison operators. \texttt{std::forward\_as\_tuple} is useful for metaprogramming. 
	
\begin{lstlisting}
std::tuple<double, char, std::string> get_student(int id){
	if (id == 0) return std::make_tuple(3.8, 'A', "Lisa Simpson");
	if (id == 1) return std::make_tuple(2.9, 'C', "Milhouse Van Houten");
}
auto student0 = get_student(0); 
std::cout << "ID: 0, " << "GPA: " << std::get<0>(student0) << ", "
<< "grade: " << std::get<1>(student0) << ", "
<< "name: " << std::get<2>(student0) << '\n';   //method 1, use get<>

double gpa1;
char grade1;
std::string name1;
std::tie(gpa1, grade1, name1) = get_student(1); //method 2, use std::tie

auto [gpa2,grade2,name2]=get_student(2); //method 3, C++17 structured binding
\end{lstlisting}

\begin{lstlisting}
struct S{
	int n;
	std::string s;
	float d;	
	friend bool operator<(const S& lhs, const S& rhs) noexcept{
	//compares lhs.n to rhs.n, then lhs.s to rhs.s, then lhs.d to rhs.d in that order
		return std::tie(lhs.n, lhs.s, lhs.d) < std::tie(rhs.n, rhs.s, rhs.d);
	}
};
\end{lstlisting}

\begin{lstlisting}
std::map<std::string, std::string> m;

m.emplace(std::piecewise_construct, std::forward_as_tuple("c"),
          std::forward_as_tuple(10, 'c'));
// an alternative is: m.try_emplace("c", 10, 'c');

// Error, it produces a std::tuple<int&&, char&&> holding two dangling references.
// auto t = std::forward_as_tuple(10, 'c');
// m.emplace(std::piecewise_construct, std::forward_as_tuple("c"), t);
\end{lstlisting}
	

\subsection{Sum type}
	All below content of vocabulary type includes five contents: 1) create, 2) change, 3) check, 4) access, 5) when to use?
\subsubsection{std::optional}

	 It is recommended to use \texttt{std::optional<T>} in situations where there is exactly one clear reason for having no value of type T, and where the absence of a value is as natural as having any regular value of T. 
	
	\begin{itemize}
		\item  If you want to represent a nullable type nicely. Rather than using unique values (like -1, nullptr, NO\_VALUE or something), For example, user’s middle name is optional. You could assume that an empty string would work here, but knowing if a user entered something or not might be important. With \texttt{std::optional<std::string>} you get more information.
		
		\item Return a result of some computation (processing) that fails to produce a value and is not an error. For example finding an element in a dictionary: if there’s no element under a key it’s not an error, but we need to handle the situation.
		
		\item To perform lazy-loading of resources. For example, a resource type has no default constructor, and the construction is substantial. So you can define it as \texttt{std::optional<Resource>} and you can pass it around the system, then load only if needed later.
		
		\item To pass optional parameters into functions.
	\end{itemize}
	
	\par \texttt{std::optiona}l can be used as a member, an argument, or a return value. Below are two code examples demonstrating these three kinds of usages: return value and data member usage.
	
\begin{lstlisting}
std::optional<int> asInt(const std::string& s) { 
	try { // convert string to int if possible:
		return std::stoi(s);
	}
	catch (...) {
		return std::nullopt;
	}
}	
\end{lstlisting}	

\begin{lstlisting}
class Name {
private:
	std::string first;
	std::optional<std::string> middle;
	std::string last;
public:
	Name (std::string f, std::optional<std::string> m,std::string l)
	: first{std::move(f)}, middle{std::move(m)}, last{std::move(l)} {
	}

	friend std::ostream& operator << (std::ostream& strm, const Name& n) {
		...
		if (n.middle) { // optional can be used in bool context.
			strm << *n.middle << ' ';
		}
	}
};
Name n{"Jim", std::nullopt, "Knopf"}; //learn how to use std::nullopt.	
\end{lstlisting}	
	
	\par Pay attention to the usage of \texttt{std::in\_place}. The intent of \texttt{std::in\_place} is to disambiguate situations where one wants to call the default constructor of \texttt{optional<T>} versus the default constructor of T.
	
\begin{lstlisting}
class UserName {
public:
	UserName() : mName("Default") { }
private:
	std::string mName;
};

std::optional<UserName> u0; // empty optional
std::optional<UserName> u1{}; // also empty

// optional with default constructed object:
std::optional<UserName> u2{UserName()}; //that will create a temp object
std::optional<UserName> opt{std::in_place}; //that is good style, no temp object	
\end{lstlisting}	

	\par Another usage of \texttt{std::in\_place} is in constructors with many arguments, similar to the emplace member functions in STL containers.  
\begin{lstlisting}
std::optional<std::vector<int>> opt{std::vector<int>{4, 1}};  //copy vector here
std::optional<std::complex<double>> opt2{complex<double>{0, 1}}; //copy complex here

std::optional<std::vector<int>> opt{std::in_place, 4, 1}; //good style, no copy
std::optional<std::complex<double>> opt2{std::in_place, 0, 1};

auto opt = std::make_optional<UserName>();
auto opt = std::make_optional<std::vector<int>>(4, 1);	
\end{lstlisting}	
	\par As summary, You can construct optional in four ways. 1) use temporary obj 2) use \texttt{std::in\_place} 3) use emplace 4) \texttt{make\_optional} function.
	
	\par There are several options to access the stored value.
	\begin{itemize}
		\item \texttt{operator*} and \texttt{operator->} - similar to iterators. If there’s no value the behaviour is undefined!
		
		\item \texttt{value()} - returns the value, or throws \texttt{std::bad\_optional\_access}.
		
		\item \texttt{value\_or(defaultVal)} - returns the value if available, or defaultVal otherwise.
	\end{itemize}
	
	\par To check if the value is present you can use \texttt{has\_value()} method or just check if (optional) as optional is automatically converted to bool.
	
\begin{lstlisting}
std::optional<int> oint = 10;              // method 1: by operator*
std::cout<< "oint " << *opt1 << '\n';

std::optional<std::string> ostr("hello");  // method 2: by value()
try {
	std::cout << "ostr " << ostr.value() << '\n';  
}
catch (const std::bad_optional_access& e) {
	std::cout << e.what() << "\n";
}

std::optional<double> odouble; // empty
std::cout<< "odouble " << odouble.value_or(10.0) << '\n';  // method 3: by value_or()
\end{lstlisting}
	

\subsubsection{std::variant and std::any}

	 
	How do you create and initialize a variant? There are three key points to understand: \texttt{std::monostate}, \texttt{std::in\_place\_index}, and \texttt{std::in\_place\_type}. By default, a variant object is initialized with its first type. If the first type does not have a default constructor defined, attempting to call the default constructor for the variant will result in an error. This is where \texttt{std::monostate} becomes necessary
	
\begin{lstlisting}
class NotSimple {
public:
	NotSimple(int, float) { }
};
//std::variant<NotSimple, int> cannotInit; //error, no default constructor
std::variant<std::monostate, NotSimple, int> okInit;
std::cout << okInit.index() << "\n";

std::variant<long,float,std::string> var1{std::in_place_index<1>, 7.6 };//use float
\end{lstlisting}	
	
	\par How do you access values in a variant? You can use \texttt{std::get<Type|Index>(variant)}, a non-member function that returns a reference to the desired type if it's currently active (you can specify either a type or an index). Variants are implemented using recursive variable templates, where all templates share a placement new mechanism. This allows us to use the \texttt{get()} function to retrieve values. If the requested type is not active, it throws a \texttt{std::bad\_variant\_access} exception. Another option is \texttt{std::get\_if}, also a non-member function, which returns a pointer to the active type or nullptr if none is active. However, the most versatile method to access a value in a variant is through visitors.
	
\begin{lstlisting}
std::variant<int, std::string> var{"hi"};  // initialized with string alternative
std::cout << var.index() << '\n';          // prints 1
var = 42;                                  // now holds int alternative
std::cout << var.index() << '\n';          // prints 0
try {
	int i = std::get<0>(var);              // access by index(OK)
	string s = std::get<std::string>(var); // access by type(throws exception)
}
catch (const std::bad_variant_access& e) { // in case a wrong type/index is used
	std::cerr << "EXCEPTION: " << e.what() << '\n';
}
\end{lstlisting}	
	
	\par We can also use \texttt{std::visit} for scenarios where we want to apply operations polymorphically based on the variant's active type. This is the primary use case for \texttt{std::visit()}.
\begin{lstlisting}
struct Fluid { };
struct LightItem { };
struct HeavyItem { };
struct VisitPackage {
	void operator()(Fluid& )       { std::cout << "fluid\n"; }
	void operator()(LightItem& )   { std::cout << "light item\n"; }
	void operator()(HeavyItem& )   { std::cout << "heavy item\n"; }
};

std::variant<Fluid, LightItem, HeavyItem> package { LightItem()};
std::visit(VisitPackage(), package);
\end{lstlisting}	
	
	\par Using \texttt{std::visit}, you can implement static polymorphism.
	
\begin{lstlisting}
using GeoObj = std::variant<Line, Circle, Rectangle>;
std::vector<GeoObj> figures;
figures.push_back(Line{Coord{1,2},Coord{3,4}});
figures.push_back(Circle{Coord{5,5},2});  
figures.push_back(Rectangle{Coord{3,3},Coord{6,4}});  

for (const GeoObj& geoobj : figure) {
		std::visit([] (const auto& obj) { obj.draw();}, geoobj);
	}
\end{lstlisting}	
	
	\par A typical usage is state machines, and we can also use \texttt{std::variant} in below applications:
	
	\begin{itemize}
		\item All the places where you might get a few types for a single field: so things like parsing command lines, ini files, language parsers, ... etc.
		
		\item Expressing efficiently several possible outcomes of a computation: like finding roots of equations
		
		\item Error handling - for example you can return \texttt{std::variant<Object, ErrorCode>}. If the value is available, then you return Object otherwise you assign some error code.
		
		\item Polymorphism without vtables and inheritance, use visiting pattern and \texttt{std::visit} instead.
		
		\item State machine
	\end{itemize}
	
\begin{lstlisting}
enum class ErrorCode {
	Ok,
	SystemError,
	IoError
};
variant<string, ErrorCode> FetchNameFromNetwork(int i) //1 Error handling

variant<std::monostate, double, pair<double, double> > result; //2 Roots of an equation
\end{lstlisting}	
	
	\par A state machine example. That is not full list code, but include main idea of how to implement a state machine. Detail can be found in "Everything You Need to Know About std::variant from C++17".
\begin{lstlisting}
struct DoorState {
	struct DoorOpened {};
	struct DoorClosed {};
	struct DoorLocked {};
	using State = std::variant<DoorOpened, DoorClosed, DoorLocked>;
	void open() {
		m_state = std::visit(OpenEvent{}, m_state);
	}
	void close() {
		m_state = std::visit(CloseEvent{}, m_state);
	}	
	struct OpenEvent { //visitor
		State operator()(const DoorOpened&){ return DoorOpened(); }
		State operator()(const DoorClosed&){ return DoorOpened(); }
		// cannot open locked doors
		State operator()(const DoorLocked&){ return DoorLocked(); } 
	};	
	struct CloseEvent {
		State operator()(const DoorOpened&){ return DoorClosed(); }
		State operator()(const DoorClosed&){ return DoorClosed(); }
		State operator()(const DoorLocked&){ return DoorLocked(); }
	};
	....	
\end{lstlisting}	
		


	 \texttt{std::any} is statically type-safe; there is no way to access a "pointer to the data" (like a \texttt{void*}) without knowing the exact static type of the stored data. Additionally, \texttt{std::any} does not utilize \texttt{dynamic\_cast}.
	
	\par The core idea behind "type erasure" involves identifying essential operations that should be supported for all types T. For \texttt{std::any}, these operations include: 1) constructing the contained object, 2) moving the contained object, and 3) retrieving the \texttt{typeid} of the contained object. Other type-specific operations are "erased", ensuring uniform behavior across different types.
	
	
	\par A good article is "std::any why when how", it explains the \texttt{std::any} very well. It's just \texttt{shared\_ptr<void>}, but it has value semantic, support deep copy and type safe. 
\begin{lstlisting}
std::any a; // a is empty
std::any b = 4.3; // b has value 4.3 of type double
a = 42; // a has value 42 of type int
b = std::string{"hi"}; // b has value "hi" of type std::string

if (a.type() == typeid(std::string)) {
	std::string s = std::any_cast<std::string>(a);
	useString(s);
}
else if (a.type() == typeid(int)) {
	useInt(std::any_cast<int>(a));
}		
\end{lstlisting}
	
	\par Use \texttt{std::any} when you need a container that can hold values of different types, akin to a more generic version of \texttt{std::variant}. This is particularly useful in scenarios such as parsing configuration files where the types of values may vary widely.
	


\chapter{Concurrent}

	 We can achieve task switching even with only one processor. However, this will only improve responsiveness and won't reduce execution time. In fact, task switching may prolong execution time due to the context switch overhead. If we have multiple processors or multiple cores within a processor, we can use hardware concurrency to achieve performance improvements. Another reasons to use concurrency is improved responsiveness by separating concerns into different threads. For example, a GUI thread and a worker thread can run concurrently to give the user a more responsive experience.
		
	\par Although concurrency has some advantage, it should not be used aggressively. It should be applied only in performance-critical parts of the application where there is potential for measurable gain. At the same time, concurrent execution can introduce race conditions and other synchronization issues. Therefore, it's important to prioritize accuracy over speed when implementing concurrency.
	
	
	\par Concurrent execution can improve performance in three fundamental ways: it can reduce latency (that is, make a unit of work execute faster); it can hide latency (that is, allow the system to continue doing work during a long-latency operation); or it can increase throughput (that is, make the system able to perform more work). Consider a web server handling incoming HTTP requests from clients.
	\begin{itemize}
		\item Reducing Latency: Each incoming request is handled by a new thread, allowing multiple requests to be processed in parallel.
		
		\item Hiding Latency: If any request involves waiting for I/O operations, other threads can continue processing other requests.
		
		\item Increasing Throughput: By leveraging threads, the server can handle many more requests simultaneously, improving the overall capacity and efficiency of the web server.
	\end{itemize}
	
	

\section{Thread}

\subsection{Joinable}
	
	 You can pass different \textbf{callable object or functor} to thread. This allows for greater flexibility and modularity in how tasks are executed concurrently. 
\begin{lstlisting}[frame=single, language=c++]
class Callable{
	operator()(){
		...
	}
}
auto l1 = [](){cout << "hello c world" << endl; };

thread t(l1);           //lambda
thread t1(Callable{});  //use bracket parenthesizes avoid vexing problem.
thread t2(f1);          //funciton
t.join(); t1.join(); t2.join();
\end{lstlisting}


	\par Once you've started your thread, you need to explicitly decide whether to wait for it to finish (by calling \texttt{join()}) or let it run on its own (by calling \texttt{detach()}). Usually, detaching a thread is not considered good practice. This is due to the non-intuitive behavior of \texttt{std::thread}. If a \texttt{std::thread} is still joinable, \texttt{std::terminate()} is called in its destructor. A thread is joinable if neither \texttt{join()} nor \texttt{detach()} has been called. A thread becomes non-joinable if there is no corresponding execution. After you join or detach a thread, it is no longer joinable.
\begin{enumerate}
	\item Detaching Threads: Calling \texttt{detach()} on a thread allows it to run independently from the main program execution. This means the main thread will not wait for it to finish, and the detached thread's resources are automatically reclaimed when it finishes execution.
	
	\item Calling \texttt{join()} on a thread makes the main thread wait until the thread's execution is complete. This is usually the preferred method to ensure proper synchronization and resource management.
\end{enumerate}

\begin{lstlisting}[frame=single, language=c++]
void foo(){
	std::this_thread::sleep_for(std::chrono::seconds(1));
}

std::thread t;
std::cout << "before starting, joinable: " << std::boolalpha << t.joinable(); //return false
t = std::thread(foo);
std::cout << "after starting, joinable: " << t.joinable(); //return ture 
t.join();
std::cout << "after joining, joinable: " << t.joinable(); //return false
\end{lstlisting}


	\par Even after a thread has finished executing its task, it can still be joinable. Therefore, whether a thread is joinable does not depend on whether it has finished its execution.

\begin{lstlisting}[frame=single, language=c++]
void foo(){
	std::this_thread::sleep_for(std::chrono::seconds(1));
}

t = std::thread(foo);
std::this_thread::sleep_for(std::chrono::seconds(5));
std::cout << "after joining, joinable: " << t.joinable(); //return true;
\end{lstlisting}

	\par Threads in C++ are not exception-safe, requiring careful handling to ensure \texttt{join()} is called properly. Failing to do so can lead to code that's difficult to maintain, with multiple \texttt{join()} calls that clutter the source. To address these issues, C++20 introduced \texttt{jthread}, which follows the RAII (Resource Acquisition Is Initialization) principle for safer thread management.

\begin{lstlisting}[frame=single, language=c++]
void f(){
	try{
		std::thread t(my_f);
	}
	catch(...){
		t.join();
		throw;
	}
	t.join;
}
\end{lstlisting}

	\par \texttt{std::jthread} in c++20 is RAII style thread, it can resolve this problem. At the same time, it also support interrupt. You can see the detail about interruption in the following chapters. Prefer to use \texttt{std::jthread} if your compiler support it. 
\begin{lstlisting}
int main() {
	try {
		std::jthread t(threadFunction); // Using jthread in C++20		
		std::cout << "Main thread continues..." << std::endl;
	} catch (const std::exception& e) {
		std::cerr << "Exception caught: " << e.what() << std::endl;
	}
}
\end{lstlisting}

	\par Exceptions thrown in one thread can't be caught in another thread. Let's assume we have a function that can throw an exception. If we execute this function in a seperate thread forked from \texttt{main} and expect to catch any exception from this thread in the \texttt{main} thread, it's not going to work. Here's an example:
\begin{lstlisting}[]
void LaunchRocket() {
  throw std::runtime_error("Catch me in MAIN");
}
int main() {
  try {
    std::thread t1(LaunchRocket);
    t1.join();
  }
  catch (const std::exception &ex) {
    std::cout << "Thread exited with exception: " << ex.what() << "\n";
  }
  return 0;
}
\end{lstlisting}

	\par The solution is to use the C++11 feature \texttt{std::exception\_ptr} to capture exception thrown in a background thread. The idea is simple, just use a global variable to communicate between thread and main. Here are the steps you need to do:
\begin{lstlisting}[]
static std::exception_ptr globalExceptionPtr = nullptr;
void LaunchRocket() {
  try {
    throw std::runtime_error("Catch me in MAIN");
  }
  catch(...){ //Set the global exception pointer in case of an exception
    globalExceptionPtr = std::current_exception();
  }
}
int main() {
  std::thread t1(LaunchRocket);
  t1.join();
  if (globalExceptionPtr) {
    try {
      std::rethrow_exception(globalExceptionPtr);
    }
    catch (const std::exception &ex) {
      std::cout << "Thread exited with exception: " << ex.what() << "\n";
    }
  }
  return 0;
}
\end{lstlisting}


\subsection{detach}


	 In C++ threading, \texttt{detach()} should be used judiciously. One suitable scenario is illustrated in "C++ Concurrency in Action" (section 2.1.4): imagine completing the initial stages of a computation where enough results are gathered to generate a report. To concurrently handle generating and sending an email report while continuing the calculation, you might spawn a new thread using \texttt{detach()} for this specific task.


	\par Suppose we have a \texttt{calculateAndReport} function that performs a computation and send a report. Here are a few comparisons of different strategies to execute this function:
\begin{lstlisting}[frame=single, language=c++]
void calculateAndReport() {
	const auto topLevelResult = TopLeve();
	std::thread t(sendEmail, topLevelResult);
	continuteCalculation(topLevelResult);
	....
}
\end{lstlisting}	

	\begin{itemize}
		
		\item join immediately, not good. 
\begin{lstlisting}[frame=single, language=c++]
void calculateAndReport(){
	const auto topLevelResult = TopLeve();
	std::thread t(sendEmail, topLevelResult);
	t.join()  //option 1, calculate thread wait here. no concurrent at all. 
	continuteCalculation(topLevelResult);
}		
\end{lstlisting}	

		\item You can use detach anywhere, and there's a good chance it will work fine, but it can be dangerous if you need access to local information. If the sendEmail function cannot be entirely independent of the application, using detach poses risks. For instance, if \texttt{topLevelResults} were passed by reference, the main thread might go out of scope and destruct \texttt{topLevelResults} while the new thread is still using it. This scenario can occur if sending an email takes longer than the calculation.
\begin{lstlisting}[frame=single, language=c++]
void calculateAndReport(){
	const auto topLevelResult = TopLeve();
	std::thread t(sendEmail, topLevelResult);
	t.detach()  //option 2, concurrent, but not safe 
	continuteCalculation(topLevelResult);
}			
\end{lstlisting}

		\item join in the end. If sendEmail is very slow, the calculateAndReport will stuck inside calculateAndReport function, while previous method (using \texttt{detach()}) doesn't. 
\begin{lstlisting}[frame=single, language=c++]
void calculateAndReport(){
	const auto topLevelResult = TopLeve();
	std::thread t(sendEmail, topLevelResult);
	continuteCalculation(topLevelResult);
	t.join()  //option 3, safe and concurrent, 
}			
\end{lstlisting}			

		\item use jthread in C++ 20, The same as previous join.
\begin{lstlisting}[frame=single, language=c++]
void calculateAndReport(){
	const auto topLevelResult = TopLeve();
	std::jthread t(sendEmail, topLevelResult); 
	continuteCalculation(topLevelResult);
	//a little different option 3, it will call join before the function finishes.
}			
\end{lstlisting}		
	\end{itemize} 

		\par Detaching threads is not forbidden. It's legal, and a lot of high-quality production code uses it. However, it can be risky if working thread \textbf{refers} (not copy) the data in the main thread. Therefore, carefully consider your choice between using \texttt{join()} and \texttt{detach()}.

	
\subsection{thread constructor}
\subsubsection{reference\_wrapper}
     An \texttt{std::reference\_wrapper} is a copyable and assignable object that emulates a reference. Contrary to its name, it does not wrap a reference. It works by encapsulating a pointer (\texttt{T*}) and by implicitly converting to a reference (\texttt{T\&}). It cannot be default constructed or initialized with a temporary; therefore, it cannot be null or invalid. Below code is usage in \texttt{std::make\_pair}. 
\begin{lstlisting}
int m=10, n = 20;

std::pair<int&, int> p0 = make_pair(m, n) //Eorror! dangle reference.
std::pair<int&, int> p1{m, n}; //OK
auto p2 = std::make_pair(std::ref(m), n); //OK, better
\end{lstlisting}

    \par In C++, you can't directly create a vector of references (\texttt{std::vector<T\&>}), because references are not objects that can be stored in containers like vectors. References in C++ are meant to alias existing objects and cannot be rebound once initialized. Unlike a reference, a \texttt{std::reference\_wrapper} is an object and thus satisfies the STL container element requirements (Erasable, to be precise). Therefore, \texttt{std::reference\_wrapper} can be used as a \texttt{vector} element type.  A \texttt{std::reference\_wrapper<T>} could be a safe alternative to a pointer type (\texttt{T*}) for storing in a vector:
\begin{lstlisting}
using namespace std;
vector<reference_wrapper<int> > v;  //OK
int a=10;
v.push_back(std::ref(a));
\end{lstlisting}

    \par An \texttt{std::reference\_wrapper<T>} can be invoked like a function as long as the \texttt{T} is a callable. This feature is particularly useful with STL algorithms if we want to avoid copying a large or stateful function object.  Besides, \texttt{T} can be any callable – a regular function, a lambda, or a function object. For example:
\begin{lstlisting}
struct Large {
 bool operator()(int i) const {
  	//Filter and process
  return true;
 }
 int internal_[10000]; //big data. 
};

const Large large; //Large immutable data and function object
std::vector<int> in1; //input vector

void process() {
 std::vector<int> out;                            
 std::copy_if(in1.begin(), in1.end(), std::back_inserter(out), std::ref(large)); 
                                           //Pass Large by std::ref to avoid copy 
}
\end{lstlisting}

	\par \texttt{std::thread} does not provide a straightforward mechanism to return a value from a thread. While it's possible to retrieve the return value of tasks or functions using references, pointers to variables, or global variables.
	
	\par The arguments are copied into internal storage, where they can be accessed by the newly created thread of execution, and then passed to the callable object or function as rvalues as if they were temporaries. \texttt{std::decay\_copy} used to finish copy. It is used mainly in thread context and isn't used very often in other places in STL.
	
\begin{lstlisting}[frame=single, language=c++]
thread(Function&& f, Arg&& arg) {
  // ... something happening
  invoke(decay_copy(std::forward<Function>(f)), std::decay_copy(forward<Arg>(arg)));
}

template <class T> 
typename decay<T>::type decay_copy(T&& v){
	return std::forward<T>(v); 
}	
\end{lstlisting}	

	\par  If you study \texttt{decay\_copy} closely, you will find that it returns by value (because its return type is \texttt{std::decay} of something). So the function \texttt{f} is called with rvalue arguments (prvalue arguments, in fact). If the \texttt{f} has reference parameter, when you input it into the \texttt{std::thread}, you need to use \texttt{std::ref} to wrap the parameter. 
	%The basic idea is just like \texttt{std::bind}. 

\begin{lstlisting}[frame=single, language=c++]
void f(int& a); //reference parameter here

int a;
//std::thread t(&f, a); //this will fail
std::thread t(&f, std::ref(a)); //this is OK.
\end{lstlisting}

		\par When the argument supplied is a pointer to an automatic variable. If we pass buffer, this is pointer to local value, once \texttt{fun} finish, the buffer will be invalid. That is why we need to change it to string, then copy a string value in thread context. About detail inside thread constructor, you can see the below section. A little hint, \texttt{decay\_copy.}
\begin{lstlisting}[frame=single, language=c++]
void f(std::string const& s)
	
void fun{
	char buffer[1024];
	sprintf(buffer, "%i", "aaa");
	thread t(f, buffer); //that is not good style
	thread t(f, std::string(buffer)); //that is good
    t.detach(); //or use t.join() to make sure buffer not invalid
}
\end{lstlisting}	

    \par Use move if the argument is only movable. thread interface use forwarding reference. 
\begin{lstlisting}[frame=single, language=c++]
void f1(unique_ptr<obj>);
unique_ptr<obj> p(new obj);

thread(f1, move(p));
\end{lstlisting}

    \par Summary of thread construction:
    \begin{itemize}
    	\item When copying is not possible, use move semantics, such as with \texttt{unique\_ptr}.
    	\item To modify parameters, use \texttt{std::ref}.
    	\item Inside the thread constructor, parameters are passed through \texttt{decay\_copy}. Pay careful attention to avoid dangling pointers.
    \end{itemize}
	


\subsubsection{decay\_copy inside of thread}

     The interface of \texttt{std::thread} looks like this:
\begin{lstlisting}[frame=single, language=c++]
thread(Function&& f, Arg&& arg) {
  // ....
  invoke(decay_copy(forward<Function>(f)), decay_copy(forward<Arg>(arg)));
}
	
template <class T> 
typename decay<T>::type decay_copy(T&& v){
  return std::forward<T>(v); 
}
\end{lstlisting}

		\par Understanding \texttt{std::decay\_copy} requires delving into some details, so brace yourself for a deeper dive. Feel free to skip below if you're not interested in the intricacies. (It involves a lot of metaprogramming and is useful for library developer only.)

		\begin{itemize}

%			\item \texttt{arg} is forwarding reference, for lvalue, T is lvalue reference, \texttt{arg} is also lvalue reference. For rvalue, T is lvalue, arg is rvalue reference. 
%\begin{lstlisting}
%f(T&& para)
%int x = 27;
%f(x)  //x is lvalue, so T is int& and para is also int&;
%f(move(x)) //move(x) is rvalue, so T is int, para is int&&
%\end{lstlisting}

		\item Inside thread function, \texttt{arg} is always lvalue, \texttt{forward<Arg>(arg)} can return lvalue or rvalue according to the outside parameter. 
\begin{lstlisting}
f(T&& para){
  forward<T>(para) //para is always lvalue, forward will return lvalue or rvalue.
}

int x = 27;
f(x)       //x is lvalue, forward<T>(para) in line 2 return lvalue reference
f(move(x));// input rvalue, forward<T>(para) in line 2 return rvalue reference
\end{lstlisting}

		\item \texttt{decay\_copy} returns a copy. Why do we need copy? because we want to copy a value to separated thread stack environment to avoid dangling reference(pointer) problem.
\begin{lstlisting}
template <class T>
typename decay<T>::type decay_copy(T&& v) {
    return std::forward<T>(v);
}
\end{lstlisting}

		\item Next talk about decay. it delete reference and const, array type and function type becomes pointers.
\begin{lstlisting}
template< class T >
struct decay {
	...
    typedef typename std::conditional< std::is_array<U>::value,
        typename std::remove_extent<U>::type*,
        typename std::conditional<std::is_function<U>::value,
        typename std::add_pointer<U>::type,
        typename std::remove_cv<U>::type>::type>::type type;
};
\end{lstlisting}
	
	\item Why do we need decay? As we mentioned earlier, we want to support copying for the incoming parameters. However, some types, like array types, do not support copy operations. So, we need to decay the array types to pointer types to enable copying. The same idea applies when we construct a \texttt{std::pair} object.
\begin{lstlisting}
char a[10] = {'a', 'b'};
pair<char [10], int> pa{a, 2} //fail too, doesn't support copy char [10] type.
pair<char*, int> pb{a, 2} //This time OK, need decay fomr char [10] to char* 
\end{lstlisting}

%	\item Below, I will implement a similar \texttt{make\_pair} function. In order to avoid conflicts with the std library, I will change its name to \texttt{make\_y}. At the same time, I will use the C++ insights website to generate template instantiation. The first example does not use \texttt{std::decay}. For a right value, \texttt{T1} is \texttt{char [10]}, which is an array lvalue type. We have previously stated that array can't be copied directly, so the compilation will fail.
%	
%
%\begin{lstlisting}[basicstyle=\scriptsize]
%template <class T1, class T2> 
%inline pair<T1,T2> make_y(T1&& x, T2&& y) { 
%    return pair<T1, T2>(std::forward<T1>(x), std::forward<T2>(y)); 
%}
%
%char arr[10]{'a','b'};
%std::pair<std::string,int> p = std::make_y(move(arr), 42);
%template<> //C++ insight generate instantiate for previous code.
%inline std::pair<char [10], int> make_y<char [10], int>(char (&&x)[10], int && y) {
% return std::pair<char [10], int>(std::forward<char [10]>(x), std::forward<int>(y));
%}
%\end{lstlisting}
%
%	\item In order to resolve this problem, we need to add decay. Because decay change array type to pointer type, so we can build \texttt{pair<char*, int>} properly. 
%\begin{lstlisting}[basicstyle=\scriptsize]
%template <class T1, class T2>
%pair<typename decay<T1>::type, typename decay<T2>::type> make_y(T1&& x, T2&& y) {
% return pair<typename decay<T1>::type ,typename decay<T2>::type>(std::forward<T1>(x), std::forward<T2>(y));
%}
%
%char arr[10]{'a','b'};
%std::pair<std::string,int> p = std::make_y(move(arr), 42); //work now.
%template<>
%inline std::pair<char *, int> make_y<char [10], int>(char (&&x)[10], int && y) {
%	return std::pair<char *, int>(std::forward<char [10]>(x), std::forward<int>(y));
%}
%\end{lstlisting}
%
%
%    \item The similarity between \texttt{std::make\_pair} and \texttt{std::thread} when deal with input argument.
%    
%\begin{center}
%    \includegraphics[width=0.99\linewidth]{pics/make_pair.drawio.png}
%\end{center}

\end{itemize}



\subsection{Management of thread}
\subsubsection{Ownership and identification of a thread}


	 The following code demonstrates the concept of a thread ID and how to obtain it. Note that the return type of the thread ID is \texttt{std::thread::id}. A \texttt{std::mutex} is utilized to prevent concurrent threads from overlapping output content, I will introduce this in the later section. 
\begin{lstlisting}[frame=single, language=c++]
std::mutex g_display_mutex;
void foo(){
	std::thread::id this_id = std::this_thread::get_id();   // std::thread::id
	g_display_mutex.lock();
	std::cout << "thread " << this_id << " sleeping...\n";
	g_display_mutex.unlock();	
	std::this_thread::sleep_for(std::chrono::seconds(5));
}

std::thread t1(foo);
std::thread t2(foo);	
t1.join(); t2.join();
\end{lstlisting}		

	
	\par Thread IDs can be used as keys in associative containers to associate specific data with each thread. Alternatively, mechanisms like \texttt{sleep()} cause a thread to pause execution for a specified duration. During this period, if no other threads or processes require execution, the CPU may enter a power-saving mode. On the other hand, \texttt{yield()} indicates that the thread is not performing critical tasks, allowing other threads or processes that need CPU time to run. If no such tasks exist, the current thread will continue its execution.
	
	\par Just like \texttt{ifstream} and \texttt{unique\_ptr}, thread is only movable but not copyable. 
\begin{lstlisting}[frame=single, language=c++]
auto l1 = [](){cout << "hello c world" << endl; };
thread t(l1);   
thread t1;
t1 = std::move(t);
cout <<boolalpha<< t.joinable();  //false
t = thread(f1);  //you can assign new value here, 
                 //you can't do it if you don't move previously.
cout << t.joinable(); //true here.
t.join();
t1.join();
\end{lstlisting}	
	
	\par There is a notable example in the second chapter of "C++ Concurrency in Action". It introduces how to dynamically choose the number of threads at runtime.
	
	\begin{itemize}
		\item If the task size is small, such as when a vector has fewer than 25 elements, using multiple threads is unnecessary due to the overhead cost associated with each thread.
		
		\item \texttt{std::thread::hardware\_concurrency()} represents the ceiling for available threads. Since it reflects true multi-threading capabilities, it's advisable to utilize it fully.
	\end{itemize}

\begin{lstlisting}[frame=single, language=c++]
template<typename Iterator, typename T>
T parallel_accumulate(Iterator first, Iterator last, T init) {
  unsigned long const length = std::distance(first, last);
		
  unsigned long const min_per_thread = 25;
  unsigned long const max_threads =(length + min_per_thread - 1) / min_per_thread;
	
  unsigned long const hardware_threads = std::thread::hardware_concurrency();
	
  unsigned long const num_threads =
  std::min(hardware_threads != 0 ? hardware_threads : 2, max_threads);
  ...
\end{lstlisting}	
	

\subsubsection{Cooperative interruption}

	 Can a thread be terminated? Before C++20, the answer was no. However, with C++20, you can politely request a thread to stop executing. Why is it generally not a good idea to forcefully terminate a thread? The answer is straightforward: when you forcibly terminate a thread, you cannot predict its current state. This uncertainty can lead to two potential undesirable outcomes:

	\begin{itemize}
		\item The thread might only be halfway through its task. Therefore, you cannot determine the state of that task or the overall state of your program. This uncertainty leads to undefined behavior, making the outcome unpredictable
		
		\item If the thread is in a critical section and holds a \texttt{std::mutex}, terminating the thread while it holds the mutex significantly increases the risk of causing a deadlock.
		
	\end{itemize}
	
	\par Terminating a thread forcefully is not advisable. Instead, in C++20, you can politely ask a thread if it is willing to stop. This approach, known as cooperative interruption, allows the thread to either accept or ignore the interruption request.
	
	\par For clear separation, the functionality of receiving stop notifications and requesting a stop is divided into two types — \texttt{std::stop\_token} and \texttt{std::stop\_source}. A \texttt{std::stop\_token} instance can be queried for stop notifications. And, \texttt{std::stop\_source} provides functions to get a \texttt{std::stop\_token} instance and send a stop notification to its associated tokens. \texttt{std::stop\_source}, \texttt{std::stop\_token}, and \texttt{std::stop\_callback} are lightweight objects that refer to a shared stop-state. A new stop-state is created when a \texttt{std::stop\_source} is default constructed. Any further copies of a \texttt{std::stop\_source}, associated \texttt{std::stop\_token(s)}, and \texttt{std::stop\_callback(s)} refer to the same stop-state. A stop-state records a stop event and maintains the callback registrations. It stays alive as long as there is at least one object referring to it. The following schematic shows the typical relationship among these objects:
	
	\begin{center}
		\includegraphics[width=0.6\linewidth]{pics/stop_token.drawio.png}
	\end{center}	
	
	
	\par Basic usage of stop source and stop token. Usually, the thread include while loop.
\begin{lstlisting}[frame=single, language=c++]	
void data_processors() {
	std::stop_source ssource;
		
	// gets a stop token from the stop source.
	std::thread processor1([stoken=ssource.get_token()]() {
		while(!stoken.stop_requested()) {
			//Process data...
		}     
	});    
	std::thread processor2([stoken=ssource.get_token()]() {
		while(!stoken.stop_requested()) {
			//Process data...
		}     
	});

	std::this_thread::sleep_for(5s);
	ssource.request_stop(); //Request stop. This would stop both data processors.	
	processor1.join();
	processor2.join();
}
\end{lstlisting}

	\par Sometimes, threads can't always actively monitor a stop token. For instance, a thread waiting on a condition variable can't check a stop condition unless it is signaled. For that reason, a callback mechanism is provided through \texttt{std::stop\_callback}. A \texttt{std::stop\_callback} instance registers a callback function for a given stop token. The callback is invoked when the token receives a stop request.

\begin{lstlisting}[frame=single, language=c++]
std::queue<int> jobs;
std::mutex mut;
std::condition_variable cv;

void worker(std::stop_token stoken) {
	std::stop_callback cb(stoken, []() { //Register a stop callback  
		cv.notify_all(); //Wake thread on stop request
	});
	
	while (true) {
		int jobId = -1;
		{ //Aquire a jobId in lock
			std::unique_lock lck(mut);
			cv.wait(lck, [stoken]() {
				return jobs.size() > 0 || stoken.stop_requested();
			});
			
			if (stoken.stop_requested()) { //Stop if requested to stop
				break;
			}
			jobId = jobs.front(); //There is jobId. Grab it.
			jobs.pop();
		} //End of locked block
	} //End of while loop
}

void manager() {
	std::stop_source ssource; //Create a stop source
	
	std::thread worker1(worker, ssource.get_token());
	std::thread worker2(worker, ssource.get_token());
	for (int i = 0; i < 5; i++) {
		{ //Locked block
			std::unique_lock lck(mut);
			jobs.push(i);
			cv.notify_one(); //Wakes up only one worker
		}
		std::this_thread::sleep_for(1s);
	}
	
	ssource.request_stop();
	worker1.join();
	worker2.join();
}	
\end{lstlisting}

	\par In fact, we don't have to use \texttt{std::stop\_callback} explicitly when waiting on a condition variable. C++20 introduced a new \texttt{std::condition\_variable\_any} class, and its member function \texttt{wait()} can takes a \texttt{std::stop\_token} and awakes a waiting thread on stop request. 
\begin{lstlisting}[frame=single, language=c++]	
std::condition_variable_any cv_any; // not std::condition_variable

void worker_cv_any(std::stop_token stoken) {
	while (true) {
		int jobId = -1;	
		{ //Locked block
			std::unique_lock lck(mut);
			//wait() function takes a stop token and predicate
			if(!cv_any.wait(lck, stoken, []() {
				return jobs.size() > 0; //Condition to wake
			})) { //returned false. Therefore woke up because of a stop request. 
				break; //Leave
			}
			jobId = jobs.front();
			jobs.pop();
		}
	} //End of while loop
}	
\end{lstlisting}

	\par \texttt{jthread} creates and owns a \texttt{std::stop\_source}, detail can be found in \texttt{jthread} constructor in cppreference.com. If initialized with a function that accepts a \texttt{std::stop\_token,} \texttt{std::jthread} gets a stop token from its stop source and passes it to the function.

\begin{lstlisting}[frame=single, language=c++]
std::jthread sleepy_worker( [] (std::stop_token stoken) {
	for(int i=0; i < 10; i++) {
		std::this_thread::sleep_for(300ms);
		if(stoken.stop_requested()) {
			std::cout << "Sleepy worker is requested to stop\n";
			return;
		}
		std::cout << "Sleepy worker goes back to sleep\n";
	}
});

// A waiting worker thread, condition variable is awoken by the stop request.
std::jthread waiting_worker([] (std::stop_token stoken) {
	std::mutex mutex;
	std::unique_lock lock(mutex);
	std::condition_variable_any().wait(lock, stoken,
	[&stoken] { return false; });
	if(stoken.stop_requested()) {
		std::cout << "Waiting worker is requested to stop" << "\n";
		return;
	}
});

sleepy_worker.request_stop(); //call request_stop directly by jthread.
sleepy_worker.join();

// waiting_worker's destructor will call request_stop() 
//and join the thread automatically here
\end{lstlisting}


	\par A good reference is "std::jthread and cooperative cancellation with stop token"

\subsubsection{Thread pool}


	 In this implementation, the \texttt{ThreadPool} class initializes a fixed number of threads upon construction and maintains them until the object is destructed. Tasks are added to the thread pool using the \texttt{enqueue} method, which generates a closure capturing the provided function and arguments, then adds it to a task queue. Threads in the pool retrieve tasks from this queue as they become available, executing them sequentially.
	
	\par Below code creates a thread pool with 4 threads and enqueue 8 tasks to be executed concurrently. Each task waits for 1 second and then prints a completion message. After a 5-second delay, the main thread returns, leading to the destruction of the thread pool. This causes all threads to be joined and terminated. To understand how a thread pool deals with tasks of different signatures (varying numbers and types of parameters) by using \texttt{std::queue< std::function<void()> >}.

\begin{lstlisting}
class ThreadPool {
public:
	ThreadPool(int numThreads) {
		for (int i = 0; i < numThreads; ++i) {
			threads.emplace_back([this]() {
				while (true) {
					std::unique_lock<std::mutex> lock(mutex_);
					condition_.wait(lock, [this]() { return !tasks_.empty() || stop_; });
					if (stop_ && tasks_.empty())
						return;
					std::function<void()> task = tasks_.front();
					tasks_.pop();
					lock.unlock();
					
					task(); //run every task here. 
				}
			});
		}
	}
	
	~ThreadPool() {
		{
			std::unique_lock<std::mutex> lock(mutex_);
			stop_ = true;
		}
		condition_.notify_all();
		for (std::thread& thread : threads) {
			thread.join();
		}
	}
	
	template <typename F, typename... Args>
	void enqueue(F&& f, Args&&... args) {
		std::unique_lock<std::mutex> lock(mutex_);
		tasks_.emplace([=]() { f(args...); }); 
	//use lambda to implement type erase, accept functions with different signature.  
		condition_.notify_one();
	}
	
private:
	std::vector<std::thread> threads;
	std::queue<std::function<void()>> tasks_;
	std::mutex mutex_;
	std::condition_variable condition_;
	bool stop_ = false;
};

void task(int i) {
	std::cout << "Task " << i << " started" << std::endl;
	std::this_thread::sleep_for(std::chrono::seconds(1));
	std::cout << "Task " << i << " finished" << std::endl;
}

int main() {
	ThreadPool pool{4};
	for (int i = 0; i < 8; ++i) {
		pool.enqueue(task, i);
	}
	std::this_thread::sleep_for(std::chrono::seconds(5));
	return 0;
}	
\end{lstlisting}	
	

\section{Sharing data}

\subsection{Invariant}

	 In computer programming, an invariant can be defined as a set of assumptions that a piece of code relies on before it can execute any significant computation. If these assumptions are not true, the resulting computation may be meaningless, or more accurately, its correctness cannot be guaranteed. An invariant typically refers to conditions that must hold true at certain points during program execution, or even continuously. For example, PreConditions and PostConditions ensure that specific conditions are met when a function is called and when it returns, respectively. Object invariants, on the other hand, assert that an object maintains a valid state throughout its existence. This adherence to conditions is foundational to the design by contract principle in programming.
	
	\par Understanding invariants involves two critical aspects. Firstly, it's crucial that only one thread can observe a broken invariant at any given time (location-based). Secondly, when designing a data structure, its invariants should ensure that modifications occur as a series of indivisible changes, with each change preserving these invariants. For example, consider a shared pointer: its invariant dictates that the underlying object exists only as long as the reference count to it is greater than zero.
	
	In languages like C++, constructors and destructors play a pivotal role in establishing and maintaining invariants. An object's life cycle begins when its constructor returns and ends when its destructor is called. It's permissible for invariants to be temporarily violated during method execution, as long as they are restored before the method returns. This caveat does not extend to private methods that are inaccessible from outside the class. Additionally, object fields involved in an object's invariants should not be externally accessible.
	
	\par Argument checking and assertions in release builds are a matter of careful consideration, and whether to include them depends on several factors:
	
\begin{itemize}
	\item Input Validation: If the argument checking serves as input validation from end users, it should definitely be kept in the release build to ensure the integrity of data flowing into the system.
	
	\item Performance Impact: In performance-critical systems, it's essential to profile the code using profilers. If argument checking is identified as a bottleneck affecting performance significantly, it might be considered for removal in release builds. However, caution should be exercised as this impacts robustness.
	
	\item Test Coverage: The effectiveness of the automated test suite is crucial. If the test suite is thorough and covers various scenarios, including edge cases caught by argument checking, it provides confidence in removing them from release builds. However, complete reliance on code coverage alone may not suffice.
	
	\item Risk Tolerance: Consider the organization's risk tolerance. If there is a high tolerance for handling potential production issues without the safety net of argument checking and assertions, it may influence the decision to omit them in release builds.
\end{itemize}
	In summary, while argument checking and assertions are beneficial for maintaining invariants and ensuring robustness during development, their inclusion in release builds should be carefully evaluated based on these factors to strike a balance between reliability and performance.
	
	\par A race condition occurs when the outcome of an operation depends on the sequence or timing of individual operations. If a race condition disrupts an invariant, it is often referred to as a data race. Thread safety refers to the capability of preserving an object’s invariants in a multi-threaded environment.


\subsection{Mutex and lock}
\subsubsection{Data race}
	
	 Why do we need mutexes? Even the increment operator (\texttt{op++}) is not an atomic operation. It translates into three assembly statements. Therefore, if two threads execute \texttt{op++} concurrently, Thread 1 may fetch the value of \texttt{op} into a register, then Thread 2 increments it before Thread 1 stores back its value. As a result, although both threads called \texttt{op++}, the value of \texttt{op} might only increment by 1. This discrepancy in memory updates is what we call a data race.
\begin{lstlisting}[frame=single, language=c++]
op++; //not a atomic operation.

move mem reg
add reg 1
move reg mem
\end{lstlisting}		

    \par Even when one thread reads and another writes, a data race can occur. Assigning a value to \texttt{i} using \texttt{i = 2} is not atomic. On 64-bit systems, some CPUs may write the lower 32 bits first and then the upper 32 bits, or vice versa. If another thread interrupts in between, a situation known as a 'torn write' can result when accessing \texttt{i}. This is another detrimental consequence of a data race.
\begin{lstlisting}[]
i = 2; //one thread write

a = i;//another thread read
\end{lstlisting}

    \par \texttt{share\_ptr} is not thread safe either, because it includes ptr and reference count, so you should not read and write the same \texttt{share\_ptr} in different thread without lock. 

\begin{lstlisting}
shared_ptr<int> p(new int(42));
//Example 1: multi read is OK
shared_ptr<int> p2(p); // tread A, reads p
shared_ptr<int> p3(p); // thread B, OK, multiple reads are safe

//Example 2: multi write to different shared_ptr is OK
p.reset(new int(1912)); // thread A, writes p
p2.reset(); // thread B OK, writes different p2

//Example 3: One thread write, the other thread read, NOT ok!
p = p3; // thread A, reads p3, writes p
p3.reset(); // thread B, Error, writes p3; undefined, simultaneous read/write

//Example 4: One thread read, the other thread destruct p2, NOT ok!
p3 = p2; // reads p2, writes p3
// thread B
// Error, p2 out of scope: undefined, the destructor is considered a "write access"

//Example 5: Both write, NOT ok!
p3.reset(new int(1)); //thread A,
p3.reset(new int(2)); //thread B, Error  undefined, multiple write		
\end{lstlisting}
   
    \begin{center}
    	\includegraphics[width=0.80\linewidth]{pics/shared_ptr_con.png}
    \end{center}
    




%    \item \texttt{share\_ptr} causes the data race. Because it also includes two seperate operations. A detail can be seen below:

    

    \par There is a conception of "Benign data race", but right now, all data race is considered bad. because sometimes compiler will change the "Benign data race" into the "harmful data race". An example can be seen in "How to miscompile programs with benign data races". If \texttt{p->data} are all positive, then \texttt{count++} update will never happen. But after compiler optimization, we have a last statement \texttt{count = reg}.  If at the same time, there is another thread modify count, then modification will "disappear" by the first thread to perform \texttt{count = reg}. That is why a benign data race is really harmful. So just remember, There is no benign data race in C++ concurrency.
\begin{lstlisting}[]
for (p = x; p != 0; p = p -> next) {
    if (p -> data < 0) count++;
} 

//previous code will be changed into below code by compiler.
reg = count;
for (p = x; p != 0; p = p -> next) {
    if (p -> data < 0) reg++;
}
count = reg //in the end, it will modify the count
\end{lstlisting}


    \par Summary: What can cause a data race? \textbf{When multiple threads access a shared resource and at least one thread writes to it while another thread performs a read or a non-atomic write operation.} In the count++ example, the write operation is not atomic because it involves reading count from memory to a register, adding 1, and then writing it back. In the \texttt{a = i} example, the low 32 bits may be written before the high 32 bits, causing non-atomicity. In the \texttt{shared\_ptr} example, the pointer part is read first, followed by the count part, demonstrating non-atomicity. All three examples illustrate non-atomic operations that can cause a data race.
    
    \par  Some good reference page are "Benign data races: what could possibly go wrong?"; "Invariants in Code Design". About data race and race condition, you can see a good reference page: "Race Condition vs. Data Race"; "Fun with Concurrency Problems". Please just google these pages. 
        


\subsubsection{Lock and mutex}

	
	 We can make an analogy that \texttt{std::mutex} is like a raw pointer, where you need to manually lock and unlock, similar to how you use \texttt{new} and \texttt{delete} with pointers. If an exception is thrown between \texttt{new} and \texttt{delete}, we won't have a chance to run \texttt{delete}. Therefore, we invented smart pointers and RAII to handle this problem. Similarly, the relationship between \texttt{std::lock\_guard} and \texttt{std::mutex} is like the relationship between smart pointers and raw pointers. That is why we usually don't use \texttt{std::mutex} directly. \texttt{std::unique\_lock}, \texttt{std::lock\_guard}, or \texttt{std::scoped\_lock} (since C++17) manage locking in a more exception-safe manner. The difference is that you can lock and unlock a \texttt{std::unique\_lock} multiple times, whereas \texttt{std::lock\_guard} will be locked only once on construction and unlocked on destruction. 
\begin{lstlisting}[frame=single, language=c++]
std::mutex mx
std::lock_guard<std::mutex> lg(mx); //specify type.
std::scoped_lock guard(mx);  //C++ 17 template argument deduction
\end{lstlisting}

	\par It is common to group the mutex and the protected data together in a class instead of using global variables. This is a standard application of object-oriented design principles. However, if one of the member functions returns a pointer or reference to the protected data, it becomes irrelevant that the member function locks the mutex because it opens a backdoor, which should be avoided.

	\par There are three main kinds of mutex: \texttt{mutex}, \texttt{recursive\_mutex}, and \texttt{shared\_mutex}. \texttt{shared\_mutex} allows multiple threads to read shared data simultaneously, but provides exclusive access for writing. \texttt{std::recursive\_mutex} is a type of mutex that can be locked multiple times by the same thread without causing a deadlock. This is useful in scenarios where a function that locks the mutex may be called recursively, either directly or indirectly.
	
	\par A simple implementation of \texttt{std::mutex} is based on a kind of "spin lock", detail can be found in the "atomic and memory order" section.
	
%	 When trying to acquire a mutex, the lock will first spin for a while. If it is unable to acquire the mutex during the spinning period, it will then suspend.
		
	\par The basic usage guidelines for locks are as follows:
	
\begin{itemize}	
	\item \texttt{std::lock\_guard}: Use this when you need to lock exactly one mutex for the entire scope.
	
	\item \texttt{std::scoped\_lock}: Use this when you need to lock multiple mutexes (not just one). This helps to avoid deadlock problems.
	
	\item \texttt{std::unique\_lock}: Use this when you need to unlock within the scope of the block (such as with a condition variable) or transfer mutex ownership between scopes.
	
\end{itemize}

    \par \texttt{std::scoped\_lock} is an enhanced version of \texttt{std::lock\_guard} that can lock multiple mutexes simultaneously using the same deadlock-avoidance algorithm as \texttt{std::lock}. Therefore, for new code, it is recommended to use \texttt{std::scoped\_lock} instead of \texttt{std::lock\_guard}. However, \texttt{std::lock\_guard} still exists for compatibility reasons and cannot be removed, as it is used in existing code.

	\par The \texttt{std::scoped\_lock} class template is a variadic template supporting any number of mutexes. The declaration of the \texttt{scoped\_lock} can be simplified thanks to C++17 template argument deduction for constructors:
\begin{lstlisting}[frame=single, language=c++]	
std::mutex mutex1;
std::recursive_mutex mutex2;
// ...
std::scoped_lock sl(mutex1, mutex2);
\end{lstlisting}	
	
    \par \texttt{std::unique\_lock} in C++ provides flexibility in managing mutex locks, including the ability to transfer ownership of the lock. This allows a function to lock a mutex and then transfer the ownership of that lock to its caller, enabling the caller to perform additional actions under the protection of the same lock.

\begin{lstlisting}[frame=single, language=c++]	
std::unique_lock<std::mutex> get_lock(){
	extern std::mutex some_mutex;
	std::unique_lock<std::mutex> lk(some_mutex);
	...prepare_data();
	return lk
}

void process_data{
	std::unique_lock<std::mutex> lk(get_lock());
	do_something.
}
\end{lstlisting}


	\par \texttt{std::mutex} is a commonly used synchronization primitive in C++ that provides mutual exclusion to shared resources. Here are some typical applications of \texttt{std::mutex}:
	\begin{itemize}
		
		\item Protecting shared data structures: When multiple threads need to access and modify the same data structure concurrently, \texttt{std::mutex} ensures that only one thread accesses the structure at a time, preventing data race conditions.
		
		\item Implementing thread-safe queues: Thread-safe queues allow multiple threads to insert and remove elements without synchronization issues. \texttt{std::mutex} ensures exclusive access to the queue, maintaining its integrity.
		
		\item Synchronizing access to I/O streams: For scenarios where multiple threads write to the same I/O stream, \texttt{std::mutex} prevents interleaved output, which can cause unexpected behavior.
		
		\item Protecting global variables: When multiple threads read from or modify the same global variable, \texttt{std::mutex} ensures that only one thread accesses the variable at any given time, avoiding synchronization issues.
		
		\item Controlling access to resources: Shared resources like network connections or databases require controlled access. \texttt{std::mutex} ensures that only one thread accesses the resource, promoting efficient and safe usage.
		
		\end{itemize}
	
		 
	
		\par \texttt{std::call\_once} is a C++11 feature that ensures a function is called exactly once by multiple threads, even if called concurrently by different threads. It is typically used to initialize resources that should only be initialized once throughout the lifetime of a program, such as global data structures or singletons.
	
\begin{lstlisting}[frame=single, language=c++]	
std::once_flag flag1, flag2;
void simple_do_once(){
	std::call_once(flag1, [](){ std::cout << "Simple example: called once\n"; });
}
void may_throw_function(bool do_throw) {
	if (do_throw) {
		std::cout << "throw: call_once will retry\n"; // this may appear more than once
		throw std::exception();
	}
	std::cout << "Didn't throw, call_once will not attempt again\n"; // guaranteed once
}

void do_once(bool do_throw) {
	try {
		std::call_once(flag2, may_throw_function, do_throw);
	}
	catch (...) {
	}
}

std::thread st1(simple_do_once); //only output once
std::thread st2(simple_do_once);
st1.join(); st2.join();

std::thread t1(do_once, true); //call twice, because there is exception.
std::thread t2(do_once, true); //need to run it again. 
t1.join();
t2.join();	
\end{lstlisting}

	\par google "What's the best way to lock multiple std::mutex'es?" in stackoverflow.
	

\subsubsection{shared\_mutex}


     In C++, the \texttt{shared\_mutex} can be used for read and write locking. If a thread acquires the exclusive lock (through \texttt{lock} or \texttt{try\_lock}), no other threads can acquire any lock (including shared locks). If a thread acquires a shared lock (through \texttt{lock\_shared} or \texttt{try\_lock\_shared}), other threads can acquire shared locks but not the exclusive lock. When a thread acquires the exclusive lock using lock() or try\_lock(), it gains exclusive access to the resource. No other threads can acquire any locks (neither shared nor exclusive) while the exclusive lock is held. When a thread acquires a shared lock using lock\_shared() or try\_lock\_shared(), it gains shared access to the resource. Other threads can also acquire shared locks simultaneously, allowing multiple threads to read the resource concurrently. However, no thread can acquire an exclusive lock while any shared locks are held.
 
\begin{lstlisting}
std::shared_mutex mtx;
mtx.lock(); // Acquires exclusive lock
// critical section
mtx.unlock(); // Releases exclusive lock

mtx.lock_shared(); // Acquires shared lock
// read-only critical section
mtx.unlock_shared(); // Releases shared lock
\end{lstlisting}

	\par The class \texttt{std::shared\_lock} is a general-purpose shared mutex ownership wrapper allowing deferred locking, timed locking and transfer of lock ownership. Locking a \texttt{std::shared\_lock} locks the associated shared mutex in shared mode (to lock it in exclusive mode, \texttt{std::unique\_lock} can be used).

\begin{lstlisting}[frame=single, language=c++]	
class ThreadSafeCounter {
	public:
	ThreadSafeCounter() = default;
	
	// Multiple threads/readers can read the counter's value at the same time.
	unsigned int get() const {
		std::shared_lock lock(mutex_);
		return value_;
	}
	
	// Only one thread/writer can increment/write the counter's value.
	unsigned int increment() {
		std::unique_lock lock(mutex_);
		return ++value_;
	}
	
	// Only one thread/writer can reset/write the counter's value.
	void reset() {
		std::unique_lock lock(mutex_);
		value_ = 0;
	}
	
private:
	mutable std::shared_mutex mutex_;
	unsigned int value_ = 0;
};	
\end{lstlisting}

    \par \texttt{shared\_mutex} has some performance concern, another option is to use common mutex and \texttt{std::shared\_ptr}. \texttt{std::shared\_ptr} is not thread safe, so we use lock to protect, In query function, once we get \texttt{std::shared\_ptr}, we don't need to protect, that is why we put protected logic into the \texttt{getData} function.

\begin{lstlisting}[frame=single, language=c++]	
class CustomerData : boost::noncopyable{
public:
	CustomerData() : data_(new Map) { }
	int query(const string& customer, const string& stock) const;
	
private:
	typedef std::pair<string, int> Entry;
	typedef std::vector<Entry> EntryList;
	typedef std::map<string, EntryList> Map;
	typedef boost::shared_ptr<Map> MapPtr;
	void update(const string& customer, const EntryList& entries);
	void update(const string& message);
	
	static int findEntry(const EntryList& entries, const string& stock);
	static MapPtr parseData(const string& message);
	
	MapPtr getData() const { 
		std::lock_guard lock(mutex_);
		return data_;
	}
	
	std::mutex mutex_;
	MapPtr data_;
};

int CustomerData::query(const string& customer, const string& stock) const{
	MapPtr data = getData();
	Map::const_iterator entries = data->find(customer);
	if (entries != data->end())
		return findEntry(entries->second, stock);
	else
		return -1;
}
\end{lstlisting}

	\par How to update? The most important points to help you understand is swap exchange not only pointer, but also reference number. 
\begin{lstlisting}
void CustomerData::update(const string& customer, const EntryList& entries){
	std::lock_guard lock(mutex_);
	if (!data_.unique()){ //only shared_ptr managing the current object 
		//somebody is reading, so copy a new one.
		MapPtr newData(new Map(*data_));
		data_.swap(newData);
    }
	assert(data_.unique());
	(*data_)[customer] = entries;
}
\end{lstlisting}

\begin{center}
		\includegraphics[width=0.58\linewidth]{pics/read_copy.png}
\end{center}


    \par By following these guidelines, you can use mutex and lock effectively to manage concurrency in your C++ programs, reducing the risk of deadlocks, race conditions, and other synchronization issues.
\begin{itemize}
    \item Using a mutex for inter-process synchronization is not recommended. Instead, use IPC (Inter-Process Communication) mechanisms like TCP sockets, which are designed to handle communication between processes.

    \item Only use non-recursive mutex. If you have to use recursive mutex, you'd better redesign your framework.
    
    \item Keep the critical section (protected region) as short as possible. This reduces contention and potential for deadlocks, improving overall performance.
    
    \item Use RAII (Resource Acquisition Is Initialization) to manage \texttt{std::mutex} lifetimes automatically with \texttt{std::scoped\_lock} or \texttt{std::unique\_lock}.
    
    \item When locking multiple mutexes, use \texttt{std::scoped\_lock} to avoid deadlocks.
    
    \item Use \texttt{ try\_lock} to attempt to acquire a lock without blocking, allowing your program to continue if the lock isn't available.
\begin{lstlisting}
if (mtx.try_lock()) {
	// Critical section
	mtx.unlock();
} else {
	// Handle the case where the lock is not available
}
\end{lstlisting}
	
	\item Avoid locking mutexes in destructors to prevent deadlocks or exceptions during stack unwinding.

\end{itemize}


\subsubsection{Problem of lock}

	How to avoid dead lock?
	\begin{itemize}
		\item Avoid nested locks, don't try to acquire a lock when you already hold one.
		
		\item Avoid calling user-supplied code while holding a lock, maybe this function has hold a lock already.
		
		\item Acquire locks in a fixed order, prefer to use \texttt{scoped\_lock} if the compiler supports it.
		
		\item Deadlock doesn't only occur with locks, it can occur with any synchronization construct that can lead to a wait cycle. For example, it's a bad idea to wait for a thread while holding a lock, because that thread might need to acquire the lock in order to proceed, so extending above guidelines beyond locks. 
	\end{itemize}	

	\par Compare below three codes, they do the same thing to avoid deadlock. So we should use \texttt{scoped\_lock} more. 
\begin{enumerate}
	\item \texttt{std::lock} is a function that can lock multiple mutexes at once, preventing deadlocks by using a deadlock avoidance algorithm. If a call to lock or unlock results in an exception, unlock is called for any locked objects before rethrowing. 
	
	
\begin{lstlisting}[frame=single, language=c++]
std::unique_lock<std::mutex> lk1(mutex1, std::defer_lock);
std::unique_lock<std::mutex> lk2(mutex2, std::defer_lock);
std::lock(lk1, lk2); // lock use deadlock avoidance algorithm. 
swap(lhs.some_detail, rhs.some_detail);		
\end{lstlisting}	
	
	\item You can use \texttt{std::adopt\_lock} to indicate that the mutexes are already locked, or \texttt{std::defer\_lock} to indicate that they should not be locked yet.

\begin{lstlisting}[frame=single, language=c++]
std::lock(lhs.m, rhs.m);
std::lock_guard<std::mutex> lock_a(lhs.m, std::adopt_lock);
std::lock_guard<std::mutex> lock_b(rhs.m, std::adopt_lock);
swap(lhs.some_detail, rhs.some_detail);	
\end{lstlisting}
\begin{description}
	\item[Source code] Pay attention to the \texttt{std::adopt\_lock.} There are three constant instances. \\ \texttt{std::defer\_lock,} \texttt{std::try\_to\_lock} and \texttt{std::adopt\_lock} are instances of empty struct tag types \texttt{std::defer\_lock\_t,} \texttt{std::try\_to\_lock\_t} and \texttt{std::adopt\_lock\_t} respectively. They are used in overload \texttt{shared\_lock} and \texttt{unique\_lock}. 
\end{description}

	\item \texttt{std::scoped\_lock} offers a RAII wrapper for \texttt{std::lock} function, and is generally preferred to a naked call to \texttt{std::lock}.

\begin{lstlisting}[frame=single, language=c++]
std::scoped_lock guard(lhs.m, rhs.m);
swap(lhs.some_detail, rhs.some_detail);	
\end{lstlisting}	

\end{enumerate}

	\par Even when you use a mutex to protect member data in your class, you still need to design your class interface to support concurrent programming.
	
\begin{itemize}
	\item It's worth noting that in order to make the stack class exception-safe, we need to have two interface functions: \texttt{top()} and \texttt{pop()}. If we could only use one function and we want to keep the class exception-safe, we can't return a value (because copying a value when returning may throw an exception).
	
	\item But from concurrent perspective, we can't have \texttt{top()} and \texttt{pop()} function for a stack at the same time, because we can't make two interface functions atomic at the same time. Why separate locks for \texttt{top()} and \texttt{pop()} don't solve the problem? Suppose we have a thread-safe stack class where both \texttt{top()} and \texttt{pop()} are protected by their own locks: Consider two threads, Thread 1 and Thread 2, operating on the stack:
\begin{enumerate}
	\item Thread 1 locks the mutex in \texttt{top()} and retrieves the top element.
	
	\item Thread 1 releases the lock after retrieving the top element.
	
	\item Thread 2 locks the mutex in \texttt{pop()} and removes the top element.
	
	\item Thread 2 releases the lock after removing the top element.
	
	\item Thread 1 now calls \texttt{pop()} and attempts to remove the element it retrieved earlier, but that element has already been removed by Thread 2.
\end{enumerate}
	
	\item The solution is to use \texttt{pop} only, we will not provide \texttt{top} interface any more. \texttt{pop} will return a \texttt{std::shared\_ptr} or a references, which will not throw any exceptions.	 
	
\begin{lstlisting}[frame=single, language=c++]
std::shared_ptr<T> pop(){
	std::lock_guard<std::mutex> lock(m);
	if(data.empty()) throw empty_stack();
	std::shared_ptr<T> const res( std::make_shared<T>( std::move(data.top()) ) );
	data.pop();
	return res;
}

void pop(T& value){
	std::lock_guard<std::mutex> lock(m);
	if(data.empty()) throw empty_stack();
	value=std::move( data.top() ); //this statement is OK here.
	data.pop();
}		
\end{lstlisting}	
\begin{description}
	\item[Line 12] The statement looks error, because you can't assign rvalue to a lvalue reference. But it's an assignment here, when you run \texttt{pop(t)} function, it will assign move value to \texttt{t}, so this function can run correctly here. 
\end{description}
\end{itemize}
	
	\par In computer science, a lock convoy is a performance problem that can occur when using locks for concurrency control in a multithreaded application.  A lock convoy occurs when multiple threads of equal priority contend repeatedly for the same lock. Unlike deadlock and livelock situations, the threads in a lock convoy do progress; however, each time a thread attempts to acquire the lock and fails, it relinquishes the remainder of its scheduling quantum and forces a context switch. The overhead of repeated context switches and underutilization of scheduling quanta degrade overall performance. A good reference is "A Complete Guide to Lock Convoys", it introduces some deep knowledge about CPU, operating system kernel, and the way your locks are implemented in software.
	
	\par Lock convoys often occur when concurrency control primitives such as locks serialize access to a commonly used resource, such as a memory heap or a thread pool. They can sometimes be addressed by using non-locking alternatives such as lock-free algorithms or by altering the relative priorities of the contending threads.


\section{Synchronization}
\subsection{Conditional variable}
	     The implementation of a condition variable can be understood in the following way: first, you lock a mutex and then check a flag. If the flag is set, you exit the wait. It's important to note that the mutex remains locked upon return from the wait. If the flag is not set, you unlock and go to sleep. After being woken up, you reacquire the mutex and check the flag again to determine if you can proceed.
\begin{lstlisting}[]
bool flag;
std::mutex m;
void wait_for_flag(){
	std::unique_lock<std::mutex> lk(m);
	while(!flag){
		lk.unlock();
		std::this_thread::sleep_for(std::chrono::milliseconds(100));
		lk.lock();
	}
}	
\end{lstlisting}	

	\par The basic idea of a condition variable is simple. In theory, you could implement something like a condition variable using only atomic accesses and timed thread suspension. However, this would perform poorly. Modern operating systems know when a thread is waiting on a condition and can wake that thread up "immediately" when the condition is satisfied. Your mechanism would require the waiting thread to wait until a specific time has passed. Moreover, you'd have many spurious wake-ups to check for, wasting thread time for no reason. An OS-based implementation will have far fewer spurious wake-ups.
	
	\par Basic usage pattern of conditional variable:

\begin{itemize}
	\item Use a global mutex \texttt{std::mutex} and \texttt{std::unique\_lock}.  
	
	\item In one thread, call \texttt{cv.wait()}, pass \texttt{unique\_lock} and lambda with flag check condition (that is for spurious wakeup).
	
	\item In another thread, use \texttt{lock\_guard} or \texttt{scoped\_lock} to lock the same mutex and update the flag.
	
	\item Call \texttt{cv.notify\_one/all()} to wake up the waiting thread. 
\end{itemize}

	\par Here's an example of synchronization between the main and worker threads: the main thread informs the worker when a resource is ready, and the worker informs the main thread when the work is finished. They can use the same mutex for coordination. It's crucial to note that when \texttt{cv.wait} returns, the mutex \texttt{m} remains locked. This detail is critical for understanding conditional variables. In the source code, remember that \texttt{lock\_guard} must be enclosed within a pair of curly braces.

\begin{lstlisting}[frame=single, language=c++]
std::mutex m;
std::condition_variable cv;
std::string data;
bool ready = false, processed = false;

void worker_thread(){ // Wait until main() sends data
	std::unique_lock<std::mutex> lk(m);
	cv.wait(lk, []{return ready;});
	
	std::cout << "Worker thread is processing data\n";
	data += " after processing"; 	// after the wait, we own the lock.
	
	processed = true; // Send data back to main()
	std::cout << "Worker thread signals data processing completed\n";
	
	// Manual unlocking is done before notifying, to avoid waking up
	// the waiting thread only to block again (see notify_one for details)
	lk.unlock();
	cv.notify_one();
}

int main(){
	std::thread worker(worker_thread);
	data = "Example data";
	{ // send data to the worker thread
		std::lock_guard<std::mutex> lk(m);
		ready = true;
		std::cout << "main() signals data ready for processing\n";
	}
	cv.notify_one(); //tell worker data is ready.
	{ // wait for the worker to finish
		std::unique_lock<std::mutex> lk(m);
		cv.wait(lk, []{return processed;});
	}
	std::cout << "Back in main(), data = " << data << '\n';
	worker.join();
}
\end{lstlisting}


    \par \texttt{notify\_all()} will wake up all the waiting threads one by one. "Broadcast" should generally be used to indicate a state change rather than resource availability.
    
\begin{lstlisting}[frame=single, language=c++]
std::condition_variable cv;
std::mutex cv_m; // This mutex is used for three purposes:
// 1) to synchronize accesses to i
// 2) to synchronize accesses to std::cerr
// 3) for the condition variable cv
int i = 0;

void waits(){
	std::unique_lock<std::mutex> lk(cv_m);
	std::cerr << "Waiting... \n";
	cv.wait(lk, []{return i == 1;});
	std::cerr << "...finished waiting. i == 1\n";
}

void signals(){
	std::this_thread::sleep_for(std::chrono::seconds(1)); {
		std::lock_guard<std::mutex> lk(cv_m);
		std::cerr << "Notifying...\n";
	}
	cv.notify_all();
	
	std::this_thread::sleep_for(std::chrono::seconds(1)); {
		std::lock_guard<std::mutex> lk(cv_m);
		i = 1;
		std::cerr << "Notifying again...\n";
	}
	cv.notify_all();
}

int main(){
	std::thread t1(waits), t2(waits), t3(waits), t4(signals);
	t1.join(); t2.join(); t3.join(); t4.join();
}
\end{lstlisting}

\begin{lstlisting}
Waiting...
Waiting...
Waiting...
Notifying...
Notifying again...
...finished waiting. i == 1
...finished waiting. i == 1
...finished waiting. i == 1
\end{lstlisting}

    \par The difference between \texttt{wait\_for} and \texttt{wait} in the condition variables \texttt{std::condition\_variable} in C++ is as follows:

\begin{itemize}
	\item \texttt{wait\_for(duration)}: This function waits for a specified duration of time or until the condition variable is notified, whichever happens first. If the specified duration elapses before the condition variable is notified, the function returns and the thread continues execution.
	
	\item \texttt{wait(unique\_lock)}: This function waits indefinitely (until notified) while atomically releasing the associated mutex (unique\_lock). When notified, the function reacquires the mutex and continues execution.
	
	\item When using \texttt{wait\_for(lock, duration, pred)} version, it's usually placed inside an if statement. When \texttt{wait\_for} return, it just return \texttt{pred} value, if it returns true, you know the condition has been satisfied, otherwise, it's just timeout. 
\end{itemize}
    
\begin{lstlisting}[frame=single, language=c++]
std::condition_variable cv;
std::mutex cv_m;
int i;

void waits(int idx) {
	std::unique_lock<std::mutex> lk(cv_m);
	if(cv.wait_for(lk, idx*100ms, []{return i == 1;})) 
		std::cerr << "Thread " << idx << " finished waiting. i == " << i << '\n';
	else
		std::cerr << "Thread " << idx << " timed out. i == " << i << '\n';
}

void signals() {
	std::this_thread::sleep_for(120ms);
	std::cerr << "Notifying...\n";
	cv.notify_all();
	std::this_thread::sleep_for(100ms); {
		std::lock_guard<std::mutex> lk(cv_m);
		i = 1;
	}
	std::cerr << "Notifying again...\n";
	cv.notify_all();
}

int main() {
	std::thread t1(waits, 1), t2(waits, 2), t3(waits, 3), t4(signals);
	t1.join(); t2.join(); t3.join(); t4.join();
}
\end{lstlisting}

\begin{lstlisting}
Thread 1 timed out. i == 0
Notifying...
Thread 2 timed out. i == 0
Notifying again...
Thread 3 finished waiting. i == 1
\end{lstlisting}



\subsection{async and future}

	
	 If you just need some code executed asynchronously i.e. Without blocking execution of Main thread, your best bet is to use the \texttt{std::async} functionality to execute the code. The same could be achieved by creating a thread and passing the executable code to the thread via a function pointer or lambda parameter. However, in the later case, you're responsible for managing creation and joining/detaching of them thread, as well as handling any exceptions that might happen in the thread. If you use \texttt{std::async}, you just get rid of all these hassels and also dramatically reduce chances of getting into a deadlock scenario. Another huge advantage of using \texttt{std::async} is the ability to get the result of the task communicated back to the calling thread via a \texttt{std::future} object. For example, assuming we have a function \texttt{fun} which returns an \texttt{int}, we can spin an async task that sets a future when it's done and we can extract the result from that future in our calling thread when at an opportune time.
	
	\par \texttt{std::async} facilitates asynchronous execution in C++, making programming more straightforward. For instance, you can concurrently retrieve data from a database in a separate thread while fetching data from a file in the main thread. This approach simplifies code and enhances readability. Although \texttt{std::async} employs synchronization mechanisms similar to those discussed earlier, it abstracts these details away from the programmer by managing thread creation and synchronization internally. \texttt{std::async} returns a \texttt{std::future} object, which represents the result of an asynchronous operation. This \texttt{std::future} can be used to retrieve the eventual result of the function or task that was executed asynchronously. The type of the result depends on the return type of the function passed to \texttt{std::async}.
	
\begin{lstlisting}[frame=single, language=c++]
using namespace std::chrono;
system_clock::time_point start = system_clock::now(); 	// Get Start Time
std::future<std::string> resultFromDB = std::async(std::launch::async, fetchDataFromDB, "Data");

std::string fileData = fetchDataFromFile("Data"); //Fetch Data from File

// Will block till data is available in future<std::string> object.
std::string dbData = resultFromDB.get();

// Get End Time
auto end = system_clock::now();
auto diff = duration_cast < std::chrono::seconds > (end - start).count();
std::cout << "Total Time Taken = " << diff << " Seconds" << std::endl;
\end{lstlisting}	

    \par If an exception is thrown inside an \texttt{async} task, it will be propagated when \texttt{std::future::get()} is called.

\begin{lstlisting}[]
std::future<int> myFuture = std::async(std::launch::async, []() {
     throw std::runtime_error("Catch me in MAIN");
     return 8;
});

if (myFuture.valid()) {
     try {
         int result = myFuture.get();
     }
     catch (const std::runtime_error& e) {
         std::cout << "Async task threw exception: " << e.what() << std::endl;
     }
}
\end{lstlisting}

 	\par Currently, \texttt{std::async} is probably best suited for handling either very long-running computations or long-running I/O for fairly simple programs. However, it doesn't guarantee low overhead, and in fact, the way it is specified makes it difficult to implement with a thread pool behind the scenes. Therefore, it's not well-suited for finer-grained workloads. For that, you either need to roll your own thread pools using \texttt{std::thread} or use something like Microsoft's PPL or Intel's TBB. \texttt{std::async} is rather limited in the current standard. It will become more useful if the suggested extensions, which incorporate some of the ideas from Microsoft's PPL, are accepted.

	\par We can also use \texttt{std::packaged\_task} to generate a \texttt{std::future}. The main differences between \texttt{std::async} and \texttt{std::packaged\_task} are:

\begin{itemize}
	\item When using \texttt{std::async}, you can't run the task on a specific thread, while a \texttt{std::packaged\_task} can be moved to other threads.
	
	\item A \texttt{packaged\_task} needs to be invoked before calling \texttt{future.get()}, otherwise your program will freeze since the future will never become ready.
	
	\item A \texttt{packaged\_task} won't start on its own; you have to invoke it. On the other hand, \texttt{std::async} with \texttt{launch::async} will attempt to run the task in a different thread. Use \texttt{std::async} if you want something done but don't really care when it's done, and use \texttt{std::packaged\_task} if you want to wrap up things to move them to other threads or call them later.
\end{itemize}
	
    \par Because \texttt{packaged\_task} returns a future object, we can use it to retrieve the return value of tasks without any issues. The typical usage of a packaged task is:

\begin{itemize}
	\item creating the packaged task with a function.
	\item retrieving the future from the packaged task.
	\item passing the packaged task elsewhere.
	\item invoking the packaged task.
\end{itemize}

\begin{lstlisting}[frame=single, language=c++]
int f(int x, int y) { return std::pow(x,y); }

void task_lambda(){
	std::packaged_task<int(int,int)> task([](int a, int b) {
		return std::pow(a, b); 
	});
	std::future<int> result = task.get_future();
	task(2, 9);  //invoke here.
	std::cout << "task_lambda:\t" << result.get() << '\n';
}
void task_bind(){
	std::packaged_task<int()> task(std::bind(f, 2, 11));
	std::future<int> result = task.get_future();
	task();
	std::cout << "task_bind:\t" << result.get() << '\n';
}
void task_thread(){
	std::packaged_task<int(int,int)> task(f);
	std::future<int> result = task.get_future();
	std::thread task_td(std::move(task), 2, 10);
    //When we move a packaged_task to thread, it begin to run.
	task_td.join();
	std::cout << "task_thread:\t" << result.get() << '\n';
}
int main(){
	task_lambda();
	task_bind();
	task_thread();
}
\end{lstlisting}

%    \item The wait() and join() methods are used to pause the current thread. wait is mainly used for shared resources, A thread notifies other waiting thread when a resource becomes free. On the other hand, join() is used for waiting a thread to finish.


    
    \par \texttt{std::promise} and \texttt{std::future} are powerful synchronization mechanisms in C++ that allow communication between threads, particularly for transferring data or signaling events from one thread to another.
\begin{lstlisting}[numbers=none]
struct Div{	
	void operator() (std::promise<int>&& intPromise, int a, int b) const {
		intPromise.set_value(a/b);
	}
	
};

int a= 20, b = 10;
std::promise<int> divPromise;                        // 1, define the promises
std::future<int> divResult= divPromise.get_future(); // 2, get future from promises

Div div;
std::thread divThread(div, move(divPromise),a,b); //3, pass promise to working thread.
std::cout << "20/10= " << divResult.get() << std::endl;//4, get result
divThread.join();	
\end{lstlisting}    
    

    \par The benefit of the \texttt{std::promise} over \texttt{std::async} and \texttt{std::packaged\_task} is that the promise can communicate a value to the future at a different time than at the end of a function call. For example, imagine a car repair shop where a customer would like to buy a car. She would like to be convinced that the engine of the car is okay. The manager of the shop instructs the mechanic to inspect the engine. As soon as it is clear that the engine is okay, the manager can negotiate a contract with the customer while the mechanic can continue his check.
    
\begin{lstlisting}[]
check_whole_car(Car& car, std::promise<bool> engine_ok){
 check_engine();
 promise.set_value(..)
 check_others().
 ...
}

main(){
  std::future<bool> answer = promise.get_future();
  std::thread thread(check_whole_car, std::ref(car), std::move(promise));
  thread.detach();
  if(answer.get()){
    begin_price_negotiates(); //engine check is OK
 }
}
\end{lstlisting}

	\par You can provide a promise to one thread and a future to another thread, which is akin to using conditional variables. However, conditional variables have an advantage in that they can synchronize threads multiple times. In contrast, a promise can notify only once. Therefore, to achieve multiple synchronizations, you would need multiple sets of promises and futures. Nevertheless, if you use a conditional variable only for a single synchronization, promises and futures offer benefits. They require no shared variables and hence no locks, making them immune to issues like spurious or lost wake-ups. Moreover, they can handle exceptions gracefully. These advantages make promises and futures preferable in many scenarios over conditional variables.
	
\begin{lstlisting}[numbers=none]
void doTheWork(){
	std::cout << "Processing shared data." << std::endl;
}
void waitingForWork(std::future<void>&& fut){
	std::cout << "Worker: Waiting for work." << std::endl;
	fut.wait();
	doTheWork();
	std::cout << "Work done." << std::endl;
}
void setDataReady(std::promise<void>&& prom){
	std::cout << "Sender: Data is ready."  << std::endl;
	prom.set_value();	
}

std::promise<void> sendReady;      //1 define a promise
auto fut= sendReady.get_future();  //2 get future from promise
std::thread t1(waitingForWork,std::move(fut));
std::thread t2(setDataReady,std::move(sendReady));
t1.join(); t2.join();	
\end{lstlisting}

    \par \texttt{std::shared\_future} example. \texttt{std::future} doesn't support copy , only move operation. \texttt{std::future} and \texttt{std::shared\_future} just like \texttt{unique\_ptr} and \texttt{shared\_ptr}. A \texttt{shared\_future} can be used to signal multiple threads simultaneously, similar to \texttt{std::condition\_variable::notify\_all()}.

\begin{lstlisting}[numbers=none]  
std::promise<void> ready_promise, t1_ready_promise, t2_ready_promise;
std::shared_future<void> ready_future(ready_promise.get_future());
std::chrono::time_point<std::chrono::high_resolution_clock> start;

auto fun1 = [&, ready_future]() -> std::chrono::duration<double, std::milli> {
	t1_ready_promise.set_value();
	ready_future.wait(); // waits for the signal from main()
	return std::chrono::high_resolution_clock::now() - start;
};
auto fun2 = [&, ready_future]() -> std::chrono::duration<double, std::milli> {
	t2_ready_promise.set_value();
	ready_future.wait(); // waits for the signal from main()
	return std::chrono::high_resolution_clock::now() - start;
};

auto fut1 = t1_ready_promise.get_future();
auto fut2 = t2_ready_promise.get_future();
auto result1 = std::async(std::launch::async, fun1);
auto result2 = std::async(std::launch::async, fun2);
fut1.wait(); // wait for the threads to become ready
fut2.wait();

// the threads are ready, start the clock
start = std::chrono::high_resolution_clock::now();
ready_promise.set_value(); 	// signal all threads to go
<< result1.get().count() << " ms after start\n"
<< result2.get().count() << " ms after start\n";	
\end{lstlisting}
\begin{description}
	\item[Source code] \texttt{ready\_promise} is main switch. \texttt{t1\_ready\_promise} is void, just like a conditional variable. The main thread wait all other threads are ready, then trigger a start singal \\ (\texttt{ready\_promise.set\_value}). In the code, \texttt{future.wait()} is used to wait for completion without retrieving the result, while \texttt{future.get()} is used to retrieve the result once it is available.
	
\end{description}

	\par In summary, there are three ways to associate a \texttt{std::future} with a task: \texttt{std::async}, \texttt{std::promise} and \texttt{std::packaged\_task}. The advantage of \texttt{std::packaged\_task} over \texttt{std::async} is its ability to separate the creation of the \texttt{std::future} from the execution of the task. On the other hand, \texttt{std::promise} offers a benefit over \texttt{std::async} and \texttt{std::packaged\_task} by allowing the communication of a value to the \texttt{std::future} at a different time than at the end of a function call.


\subsection{counting\_semaphore, latch and barrier}
	 C++ implements synchronization primitives by using atomic operations and memory barriers, relieving users from the burden of handling these aspects manually. These primitives encompass mutexes, condition variables, shared/exclusive locks, and semaphores, akin to those found in other operating systems.
	
	\par A semaphore can be thought as a public lending library without late fees. Supposed a library that has 5 copies of the book "C++ Concurrency in Action" available for borrowing. The first five people who arrive looking for a copy will get one, but the sixth person will need to wait or return later. The library doesn't track who returns the books, so there are no late fees. When a copy is returned, it's given to someone who is waiting for it. If no one is waiting, the book is returned to the shelf until another request comes in. In below code, The semaphore ensures that at most 5 worker threads can acquire permits concurrently. Additional threads will block until a permit becomes available.
	
\begin{lstlisting}
std::counting_semaphore<5> sem(5); // Semaphore with 5 permits

void worker(int id) {
	sem.acquire(); // Acquire a permit
	std::cout << "Worker " << id << " acquired a permit" << std::endl;
	
	std::this_thread::sleep_for(std::chrono::seconds(2)); // Simulating some work
	
	sem.release(); // Release the permit
	std::cout << "Worker " << id << " released a permit" << std::endl;
}

int main() {
	std::thread workers[10]; // 10 workers
	for (int i = 0; i < 10; ++i) {// Start all worker threads
		workers[i] = std::thread(worker, i);
	}
	
	// Join all worker threads
	for (int i = 0; i < 10; ++i) {
		workers[i].join();
	}
}	
\end{lstlisting}

	\par How to understand mutex and semaphore?
\begin{itemize}
    \item A semaphore is a data structure with a queue and a counter. The counter is initialized to a value equal to or greater than zero. It supports the two operations wait and signal. wait acquires the semaphore and decreases the counter; it blocks the thread acquiring it if the counter is zero. signal releases the semaphore and increases the counter. \textbf{Blocked threads are added to the queue to avoid starvation.}
    
    \item mutex make sure that \textbf{critical section}(a piece of code) will not be run concurrently. Semaphore limit the number of access to the same resource. 
    
    \item The mutex has ownership. Ownership dictates that when a task locks (acquires) a mutex, only that task can subsequently unlock (release) it. If a task attempts to unlock a mutex it hasn’t previously locked (and therefore doesn’t own), an error condition is encountered, and crucially, the mutex remains locked.
    
    \item \texttt{binary\_semaphore} is an alias for specialization of \texttt{std::counting\_semaphore} with LeastMaxValue being 1. Implementations may implement \texttt{std::binary\_semaphore} more efficiently than the default implementation of \texttt{std::counting\_semaphore}.
    
    \item \texttt{std::binary\_semaphore} is a specialization of the more general \texttt{std::counting\_semaphore} that only supports two values, 0 and 1 in C++20. The main use case of a binary semaphore is for simple signalling, where the alternative approach would be to use the combination of \texttt{std::mutex}, \texttt{std::condition\_variable} and a boolean variable. Semaphore often has better performance than condition variable. 
    
\begin{lstlisting}
std::binary_semaphore signal(0);
auto t = std::jthread([&signal]() {
	// Wait until this thread is signaled
	signal.acquire(); // decrements the internal counter or blocks until it can
	// Actual code...
});

signal.release(); // Signal the thread to run, increments the internal counter
\end{lstlisting}

	\item For simple notifying context, you also can use 1) \texttt{binary\_semaphore} or 2) \texttt{promise<void>} instead of conditional variable.
    
    \item You can find a good article on this topic, "Mutex vs. Semaphores – Part 1: Semaphores," and "Mutex vs Semaphore: What’s the Difference?".
    
\end{itemize}
    
    \par \texttt{std::latch} has two typical usages: 
\begin{enumerate}

	\item Setting multiple threads to perform a task, and then waiting until all threads have reached a common point. \textbf{wait until finish, aka, finish together.}
	
\begin{lstlisting}[numbers=none]
void DoWork(threadpool* pool) {
	std::latch completion_latch(NTASKS);
	for (int i = 0; i < NTASKS; ++i) {
		pool->add_task( [&] {
			... // perform work
			completion_latch.count_down();
		}));
	}
	
	// Block until work is done
	completion_latch.wait(); //Arrive here together.
}
\end{lstlisting}	

	\item Creating multiple threads, which wait for a signal before advancing beyond a common point. \textbf{wait until start, aka, start together.}
\begin{lstlisting}[numbers=none]
void DoWork() {
	latch start_latch(1);
	vector<thread*> workers;
	for (int i = 0; i < NTHREADS; ++i) {
		workers.push_back(new thread([&] {
			...// Initialize data structures. This is CPU bound.
			start_latch.wait();
			...// perform work together.
		}));
	}

	...// Load input data. This is I/O bound.
	// Threads can now start processing
	start_latch.count_down(); //Run from here together.
}
\end{lstlisting}

\end{enumerate}

	\par A \texttt{std::barrier} is quite similar to a \texttt{std::latch.} The subtle difference is that you can use a  \texttt{std::barrier} more than once because the counter will be reset to its previous value. Immediately, after the counter becomes zero the so-called completion phase starts. This completion phase is in the case of a \texttt{std::barrier} empty. You can see there are two places we use \texttt{arrive\_and\_wait}. 

\begin{lstlisting}[numbers=none]
const auto workers = { "anil", "busara"};
auto on_completion = []() noexcept { 
	static auto phase = "... done\n" "Cleaning up...\n"; //locking not needed here
	std::cout << phase;
	phase = "... done\n";
};

std::barrier sync_point(std::ssize(workers), on_completion);

auto work = [&](std::string name) {
	std::string product = "  " + name + " worked\n";
	std::cout << product;  // ok, op<< call is atomic
	sync_point.arrive_and_wait();
	
	product = "  " + name + " cleaned\n";
	std::cout << product;
	sync_point.arrive_and_wait();
};

std::cout << "Starting...\n";
std::vector<std::thread> threads;
for (auto const& worker : workers) { //two threads
	threads.emplace_back(work, worker);
}
for (auto& thread : threads) { thread.join();}	
\end{lstlisting}

\begin{lstlisting}
Starting...   //output
anil worked
carl worked
... done  //the first time go into the on_completion
Cleaning up...
busara cleaned
carl cleaned
... done  //the second time go into the on_completion
\end{lstlisting}

\par Summary: For \texttt{std::counting\_semaphore}, \texttt{std::latch} and \texttt{std::barrier}, these three synchronization primitives all internally manage a number, and when this number meets certain conditions, the waiting (blocked) state is lifted. The difference is that \texttt{std::counting\_semaphore} maintains a queue where all the waiting threads reside, ensuring first-come, first-served order. What makes a barrier special is that once the waiting is over, it automatically resets the number to its initial state.



\section{Atomic and memory order}
\subsection{Atomic type}
\subsubsection{Basic operations}
	 Any built-in atomic types, such as bool, integral types, floating point types, pointers, and smart pointers (since C++20) can be made atomic. Type aliases are provided for bool and all integral types listed below, as follows:
\begin{lstlisting}
atomic_bool   std::atomic<bool>
atomic_char   std::atomic<char>
atomic_int    std::atomic<int>
...
\end{lstlisting}
	
	\par Any trivially copyable type can be made atomic. What is trivially copyable?
	
\begin{itemize}
	\item Continuous chunk of memory.
	
	\item Copying the object means copying all bits (memcpy).
	
	\item No virtual functions, noexcept constructor.
\end{itemize}
	
	
	\par Although these types can be made atomic, they are not necessarily created equal. Some atomics are implemented lock-free and some are not. This is platform-dependent, mainly due to \textbf{alignment requirements} for atomic instructions on said platform. When an atomic is not lock-free, it is usually implemented with some type of mutex or other locking operation. But regardless of that, the member functions of a \texttt{std::atomic} remains the same.
	
	\par This property can be evaluated at runtime through \texttt{is\_lock\_free()}. In C++17, we now have \texttt{is\_always\_lock\_free()} which is retrievable at compile time, but it is a subset of \texttt{is\_lock\_free()} i.e. even if \texttt{is\_always\_lock\_free()} returns false, \texttt{is\_lock\_free()} may still return true at runtime. the reason it could only be determined at runtime is due to memory alignment. Let’s take a look at some code to understand this.
\begin{lstlisting}
struct A {uint32_t a; uint32_t b; uint32_t c;}; // 12 bytes
struct alignas(16) B {uint32_t a; uint32_t b; uint32_t c;}; // 16 bytes
struct C {uint64_t a; uint64_t b;}; // 16 bytes
struct D {uint64_t a; uint64_t b; uint64_t c;}; // 24 bytes

std::atomic<A> a; std::atomic<B> b; std::atomic<C> c; std::atomic<D> d;

std::cout << "Struct A: " << a.is_lock_free() << std::endl;  //output: 0
std::cout << "Struct B: " << b.is_lock_free() << std::endl;  //output: 1
std::cout << "Struct C: " << c.is_lock_free() << std::endl;  //output: 1
std::cout << "Struct D: " << d.is_lock_free() << std::endl;  //output: 0
\end{lstlisting}


	\par The standard allows implementing any atomic type (with exception of \texttt{std::atomic\_flag}) to be implemented with locks. So always use \texttt{is\_lock\_free()} on your platform to confirm that. If the atomic operations use an internal mutex, the performance gains from using atomic types will probably not be good and may even be detrimental. Therefore, if you have many atomic operations together, it is often better to use a single mutex to protect them all rather than relying on multiple atomic operations.
	
	\par Basic operations supported by different atomic type. 
	
	\begin{tabular}{|p{0.28\textwidth}|p{0.10\textwidth}|p{0.10\textwidth}|p{0.1\textwidth}|p{0.1\textwidth}|p{0.1\textwidth}|}
		\hline
		Member function& \texttt{atomic <bool>}  & \texttt{atomic <int>}  & \texttt{atomic <T*>}  & \texttt{atomic <float>}  & \texttt{atomic <UDT>}  \\
		\hline
		test\_and\_set, clear & Y &  &  &  &  \\
		\hline
		operator = & Y & Y & Y & Y & Y \\
		\hline
		is\_lock\_free & Y & Y & Y & Y & Y  \\
		\hline
		is\_always\_lock\_free & Y & Y & Y & Y & Y  \\
		\hline
		load, store & Y & Y & Y & Y & Y  \\
		\hline
		exchange & Y & Y & Y & Y & Y  \\
		\hline
		compare\_exchange\_* & Y & Y & Y & Y & Y  \\
		\hline
		fetch\_add(sub), +=, -=&  & Y & Y & Y &  \\
		\hline
		fetch\_and(or,xor), \&=,|= & Y &  &  &  &  \\
		\hline
		++, -- &  & Y  & Y &  &  \\
		\hline
	\end{tabular}
	
		
	\par All operations in above table on an atomic type are atomic. Because operator syntax does not allow you to specify the memory order, these operations will be performed with \texttt{std::memory\_order\_seq\_cst}, as this is the default order for all atomic operations in C++ 11. It guarantees sequential consistency (total global ordering) between all atomic operations.
\begin{lstlisting}
std::atomic<long> value(0);
value++;    //This is an atomic operation with std::memory_order_seq_cst order.
value += 5; //Also an atomic operation with std::memory_order_seq_cst order.
\end{lstlisting}

	\par  If you want to specify the memory order, you can use more explicit function form.
\begin{lstlisting}
std::atomic<long> value {0};
value.fetch_add(1, std::memory_order_relaxed); 
//no synchronization or ordering constraints
value.fetch_add(5, std::memory_order_release); //performs 'release' operation
\end{lstlisting}

	\par Construct, assignment and copy operation of an atomic type:
	
	\begin{itemize}
		\item Construct is not an atomic operation. Usually, we only construct an atomic variable in one thread. 
\begin{lstlisting}[numbers=none]
atomic<int> x_int{0};    //good style,
atomic<int> z_int = {0}; //OK
\end{lstlisting}

		\item Atomic doesn't support copy or assignment directly.
\begin{lstlisting}[numbers=none]
atomic<int> a{1}, b{2};
b = a //doesn't compile 
b.store(a.load()); //OK, but two atomic operations. It actually does two things:
// int temporary = a.load(); // #1
// i2.store(temporary); // #2
// Each of those 2 instructions are atomic, 
// but b.store(a.load()) is not atomic as a whole.
\end{lstlisting}		
		
	\item Although the overloaded operators are convenient, I would still recommend using the more verbose member functions, as the operators are more error-prone and less clear as our expressions get more complex. For instance, \texttt{x.fetch\_add(1)} would immediately tell another programmer that the variable is an atomic and we are doing increments atomically. \texttt{x++} can mean the same thing for non-atomic variables. Similarly, using \texttt{x.load()} and \texttt{x.store(1)} immediately suggests an atomic type, unlike \texttt{x} or \texttt{x = 1} which is less explicit.
\begin{lstlisting}[numbers=none]
atomic<int> a_x{1};
int y = 2;
y = a_x;  
//y = a_x.load(), a_x.load() is atomic operation, whole expression is not
a_x = y;  //a_x.store(y) , the whole expression is atomic. 	 	
\end{lstlisting}

	\end{itemize}	
	
	\par A good reference paper is "Atomics in C++ — What is a std::atomic?" 

\subsubsection{Read-modify-write}

	 In computer science, read–modify–write is a class of atomic operations (such as test-and-set, fetch-and-add, and compare-and-swap) that both read a memory location and write a new value into it simultaneously. In C++ atomic type, \texttt{test\_and\_set}, \texttt{exchange}, \texttt{compare\_exchange\_weak/strong} are all read-modify-write atomic operations. \texttt{exchange(desired)} atomically replaces the underlying atomic value with the specified desired value. This operation is a read-modify-write operation, meaning it \textbf{always} writes the desired value to the underlying atomic value. 

	\par \texttt{test\_and\_set} and \texttt{clear} can only be used in atomic bool type. \texttt{test\_and\_set} sets a \texttt{atomic\_flag} (make it true) and returns whether it was already set immediately before the call. There are a few points here: 1) it first read the \texttt{atomic\_flag} as return value, then it \textbf{ALWAYS} set(write) \texttt{atomic\_flag}. 2) The read and set are atomic operation(an atomic read-modify-write operation): the value is not affected by other threads between the instant its value is read (to be returned) and the moment it is modified by this function. A typical usage of \texttt{test\_and\_set} is spin lock and I will introduce it in the next section "Usage of atomic type".

	\par \texttt{compare\_exchange\_weak} is a kind of CAS(compare-and-swap). If \texttt{atomic<> shared} matches \texttt{expected}, we write \texttt{desired} to \texttt{atomic<> shared} and return true. If not, it load the \texttt{atomic<> shared} back into the \texttt{expected}. Please note here, \texttt{expected} is in/out parameter. 

\begin{lstlisting}
shared.compare_exchange_weak(expected, desired)
\end{lstlisting}
	\begin{center}
		\includegraphics[width=0.80\linewidth]{pics/cas.drawio.png}
	\end{center}
	
	
	\par Most of time, \texttt{compare\_exchange\_weak} is used as building blocks of lock-free data structures (CAS loop pattern):  \texttt{shared} is usually atomic pointer type. We first read from memory into \texttt{expected}, then compare it \texttt{shared}, because at this time, \texttt{shared} can be modified by another thread, so we need to compare.
\begin{lstlisting}[numbers=none]
atomic<int> shared{1}
auto expected = shared.load();
while(!shared.compare_exchange_weak(expected, desired));
\end{lstlisting}

\begin{itemize}
	\item If \texttt{shared} and \texttt{expected} are equal, (no other thread touch \texttt{shared}), then we can update it with \texttt{desired} and \texttt{compare\_exchange\_weak} true, while loop will exit and we finish update. 
	
	\item Sometimes, when \texttt{shared} and \texttt{expected} are equal, it returns false and \textbf{NO} writing \texttt{desired} value to \texttt{shared}, we call it \textbf{spurious failure}. on some platforms where a sequence of instructions (instead of one as on x86) are used to implement it. On such platforms, context switch, reloading of the same address (or cache line) by another thread, etc can fail the primitive. It’s spurious as it’s not the value of the object (not equal to expected) that fails the operation. it’s kind of timing issue.
	
	\item If \texttt{shared} and \texttt{expected} are NOT equal, (other thread touch \texttt{shared}), then we load new \texttt{shared} to \texttt{expected},  we don't update \texttt{shared} with \texttt{desired} this time. \texttt{compare\_exchange\_weak} return false, while loop will not exit, we perform next round \texttt{compare\_exchange\_weak} with new updated \texttt{expected}. 
	
	
\end{itemize}
	  	
		\par Different with \texttt{compare\_exchange\_weak}, the strong version conceptually wraps this around and tries in case of any spurious failure.

		\par When do we need \texttt{compare\_exchange\_weak}?  So the answer seems to be quite simple to remember: If you would have to introduce a loop only because of spurious failure, don't do it; use strong. If you have a loop anyway, then use weak. In this example, we have to use while to deal with the modification from another thread, so we should use weak from. Because when a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms.
		
		\par Common usages example of \texttt{compare\_exchange\_weak}. 
		
\begin{itemize}
	\item  You need achieve an atomic update based on the value in the atomic variable. A failure indicates that the variable is not updated with our desired value and we want to retry it. Note that we don’t really care about whether it fails due to concurrent write or spurious failure. But we do care that it is we that make this change. A real-world example is for several threads to add an element to a singly linked list concurrently. Each thread first loads the head pointer, allocates a new node and appends the head to this new node. Finally, it tries to swap the new node with the head. 
	
	
%	Another example is to implement mutex using std::atomic<bool>. At most, one thread can enter the critical section at a time, depending on which thread first set current to true and exit the loop.
%\begin{lstlisting}
%expected = current.load();
%do 
%	desired = function(expected);
%while (!current.compare_exchange_weak(expected, desired));	
%\end{lstlisting}

	\item Another example two threads multiply the same atomic value. Please note here, C++ support \texttt{fetch\_add()} operation(\texttt{+=}) on atomic type, but doesn't support \texttt{fetch\_multiply()} operation(\texttt{*=}), so you can implement this operation by yourself. 

\begin{center}
	\includegraphics[width=0.85\linewidth]{pics/cas1.png}
\end{center}

\begin{lstlisting}
uint32_t fetch_multiply(std::atomic<uint32_t>& shared, uint32_t multiplier) {
	uint32_t oldValue = shared.load();
	while (!shared.compare_exchange_weak(oldValue, oldValue * multiplier)){
	}
	return oldValue;
}	
\end{lstlisting}


	\item  Contrary to previous example, you want the atomic variable to be updated once, but you don’t care who does it. As long as it’s not updated, you try it again. This is typically used with boolean variables. E.g., you need implement a trigger for a state machine to move on. Which thread pulls the trigger is regardless. In below code, when \texttt{current.compare\_exchange\_weak(expected, true)} return false, there are two possibilities, one is \texttt{current} is hold true, at this time, compare\_exchange\_weak write true to \texttt{expected}, we exit the while loop; The other possible is spurious failure, at this time, \texttt{expected} is still false, so we are still in side while loop. 
\begin{lstlisting}
expected = false;
// !expected: if expected is set to true by another thread, done!
// Otherwise, it fails spuriously and we should try again.
while (!current.compare_exchange_weak(expected, true) && !expected);	
\end{lstlisting}
	
\end{itemize}
	
	\par It should be rare to use compare\_exchange\_weak() outside a loop, strong version should be used outside a loop. \texttt{compare\_exchange\_weak()} is improper in below code because when it returns due to spurious failure, you don't go into the critical section event it's available. 
\begin{lstlisting}
bool criticalSection_tryEnter(lock){
	bool flag = false;
	return lock.compare_exchange_strong(flag, true);
}	
\end{lstlisting}	
	




%\begin{center}
%	\includegraphics[width=0.90\linewidth]{pics/atomic_operator.png}
%\end{center}




\subsection{Memory model}
\subsubsection{Memory model basic knowledge}
	
	
%	\item First of all, why do we need a memory model? You must remember that cache and store buffers sit between the CPU and memory. When software writes a value, it typically lands in the cache, but it may never reach main memory if the value is overwritten before the cache copies it to RAM (think loop variables and locals). This discussion revolves around the different models for when data is actually placed in or read from RAM. Within a core, it doesn't really matter, as they will use the last value written, whether it comes from cache or RAM.
%	
%	Let's consider an example: One possibility is when a value of 1 is written to \texttt{a}. It first writes to the store buffer, then writes \texttt{b} to the cache line. At the same time, thread 2 reads \texttt{b} = 1, but at this point, a has not yet been reflected in the cache line, so thread 2 reads \texttt{a} = 0 from its own cache. This would cause the assertion to fail. This is a kind of "reordering" — at first glance, it appears as if \#1 and \#2 have been reversed in order.
%	
%
%		
%		
%		\item Above, we explained one of the reasons for reordering. There are two kinds of reordering: CPU reordering and compiler reordering. Reordering can also occur in the compiler. For example, consider the following code:
%		\begin{lstlisting}
%			payload = 2; //in thread 1 #1
%			ready = true;              #2
%			
%			while(ready){ // in thread 2
%				load(payload)
%			}	
%		\end{lstlisting}	
		
		
		 Why does C++ 11 need memory model? Before C++ 11, we only focus single thread program, it is not possible to write multi-threaded C++ code that is "fully portable" without memory model. For example, the result from below code is undefined behavior. Because it can print out "26 0", when \texttt{y} is 26, we can't  grantee \texttt{x}(16) has been visible by thread 2. 
\begin{lstlisting}
int x, y; // global variable, default is 0.

// #thread 1
x = 16;   //step 1
y = 26;	  //step 2

// #thread 2
cout<< y <<" "<< x <<endl;  //can print out "26 0" here.
\end{lstlisting}

	\par Why do we have such undefined behavior?
	
	\begin{itemize}
		
		\item In modern CPU, cache and store buffers sits between the CPU and memory.
\begin{center}
	\includegraphics[width=0.74\linewidth]{pics/cache.drawio.png}
\end{center}		
		 When software writes a value, it typically lands in the cache, but it may never reach main memory if the value is overwritten before the cache copies it to RAM. In above example,  value of 16 is written to \texttt{x}. It first writes to the store buffer, then writes \texttt{y} to the cache line. At the same time, thread 2 reads \texttt{y} = 26, but at this point, \texttt{x} has not yet been reflected in the cache line, so thread 2 reads \texttt{x} = 0 from its own cache, then print out "26 0". This is a kind of "reordering" — at first glance, it appears as if step 1 and step 2 have been reversed in order in thread 1. 
		
		\item The compiler can also reorder the execution \texttt{x= 16;} and \texttt{y=26;}, because for thread 1, they have the same meaning. 
		
		\item "reordering" is important concept in memory model. It sometimes happen across thread boundary, For example, there are four threads: threadA, threadB, threadC and threadD. For threadC, maybe it see an order(threadA->ThreadB),  but for threadD, it will see a reverse ordering(threadB->threadA). I will give this complex example later. 
		
	\end{itemize}


	\par A memory model is a specification of the allowed behavior of multithreaded programs executing with shared memory. The C++ memory model defines a contract between the programmer and the system, which includes the compiler that compiles the program into assembly instructions, the processor that executes these instructions, and the various caches that store the program's state. This contract requires the programmer to adhere to certain rules, and in return, it grants the system the ability to optimize the program as long as these rules are not violated. The main features of the C++ memory model are as follows:
		\begin{enumerate}
			\item Atomic operations.
			\item Sequential consistency.
			\item Memory order. 
		\end{enumerate}
	
	\par In C++, only atomic type allows the concurrent read/write/access operation in multithreading application without causing any data races or undefined error, we have introduced in the previous section. 
		
	\par With help of memory model, the previous code can be rewritten as below. Now the behavior here is defined. Thread 2 could now print "0 0" (if it runs before Thread 1), "26 16" (if it runs after Thread 1), or "0 16" (if it runs after Thread 1 assigns to \texttt{x} but before it assigns to \texttt{y}), but it cannot print "26 0", because the default mode for atomic loads/stores in C++11 is to enforce sequential consistency. This just means all loads and stores must be "as if" they happened in the order you wrote them within each thread, while operations among threads can be interleaved whatever the system likes. So the default behavior of atomics provides both atomicity and ordering for loads and stores.
\begin{lstlisting}
atomic<int> x, y;

// #thread 1
x.store(16);
y.store(26)

// #thread 2
cout<< y.load() <<" "<< x.load() <<endl;
\end{lstlisting}

	
		\par Now, on a modern CPU, ensuring sequential consistency can be expensive. In particular, the compiler is likely to emit full-blown memory barriers between every access here. This approach is slower because (1) an SMP (symmetric multiprocessing) system must synchronize caches between processors, and (2) the compiler has significantly less freedom in optimizing code around the atomic access. In order to improve the efficiency, we can just keep particular loads and stores in order, you can improve your code like this. For this small toy code, "26 0" is no longer a possible output – but it does so with minimal overhead. (In this trivial example, the result is the same as full-blown sequential consistency; in a larger program, it would not be.)
\begin{lstlisting}
atomic<int>y;
int x;

// #thread 1
x = 16;
y.store(26, memeory_order_release)

// #thread 2
cout<< y.load(memory_order_acquire) <<" "<< x <<endl;
\end{lstlisting}
	\par The same ideal is also applied in very popular "payload-guard" idiom in concurrent. 
\begin{lstlisting}
payload = 2; //in thread 1 
guard.store(true; memeory_order_release)           

while(guard.load(memory_order_acquire)){ // in thread 2
	//use payload here.
	...
}	
\end{lstlisting}
	
		\par For some application, we don't care about order, only atomic. So we can use \texttt{memory\_order\_relaxed}, which provides no synchronization or ordering guarantees beyond atomicity.
\begin{lstlisting}
atomic<int> counter(0); 

void incrementCounter() { 
	for (int i = 0; i < 10000; ++i) { 
		counter.fetch_add(1, memory_order_relaxed); 
		// memory_order_relaxed is used for minimal synchronization overhead
	} 
} 

thread t1(incrementCounter); 
thread t2(incrementCounter); 
t1.join(); // Wait for the first thread to finish 
t2.join(); // Wait for the second thread to finish 
cout << counter.load(memory_order_relaxed) << endl; 
\end{lstlisting}
		
	
%		\item Another important topic related to atomic types is memory order. Only atomic variables have a defined memory model because they are specifically designed to ensure safe concurrent access and modification in multi-threaded environments. Here, I will provide three different examples of memory order:
%	
%	\begin{enumerate}
%		
%		\item In this case, we don't use atomic operations, leading to potential data races and undefined behavior in a multithreaded environment. If \texttt{i} is accessed by more than one thread, including at least one write, the behavior is undefined in the absence of synchronization. The compiler can assume that no other thread can modify \texttt{i}, allowing it to reorder or optimize access to the variable. For instance, it might load \texttt{i} into a register once and never read it from memory again, or it might move writes out of a loop and perform a single write at the end.
%\begin{lstlisting}[]
%int i = 0; 
%if(i == 10)  {...}  // may actually be optimized away since `i` is clearly 0 now
%\end{lstlisting}	
%		
%		\item In this case, we use atomic operations with the default memory order (memory\_order\_seq\_cst), which ensures the strongest synchronization and ordering guarantees. By default, reads and writes to an atomic variable are done using \texttt{std::memory\_order\_seq\_cst} (sequentially-consistent) memory order. This means that not only are reads and writes to \texttt{ai} atomic, but they are also visible to other threads in a timely manner, including any reads or writes to other variables before or after it. In essence, reading or writing an atomic variable acts as a memory fence. However, 
%		
%\begin{lstlisting}[]
%std::atomic<int> ai{0}; 
%if(ai == 10) {...}  // [2]    
%\end{lstlisting}		
%		
%		\item In this case, we use atomic operations with a relaxed memory order (memory\_order\_relaxed), which provides no synchronization or ordering guarantees beyond atomicity. The code below guarantees atomicity of \texttt{ai} reads and writes only. This means the compiler is free to reorder access to it and guarantees that writes are visible to other threads in a reasonable amount of time. However, its applicability is very limited because it makes it difficult to reason about the order of events in a program. For example, this mode is often slower than case 1 because the compiler must ensure each read and write actually goes out to cache or RAM. However, it is faster than case 2, as it still allows for optimization of other variables around it.
%\begin{lstlisting}[]
%std::atomic<int> ai{0}, aj{0}; 
%
%aj.store(1, std::memory_order_relaxed);  // thread 1 
%ai.store(10, std::memory_order_relaxed); 
%
%if(ai.load(std::memory_order_relaxed) == 10) {  // thread 2 
%	aj.fetch_add(1, std::memory_order_relaxed); 
%	// is aj 1 or 2 now??? no way to tell. 
%} 	
%\end{lstlisting}		
%	\end{enumerate}



\subsubsection{memory ordering}

	
	 Memory ordering refers to the order in which the read and write operations are preformed. We have five types of memory ordering in C++: 1) memory\_order\_relaxed, 2) memory\_order\_acquire, 3) memory\_order\_release, 4) memory\_order\_acq\_rel and 5) memory\_order\_seq\_cst. 

	\par Essentially memory\_order\_acq\_rel provides read and write orderings relative to the atomic variable, while memory\_order\_seq\_cst provides read and write ordering globally. That is, the sequentially consistent operations are visible in the same order across all threads.

	\par Next, I will tell the difference between these memory ordering by a few examples.
	
\begin{itemize}
	

	\item For this example, we may get \texttt{r1=r2=42}. 
	%It's has \textbf{sequence before order}, then it will lead to happen before order. But please remember, happy before is logic order, not runtime execution order. 
	In thread 2, \texttt{x} and \texttt{y} will not affect each other. for C and D, due to store buffer, maybe it has "reordering" effect. it doesn't mean D is executed before C, maybe we first issue \texttt{r2 = x}, but it need go to three level cache, at the same time, maybe \texttt{x.store} invalid cache line. 

\begin{lstlisting}
atomic<int> x, y;

// Thread 1:
r1 = y.load(memory_order_relaxed); // A
x.store(r1, memory_order_relaxed); // B

// Thread 2:
r2 = x.load(memory_order_relaxed); // C
y.store(42, memory_order_relaxed); // D
\end{lstlisting}


	\item Default order for atomic type is \texttt{memory\_order\_seq\_cst} order. it means that there is global certain order. In another word, For any thread, they see other threads has the same order.  


\begin{lstlisting}
void write_x(){
	x.store(true, std::memory_order_seq_cst);	// A
}
void write_y(){
	y.store(true, std::memory_order_seq_cst);	// B
}
void read_x_then_y(){
	while (!x.load(std::memory_order_seq_cst));
	if (y.load(std::memory_order_seq_cst)) {
		++z;
	}
}
void read_y_then_x(){
	while (!y.load(std::memory_order_seq_cst));
	if (x.load(std::memory_order_seq_cst)) {
		++z;
	}
}

std::thread a(write_x);
std::thread b(write_y);
std::thread c(read_x_then_y);
std::thread d(read_y_then_x);
a.join(); b.join(); c.join(); d.join();
assert(z.load() != 0);			// never trigger here.
\end{lstlisting}

	\item If we change it to release and aquire, it can give you same variable synchronize-with relationship, but it will not give you global order guaranty. 
	%There exists no such total order between acquire/release operations in different threads, so there is not visibility guarantee. The operations are only ordered once an acquire-operations observes the value from a release-operation, but there is no guarantee when the value of the release-operation becomes visible to the thread performing the acquire-operation. 
	Since we have no guarantee about visibility, it could happen that thread C observes \texttt{x == true} and \texttt{y == false}, while at the same time thread D could observe \texttt{y == true} and \texttt{x == false}. So neither thread would increment \texttt{z} and the assertion would fire. In another word, reordering happens across thread boundary: For thread C, it see order(thread A-->thread B), but for thread D, it sees "reordering" (thread B-->thread A).

\begin{lstlisting}
void write_x(){
	x.store(true, std::memory_order_release);	// thread A
}
void write_y(){
	y.store(true, std::memory_order_release);	// thread B
} 
void read_x_then_y(){                           // thread C
	while (!x.load(std::memory_order_aquire));
	if (y.load(std::memory_order_aquire)) {
		++z;
	}
}
void read_y_then_x(){                           // thread D
	while (!y.load(std::memory_order_aquire));
	if (x.load(std::memory_order_aquire)) {
		++z;
	}
}

std::thread a(write_x);
std::thread b(write_y);
std::thread c(read_x_then_y);
std::thread d(read_y_then_x);
a.join(); b.join(); c.join(); d.join();
assert(z.load() != 0);			// Maybe trigger here!
\end{lstlisting}

	\item release and acquire can't give you global order consistence, but it used widely in guard and payload pattern.

\begin{lstlisting}
void producer(){
	std::string* p = new std::string("Hello");			// A
	data = 42;							// B
	ptr.store(p, std::memory_order_release);			// C
}

void consumer(){
	std::string* p2;
	while (!(p2 = ptr.load(std::memory_order_acquire))); // D
	assert(*p2 == "Hello");					// E
	assert(data == 42);						// F
}

std::thread t1(producer);
std::thread t2(consumer);
t1.join(); t2.join();	
\end{lstlisting}

	\item std::memory\_order\_acq\_rel — the acquire release barrier combines both acquire and release barriers to ensure no memory operations can move across the barrier. Similar to the acquire-release ordering, this guarantee only holds if the threads are referring to the same atomic. An example use case is decrementing the reference count in a smart pointer implementation. This is because we want to ensure that changes made to the control block in our thread are released to other threads, and also acquire changes from other threads to safely destroy the control block, in case we are the last reference to the object.
	
\begin{lstlisting}
smart_ptr<T>::~smart_ptr(){
	// Release changes that we've made to the object
	if(pn->refCount.fetch_sub(1, std::memory_order_acq_rel) == 0){
		// Acquire all changes made in other threads to call dtor safely
		...
	}
}
\end{lstlisting}

\end{itemize}

	\par Memory barrier usage: 1) stop reorder, 2) provide synchronize.
\begin{lstlisting}
std::atomic<bool> flag(false);
int a;

void func1(){
	a = 100;
	atomic_thread_fence(std::memory_order_release);
	flag.store(true, std::memory_order_relaxed);
}

void func2() {
	while(!flag.load(std::memory_order_relaxed)) ;
	
	atomic_thread_fence(std::memory_order_acquire);
	std::cout << a << '\n'; // guaranteed to print 100
}

int main() {
	std::thread t1 (func1);
	std::thread t2 (func2);
	
	t1.join(); t2.join();
}	
\end{lstlisting}

	\par Considering efficiency, release-acquire order > memory fence > memory\_order\_seq\_cst. There are two key differences:

\begin{enumerate}
	\item A memory barrier with acquire semantics imposes stricter ordering constraints. While both an acquire operation on an atomic and a memory barrier require that no read or write operation can be moved before the acquire operation, an acquire memory barrier provides an additional guarantee: no read operation can be moved after the acquire memory barrier.
	
	
	\item The similar statement holds for the release memory barrier. no read or write operation can be moved after the release operation, Furthermore, store operations can’t be moved before the memory barrier.
	
	\begin{center}
		\includegraphics[width=0.63\linewidth]{pics/release1.png}
	\end{center}
	
	\begin{center}
		\includegraphics[width=0.74\linewidth]{pics/release2.png}
	\end{center}
	
	\item detail can be found in "Acquire and Release Fences Don't Work the Way You'd Expect" and 
	\verb|https://www.modernescpp.com/index.php/acquire-release-fences|
	
%	\item The store operation with \texttt{std::memory\_order\_release} places fewer memory ordering constraints on neighboring operations compared to a memory fence with \texttt{std::memory\_order\_release}. The store operation with \texttt{std::memory\_order\_release} only needs to prevent preceding memory operations from being reordered past itself, whereas a memory fence with \texttt{std::memory\_order\_release} must prevent preceding memory operations from being reordered past all subsequent writes. 
%	
%	
%	
%	Due to this distinction, a release operation cannot replace a release fence. In other words, the relaxed semantics suffice for reading the atomic variable var. The std::atomic\_thread\_fence(std::memory\_order\_acquire) ensures that this operation cannot be moved after the acquire fence.	
	
	
	
	
	
\end{enumerate}



\subsubsection{Synchronizes-with}
	
	 One of the important concepts in memory order is the "synchronize-with" relationship. This relationship determines whether a variable is visible to another thread, considering caching and cache coherence. In some cases, a write to memory may not be immediately visible to another thread due to caching, and statements may appear to have been reordered in the source code, especially in "payload and flag" situations. For example, consider the double-checked locking pattern in a singleton implementation.
	
	\par Let A and B represent operations performed by a multithreaded process. If \textbf{A happens-before B}, then the memory effects of A effectively become visible to the thread performing B before B is performed.


	\par \textbf{Happens-Before Does Not Imply Happening Before}. One possible is: When \texttt{A = 1} just write to store buffer, then B = 1 will write it to memory. After that, we write A back to memory, Has the happens-before relation been violated? Let’s see. According to the definition, the memory effects of (1) must effectively be visible before (2) is performed. In other words, the store to A must have a chance to influence the store to B. In this case, though, the store to A doesn’t actually influence the store to B. (2) still behaves the same as it would have even if the effects of (1) had been visible, which is effectively the same as (1)’s effects being visible. Therefore, this doesn’t count as a violation of the happens-before rule. I’ll admit, this explanation is a bit dicey, but I’m fairly confident it’s consistent with the meaning of happen-before in all those language specifications.

\begin{lstlisting}
int A = 0;
int B = 0;

void foo(){
    A = B + 1;              // (1)
    B = 1;                  // (2)
}
\end{lstlisting}

	\par \textbf{Happening Before Does Not Imply Happens-Before.} Furthermore, let’s suppose that at runtime, the line marked (3) ends up reading 1, the value that was stored at line (2) in the other thread. In this case, we know that (2) must have happened before (3). But that doesn’t mean there is a happens-before relationship between (2) and (3)! The happens-before relationship only exists where the language standards say it exists. And since these are plain loads and stores, the C++11 standard has no rule which introduces a happens-before relation between (2) and (3), even when (3) reads the value written by (2). Furthermore, because there is no happens-before relation between (2) and (3), there is no happens-before relation between (1) and (4), either. Therefore, the memory interactions of (1) and (4) can be reordered, either due to compiler instruction reordering or memory reordering on the processor itself, such that (4) ends up printing “0”, even though (3) reads 1.
		
\begin{lstlisting}
int isReady = 0;
int answer = 0;

void publishMessage(){
    answer = 42;                      // (1)
    isReady = 1;                      // (2)
}

void consumeMessage(){
    if (isReady)        // (3) <-- Let's suppose this line reads 1
        printf("%d\n", answer);       // (4)
}
\end{lstlisting}

%		\par An atomic operation A that performs a release operation on an atomic object M synchronizes with an atomic operation B that performs an acquire operation on M and takes its value from any side effect in the release sequence headed by A.
		
		\par In every synchronizes-with relationship, you should be able to identify two key ingredients, which I like to call the guard variable and the payload. The payload is the set of data being propagated between threads, while the guard variable protects access to the payload. Don’t fall into the trap of thinking that synchronizes-with is a relationship between statements in your source code. It isn’t! It’s a relationship between operations which occur at runtime, based on those statements.


\begin{center}
	\includegraphics[width=0.85\linewidth]{pics/happen_before.drawio.png}
\end{center}

%\begin{center}
%	\includegraphics[width=0.85\linewidth]{pics/happen1.png}
%\end{center}

	\par From above figure, you can see \texttt{thread.join()} creates a synchronization-with relationship between the calling thread and the joined thread. When a thread calls \texttt{join()} on another thread, the calling thread will wait for the joined thread to complete before continuing its execution. This ensures that any operations performed by the joined thread are completed before the calling thread proceeds, creating a synchronization-with relationship between the two threads. In other words, the join operation establishes a happens-before relationship between the end of the joined thread's execution and the continuation of the calling thread's execution.
	
	\par The synchronizes-with relationship is something that you can get only between operations on atomic types. One thing they have in common is that whenever there’s a synchronizes-with relationship between two operations, typically on different threads, there’s a happens-before relationship between those operations as well.
	


		\par A good article is "The Happens-Before Relation".


\subsection{Usage of atomic type}

\subsubsection{spin lock}

	
	 In this section, based on the knowledge I introduced earlier, I'll demonstrate the implementation of a spin lock using different methods. Spin locks aren't as commonly used as other locks, but understanding implementations based on atomic operations and memory ordering (synchronize-with relationship) is valuable. First, let's implement it using \texttt{test\_and\_set}.
\begin{lstlisting}
class spinlock_mutex{
	std::atomic_flag flag; //test_and_set is a method of std::atomic_flag.
public:
	spinlock_mutex():flag(ATOMIC_FLAG_INIT){}
	void lock(){
		while(flag.test_and_set(std::memory_order_acquire));
	}
	void unlock(){
		flag.clear(std::memory_order_released);
	}
};	
\end{lstlisting}

	\par test-and-set (TAS) operation. TAS atomically writes to the memory location and returns its old value in a single indivisible step. Actually, the name test-and-set is a little misleading, because the caller is responsible for testing if the operation has succeeded or not. In C++11 \texttt{std::atomic\_bool::exchange()} can be used to perform a TAS operation on an \texttt{std::atomic\_bool} synchronization variable. Implementation of spin lock can also based the \texttt{exchange}. \texttt{exchange} and \texttt{test\_and\_set} has the same basic idea and same performance. 
\begin{lstlisting}[]
struct tas_lock {
	std::atomic<bool> lock_ = {false};
	void lock() { 
		while(lock_.exchange(true, std::memory_order_acquire)); 
	}
	void unlock() {
		 lock_.store(false, std::memory_order_release); 
	 }
};	
\end{lstlisting}	
	
	\par The problem with the above implementation occurs when there is contention on the lock. In order to keep all CPU caches synchronized a cache coherency protocol is used. There are several different cache coherency protocols (MESI, MOESI, MESIF), but they all have in common that only a single CPU core may write to a cache line but multiple CPU cores may simultaneously read from a cache line. The atomic exchange operation requires write access to the cache line where the lock is stored. If more than one thread is spinning trying to acquire the lock a lot of cache coherency traffic is required to continuously change which core has exclusive write access to the lock.
	
	\par Since the coherency protocol allows for multiple simultaneous readers we can reduce the coherency traffic by instead spinning on an atomic load operation (spin-wait loop). Instead of continuos futile attempts to acquire the held lock we wait for the lock holder to first release the lock. This eliminates cache coherency traffic during spinning:
\begin{lstlisting}[]
struct ttas_lock { //ttas is test test_and_set.
	void lock() {
		for (;;) {
			if (!lock_.exchange(true, std::memory_order_acquire)) {
				break;
			}
			while (lock_.load(std::memory_order_relaxed));
		}
	}
	...
};	
\end{lstlisting}	
	
	\par You can also use \texttt{compare\_exchange\_weak} to implementation spin lock. Frankly speaking, \newline \texttt{compare\_exchange\_weak} interface is not good for spin lock.  You should prefer TAS. 
	
\begin{lstlisting}
struct spinlock{
	atomic<bool> flag;
	spinlock():flag(false){}
	void lock(){
		bool temp=false;
		while(!flag.compare_exchange_weak(temp, true, std::memory_order_seq_cst)){
			temp = false;  //everytime, temp will be overwritten to true
			               //if flag is true. so need to make temp false again.
		};
	}	
	void unlock(){
		flag.store(false, std::memory_order_seq_cst);
	}
};	
\end{lstlisting}

	\par A spin lock is a simple lock mechanism that uses busy waiting to achieve synchronization. When a thread attempts to acquire a spin lock, it repeatedly checks the lock's state in a loop until it becomes available. While waiting, the thread keeps the CPU busy, spinning in a tight loop, hence the name "spin lock". Spin locks are often used in situations where the lock is expected to be held for only a short period of time, and contention for the lock is rare. A mutex, on the other hand, is a more sophisticated lock mechanism that uses a data structure to manage access to shared resources. When a thread attempts to acquire a mutex, it is added to a queue of threads waiting for the mutex. When the mutex becomes available, the thread at the front of the queue acquires it and can access the shared resource. Mutexes are often used in situations where the lock is expected to be held for a longer period of time, or where contention for the lock is more likely.

	In summary, spin locks are simple and lightweight but can cause performance issues if used in highly contended scenarios. Mutexes are more complex and have some overhead due to the management of the waiting queue, but are better suited for highly contended scenarios where lock holding time is longer.	
	

 \subsubsection{singleton in concurrent}

	
	 We can use a lock+mutex to make \textbf{1) atomic access m\_Instance; 2) synchronize-with relationship with the other thread} guarantee at the same time. The only problem is that this lock+mutex implementation is not efficient.  Because if we have many threads to run \texttt{getInstance}, only one can get lock, and all the others will be suspended. It cause lock convery problem, Let's consider one possibility, if one thread get lock but the time slice has been taken away by the OS schedular. Then this mutex is in lock status. Then all the others threads can't get lock,  they will be suspended and all the time slice have been reduced by the OS. then context switch will happen more often, it will cause performance penalty.  From this implementation, you can see lock+mutex is the safest way, because it guarantee atomic and synchronized-with relationship at the same time. But you pay performance bill. If you want to improve it, you have to take care of atomic access and synchronize-with by you self, let's introduce in the next item.
	
\begin{lstlisting}[]
Singleton* Singleton::m_Instance = nullptr;

Singleton* Singleton::getInstance () {
	lock_guard<mutex> lock(m_mutex);
	if (m_Instance == nullptr) {
		m_Instance = new Singleton;
	}
	return Singleton;
}   	
\end{lstlisting}	
	
	\par In order to resolve performance concern, you can try double check lock patten. there are two problems with this code. The first one is reading \texttt{m\_Instance} is not atomic operation,  The second problem is there is no synchronize with relationship with line 7 and line 4. 
\begin{lstlisting}[]
Singleton* Singleton::m_Instance = nullptr;

Singleton* Singleton::getInstance () {
	if (m_Instance == nullptr) {
		lock_guard<mutex> lock(m_mutex);
		if (m_Instance == nullptr) {
			m_Instance = new Singleton;
		}
	}
	return Singleton;
}	
\end{lstlisting}	
	
	\par This problem can NOT be resolved by introducing a temp variable, \texttt{tmp=new Singleton} can be divided by two steps: 
\begin{lstlisting}[]
Singleton* Singleton::getInstance () {
	Singleton * tmp = m_Instance;
	if (m_Instance == nullptr) {
		lock_guard<mutex> lock(m_mutex);
		tmp = m_Instance;
		if (m_Instance == nullptr) {
			tmp = new Singleton;   //oops
			m_Instance = tmp;  
		}
	}
	return Singleton;
}
1) tmp = operator new(sizeof(Singleton));  
2) new(tmp) Singleton;  
3) m_instance = tmp;   //The compile can reorder 3) in front of 2). 	
\end{lstlisting}	
	
	
	\par Below is workable implementation. The code use atomic variable to make sure atomic read operation. At the same time, use memory fence to make sure synchronize relationship. 
	
\begin{lstlisting}[]
std::atomic<Singleton*> Singleton::m_instance; //read and write is atomic
std::mutex Singleton::m_mutex;

Singleton* Singleton::getInstance() {
	Singleton* tmp = m_instance.load(std::memory_order_relaxed);
	std::atomic_thread_fence(std::memory_order_acquire);
	if (tmp == nullptr) {
		std::lock_guard<std::mutex> lock(m_mutex);
		tmp = m_instance.load(std::memory_order_relaxed);
		if (tmp == nullptr) {
			tmp = new Singleton;
			std::atomic_thread_fence(std::memory_order_release);
			m_instance.store(tmp, std::memory_order_relaxed);
		}
	}
	return tmp;
}	
\end{lstlisting}	
	\begin{description}		
		\item[line 5] Why do we need a \texttt{tmp} here? \texttt{tmp} is not necessary for atomic and synchronize. because \texttt{m\_instance} is atomic, so it will be easy to load once, if you return \texttt{m\_instance} in the last line, it just like \texttt{m\_instance.load(seq\_cst)}, it will insert mem fence and a little expensive. 
		
		\item [line 8] Think that a group of threads come to the line 8,  only one get lock, the others will be blocked in lock. when the one finish new and release lock, the others get lock and load it again and found it is not nullptr, then returen back again.  You can see the load in line 9 is relaxed. we only need to keep atomic read, synchronize with is guarantee by the mutex. 
		
		\item [Source code] When the one thread just new singleton in line 11, we need to make sure that m\_instance has been constructed. and be visible by other thread. That is why we need line 12 synchronized-with line 6. How to understand memory fence? An acquire fence prevents the memory reordering of any read which precedes it in program order with any read or write which follows it in program order. A release fence prevents the memory reordering of any read or write which precedes it in program order with any write which follows it in program order.
	\end{description}
	
	\begin{center}
		%\includegraphics[width=0.65\linewidth]{pics/singleton.png}
		
			\includegraphics[width=0.8\linewidth]{pics/singleton.drawio.png}
		
	\end{center}
	
	
	\par That’s what all those flawed double check singleton implementations were missing: Without any synchronizes-with relationship, there was no guarantee that all the writes performed by the first thread – in particular, those performed in the Singleton constructor – were visible to the second thread, even if the m\_instance pointer itself was visible! The lock held by the first thread didn’t help, either, since the second thread doesn’t acquire any lock, and can therefore run concurrently.
	
	\par Another implementation is using release and acquire semantic.
\begin{lstlisting}[]
std::atomic<Singleton*> Singleton::m_instance;
std::mutex Singleton::m_mutex;

Singleton* Singleton::getInstance() {
	Singleton* tmp = m_instance.load(std::memory_order_acquire);
	if (tmp == nullptr) {
		std::lock_guard<std::mutex> lock(m_mutex);
		tmp = m_instance.load(std::memory_order_relaxed);
		if (tmp == nullptr) {
			tmp = new Singleton;
			m_instance.store(tmp, std::memory_order_release);
		}
	}
	return tmp;
}	
\end{lstlisting}	
	
	\par Another implementation is use cst\_seq
\begin{lstlisting}[]
std::atomic<Singleton*> Singleton::m_instance;
std::mutex Singleton::m_mutex;

Singleton* Singleton::getInstance() {
	Singleton* tmp = m_instance.load();
	if (tmp == nullptr) {
		std::lock_guard<std::mutex> lock(m_mutex);
		tmp = m_instance.load();
		if (tmp == nullptr) {
			tmp = new Singleton;
			m_instance.store(tmp);
		}
	}
	return tmp;
}	
\end{lstlisting}

	\par A good paper can be found "Double-Checked Locking is Fixed In C++11".
	


\section{Construct and destruct in concurrency}

	 For construct in concurrency, \textbf{Don't} register any call back or give \texttt{this} pointer to any another thread object, even in the last line of constructor, because maybe it's a child class, after the last line, it will call base class constructor implicitly. If you really need to register this pointer,(such as Observer pattern),  use two phrase methods, construct+ initialize() methods.
\begin{lstlisting}
class Foo : public Observer{
public:
  Foo(Observable* s){
    s->register(this) //don't do this in concurrent context. 
  }
}
\end{lstlisting}

    \par Compared with construction, destruction is challenging because we can \textbf{NOT} lock a mutex in the destructor. When an object is being accessed concurrently by multiple threads—where one thread uses a member function while another attempts to destroy it—this situation leads to a data race or undefined behavior.
\begin{lstlisting}[]
Foo* foo = new Foo();
thread A(fun, foo);  //thread A

delete foo;     //thread B, How can you make sure foo isn't used in thread A? 
\end{lstlisting}

	\par To address the data race issue in destructors, we can use \texttt{shared\_ptr} and \texttt{weak\_ptr} to resolve it. The safety guarantee lies in \texttt{weak\_ptr::lock()}, which executes atomically. This allows us to obtain a \texttt{shared\_ptr} from other threads without needing additional synchronization. (This is possible because access to the reference count is atomic.)
	
\begin{lstlisting}
weak_ptr::lock(){
	returns expired() ? shared_ptr<T>() : shared_ptr<T>(*this) 
	//this return execute automatically.
}	
\end{lstlisting}
        
\begin{lstlisting}[]
fun(weak_ptr<Foo> wptr){ //thread 1
  ...
  if(wptr.lock())
    ..if true, at this time, shared_ptr will increased.
    ..if false, at this time,  shared_ptr has been nullptr in thread 2. 
}

shared_ptr<Foo> foo = new Foo(); //thread 2
thread b(fun, foo); //suppose the foo has go outside of scope here.
\end{lstlisting}

    \par \texttt{shared\_ptr} is a valuable tool when writing concurrent programs. In the "read and write mutex" section, we discussed "copy on write" where we typically use \texttt{shared\_ptr.unique()} to determine if other threads are reading. This pattern also helps us avoid deadlocks.

%		\item Why share pointer is important, because it can help you to make sure destructor and other operation thread safe. We can't use mutex in object destructor, in order to make sure destructor and other operations can be synchronized properly. The detail can be found in chenshuo 's book. A famous example is observer. 

        \par share pointer has two advantages: 1) share pointer+weak pointer can resolve data race happened in destructor, 2) share pointer can help you to manage the memory. Below is a very good example.  I will explain in detail:
        


\begin{lstlisting}
class StockFactory: public enable_shared_from_this<StockFactory> {
public:
	shared_ptr<Stock> get(const string& key) {
		shared_ptr<Stock> pStock;
		MutexLockGuard lock(mutex_);
		weak_ptr<Stock>& wkStock = stocks_[key];
		pStock = wkStock.lock();  //atomic operation here.
		if (!pStock) {
			pStock.reset(new Stock(key), bind(&StockFactory::weakDeleteCallback,
                     weak_ptr<StockFactory>(shared_from_this()), _1));
			wkStock = pStock;
		}
		return pStock;
	}
private:
	static void weakDeleteCallback(const weak_ptr<StockFactory>& wkFactory, Stock* stock) {
	    printf("weakDeleteStock[%p]\n", stock);
		shared_ptr<StockFactory> factory(wkFactory.lock());
		if (factory) {
			factory->removeStock(stock);
		}
		else {
			printf("factory died.\n");
		}
		delete stock;  
	}
	void removeStock(Stock* stock) {
		if (stock) {
			MutexLockGuard lock(mutex_);
			auto it = stocks_.find(stock->key());
			if (it != stocks_.end() && it->second.expired()) {
				stocks_.erase(stock->key());
			}
		}
	}
	mutable MutexLock mutex_;
	std::map<string, weak_ptr<Stock> > stocks_;
};
\end{lstlisting}

\begin{itemize}
	\item line 7 uses \texttt{weak\_ptr}, in this way, we return \texttt{Stock} object from \texttt{StockFactory} to different thread, If other thread is destructing a stock object,  \texttt{std::weak\_ptr} will return false, then we will know this object has been deleted, we can reset it again.  Otherwise, lock will increase reference number in the \texttt{std::shared\_ptr} and and stop other thread from destructing stock object. 
	
	\item \texttt{enable\_shared\_from\_this} is CRTP, it add \texttt{shared\_from\_this} function to \texttt{StockFactory} class. We need to pass \texttt{std::shared\_ptr} of \texttt{StockFactory} to stock object. 
	
	\item Both \texttt{Stock} and \texttt{StockFactory} keep a \texttt{std::weak\_ptr} to each other, so it will not affect other life time. 
	
	\item \texttt{std::shared\_ptr} support customized deleter, this deleter will come back to factory delete the \texttt{std::weak\_ptr} there, in this way, we don't have any memory leak. 
\end{itemize}



\begin{center}	
	\includegraphics[width=0.85\linewidth]{pics/weak_ptr.png}
\end{center}



		\par Based on previous code, test long life and short life Factory. 
\begin{lstlisting}
void testLongLifeFactory() {
  shared_ptr<StockFactory> factory(new StockFactory);
  { //build a scope, so stock can be deleted in the end of scope.
    shared_ptr<Stock> stock = factory->get("NYSE:IBM");
    shared_ptr<Stock> stock2 = factory->get("NYSE:IBM");
    assert(stock == stock2); 
  } // stock destructs here
} // factory destructs here

void testShortLifeFactory() {
  shared_ptr<Stock> stock;
  {
    shared_ptr<StockFactory> factory(new StockFactory);
    stock = factory->get("NYSE:IBM");
    shared_ptr<Stock> stock2 = factory->get("NYSE:IBM");
    assert(stock == stock2);
  } // factory destructs here
} // stock destructs here
\end{lstlisting}
	

\section{Summary of the chapter}

	 The main components in concurrent programming in C++ can be illustrated by the figure below.
	\begin{center}
		\includegraphics[width=0.66\linewidth]{pics/concurrent.drawio.png}
	\end{center}
	

	 \par This chapter also presents four valuable concurrent application examples: 1) singleton, 2) spin lock, 3) stock factory, and 4) using shared\_ptr instead of read and write mutex. Understanding these examples fully, including their design concepts and implementation details, is crucial. Moreover, these examples can prove highly useful in practical applications.
	 
	 \par Some important guide line when you use the concurrency in your application:

\begin{itemize}
	\item Only use multi-threading when absolutely necessary, as synchronization comes with overhead. Typical scenarios where multi-threading is beneficial include:
	\begin{enumerate}
		\item Web servers handling multiple requests concurrently.
		
		\item GUI applications separating UI responsiveness from background processing.
		
		\item Utilizing multiple processors efficiently.
	\end{enumerate}
	
	\item Use \texttt{join()} to wait for background threads before terminating an application. 
	
	\item It's not recommended to create more threads than available cores; instead, using a thread pool is preferred to manage thread lifecycle efficiently. Additionally, volatile should be avoided for synchronization purposes.
	
	\item If there's no strong reason against it, it's generally recommended to use higher-level concurrent functions such as \texttt{std::async} instead of directly managing threads.
	
	\item Compact and small critical sections help minimize potential issues like race conditions and improve concurrency performance.
	
	\item Don't attempt to acquire a \texttt{std::mutex} twice. The fix is to structure your code so that it doesn't attempt to acquire a mutex that has already been locked. Using a \texttt{std::recursive\_mutex} might seem like a quick fix, but it often indicates a poor design.  
	
	\item Acquire multiple locks in the same order to avoid deadlocks.
	
	\item Avoid using mutexes when \texttt{std::atomic} types can suffice. For example, when incrementing a \texttt{counter} using multiple threads.
	
\begin{lstlisting}[]
mu.lock(); //use mutex and lock 
counter++;
mu.unlock();

std::atomic<int> counter; //better solution.
counter++;
counter.fetch_add(1, std::memory_order_relaxed); //better performance	
\end{lstlisting}	
	
	\item Don't try to implement lock-free architectures by yourself because it's very complex and tricky.
	
	
\end{itemize}
		
	
	
	
	
   
    
    
     
%     \item A common method is to make \texttt{std::shared\_ptr} thread safe. when copy it add lock, then use local copy. In this way, we can make our critical section shorter.
%\begin{lstlisting}
%std::shared_ptr<T> global_ptr;
%std::mutex mu;
%
%void ThreadOpSharedPtr() {
%    std::shared_ptr<T> local_ptr;
%    { 
%        MutexLockGuard lock(mu);
%        local_ptr = global_ptr; //critical section is small 
%    }
%    // use local_ptr do whatever you want, it's thread-safe now
%}
%
%void write(){
%  shared_ptr<Foo> new Ptr(new Foo);
%  {
%	MutexLockGuard lock(mutex);
%	globalPtr = newPtr;
%  }
%  doit(newPtr);
%}
%\end{lstlisting}
    

    
   
\chapter{Internet}
\section{Common used protocols}
\subsection{Level and different protocols}

	 Protocols play a central role in internet programming by providing a standardized way of performing certain actions and formatting data. It enables two or more devices to communicate with and understand each other. Below are some important protocols that you need to know at different levels:
	
	\begin{enumerate}
		\item Application level: DHCP, HTTP, FTP, RPC.
		\item Transport  level (Segment): UDP(User Datagram Protocol), TCP(Transmission Control Protocol).
		\item Net level (Packet): ICMP,  NAT, IP(Internet Protocol). 
		\item Data link level (Frame): ARP, VLAN, STP.
		\item Physics level: Net cable, WIFI. 
	\end{enumerate}

	\par TargetMac(6 bytes)+sourceMacMac(6 bytes)+ EtherType(2 bytes, 0800 is ip packet, 0806 is ARP packet) + data(46-1500 bytes)+CRC(4 bytes). That is the data link frame. In \textbf{data link level}, we call data as \textbf{frame}. The EtherType field is a 2-byte value used in Ethernet frames to identify the protocol encapsulated in the payload. This field is crucial for the correct processing of the frame's data by the receiving device.

	\par STP stands for Spanning Tree Protocol, which is a link management protocol designed to support redundant links in a network and prevent switching loops. To learn more about STP, you can refer to a tutorial such as 'Spanning Tree Protocol (STP) Tutorial' available on Google.

	
\begin{center}
	\includegraphics[width=0.50\linewidth]{pics/vlan.png}
\end{center}

	\par A VLAN (virtual LAN) is a sub network which can group together collections of devices on separate physical local area networks (LANs). VLANs are often set up by larger businesses to re-partition devices for better traffic management.
	

		\par In data link layer(level 2), If you know IP address, but don't know mac address, then you need to use ARP protocol(Address resolution Protocol). Broadcast an ARP packet, then the target computer will answer with his mac address. Switch will cache this mac address for future use.
		
		\begin{center}
			\includegraphics[width=0.90\linewidth]{pics/it_layer.png}
		\end{center}
	
		\par All the package in the internet, Maybe it doesn't have upper layer, but it must includes lower layer, (Mac level and IP level). Lower refer the bottom of previous figure. When we talk about level 2 or leve 3, we also count this number from lower to upper. So it's important to remember and understand above figure. 
		
		\par Below figure illustrates the relationship between different common used protocols and some explanations about it:
		\begin{itemize}
			\item Network File System (NFS) is a distributed file system protocol allowing a user on a client computer to access files over a computer network much like local storage is accessed.
			
			\item PPP is an acronym for Point to Point Protocol. It is a member of the TCP/IP suite of network protocols. PPP is an extension to TCP/IP that adds two additional sets of functionality: 1) it can transmit TCP/IP packets over a serial link, 2) it has login security. When we dial-up ISP to connect internet, we use PPP to build connection between your computer and ISP server. Pay attention here, PPP is different with Peer to peer protocal (P2P). Point-to-Point Protocol usually refers to the protocol used in the data link layer of the IP protocol stack (PPP). While P2P(Peer-to-Peer) is on application level. 	
			
			\item  ICMP is Internet Control Message Protocol. When you run ping command, it uses this protocol. 
			
		\end{itemize}
		
	
\begin{center}
	\includegraphics[width=0.60\linewidth]{pics/protocols.png}	
\end{center}


		
	
	\par Level 2 switch has mac address, level 3 router has ip address. For router, each port has MAC address and IP address. If it's not in the same subnet, just pass it to gateway(a router). That is the basic difference between switcher(level 2 devices) and router(level 3 devices). 
	
	\par Run \texttt{ifconfig} or \texttt{ip addr} command in Linux, below is the output and explanation. mtu is maximum transport unit. qdisc is queue discipline.  \texttt{pfifo\_fast} has three queues. Scope global can get data from outside. Scope host only get data from local, such as lo(loopback). Mac address used inside subnet and ip used for navigate. Knowing the 10.100.122.2/24 format, it is Classless Inter-Domain Routing(CIDR) notation. The most significant bits are the network prefix, which identifies a whole network or subnet, and the least significant set forms the host identifier.
\begin{lstlisting}
root@test:~# ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default
	link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
	inet 127.0.0.1/8 scope host lo
	valid_lft forever preferred_lft forever
	inet6 ::1/128 scope host
	valid_lft forever preferred_lft forever

2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
	link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff
	inet 10.100.122.2/24 brd 10.100.122.255 scope global eth0
	valid_lft forever preferred_lft forever
	inet6 fe80::f816:3eff:fec7:7975/64 scope link
	valid_lft forever preferred_lft forever
\end{lstlisting}


	\par  For IP, you need to know two things: router protocol and NAT. The most common used router protocol is OSPF(Open shortest Path First) which is based link state routing.  It mainly used in Interior Gateway Protocol, IGP.  BGP is based path-vector protocol. Why do we have IGP and BGP?, because BGP mainly deal with AS(Autonomous system). You can think IGP and BGP as 192.168.0.1/24, one is for net id, and the other is for computer id. 
	
	\par NAT stands for Network Address Translation. It is a protocol used in computer networking to map an IP address from one network to another. NAT is typically used in small-scale networks where a limited number of public IP addresses are available, but many devices need to access the internet. NAT allows the devices in the network to share a single public IP address while maintaining communication with external devices on the internet. There are different types of NAT protocols, including Static NAT, Dynamic NAT, and Port Address Translation (PAT). Each type has its own specific use case and benefits. NAT operates on a router—generally connecting only two networks. Before any packets are forwarded to another network, NAT translates the private (inside local) addresses within the internal network into public (inside global) addresses. This functionality gives you the option to configure NAT so that it advertises only a single address for your entire network to the outside world. Doing this translation, NAT effectively hides the internal network from the world, giving you some additional security. Most our home and small office internet connection use this protocol to connect to internet. 
	
	\par Implementation of NAT is based on Netfilter. 
	\begin{itemize}
		\item Use iptables can customized these hook functions. 
\begin{lstlisting}
	iptables -t filter -A INPUT -s 0.0.0.0/0.0.0.0 -d X.X.X.X -j DROP
\end{lstlisting}				
		\item Any message for me, from PREROUTING to INPUT, I will accept it.
		\item Any message for others, from OUTPUT to POSTROUTING, I will send it out.
		\item Any message pass by, from PREROUTING to FORWARD, then to POSTROUTING, last send it out. 
	
		\item When we have NAT rule, in PREROUTING, we call nf\_nat\_ipv4\_in to transfer ip address, in POSTROUTING, we can nf\_nat\_ipv4\_out to transfer ip address. The lower data structure is connection hash table.
		
	\end{itemize}
 
	\begin{center}
		\includegraphics[width=0.85\linewidth]{pics/nat.png}
	\end{center}
	
	
	\par WebSocket is bidirectional, a full-duplex protocol that is used in the same scenario of client-server communication, unlike HTTP, it starts from ws:// or wss://. It is a stateful protocol, which means the connection between client and server will keep alive until it is terminated by either party (client or server). After closing the connection by either of the client and server, the connection is terminated from both ends. Real-time web application uses a web socket to show the data at the client end, which is continuously being sent by the backend server. In WebSocket, data is continuously pushed/transmitted into the same connection which is already open, that is why WebSocket is faster and improves the application performance. For e.g. in a trading website or bitcoin trading, for displaying the price fluctuation and movement data is continuously pushed by the backend server to the client end by using a WebSocket channel.
	
	\par UDP (User Datagram Protocol) and TCP (Transmission Control Protocol) are both transport layer protocols used in computer networking, but there are some key differences between them:
	\begin{itemize}
		\item Connection-oriented vs Connectionless: TCP is a connection-oriented protocol that establishes a reliable and ordered communication channel between two endpoints, ensuring reliable delivery through acknowledgment and retransmission mechanisms. while UDP is a connectionless protocol that does not establish a dedicated end-to-end connection before transmitting data. UDP does not guarantee delivery or order of packets, focusing on speed and efficiency.
		
		\item Reliability: TCP guarantees reliable data delivery by implementing flow control, error detection, and retransmission mechanisms. UDP does not provide reliability guarantees, and packets may be lost, duplicated, or delivered out of order.
		
		\item Packet overhead: TCP has a larger packet overhead due to the need to establish a connection and maintain the reliability mechanisms, while UDP has a smaller packet overhead and less processing overhead.
		
		\item Speed: UDP is faster than TCP due to its connectionless nature and smaller overhead, but this comes at the cost of reliability.
		
		\item Applications: TCP is used in applications that require reliable data delivery, such as web browsing, email, and file transfer, while UDP is used in applications that prioritize speed over reliability, such as video streaming, online gaming, and real-time communication.
	\end{itemize}
	
	\par You need to know three basic conceptions about TCP: 1) Three shakes to connect. four waves to disconnect. These two conceptions will be introduced in socket section later. 2) What is RST? 3) advertise windows. RST is one of six flags in the TCP header, along with SYN, ACK, FIN, PSH, and URG. The flags indicate the state and direction of a TCP connection. RST stands for reset and is a packet that terminates a connection between two devices. the advertised window is a value sent by the receiving device to indicate how much data it can accept at any given time. The receiving device uses this value to control the flow of data. 


\subsection{VPN, GRE and tunnel}
	
	
	
	 Computer networks use a \textbf{tunneling protocol} when one network protocol (the \textbf{delivery protocol}) encapsulates a different \textbf{payload protocol}. By using tunneling, one can carry a payload over an incompatible delivery network or provide a secure path through an untrusted network. GRE is a protocol running over IP that often serves to carry IP packets with private addresses over the Internet using delivery packets with public IP addresses. In this case, the delivery and payload protocols are compatible, but the payload addresses are incompatible with those of the delivery network. Another example is a VPN (Virtual Private Network). The basic idea is the same: the payload packet can't be transmitted in the delivery network because it has been encrypted.
	
	
	\begin{center}
		\includegraphics[width=0.70\linewidth]{pics/tunnel.png}
	\end{center}
	
	\par Generic Routing Encapsulation (GRE) is a protocol for encapsulating one protocol within another, while a VPN (Virtual Private Network) is a technology for creating a secure, private connection over a public network. Although both technologies have their specific use cases, a VPN is generally considered more versatile and secure. GRE is typically used to connect two networks, allowing them to communicate as if they were on the same network. On the other hand, a VPN can be used to connect two devices or networks, but it is most commonly used to connect remote workers or branch offices to a company's internal network.
	
	\begin{center}
		\includegraphics[width=0.40\linewidth]{pics/payload.drawio.png}
	\end{center}

	\par How tunnel is implemented? We usually use virtual network devices. In computer networking, TUN and TAP are kernel virtual network devices. Being network devices supported entirely in software, they differ from ordinary network devices which are backed by physical network adapters. different with eth0, other side tun0 can be attached to user application. Data sent by network protocol stack can be read by this user application. 
	\begin{enumerate}
		\item User application A send a packet by socket A to 192.168.3.1
		
		\item socket A give this packet network protocol stack.
		
		\item network protocol stack find that target address is 192.168.3.1, according to router table rule, I know that this packet should be sent to tun0. 
		
		\item tun0 receives the packet from one side, and send it from the other side, The other side is User application B. 
		
		\item Application B do some extra job, For VPN, it will encrypt the data, and embedded old packet to new packet. At this time, it changes the target address 10.33.0.1 and send it to protocol stack by socket B.
		
		\item sockB give the data to network protocol stack.
		
		\item network protocol stack find this packet should be sent by eth0. 
		
		\item eth0 send out the new packet. 
	\end{enumerate}
	
	
\begin{center}
	\includegraphics[width=0.46\linewidth]{pics/vpn.drawio.png}
\end{center}

	\par How to understand a tunnel? A tunnel is not a physical link between nodes (A, B) in an overlay network, but a logical one. Payload data (payload protocol) between A and B cannot be transferred directly in the underlay network, perhaps because it has been encrypted. So we wrap it in another header (IP). With this header, the data can be transferred over the underlay network (delivery protocol). Think of it this way: data is a car (payload protocol), but the underlay network is an ocean. To move the car from A to B, we build a tunnel under the ocean. This tunnel allows the car to travel from A to B. That is the metaphor for a tunnel in networking.
	

	 In protocol section, I summary all the knowledge to five important topics(\textbf{5V}) as below: 
	\begin{enumerate}
		\item \textbf{VLAN} (in this level, need to know switch, mac address, ARP)
		
		\item \textbf{Virtual device}(tun/tap, veth, bridge), sometimes, tun/tap and veth can be thought as a net cable. know the basic commands (brctl) to build virtual bridge.  A good reference is: \\
		https://segmentfault.com/a/1190000009251098?utm\_source=sf-similar-article
		
		\item \textbf{Virtual machine}. NAT, bridge and host three models, basic implementation behind it. Below figure shows the bridge model. 
		\begin{enumerate}
			
			\item Network Address Translation (NAT) will setup a virtual router on the host. This will enable you to setup a subnet on the VM/s with all traffic to/from the subnet being forwarded by the host. All IP addresses on the subnet will be different from the host. This option makes more sense if you want several VMs that can communicate together and access the Internet.
			
			\item Host only means that the NIC can only communicate with the host and other VMs on the host. It will not be able to access the host’s physical NIC so there will be no Internet access or any other service on the physical LAN outside the host.
			
			\item Bridged means that the VM will have a IP address on the same domain as the host. It will behave just like it was just another machine on the same network as the host. This option is mainly used when you don’t need it to be on a separate network and need Internet access.
			
			
		\end{enumerate}
	\begin{center}
		\includegraphics[width=0.69\linewidth]{pics/bridge.drawio.png}
	\end{center}
				
		\item \textbf{VPN}, Know the tunnel conception tunnel means use one protocal to wrap another protocal. You can use tun/tap to implement it. 
		
		\item \textbf{Vxlan}, need to know the overlay conception. and vxlan also use tunnel. The links that connect the overlay nodes are implemented as tunnels through the underlying network. 
	\end{enumerate}



\section{Socket}

\subsection{Address}
		
	
	 A socket is a combination of an IP address and a port number, which together provides a unique address for a particular communication channel. Sockets can be used with both UDP and TCP protocols to establish a connection between two programs running on different devices on a network. UDP and TCP use sockets to send and receive data between the endpoints of a network communication. With UDP, data is transmitted as individual packets without establishing a dedicated connection between the two endpoints. In contrast, TCP establishes a connection between the two endpoints before transmit data.
	
	\par A socket address structures is always passed by reference when passed as an argument to any socket functions. But any socket function that takes one of these pointers as an argument must deal with socket address structures from any of the supported protocol families. A problem arises in how to declare the type of pointer that is passed. With ANSI C, the solution is simple: \texttt{void *} is the generic pointer type. But, the socket functions predate ANSI C and the solution chosen in 1982 was to define a generic socket address structure in the <sys/socket.h> header. We use PF\_ to initialize socket, and use AF\_ to initialize  address. Please note here, generic address is just used for socket function interface, you don't need to care about it if it has enough length to contain all different kind of address format. 
	
%	\item A socket address structure is always passed by reference when used as an argument in socket functions. However, socket functions must handle socket address structures from various supported protocol families. This poses a challenge in how to declare the type of pointer that is passed. In ANSI C, the solution is straightforward: \texttt{void *} serves as the generic pointer type. However, socket functions predate ANSI C, and the approach adopted in 1982 was to define a generic socket address structure in the <sys/socket.h> header. When initializing sockets, \texttt{PF\_} (Protocol Family) is used, and when initializing addresses, \texttt{AF\_} (Address Family) is used. It’s important to note that the generic address structure is solely used for the socket function interface; programmers need not concern themselves with its internal details as long as it is large enough to accommodate all supported address formats.
	
\begin{lstlisting}
typedef unsigned short int sa_family_t;
struct sockaddr{
	sa_family_t sa_family; /* address family. 16-bit*/
	char sa_data[14]; /* address 112-bit */
}; //AF_LOCAL, AF_INET , AF_INET6			
\end{lstlisting}	
	
	\par The Unix system has a universal beauty in its simplicity: everything is a file, including sockets. 
	
\begin{itemize}
	\item As described in the structure of \texttt{sock\_addr}, several types of sockets need to have two fields: the address family and address. This is easy to understand because if you want to communicate with the outside world, you must at least tell the computer the other party's address and which type of address is being used. Communication with a remote computer also requires a port number. The difference with local sockets is that they do not require a port number.
	
	\item Local sockets essentially access the local file system, so they naturally do not need a port number. Remote sockets directly send a stream of bytes to a process on a remote computer, which may have multiple processes listening, so a port number is used to specify which process to send to.
\end{itemize}
	 

	\par There are five different kinds of address. 
	
	\begin{center}
		\includegraphics[width=0.8\linewidth]{pics/address}
	\end{center}
		

	\par This requirement means that any calls to these functions must cast the pointer to the protocol-specific socket address structure as a pointer to a generic socket address structure. For example, the basic structure for an IPv4 address is shown below:
\begin{lstlisting}
struct sockaddr_in {
	short            sin_family;   // e.g. AF_INET
	unsigned short   sin_port;     // e.g. htons(3490), port number
	struct in_addr   sin_addr;     // see struct in_addr, below
	char             sin_zero[8];  
	// Padding to ensure that struct sockaddr_in matches the size of struct sockaddr.
};
struct in_addr {
	unsigned long s_addr;  // load with inet_aton()
};

struct sockaddr_in  serv;      /* IPv4 socket address structure */
.... /* fill in serv{} */
bind(sockfd, (struct sockaddr *) &serv, sizeof(serv));			
\end{lstlisting}		
	


\subsection{Connection and non-block}
	
	 The sequence of function calls for the client and server involved in a UDP connection. Server use socket, bind, listen, accept. client use socket, connect to finish the connection. Why client don't need bind, it can use temporary port to.
	
	\begin{center}
		\includegraphics[width=0.40\linewidth]{pics/udp.drawio.png}
	\end{center}
	
	\par The sequence of function calls for the client and server involved in a TCP connection.
	
	\begin{center}
		\includegraphics[width=0.53\linewidth]{pics/socket.drawio.png}
	\end{center}
	
	\par We can create a socket to use different protocol, for ping, we use ICMP protocol. 
\begin{lstlisting}
socket(AF_INET, SOCK_RAW, IPPROTO_ICMP)  //icmp
socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) //tcp
socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP) //udp		
\end{lstlisting}	
	
	\par Use the \texttt{fcntl()} function to set the socket to non-blocking mode. This involves retrieving the current flags with F\_GETFL, modifying them to include O\_NONBLOCK, and then setting them back with F\_SETFL:
\begin{lstlisting}
#include <fcntl.h>	
int sockfd = socket(AF_INET, SOCK_STREAM, 0);  // Example socket creation

int flags = fcntl(sockfd, F_GETFL, 0); // Set socket to non-blocking mode
if (flags == -1) {
	perror("fcntl F_GETFL"); // Handle error
}

flags |= O_NONBLOCK;
if (fcntl(sockfd, F_SETFL, flags) == -1) {
	perror("fcntl F_SETFL"); // Handle error
}	
\end{lstlisting}	
	
\par When you try to connect from client, sequence function call and socket state is illustrated by below figure. 

\begin{center}
	\includegraphics[width=0.50\linewidth]{pics/tcp1.png}
\end{center}


\par There are three possibilities when you try to connect.
\begin{enumerate}
	\item Client send out SYN, but without any replay, then return TIMEOUT error, mainly reason is wrong server IP or server is too busy. 
	
	\item Client get RST(Reset), at this time, client return CONNECTION REFUSED error.  The main reason is wrong PORT.  When we get RST?
	\begin{enumerate}
		\item SYN arrive, but server is not listening on this PORT. 
		\item Server want to cancel a connnection. 
		\item Server got a segment which belongs to an non-existing connection.
	\end{enumerate}
	
	\item syn cause "destination unreachable", main reason is router is not connect between client and server.
\end{enumerate}



	\par Based on the previous introduction, below is the server-side code. You should specify the port in the server configuration. However, when used on the client side, you do not need to specify the port because the client will randomly select a port to use for connecting to the server. 
	\begin{itemize}
		\item \texttt{INADDR\_ANY} is a kind of "generic address", it tells the operating system kernel, "Hi, I'm not picky, as long as the destination address belongs to us, it's all good." For example, if a machine has two network cards with IP addresses of 202.61.22.55 and 192.168.1.11, then the application program we write will handle the request packets sent to both of these IPs. 
		
		\item If the port is set to 0, it means that the selection of the port is handed over to the operating system kernel for processing. The operating system kernel will select an available port based on a certain algorithm to complete the binding of the socket. This is not commonly used on the server side.
		
		\item Basically, what the \texttt{listen()} backlog affects is how many incoming connections can queue up if your application isn't accept()ing connections as soon as they come in. It's not particularly important to most applications. The maximum value used by most systems is 128, and passing that is generally safe.
		
		\item \texttt{accept()} will return a new socket which can be used for read and write. Use infinite loop to prepare accept new connection all the times. 
		
		\item For \texttt{accept()}, It is important to note that there are two socket descriptors. The first one is the listening socket descriptor, "\texttt{listensockfd}", which exists as an input parameter; the second one is the returned connected socket descriptor.
	\end{itemize}
	
\begin{lstlisting}
void read_data(int sockfd) {
	ssize_t n; char buf[1024];	
	for (;;) {
		if ((n = readn(sockfd, buf, 1024)) == 0)
			return;
		usleep(1000);
	}
}
int main(int argc, char** argv){	
	int listenfd, connfd;
	socklen_t client;
	struct sockaddr_in cliaddr, servaddr;	
	listenfd = socket(AF_INET, SOCK_STREAM, 0);  //build TCP protocol

	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_ANY); //
	int port = atoi(argv[i]);
	servaddr.sin_port = htons(port);
	
	bind(listenfd, (struct sockaddr *) &servaddr, sizeof(servaddr)); 
	listen(listenfd, 1024); 	/* listen's backlog is 1024 */

	for (;;) {  	/* loop  */
		client = sizeof(cliaddr);
		connfd = accept(listenfd, (struct sockaddr *) &cliaddr, &client);
		read_data(connfd);   /* read data */
		close(connfd);          /* close link socket, not listening socket.*/
	}
}
\end{lstlisting}

	\par  Below is client side code. \texttt{connect} function will use the first two byte to decide the sockaddr* pointer properly which is passed into the function. Why? because when we develop socket, we still don't have void* pointer. so we invent generic address. 
	\begin{itemize}
		\item \texttt{inet\_pton} will change ip address (char format) to binary form. 
		
		\item The client does not have to call the \texttt{bind()} function before calling the \texttt{connect()} function because, if necessary, the kernel will determine the source IP address and select a temporary port as the source port according to a certain algorithm.
		
		\item For server, port is specified, address is any. For client, port is any, need to specify server address which you want to connect.
		
	\end{itemize}

\begin{lstlisting}
int main(int argc, char **argv){
	int sockfd;
	struct sockaddr_in servaddr;
	if (argc != 2)
		err_quit("usage: tcpclient <IPaddress>");
		
	sockfd = socket(AF_INET, SOCK_STREAM, 0);
	bzero(&servaddr, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_port = htons(SERV_PORT);
	inet_pton(AF_INET, argv[1], &servaddr.sin_addr);
	connect(sockfd, (SA *) &servaddr, sizeof(servaddr));
	send_data(stdin, sockfd);
	exit(0);
}                  
\end{lstlisting}

\par Run your server and client on the same computer to do the test
\begin{lstlisting}
./Server 8899  //input the port number as application argument.
./Client 127.0.0.1 8899 //need to specify the server address and port
\end{lstlisting}
	

\subsection{Communication}

\subsubsection{Read and write}

	\par Once a connection is established, the operating system builds a buffer for this socket. In another word, there are buffers in core between your read and physical net device. 
		 
	\begin{center}
		\includegraphics[width=0.8\linewidth]{pics/socket_inside.drawio.png}
	\end{center}

\par You can use \texttt{getsockopt} to check and set the socket buffer size. 
\begin{lstlisting}
int defRcvBufSize = -1; //check the system default socket buffer
socklen_t optlen = sizeof(defRcvBufSize);
if (getsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &defRcvBufSize, &optlen) < 0){
	printf("getsockopt error=%d(%s)!!!\n", errno, strerror(errno));
	goto error;
}
printf("OS default udp socket recv buff size is: %d\n", defRcvBufSize);

int rcvBufSize = atoi(argv[1]); //set SOCKET receiving buffer
optlen = sizeof(rcvBufSize);
if (setsockopt(sockfd, SOL_SOCKET, SO_RCVBUF, &rcvBufSize, optlen) < 0){
	printf("setsockopt error=%d(%s)!!!\n", errno, strerror(errno));
	goto error;
}
printf("set udp socket(%d) recv buff size to %d OK!!!\n", sockfd, rcvBufSize);		
\end{lstlisting}

	\par The difference is that \texttt{recv()/send()} work only on socket descriptors and let you specify certain options for the actual operation. Those functions are slightly more specialized (for instance, you can set a flag to ignore SIGPIPE, or to send out-of-band messages...). Out-of-band data refers to urgent data based on the TCP protocol, which is used for urgent processing between the client and server in specific scenarios. Functions \texttt{read()/write()} are the universal file descriptor functions working on all descriptors.		

	\par Three output functions. With a zero flags argument, \texttt{send()} is equivalent to \texttt{write(2)}.
	
\begin{lstlisting}
ssize_t write (int socketfd, const void *buffer, size_t size)
ssize_t send (int socketfd, const void *buffer, size_t size, int flags)
ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags)	
\end{lstlisting}

	
	\par When you use \texttt{write()} , data is simply copied from your application to the OS's buffer. Subsequently, the OS utilizes lower-level mechanisms to send out TCP packets. This process introduces three possible outcomes when you perform a write operation:
	\begin{itemize}
		\item The data is successfully copied to the OS buffer, \texttt{write()} function return and return the bytes it has written to the buffer. 
		
		\item The data is partially copied due to buffer limitations, and the remaining data is queued in the buffer for later transmission, \texttt{write()} will block and return untill all the data has been written to OS buffer. 
		
		\item An error occurs during the write operation, which could be due to various reasons such as network issues or buffer overflows, \texttt{write()} return -1. 
	\end{itemize}

	\par When reading from a socket, the read operation typically reads up to the specified size and returns the actual number of bytes read. Here's what the return values signify:
	
\begin{itemize}
	\item If read returns EOF, it indicates that the other side has sent a FIN (finish) signal, indicating the orderly shutdown of the connection.
	
	\item If read returns -1, it indicates an error occurred during the read operation. This could be due to various reasons such as network issues, connection resets, or other errors.
	
	\item Otherwise, \texttt{read()} function returns the number of bytes read.
\end{itemize}

\begin{lstlisting}
ssize_t recv(int sockfd, void* buf, size_t len, int flags);
ssize_t read (int socketfd, void *buffer, size_t size)	
\end{lstlisting}	

 \par If you want to specify number byte you want to read, you need to write function like this.
 
\begin{lstlisting}
ssize_t readn(int fd, void *vptr, size_t size){ //from socketfd read "size" char
	size_t nleft;
	ssize_t nread;
	char *ptr;
	ptr = vptr;
	nleft = size;
	while (nleft > 0) {
		if ( (nread = read(fd, ptr, nleft)) < 0) {
			if (errno == EINTR)
			nread = 0; // call read again.
			else
			return(-1);
		} else if (nread == 0)
		break;  //EOF(End of File) means close socket
		nleft -= nread;
		ptr += nread;
	}
	return(n - nleft); //return the actual read byte 
}
\end{lstlisting}


	\par For \texttt{send()}, a successful return only means that the data has been written to the send buffer successfully, but not necessarily that the other end has received it successfully.
\begin{lstlisting}[numbers=none]
# define MESSAGE_SIZE 10240000
void send_data(FILE *fp, int sockfd, char* query){
	query[MESSAGE_SIZE] = '\0';
	const char *cp;
	cp = query;
	remaining = strlen(query);
	while (remaining) {
		n_written = send(sockfd, cp, remaining, 0);
		fprintf(stdout, "send into buffer %ld \n", n_written);
		if (n_written <= 0) {
			perror("send");
			return;
		}
		remaining -= n_written;
		cp += n_written;
	}
	return;
}		
\end{lstlisting}
	
	
	\par For \texttt{read()}, you need to read the data in a loop and consider exceptional conditions such as EOF.

	\par non-block \texttt{read()}, when no data, it will return immediate, return  EWOULDBLOCK or EAGAIN

	\par non-block \texttt{write()}, it also return, but return value indicate how many has been written. In practical, you don't need to distinguish, just use a loop, but when in block, loop just run once.

	\par Different reaction when we use \texttt{read()} and \texttt{write()} functions. 
 
\begin{tabular}{| p{0.06\textwidth} |p{0.2\textwidth}|p{0.3\textwidth}|p{0.3\textwidth}|}
	\hline
	& buffer in OS & block  & non-block  \\
	\hline
read	&  has data & return immediate & return immediate  \\
	\hline
read	& no data & wait block &  return immediate, EWOULDBLOCK or EAGAIN  \\
	\hline
write	& send buffer avail & all data write to buffer than return & write as many as possible, then return  \\
	\hline
write	& send buffer not avail  & wait it avail & return immediate, EWOULDBLOCK or EAGAIN \\
	\hline
\end{tabular}



	\par Regarding \texttt{read()} and \texttt{write()}, there are several conclusions that you need to grasp:
\begin{itemize}
	\item \texttt{read()} always returns immediately when there is data in the receive buffer, instead of waiting for the application to provide enough data. When the receive buffer is empty, the blocking mode will wait, and the non-blocking mode will immediately return -1 with "EWOULDBLOCK" or "EAGAIN" error.
	
	\item Unlike \texttt{read()}, in the blocking mode, \texttt{write()} only returns when the send buffer can accommodate the output bytes of the application; in the non-blocking mode, it writes as much as it can and returns the actual number of bytes written.
	
	\item There is a special case for the blocking mode of \texttt{write()}. When the other end actively closes the socket, the \texttt{write()} call will return immediately and inform the application of the actual number of bytes written through the return value. If you try to write to such a socket again, it will fail and notify the application with a return value of -1.
	
\end{itemize}


%When recieving buffer has data, read return immediately. When receiving buffer is empty, block will wait, non block will return -1 immediately. and has EWOULDBLOCK or  EAGAIN error
%
%
%different with read, block write only return when sending buffer get all app data. In non-block, write as much as possible, then return the actual number. 
%
%
%in block, write will return immediately when oppsite close the socket.  if you write again to such socket, socket will return failue(-1)



%\begin{itemize}
%	\item muduo::InetAddress wrap sockaddr\_in, it just address, and use INADDR\_ANY on server side. then use port which specified by the user. 
%	
%	\item TcpServer, need a loop and InetAddress.
%\begin{lstlisting}[numbers=none]
%typedef std::map<std::string, TcpConnectionPtr> ConnectionMap;
%
%EventLoop* loop_;  // the acceptor loop
%const std::string name_;
%boost::scoped_ptr<Acceptor> acceptor_; // avoid revealing Acceptor
%ConnectionCallback connectionCallback_;
%MessageCallback messageCallback_;
%bool started_;
%int nextConnId_;  // always in loop thread
%ConnectionMap connections_;
%\end{lstlisting}
%	
%	\item When TcpServer construct in test8.cc, it create a new acceptor. The new acceptor includes 	
%\end{itemize}

\subsubsection{Stream and message format}

	
	
	 This section is about how an application interprets the byte stream. This is where message formatting and parsing become crucial. The message format defines how bytes are organized, ensuring both the sender and receiver transmit and parse data according to a unified format, enabling effective communication. Understanding the message format is crucial for the receiver to read and parse messages accurately. A key consideration in message formatting is determining message boundaries. 
	 
%	 There are two common approaches:
%	 
%	\begin{itemize}
%		\item The sender informs the receiver of the message length beforehand.
%		
%		\item Special characters are used to delineate message boundaries.
%	\end{itemize}
%	These approaches ensure that data transmission is structured and interpretable, facilitating reliable communication between applications.
%	
	

	
	
	\par TCP is stream, so we need to parse the message. There are two ways: 
\begin{itemize}
	

	\item The first one is client and server follow the same format. 
	
\begin{lstlisting}
struct {
	u_int32_t message_length; //length
	u_int32_t message_type; //type.
	char buf[128];
} message;

size_t read_message(int fd, char *buffer, size_t length) {
	u_int32_t msg_length, msg_type;
	int rc;
	rc = readn(fd, (char *) &msg_length, sizeof(u_int32_t));
	if (rc != sizeof(u_int32_t))
		return rc < 0 ? -1 : 0;
	msg_length = ntohl(msg_length);
	rc = readn(fd, (char *) &msg_type, sizeof(msg_type));
	if (rc != sizeof(u_int32_t))
		return rc < 0 ? -1 : 0;
	if (msg_length > length) { //this part is for safety check. 
		return -1;
	}
	rc = readn(fd, buffer, msg_length);
	if (rc != msg_length)
		return rc < 0 ? -1 : 0;
	return rc;
}	
\end{lstlisting}	
	
	
%	\item scatter/gatter IO. and Nagle and delay ACK mechanism. 
%	\begin{lstlisting}
%		struct iovec iov[2];  //This is the important part to understand
%		char *send_one = "hello,";
%		iov[0].iov_base = send_one;
%		iov[0].iov_len = strlen(send_one);
%		iov[1].iov_base = buf;
%		while (fgets(buf, sizeof(buf), stdin) != NULL) {
%			iov[1].iov_len = strlen(buf);
%			int n = htonl(iov[1].iov_len);
%			if (writev(socket_fd, iov, 2) < 0)
%			
%		}
%	\end{lstlisting}
	
	
	\item Another parsing method is using a kind of delimiter. The difference is that \texttt{recv()/send()} work only on socket descriptors and let you specify certain options for the actual operation. Those functions are slightly more specialized (for instance, you can set a flag to ignore SIGPIPE, or to send out-of-band messages...). Functions \texttt{read()/write()} are the universal file descriptor functions working on all descriptors.
	http use return as delimiter. That is why we use \texttt{read\_line} to parse message.
\begin{lstlisting}
int read_line(int fd, char *buf, int size) {
	int i = 0;
	char c = '\0';
	int n;
	while ((i < size - 1) && (c != '\n')) {
		n = recv(fd, &c, 1, 0);
		if (n > 0) {
			if (c == '\r') {
				n = recv(fd, &c, 1, MSG_PEEK);
				if ((n > 0) && (c == '\n'))
				recv(fd, &c, 1, 0);
				else
				c = '\n';
			}
			buf[i] = c;
			i++;
		} else
		c = '\n';
	}
	buf[i] = '\0';
	return (i);
}	
\end{lstlisting}	

	\item The "n" in below functions represents network, "h" represents host, "s" represents short, and "l" represents long, indicating 16-bit and 32-bit integers respectively. These functions can help us flexibly convert between the formats of host and network. When using these functions, we do not need to be concerned about the byte order of the host, as long as we use the given values to convert between network byte order and host byte order.

\begin{lstlisting}
uint16_t htons (uint16_t hostshort)  uint16_t ntohs (uint16_t netshort)
uint32_t htonl (uint32_t hostlong)   uint32_t ntohl (uint32_t netlong)	
\end{lstlisting}

	
\end{itemize}	
	


\subsubsection{Exceptions in practical usage}
	 In TCP connections, by default, it can take up to 7 hours to detect if a connection is still active. Therefore, implementing a keep-alive mechanism at the application level is necessary. This involves two main components: a timer (often implemented using IO-multiplexing) and the use of ping-pong messages.
\begin{itemize}
	\item Timer Implementation: Use IO-multiplexing techniques to manage a timer that periodically sends a keep-alive message to ensure the connection remains active.
	
	\item Ping-Pong Message Type: Define a protocol where both ends of the connection periodically exchange ping (or heartbeat) messages. The recipient responds with a corresponding pong message to confirm the connection is still alive.
\end{itemize}
	
	By combining these elements, applications can maintain active and reliable TCP connections, ensuring timely detection of inactive connections without relying solely on TCP's default timeout settings.
	
	
	\par \textbf{After TCP connection establishment, the ways to perceive the TCP link are very limited, one is reading operation, the other is writing operation.} Next, we will explore how to detect abnormal situations through reading and writing operations, and the corresponding processing methods.
	
	\par There are many reasons that can cause a network interruption. In this case, the TCP program cannot perceive the abnormal information in time unless other devices in the network, such as routers, send an ICMP message indicating that the destination network or host is unreachable. At this time, the read or write call will return an "\textbf{Unreachable}" error. Unfortunately, most of the time this is not the case. Without an ICMP message, the TCP program cannot understand and detect connection abnormalities. If the program is \textbf{blocked} in a read call, then unfortunately, the program cannot recover from the exception. This is obviously very unreasonable, but we can solve this problem by setting a timeout for the read operation. Use setsockopt to set waiting time. Timeouts are for blocking mode. A non-blocking \texttt{recv()} or \texttt{send()} won't block, and therefore cannot get time out error either.
\begin{lstlisting}
struct timeval tv;
tv.tv_sec = 5;
tv.tv_usec = 0;
setsockopt(connfd, SOL_SOCKET, SO_RCVTIMEO, (const char *) &tv, sizeof tv); 
while (1) {
	int nBytes = recv(connfd, buffer, sizeof(buffer), 0);
	if (nBytes == -1) {
		if (errno == EAGAIN || errno == EWOULDBLOCK) {
			printf("read timeout\n");
			onClientTimeout(connfd);
		} else {
			error(1, errno, "error read message");
		}
	} else if (nBytes == 0) { //zero indicates end of file
		error(1, 0, "client closed \n");
	}
	...
}
//Another method is to use multiplexing IO method.
FD_ZERO(&allreads);
FD_SET(socket_fd, &allreads);
for (;;) {
	readmask = allreads;
	int rc = select(socket_fd + 1, &readmask, NULL, NULL, &tv);
	if (rc < 0) {
		error(1, errno, "select failed");
	}
	if (rc == 0) {
		printf("read timeout\n");
		onClientTimeout(socket_fd);
	}
	...
}
\end{lstlisting}	
	
	
	\par If a program initiates a write operation to send a stream of data and subsequently blocks in a read call, the outcome can vary significantly. The Linux TCP protocol stack will continually attempt to send the data stored in the send buffer. After approximately 12 re-transmissions, totaling about 9 minutes, the protocol stack will flag the connection as abnormal. At this point, the blocked read call will return a "TIMEOUT" error message. If the program continues to attempt writing data to this connection, the write operation will immediately fail and trigger a SIGPIPE signal to the application.
	
	
	\par When the system crashes suddenly, such as during a power outage, there is no time for the network connection to send anything out. Unlike killing an application through a system call, no FIN packet is sent out. This situation is very similar to the result of a network interruption. Without an ICMP message, the TCP program can only obtain information about the network connection exception through read and write calls, and a timeout error is a common result.
	
	\par However, there is another situation to consider, which is when the system restarts after crashing. When the retransmitted TCP packets reach the restarted system, since there is no connection data corresponding to the TCP packets in the system, the system will return a RST reset segment. The TCP program can handle the RST through read or write calls. If it is a blocking read call, an error will be returned immediately, and the error message will be "Connection Reset". If it is a write operation, it will also fail immediately, and the application program will be returned a SIGPIPE signal.
	
	\par In all exceptions patterns, receiving a FIN from the opposite side simply indicates that the opposite will no longer send any messages. Despite receiving a FIN, you can still send messages to the opposite side. Once you have finished writing all your data, you can close the socket from your end. The FIN signal will be sent out either by calling \texttt{close()} or \texttt{shutdown()}, or due to an application crash. It's important to note that this behavior differs from a sudden power loss, where network state changes are not gracefully managed by software.
	
	
	\par When the remote end sends a FIN packet, there are two possible scenarios: the remote end explicitly closes the connection by calling close or shutdown, or the remote application crashes and the operating system kernel cleans up the connection on its behalf. From the application's perspective, it is impossible to distinguish between the two scenarios.
	
	\par After a blocking read operation completes reading the expected data, the FIN packet is acknowledged by returning an EOF to complete the notification. At this point, the return value of the read operation is 0. It should be emphasized that the read operation does not return immediately upon receiving the FIN packet. You can think of receiving the FIN packet as placing an EOF marker in the receive buffer, which does not affect the previously received data in the receive buffer.
	
	
	
	\par The below figure illustrate the above various exceptions when you perform socket I/O. 
\begin{itemize}
	\item No FIN from opposite. This happen when connection abnormal or system crashes without sending a FIN signal.  Client perform 1) \textbf{only read} 2) \textbf{read and write} and 3) \textbf{only write}.
	\begin{enumerate}
		\item If the program only performs a read operation and it blocks, it will get stuck waiting indefinitely. Therefore, you should consider using non-blocking mode or manually setting a timeout by using setsockopt.
		
		\item If the program performs write and read, the write operation will put data into the buffer. The TCP protocol stack will attempt to send the data 12 times over about 9 minutes. If unsuccessful, it will mark the connection as abnormal. If the program is blocking on a read operation, read will return a timeout error. 
		
		\item If you only perform write, program persistently attempts to write data to this abnormal connection, the write operation will immediately fail, returning a SIGPIPE signal to the application.
		
		\item Unreachable is indicated by ICMP protocol messages, which are sent by routers. However, it is not guaranteed to occur in every instance of a network issue.
		
		\item When the server restarts and receives a packet, it will send a RST (reset) signal. The client’s read operation will detect this and the system will indicate "Connection reset by peer" on macOS, while on Linux, it will place EOF into the read buffer. Write to this connection will trigger SIGPIPE signal.
	\end{enumerate}
	
	\item Has FIN from opposite:
	\begin{enumerate}
		\item When the server sends a FIN signal, the client’s read operation will not immediately return. Instead, the FIN signal indicates the end of the data stream. The client’s read function will read all remaining data in the buffer and then return 0, indicating EOF (end of file).
		
		\item If the server sends a FIN signal and the client continues to write, the server will respond with a RST signal. The client’s read operation will detect this and the system will indicate "Connection reset by peer" on macOS, while on Linux, it will place EOF into the read buffer.
		
		\item If the client continues to write after receiving a FIN and then a RST from the server, the system will send a SIGPIPE signal to the client, indicating that the connection is broken.
	\end{enumerate} 
\end{itemize}
	\begin{center}
	\includegraphics[width=0.69\linewidth]{pics/net_ex.drawio.png}
	\end{center}
	
	\par In one word, to handle different network abnormalities effectively, you need to combine \texttt{write()} and \texttt{read()} operations while checking for the aforementioned errors. The \texttt{read()} function in network programming returns three possible values: -1, 0, and a positive number. All errors encountered during \texttt{read()} and \texttt{write()} operations are detected and reported through the error handling mechanism. Main types of errors:
		\begin{itemize}
			\item Unreachable: Indicates that the destination is unreachable.
			\item Timeout: Occurs when the operation takes too long and exceeds the specified timeout period.
			\item FIN: Signals that the other side has finished sending data.
			\item RST: Indicates that the connection has been reset.
			\item SIGPIPE: Generated when attempting to write to a socket that has been closed on the other side.
		\end{itemize}	
		


\subsection{close and shutdown}
	 Only close sender can go into TIME\_WAIT state. It's 60 second default. Why do we need TIME\_WAIT? There are two reasons behind it:
	\begin{enumerate}
		\item When client A get FIN, then send out ACK, then wait, if server B didn't get ACK, client A will wait 2MSL to get another FIN from server B.
		
		\item On closing client, if we don't wait, there is another Avatar connection will receive old segment from previous connection.
	\end{enumerate}

	\begin{center}
		\includegraphics[width=0.56\linewidth]{pics/tcp2.png}
	\end{center}

%	\par A TCP connection consumes at least one local port. Generally, ports 32768 to 61000 can be opened, or they can be specified by using the net.ipv4.ip\_local\_port\_range parameter. If there are too many connections in the TIME\_WAIT state, it can lead to the inability to create new connections. In order to resolve this problem, we can use net.ipv4.tcp\_tw\_reuse option, but at the same time, you must set net.ipv4.tcp\_timestamps=1 (default is 1)
	
	\par \texttt{close()} function closes two directions data stream. In input direction, kernel will make this socket unreadable,  any read will return exception. For output, kernel will send all data in buffer to opposite, then send out FIN. Then, any write to this socket will trigger an exception. If opposite doesn't detect you have closed socket and continue send out data, it will receive RST. 

	\par Suppose that a client initiates the connection interruption, which closes the data flow direction from itself to the server. At this time, the client no longer writes data to the server, and after the server reads the client's data, there will be no new packets arriving. However, this does not mean that the TCP connection has been completely closed. It is very likely that the server is processing the final packets from the client, such as accessing the database and storing some data or calculating a value that the client needs. After completing these operations, the server writes the result through the socket to the client, and we say that the state of the socket is "half-closed" at this time. Finally, the server calmly closes the remaining half of the connection and ends this TCP connection mission.

	\par Usually, we just want to close one direction, but \texttt{close()} will close two directions. That is why we need to use \texttt{shutdown()} to close connection selectively. That is gracefully.
	
	
		\begin{center}
		\includegraphics[width=0.72\linewidth]{pics/shutdown}
	\end{center}
	
\begin{lstlisting}
int shutdown(int sockfd, int howto)
//howto can be : SHUT_RD(0), SHUT_WR(1) and SHUT_RDWR(2)

shutdown(socket_fd, 1) //client side, send out FIN to server, but can still read.
for(;;){
	n = read(socket_fd, recv_line, MAXLINE);
}

sleep(5s); //server side code
write() // client use shutdown(SHUT_WR),  so client still can receive.
for(;;){
	n = read(socket_fd, recv_line, MAXLINE);
	if (n==0) exit; //get FIN from client, Send out FIN to client by exit.
}
\end{lstlisting}

	
	

\section{Reactor}

	
%	\item fcntl(sockfd, F\_SETFL, O\_NONBLOCK); you must use non-block and buffer. detail can be found in mudo
	
	 In the context of network programming, non-blocking I/O is particularly useful. When using non-blocking sockets, the \texttt{read()} and \texttt{write()} operations return immediately if no data is available for reading or if the buffer is full for writing, respectively. This allows the application to perform other tasks or check for the completion of the I/O operation later, without being blocked.
	
	\par I/O multiplexing is another technique used to improve the efficiency of I/O operations. It involves using a single thread to handle multiple I/O operations simultaneously, instead of having a separate thread for each I/O operation. This can help to reduce the overhead associated with managing multiple threads and improve the overall performance of the application. I/O multiplexing allows a program to monitor multiple file descriptors to see if any of them are ready for an I/O operation (e.g., reading or writing). This is typically achieved using system calls such as \texttt{select()}, \texttt{poll()}, or \texttt{epoll()} on Linux. 
	
%	The main advantage of I/O multiplexing is that it enables a single thread to efficiently manage multiple I/O streams, reducing the need for multiple threads and the associated context-switching overhead.
	
	\par The core idea of non-blocking I/O is to avoid blocking on \texttt{read()}, \texttt{write()}, or other I/O system calls so that the thread of control can be maximally reused, allowing a single thread to serve multiple socket connections. I/O threads can only block on I/O multiplexing functions such as \texttt{select()}, \texttt{poll()}, or \texttt{epoll\_wait()}. Therefore, application-level buffering is necessary. Buffering involves temporarily storing data in a buffer (a region of memory) before it is written to a storage device or transmitted over a network. Buffering can help improve the performance of I/O operations by reducing the number of times data needs to be transferred between the application and the storage device or network. This model is very common in network programming, especially in implementing high-performance servers. It can greatly improve the throughput and response speed of the application, and reduce the use of system resources.
	
	
	\par The main difference between \texttt{poll()} and \texttt{epoll()} is their scalability.
	\begin{itemize}
		\item \texttt{epoll()} is generally considered to be more scalable than \texttt{poll()} for handling a large number of file descriptors. This is because \texttt{poll()} maintains a list of file descriptors to be monitored, whereas \texttt{epoll()} uses a callback mechanism that is triggered only when an event occurs,
		
		\item \texttt{epoll()} uses a callback mechanism. When executing the add operation of \texttt{epoll\_ctl}, it not only puts the file descriptor in the red-black tree, but also registers a callback function. The kernel will call the callback function when it detects that a file descriptor is readable/writable, and the callback function will place the file descriptor in the ready linkedlist. It reduces the number of system calls and context switches required. 
		
		\item Another difference is that \texttt{poll()} does not support edge-triggered notification, while \texttt{epoll()} does. Edge-triggered notification means that a notification is triggered only when new data is available, as opposed to level-triggered notification, which means that a notification is triggered as long as there is data available to be read. 
		
	\end{itemize}
	
\begin{lstlisting}
#include <iostream>
#include <sys/epoll.h>
#include <unistd.h>

int epoll_fd = epoll_create1(0);  //The first step
if (epoll_fd == -1) {
	std::cerr << "Failed to create epoll file descriptor\n";
	return 1;
}

epoll_event event {};
event.events = EPOLLIN;
event.data.fd = STDIN_FILENO;
//The second step, add fd and what event you want to monitor
if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, STDIN_FILENO, &event) == -1) {
	std::cerr << "Failed to add file descriptor to epoll\n";
	close(epoll_fd);
	return 1;
}

constexpr int MAX_EVENTS = 1;
epoll_event events[MAX_EVENTS];
while (true) {
	//The third step, get the event. 
	int num_events = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
	if (num_events == -1) {
		std::cerr << "Failed to wait for events\n";
		close(epoll_fd);
		return 1;
	}	
	for (int i = 0; i < num_events; i++) {
		if (events[i].data.fd == STDIN_FILENO) {
			char buffer[256];
			std::cin.getline(buffer, 256);
			std::cout << "You typed: " << buffer << "\n";
		}
	}
}
close(epoll_fd);
\end{lstlisting}

	\par The basic data structure behind of \texttt{epoll()} function is illustrated by below figure.
\begin{center}
	\includegraphics[width=0.5\linewidth]{pics/epoll1.png}
\end{center}

%\subsection{multi threads}
%\begin{itemize}
%	\item 
%\end{itemize}

\section{Summary of the chapter}
	 The first section of this chapter covers protocols. You should be familiar with the key 5V concepts: VLAN, Virtual Device, Virtual Machine, VPN, and VXLAN (including overlay and underlay networks).
	 
	 \par For sockets, you’ll need to understand addressing, the three-way handshake, and the four-way termination process. It’s also essential to know the difference between close() and shutdown(), with shutdown() generally recommended for use in applications.
	 
	 \par Basic socket I/O includes understanding blocking versus non-blocking I/O models, as well as recognizing various types of exceptions that may occur.
	 
	 \par Finally, the main server-side architecture patterns are discussed, particularly Non-blocking + I/O multiplexing + buffering.


\chapter{Test}
\section{TDD}
\subsection{Basic principal}

	
	 When doing Test-Driven Development (TDD), you repeat a short cycle of the following steps:
	\begin{itemize}
		\item Write a test (red): Describe the expected feature.
	
		\item Write code to make the test pass (green): The code should be logically correct and suitable. Since it passes the test, and the test represents our expected feature, the code is both what we want and correct.
	
		\item Optimize the design (refactor): Once the basic code is correct, improve the overall codebase. Refactoring is done with confidence because the tests can verify the changes after they are made.
\end{itemize}

	\par The three rules of TDD:
	\begin{itemize}
		\item Write production code only to pass a failing unit test.
		
		\item Write no more of a unit test than sufficient to fail.
		
		\item Write no more production code than necessary to pass the one failing unit test. 
	\end{itemize}

	\par What's the next test? 
	\begin{itemize}
		\item What's the next most logically meaningful behavior?
		
		\item What's the smallest piece of that meaningful behavior you can verify?
		
		\item demonstrates that the current behavior is insufficient.
	\end{itemize}

	\par When writing tests, follow the given-when-then or arrange-act-assert rule:
	
	\begin{itemize}
		\item Given (Arrange): Set up the initial conditions and prepare the necessary context for the test.
		
		\item When (Act): Execute the code or operation being tested.
		
		\item Then (Assert): Verify the outcome to ensure it meets the expected result.
	\end{itemize}
	
	\par When doing TDD, you write the tests first. Strive to keep the granularity of tests small and consistent. Avoid writing tests that cover a wide swath of functionality. The responsibility for such end-to-end tests lies elsewhere, perhaps in the realm of acceptance tests or system tests.
	
	\par \textbf{Test behavior, not methods}. Think of your tests as examples that describe or document the behavior of your system. 
		
	\par If your code makes a test fail and you can't resolve it within 10 minutes, consider discarding your current effort and starting over. However, this is a guideline, not a strict rule. It suggests that if you are stuck on a problem for an extended period, it may be more efficient to start over rather than continuing to try to fix the issue. Nevertheless, it's important to use your judgment and consider the context of the situation. If you feel that you are making progress and can eventually solve the issue, it may be worth continuing to work on it. Ultimately, the decision to discard your current effort and start over should be based on the specific circumstances and your own judgment.
		
	\par For private data,  don't use state-base test, use more behavioral test. For private method, if it's compel, move it to a new class. 
		
	\par Why TDD?
		\begin{itemize}
			\item Before you coding, use a test to describe your requirement, it helps to make sure your requirement is right.
			
			\item Give your tests descriptive names and use them as a documentation.
			
			\item Use your test to make sure your implementation is correct.
			
			\item Write only one or a small number of tests to ensure that you follow small incrementalism.
			
			\item When you develop code, you will not go too wide or too deep (only driven by test).
			
			\item After coding, make sure your refactoring is correct. There are two refactoring methods: avoid duplication and use SRP and small methods to increase expressiveness. For example, you can introduce an abstraction such as a new member function or class.
			
			\item When you write the next test, you are engaging in incremental design.
		
		\end{itemize}
	

\subsection{how to write good tests?}
	 The FIRST mnemonic:
		F for fast,
		I for isolated, 
		R for Repeatable,
		S for Self-verifying,
		T for timely.
		\textbf{Don't write a bunch of tests in advance of any code}. 

	\par Reducing the build time by mock, or running a subset of test by filter. 
	
	\par If you're doing TDD, each of your tests should always fail at least once. A unit test must have at least one assertion, it must have failed at least once in the course of its existence. 
	
	\par You want your tests to be isolated, failing for a single reason. Not only should tests be independent from external production system factors, but they should also be independent from other tests. Any test that uses static data runs the risk of failing because of stale data.
	
	\par Intermittent tests failures are bad news. you maybe use static data or volatility of external service or concurrency, just avoid these elements and make you test \textbf{repeatable}. 
	
	\par The most important declaration of intent is the test's name, which should clarify the context and goal. The names of single-purpose tests stand on their own. 
	
	\par Put bloated construction or irrelevant details into the helper function or fixture. Assert null or exception should be put in different test. Direct use of global I/O streams makes functions or types hard to test:
\begin{lstlisting}
void bad_log (State const& s) { std::cout << ... } //bad

void log (std::ostream& os, State const& s) { os << s.msg; } //good
TEST_CASE("State Log") {
	State s {"expected"};
	std::ostringstream oss;
	log(oss, s);
	CHECK(oss.str() == "expected");
}	
\end{lstlisting}




\section{gtest}

 gtest need to be compiled in your platform. The good news is it's very simple with help of CMake. 
\begin{lstlisting}
download gtest from github.
cd source_dir and mkdir build
cd build and cmake ..
make 
sudo make install.  \\it will copy .h file and lib files to below directory,
                    \\ if you don't specify \usr\local\include and \usr\local\lib
\end{lstlisting}	


\subsection{Basic usage}
	 gtest is independent and repeatable. Debugging a test that succeeds or fails as a result of other tests is a pain. gtest isolates the tests by running each of them on a different object. When a test fails, gtest allows you to run it in isolation for quick debugging.
	
	\par Build test directory put all tests source code parallel with the normal source code. You can use cmake to manage the whole project,  github link: https://github.com/zhaoyan/gtest\_cmake. it has a simple project template, it includes all the necessary cmake files that you can modify. The basic usage is as below. You can add and modify source file and test files, then run make test, That is all need to do. 
\begin{lstlisting}
cd demo && mkdir build && cd build && cmake ../
make // this will build demo and all tests executable. 
make test //run all the test. 
\end{lstlisting}
	
	\par TEST() arguments go from general to specific. The first argument is the name of the test suite, and the second argument is the test’s name within the test suite. Both names must be valid C++ identifiers, and they should not contain any underscores (\_). A test’s full name consists of its containing test suite and its individual name. Tests from different test suites can have the same individual name.
	
\begin{lstlisting}
TEST(TestSuiteName, TestName) { 
	EXPECT_EQ(Factorial(0), 1);
}
\end{lstlisting}
	
	\par You can omit the main function in your code. That give me a good clue. write TEST case in a separate file then use -lgtest\_main to compile it. 
	
\begin{lstlisting}
#include "gtest/gtest.h"
int Add(int i, int j){
	return i+j;
}

TEST(AddTest, Positive){
	EXPECT_EQ(Add(2,3), 4);
}
//Don't need to write main if you don't have specific requirement.
g++ test.cpp -lgtest_main -lgtest -lpthread
\end{lstlisting}

	\par You can also add main function here. Don't put -lpthread in front of -lgtest. Because lgtest still use pthread, if put it in front of -lgtest, it will report compiling error.
\begin{lstlisting}
int main(int argc, char ** argv){
	testing::InitGoogleTest(&argc, argv);
	return RUN_ALL_TESTS();
}
//If you write you onw main use blow to compile. 
g++ test.cpp  -lgtest -lpthread
\end{lstlisting}

	\par You can also use matcher, but you have to include gmock.h and use testing namespace.
\begin{lstlisting}
#include "gtest/gtest.h"
#include "gmock/gmock.h"

using namespace testing;

TEST(AddTest, Positive){
	EXPECT_THAT(Add(2,3), Ge(8)) <<"2+3 is bigger than 8";
} // use << to output customized message. 
\end{lstlisting}

\par Three levels. TestSuiteName and TestName and assert. You can use \texttt{--gtest\_filter} to filter them.

\begin{lstlisting}
TEST(TestSuiteName, TestName) {
	... test body ...
}
//test --gtest_list_tests list all tests.
//test --gtest_filter=Test_Case* to filter 
\end{lstlisting}

	\par Basic filter syntax. 
\begin{lstlisting}
./test --gtest_filter=TestSuiteName.*
./test --gtest_filter=TestSuiteName1.*:TestSuiteName2.*Construct*
\end{lstlisting}

	\par  You disable a test by prepending DISABLED\_ to its name.  Don't check in code with disabled tests unless you have a really good reason.
\begin{lstlisting}
TEST(ATweet, DISABLED_RequireUserNameToStartWithAnAtSign)
\end{lstlisting}

	\par  \texttt{ASSERT\_*} and \texttt{EXPECT\_*} are different, ASSERT will end test once it fails. Use \texttt{ASSERT\_*} when the failure of an assertion indicates a fundamental problem that makes further testing meaningless. There are few kinds of check as follow: 
	
\begin{itemize}
	
	\item EXPECT\_THAT + matcher. Here, \texttt{Contains}, \texttt{SizeIs}, and \texttt{IsEmpty} are matchers provided by Google Test and Google Mock. These matchers provide expressive ways to specify expectations in your tests, enhancing readability and maintainability.
\begin{lstlisting}
#include <gtest/gtest.h>
#include <gmock/gmock.h> // Include Google Mock for matchers

using namespace testing;

// Example function that returns a vector of integers
std::vector<int> getNumbers() {
	return {1, 2, 3, 4, 5};
}

TEST(ExpectThatMatcherTest, ExampleTest) {
	std::vector<int> numbers = getNumbers();
	
	EXPECT_THAT(numbers, Contains(3)); // Verify that it contains the value 3
	EXPECT_THAT(numbers, SizeIs(5));   // Verify that it has a size of 5
	EXPECT_THAT(numbers, Not(IsEmpty())); // Verify that it is not empty
}
\end{lstlisting}
	\item Bool, such as EXPECT\_TRUE(FALSE)
	\item Binary Comparsion EXPECT\_EQ(NE, LT, LE, GT)
	\item String Comparsion and Floating-Point Comarsion.
\begin{lstlisting}
EXPECT_STRNE(str1,str2)
EXPECT_FLOAT_EQ(val1,val2)
\end{lstlisting}
	\item THROW, ANY\_THROW and NO\_THROW.
\begin{lstlisting}
EXPECT_THROW(statement,exception_type)
ASSERT_THROW(statement,exception_type)
\end{lstlisting}	
	\item Predicate Assertions, used for more complex predicates. Verifies that the predicate pred returns true when passed the given values as arguments. \texttt{EXPECT\_PRED} allows you to create custom assertions using a predicate function or functor. This is useful when the existing matchers or assertions provided by gtest do not fully cover your testing needs, or when you need to express assertions in a more customized manner.
\begin{lstlisting}
EXPECT_PRED1(pred,val1)

template <typename T>
bool IsNegative(T x) {
	return x < 0;
}
...
EXPECT_PRED1(IsNegative<int>, -5);  // Must specify type for IsNegative
\end{lstlisting}

	\item More detail can be found in gtest reference Assertions sections.
\end{itemize}

	
	


\subsubsection{Test fixture and matcher}
	 The first step, define a fixture. You typically define the fixture at the beginning of your test files. Derive your class from \texttt{::testing::Test}. Use protected: access to allow access to members from test cases. Implement \texttt{SetUp()} for initialization and \texttt{TearDown()} for cleanup. Declare member variables that will be used across multiple tests.
\begin{lstlisting}
using namespace ::testing  //using namespace here
class QueueTest : public ::testing::Test { //make fixture name describe the context.
protected:
	void SetUp() override {
		q1_.Enqueue(1);
	}
	void TearDown() override {}
	Queue<int> q1_;
};

//The test case name must match the fixture name.
TEST_F(QueueTest, IsEmptyInitially) {
	EXPECT_EQ(q1_.size(), 0);
}

TEST_F(QueueTest, DequeueWorks) {
	int* n = q1_.Dequeue();
	EXPECT_EQ(n, nullptr);
}
\end{lstlisting}

	\par \texttt{TEST\_F} the first name is test fixture name. And each test case are independent. That is to say each test case will run SetUp and call TearDown after finish this test case. So please don't put slow operation into the \texttt{SetUp} and \texttt{TearDown}.

	\par When you need to write per-test set-up and tear-down logic, you have the choice between using the test fixture constructor/destructor or \texttt{SetUp()/TearDown()}. The former is usually preferred, as it has the following benefits:
	
\begin{itemize}
	\item By initializing a member variable in the constructor, we have the option to make it const, which helps prevent accidental changes to its value and makes the tests more obviously correct.
	
	\item In case we need to subclass the test fixture class, the subclass' constructor is guaranteed to call the base class' constructor first, and the subclass' destructor is guaranteed to call the base class' destructor afterward. With \texttt{SetUp()/TearDown()}, a subclass may make the mistake of forgetting to call the base class' \texttt{SetUp()/TearDown()} or call them at the wrong time.
\end{itemize}

	\par Benefits of Using Test Fixtures:
	
\begin{itemize}
	\item Code reuse: Setup and teardown code is shared across multiple tests, reducing duplication.


	\item Isolation: Each test runs in its own controlled environment, preventing interference between tests.
	
	\item Readability: Tests are more concise and focused on specific scenarios, enhancing code readability and maintainability.
	
\end{itemize}

Test fixtures in Google Test help organize and streamline your unit tests, making it easier to manage common setup and teardown operations for groups of test cases.

	
	 A matcher matches a single argument. You can use it inside ON\_CALL() or EXPECT\_CALL(), or use it to validate a value directly using two macros: EXPECT\_THAT and ASSERT\_THAT. The use of matchers makes EXPECT\_THAT a powerful, extensible assertion. 
\begin{lstlisting}
EXPECT_THAT(value1, StartsWith("Hello"));
EXPECT_THAT(value2, MatchesRegex("Line \\d+"));
ASSERT_THAT(value3, AllOf(Gt(5), Lt(10)));
\end{lstlisting}

	\par It includes generic comparison(Eq, Ge, Le, IsNull...), string matchers(EndsWith, ContainsRegex, StrEq...), container matcher(Each, ElementsAre...), member matcher(Field, key), Pointer matcher, composite matcher etc. Detail can be found in gtest reference website. 

	\par Composite Matchers usage. 
\begin{lstlisting}
AllOf
AnyOf
Not
EXPECT_THAT(value1, Allof(Ge(0), Le(100), Ne(50) ) );
\end{lstlisting}

	\par Member matcher usage. See you can use Matcher \texttt{Ge(0)} inside another Matcher \texttt{FieldAre}
\begin{lstlisting}
std::tuple<int, std::string> my_tuple{7, "hello world"};
EXPECT_THAT(my_tuple, FieldsAre( Ge(0), HasSubstr("hello") ) );

struct MyStruct {
	int value = 42;
	std::string greeting = "aloha";
};
MyStruct s;
EXPECT_THAT(s, FieldsAre(42, "aloha"));	
\end{lstlisting}

	\par Matcher can also used in mock. 

\begin{lstlisting}
TEST(TestField, Simple) {
	MockFoo mockFoo;
	Bar bar;
	EXPECT_CALL(mockFoo, get(Field(&Bar::num, Ge(0)))).Times(1);
	mockFoo.get(bar);
} //get must be called once. when you pass bar, bar.num is greater than 0. 

EXPECT_CALL(foo, DoThat(Not(HasSubstr("blah")), NULL));
//DoThat's first parameter not include "blah" substring.
\end{lstlisting}


\subsection{Mock}
When to use mock?
\begin{itemize}
	\item Database Interaction: Instead of connecting to a real database in unit tests, mock the database interface to simulate different query responses and error conditions.
	
	\item External API Calls: Mock HTTP requests and responses in tests that verify how your application handles different API responses without making actual network calls.
	
	\item File System Operations: Mock file read/write operations to test error handling and edge cases without manipulating real files.
\end{itemize}


	 Basic usage of mock:
\begin{enumerate}
	\item Create mock class by using MOCK\_METHOD.
	\item Define expectation by using EXPECT\_CALL.
	\item give mock to test object.
	\item use Assert or test it directly, (It's ok not use assert.)
	
\end{enumerate}
	 
	
\begin{lstlisting}
lass FooInterface {
public:
	virtual ~FooInterface() {}
	virtual std::string getArbitraryString() = 0;
};

class MockFoo: public FooInterface {
public:
	MOCK_METHOD0(getArbitraryString, std::string());
};

class Bar {
public:
	Bar(FooInterface *foo) : m_foo(foo) {
	}	
	std::string getFooString() {
		return m_foo->getArbitraryString();
	}	
private:
	FooInterface *m_foo;
};
\end{lstlisting}

\begin{lstlisting}
using namespace ::testing;  //using namespace here
class FooTest : public Test { //make fixture name describe the context.
protected:
	void SetUp() override {
		mockFoo = new MockFoo();
	}
	void TearDown() override {
		delete mockFoo;     
	}
	MockFoo *mockFoo;
};

TEST_F(FooTest, mock_foo_in_bar) {	
	EXPECT_CALL(*mockFoo, getArbitraryString())
	.Times(1)
	.WillOnce(Return("hello"));
	
	Bar bar{mockFoo};
	std::string s = "hello";
	EXPECT_EQ(bar.getFooString(), s);
}
\end{lstlisting}

	\par Inject mock object into the test object, you can use template, or constructor or class factory. In previous example, we use constructor method to pass into the mock object, because \texttt{Bar(FooInterface*)} use base \texttt{FooInterface*} and our mock object inherit from it. 
\begin{lstlisting}
class Bar {
public:
	Bar(FooInterface *foo) : m_foo(foo) {	
	...
\end{lstlisting}

	\par Below code use template to inject mock object.
\begin{lstlisting}
class CSumWnd : public CBaseWnd{
	private:
	bool MethodA()
}

class MockCSumWnd : public CBaseWnd{
	private:
	MOCK_METHOD(MethodA, bool());
};

template <class CSumWndClass>
class TestedClass {
	//...
	void useSumWnd(const CSumWndClass &a);
	
	private:
	CSumWndClass sumWnd;
};

TestedClass <CSumWnd> obj; // Instantiation of TestedClass in production.
TestedClass <MockCSumWnd> testObj; //Instantiation of TestedClass object in test.	
\end{lstlisting}
	
	
	\par Basic syntax. EXPECT\_CALL is google mock core function. You must remember all the detail information about it.
\begin{lstlisting}
EXPECT_CALL(mock_object, method(matcher1, matcher2, ...))
.With(multi_argument_matcher)
.Times(cardinality)
.InSequence(sequences)
.After(expectations)
.WillOnce(action)
.WillRepeatedly(action)
.RetiresOnSaturation();	
\end{lstlisting}
	
	\par Use more expect, match the nearest one.
\begin{lstlisting}
using ::testing::Return;

EXPECT_CALL(point, GetX())		// #1
.WillOnce(Return(10))
.RetiresOnSaturation();

EXPECT_CALL(point, GetX())		// #2
.WillOnce(Return(20))
.RetiresOnSaturation();

point.GetX()					// match #2, return 20, then #2 retire
point.GetX()					// match #1, return 10
\end{lstlisting}	

	\par You can also customize return value multi times. The first time return 100, the second time returns 150. Then all return 200.
\begin{lstlisting}
EXPECT_CALL(turtle, GetX())
.Times(5)
.WillOnce(Return(100))
.WillOnce(Return(150))
.WillRepeatedly(Return(200));	
\end{lstlisting}

	\par When a mock function takes arguments, we may specify what arguments we are expecting, for example: forward expect receive argument 100. 
\begin{lstlisting}
using ::testing::_;
using ::testing::Ge;
EXPECT_CALL(turtle, Forward(100)); // only match Forward(100)
EXPECT_CALL(turtle, GoTo(Ge(50), _)); // match GoTo(x,y) when x>=50
\end{lstlisting}


	
	 \par When you use dummy, it will follow EXPECT\_CALL sequence. dummy name is irrelevant here.
	
\begin{lstlisting}
using ::testing::InSequence;
using ::testing::Return;
int main(int argc, char **argv) {
	::testing::InitGoogleMock(&argc, argv);
	InSequence dummy; //getSize should be called before getValue
	MockFoo mockFoo;
	EXPECT_CALL(mockFoo, getSize()).WillOnce(Return(1));
	EXPECT_CALL(mockFoo, getValue()).WillOnce(Return(string("Hello World")));
	cout << "First:\t" << mockFoo.getSize() << endl;
	cout << "Second:\t" << mockFoo.getValue() << endl;
}	
\end{lstlisting}


	 \par Below can be used in Times: AnyNumber, AtLeast(n), AtMost(n), Between(m,n).


	 \par Action is used to specify the expected actions of the methods in a mock class, such as what values to return, how to assign values to references or pointers, and so on. The common actions are: Return(value), Assign(\&variable, value), Invoke(f), DoAll(a1, a2, ...). 
	
	\par Return and other side effects. \texttt{getParameter} will return 1, at the same time, point pointer \texttt{a} to pointer \texttt{b}. Please see here we use \texttt{::DoAll(..)}, it's useful in such context. 
\begin{lstlisting}
virtual int getParameter(std::string* name,  std::string* value) = 0
	
TEST(SimpleTest, F1) {
	std::string* a = new std::string("yes");
	std::string* b = new std::string("hello");
	MockIParameter mockIParameter;
	EXPECT_CALL(mockIParameter, getParameter(testing::_, testing::_)).Times(1).\
	WillOnce(testing::DoAll(testing::Assign(&a, b), testing::Return(1)));
	
	mockIParameter.getParameter(a, b);
}
\end{lstlisting}

    \par In MOCK\_METHOD, The first 3 parameters are simply the method declaration, split into 3 parts. The 4th parameter accepts a closed list of qualifiers, which affect the generated method. If all you need to do is to change an output argument, the built-in \texttt{SetArgPointee()} action is convenient. In below example,  when \texttt{mutator.Mutate()} is called, we will assign 5 to the int variable pointed to by argument \texttt{int* value}. 
\begin{lstlisting}
class MockMutator : public Mutator {
	public:
	MOCK_METHOD(void, Mutate, (bool mutate, int* value), (override));
	...
}
...
MockMutator mutator;
EXPECT_CALL(mutator, Mutate(true, _))
.WillOnce(SetArgPointee<1>(5)); //assign 5 to *value in line 3
\end{lstlisting}

	



\section{Catch2}
	
	 In Ubuntu, run below commands, it will install doc, lib and header file to /usr/local
	
\begin{lstlisting}
git clone https://github.com/catchorg/Catch2.git
- cd Catch2
- cmake -Bbuild -H. -DBUILD_TESTING=OFF
- sudo cmake --build build/ --target install
\end{lstlisting}

	\par You also need to build parallel directory just like gtest. You can find cmake and folder structure in https://github.com/zhaoyan/catch2\_cmake.  One thing need to be mention, I am using Catch2 V3 version, so you need to use -std=C++17 switcher when you compile your project. 
	
	
\subsection{Basic usage}
	
	 Just like gtest, Catch supports two assert, they are REQUIRE and CHECK. REQUIRE is used to specify a requirement that must be true for the test case to continue executing. If the requirement fails, the test case is immediately marked as failed and no further test code is executed. CHECK, on the other hand, is used to verify a condition, but if it fails, the test case continues to execute. The test case is only marked as failed when the end of the test case is reached and at least one CHECK has failed.
	
\begin{lstlisting}
CHECK( str == "string value" );
CHECK( thisReturnsTrue() );
REQUIRE( i == 42 );
CHECK(i > 10);

REQUIRE_FALSE( expression );
CHECK_FALSE( expression );

Approx target = Approx(100).epsilon(0.01); //margin, and scale. 
100.0 == target; // true //see the catch documents.
200.0 == target; // false
100.5 == target; // true
\end{lstlisting}

	\par Another example, test case supports tag. That is Catch2 version 2 source code. 
\begin{lstlisting}
// This tells Catch to provide a main() - only do this in one cpp file
#define CATCH_CONFIG_MAIN  
#include "catch.hpp"
 
TEST_CASE( "Factorials are computed", "[factorial]" ) { //[factorial] is tag.
	REQUIRE( Factorial(3) == 6 );    
}
TEST_CASE( "D", "[widget][gadget]" ) { /* ... */ }

./my_test_suite -t [factorial] // run only test cases with the "factorial" tag
./my_test_suite -e [slow] // exclude all test cases with the "slow" tag
\end{lstlisting}

	%\par A section in gtest is simply a fixture. In contrast, 
	
	\par Catch2 supports a class-based fixture mechanism where individual tests are methods on a class, and setup/teardown can be done in the constructor/destructor of the class. However, this mechanism is rarely used in Catch2 because idiomatic Catch2 tests use sections to share setup and teardown code between test code. This can be explained through an example below.
	
\begin{lstlisting}
TEST_CASE( "vectors can be sized and resized", "[vector]" ) {
	std::vector<int> v( 5 );    
	REQUIRE( v.size() == 5 );    
	REQUIRE( v.capacity() >= 5 );  
	  
	SECTION( "resizing bigger changes size and capacity" ) {
		v.resize( 10 );        
		REQUIRE( v.size() == 10 );        
		REQUIRE( v.capacity() >= 10 );    
	}    
	SECTION( "resizing smaller changes size not capacity" ){
		v.resize( 0 );        
		REQUIRE( v.size() == 0 );        
		REQUIRE( v.capacity() >= 5 );    
	}    
}
\end{lstlisting}

	\par Test functions can be nested without limit, forming a tree structure with test cases as root nodes and test functions as inner and leaf nodes. When a leaf test function is run, the entire code from the root test case to the leaf test function is executed. As a result, when multiple test functions (i.e., sections) share common code, that code is executed for each section. This makes it unnecessary to have fixtures with setup and teardown code.

	\par Section can also be nested.
\begin{lstlisting}
SECTION( "reserving bigger changes capacity but not size" ) {
	v.reserve( 10 );
	
	REQUIRE( v.size() == 5 );
	REQUIRE( v.capacity() >= 10 );
	SECTION( "reserving down unused capacity does not change capacity" ) {
		v.reserve( 7 );
		REQUIRE( v.size() == 5 );
		REQUIRE( v.capacity() >= 10 );
	}
}
\end{lstlisting}


%	\item will compile slowly, you can use below tech. use one main file and only include .hpp file. It will only compile once. 
%\begin{lstlisting}
%//catch_main.cpp
%#define CATCH_CONFIG_MAIN
%#define CATCH_CONFIG_FAST_COMPILE
%#include "libraries/Catch/single_include/catch.hpp"
%
%//catch_tests.cpp
%TEST_CASE( "Factorials are computed", "[factorial]" )
%{
%	REQUIRE( Factorial(1) == 1 );
%}
%\end{lstlisting}

	\par BDD, Behaviour-Driven Development  Behind, \texttt{GIVEN}, \texttt{WHEN} and \texttt{THEN} are all sections. catch support BDD, but gtest support mock. gtest is heavier than Catch2.

\begin{lstlisting}
SCENARIO( "vectors can be sized and resized", "[vector]" ) {	
	GIVEN( "A vector with some items" ) {
		std::vector<int> v( 5 );		
		REQUIRE( v.size() == 5 );
		REQUIRE( v.capacity() >= 5 );
		WHEN( "the size is increased" ) {
			v.resize( 10 );
			THEN( "the size and capacity change" ) {
				REQUIRE( v.size() == 10 );
				REQUIRE( v.capacity() >= 10 );
			}
		}
		WHEN( "the size is reduced" ) {
			v.resize( 0 );
			THEN( "the size changes but not capacity" ) {
				REQUIRE( v.size() == 0 );
				REQUIRE( v.capacity() >= 5 );
			}
		}
	}
}
\end{lstlisting}
	\par Catch2 can be a good choice for BDD-style testing in C++ projects, especially if you are looking for a lightweight and easy-to-integrate solution. However, if you need a more feature-rich BDD framework or if your project involves multiple languages or requires extensive collaboration with non-technical stakeholders, you might consider using a dedicated BDD framework alongside Catch2 or looking into other options that better suit those needs. 



\section{Pytest}
\subsection{Basic}

	
	 You need to follow below rules to write pytest.
	\begin{itemize}
		\item Running pytest without mentioning a filename will run all files of format test\_*.py or *\_test.py in the current directory and subdirectories. Pytest automatically identifies those files as test files. We can make pytest run other filenames by explicitly mentioning them.
		
		\item Pytest requires the test function names to start with \texttt{test\_}. Function names which are not of format test* are not considered as test functions by pytest. We cannot explicitly make pytest consider any function not starting with test as a test function.
		
		\item Test class begins with \texttt{Test}, and can't have init method.
\begin{lstlisting}[language=Python]
class TestClass:  
	def test_one(self):  
		x = "this"  
		assert 'h' in x  

	def test_two(self):  
		x = "hello"  
		assert hasattr(x, 'check')
\end{lstlisting}
		
		\item Just use basic assert.
	\end{itemize}

	\par Pytest provides two ways to run the subset of the test suite.
	\begin{enumerate}
		\item Select tests to run based on substring matching of test names.
		\item Select tests groups to run based on the markers applied.
	\end{enumerate}
	
	\par  We have a fixture function named '\texttt{input\_value}' which supplies the input to the tests. To access the fixture function, the tests have to mention the fixture name as an input parameter.
	
\begin{lstlisting}[language=Python]
import pytest

@pytest.fixture
def input_value():
	input = 39
	return input

def test_divisible_by_3(input_value):
	assert input_value % 3 == 0

def test_divisible_by_6(input_value):
	assert input_value % 6 == 0	

pytest -k divisible -v # -k filter test name.
\end{lstlisting}

	\par We can define the fixture functions conftest.py to make them accessible across multiple test files. Create a new file conftest.py and add the below code into it. The fixture method is invoked and the result is returned to the input argument of the test.
\begin{lstlisting}[language=Python]
import pytest

@pytest.fixture 
def input_value():
	input = 39
	return input
\end{lstlisting}

\begin{lstlisting}[language=Python]
import pytest
def test_divisible_by_13(input_value):
	assert input_value % 13 == 0
\end{lstlisting}

	\par In a real scenario, a test suite will have a number of test files and each file will have a bunch of tests. This will lead to a large execution time. To overcome this, pytest provides us with an option to run tests in parallel.

\begin{lstlisting}[language=Python]
pip install pytest-xdist
pytest -n 3
\end{lstlisting}

	\par pytest can be used in conjunction with Behavior Driven Development (BDD) principles. While pytest itself is primarily a framework for writing and executing traditional unit tests in Python, you can extend its capabilities to support BDD-style tests using plugins like pytest-bdd.
\begin{itemize}
	\item Your project directory structure should look something like this:

\begin{lstlisting}
pip install pytest-bdd 

your_project/
	--test_scenario.feature
	--test_steps.py
\end{lstlisting}
	\item You need to define feature file. test\_scenario.feature.
\begin{lstlisting}
Feature: Showing off pytest-bdd  

	Scenario: run a simple test
	Given we have pytest-bdd installed
	When I enter "1" and "2"
	Then pytest-bdd will test it for us!
\end{lstlisting}
	\item Create a Python file where you will implement the steps defined in the feature file. Pay attention to the usage of \texttt{parsers.parse}.
\begin{lstlisting}
from pytest_bdd import scenarios, given, when, then

# Define the path to the feature file
scenarios('test_scenario.feature')

# Implement the steps
@given('we have pytest-bdd installed')
def we_have_pytest_bdd_installed():
	pass  # Here you can add code to check if pytest-bdd is installed

@when(parsers.parse('I enter "{a}" and "{b}"'))
def we_implement_a_test(a, b):
	return a+b; 

@then('pytest-bdd will test it for us!')
def pytest_bdd_will_test_it_for_us():
	assert True  # Here you can add the assertions for your test
\end{lstlisting}

\end{itemize}



\iffalse

\chapter{Embedded}
\section{communication}
	 topology has two main two category:
	\begin{enumerate}
		\item Point-to-Point, One sender, one receiver and can be bidirectional. It can be Simplex, Half Duplex, and Full duplex. The common methods are UART, SPI, USB, Ethernet, Fiber and LVDS. 
		\item Mulit-point, One sender, multiple receivers and can be bidirectional. 
	\end{enumerate}

	\par Common Point-to-point.
	\begin{enumerate}
		\item UART, Asynchronous, TTL-or RS-voltage levels, duplex,
		\item SPI, synchronous, clock, Data out, data in, select singal, can be "multi-point"
		\item USB, Asynchronous, differential, half-duplex,
		\item Ethernet, Differential duplex, 
		\item fiber, duplex,
		\item LVDS, differential, simplex. 
	\end{enumerate}

	\par multi-point
	\begin{enumerate}
		\item I2C, clock controlled by master, single data, open collector, pulled down by any device,  buts arbitration, single ended. 
		
		\item CAN, All are masters, bus arbitration, differential. 
		
		\item RS-285, single master, Poll-response, differential.
	\end{enumerate}

	\par UART and RS-232 are not the same.

UART is responsible for sending and receiving a sequence of bits. At the output of a UART these bits are usually represented by logic level voltages. These bits can become RS-232, RS-422, RS-485, or perhaps some proprietary spec.

RS-232 specifies voltage levels. Notice that some of these voltage levels are negative, and they can also reach ±15V. Larger voltage swing makes RS-232 more resistant to interference (albeit only to some extent).

A microcontroller UART can not generate such voltages levels by itself. This is done with help of an additional component: RS-232 line driver. A classic example of an RS-232 line driver is MAX232. If you go through the datasheet, you'll notice that this IC has a charge pump, which generates ±10V from +5V.

	\par uat is TTL-232, level-shifter for RS-232 comms,  through differential driver/receiver for RS-485 comms
	
	\par SPI, message oriented, synchronous, chip select/latch.  should be combined with differential driver/receiver for off-board peripherals.  Vibration/accelerometer sensor, GPIO expander, Line sensors, stepper motor controllers Cuff pressure sensors, LED controllers(donor indicator)
	
	\par I2C message oriented, synchronous, device have IDs, bus arbitration, open-collector. I2C for ADC. (temperature, pressure, current sensor, voltage sensor,  load cells).
	
	\par CAN, multi-master, asynchronous, bust arbitration, devices have IDs. 

	\par speed comparison
	UART 115,200 bps
	SPI 10M-100M bps
	I2C 100k, 400K, 1M 
	CAN 1M, 5M-8M(CAN FD)
	RS-485 2M-10M
	USB 1.5M~40G
	
	\par shortcoming of each 
	uart: low speed, single ended so you can only run a few feet.
	spi four wires and interfaceing is a little more complex,
	i2c has a limit on the number of devices that you can put on the bus, 
	can the amount of the data isn't big, otherwise, you have to chop it up into little pieces and send sequentially and reassemble it.
	USB is the uttler complexity
	
	\par SPI’s advantages make it appropriate for applications like reading/writing data to an SD card, or any other application where data transfer speed is essential. Conversely, I2C tends to be strong when sending rather simple control signals to multiple peripherals, such as reading from a real-time clock or adjusting the volume of a remote speaker. Users can also utilize SPI for remote speaker control, though SPI’s more complex wiring requirements may make it a less attractive option. As a very simplified rule of thumb, you might say that SPI is a better choice for the small number of peripherals that need to transfer a large amount of data. I2C is the best option if you need to control many peripherals, especially if you are transferring a small amount of data to each one. Your application, of course, may be different, and designers should also consider what devices are available that support only one protocol or the other.
	

\chapter{Commonly Used Libraries}

A complete list of awesome cpp librarys lsit is:  \\
\verb|https://github.com/fffaraz/awesome-cpp#logging|

\section{boost}
\subsection{install}
	
\begin{lstlisting}[]
sudo apt-get install libboost-all-dev
#include <iostream>
#include <boost/array.hpp>

using namespace std;
int main(){
  boost::array<int, 4> arr = {{1,2,3,4}};
    cout << "hi" << arr[0];
      return 0;
      }
g++ -o s b.cpp

\end{lstlisting}

 You can test in compiler explore by using below command. Select boost library to use. Right now, compiler explore supports many library, such as fmt. You can also test fmt functions. 
\begin{lstlisting}
-std=c++20 -I/opt/compiler-explorer/libs/boost_1_82_0 
\end{lstlisting}
	

\subsection{Date and time}
\subsubsection{Date}
	  The "boost:: timer::cpu\_timer" class is used to measure the execution time of a section of code. It also calculates and prints the time taken to read the file using "cpu\_timer".
	"boost::timer::cpu\_timer" provides member functions "stop()" and "resume()",which stop and resume timers.
	
\begin{lstlisting}
 #include <boost/timer/timer.hpp>
#include <iostream>
#include <cmath>
using namespace boost::timer;
int main(){
	cpu_timer timer;
	for (int i = 0; i < 1000000; ++i)
	std::pow(1.234, i);
	std::cout << timer.format() << '\n';
}

//output is 5.713010s wall, 5.709637s user + 0.000000s system = 5.709637s CPU (99.9%)
\end{lstlisting}

	\par Knowing how long a program takes to execute is useful in both test and production environments. It may also be helpful if such timing information is broken down into wall clock time, CPU time spent by the user, and CPU time spent by the operating system servicing user requests.
	
%	\item clock() is defined to tell you how much \textbf{CPU} time is used; using more threads uses more CPU time, sleeping threads use less time.
%	
%	Secondly, not all platforms implement the same behavior; some platforms implement clock() as though it were supposed to give wall-clock time. Thus portable code can't use it for either purpose. The C++11 <chrono> API is much better about these things. The one problem is that <chrono> doesn't have a CPU time clock. If you want wall-clock time then std::chrono::steady\_clock is the best choice; It has a type-safe API and it's defined to advance 'at a steady rate with real time'.
%	
	
	
	\par date\_time library is based on gregorian calendar, it can define \textbf{time point}, \textbf{time duration} and \textbf{time period}. It both supports conversion from/to tm in C and infinite time and invalid time.
\begin{lstlisting}
#include <boost/date_time/gregorian/gregorian.hpp>
using namespace boost::gregorian;
date d1; //invalid date.
date d2(2010,1,1);
cout<<d2.year()<<d2.month()<<d2.day()<<d2.day_of_week()
cout<<d2.day_of_year()<<d2.week_number.
coiut<<to_sinple_string(d2)<<to_ios_string(d2).
date d3(2000, Jan , 1);
date d4(d2);
date d5 = from_string("1999-12-31");
date d6 ( from_string("2015/1/1") );
date d7 = from_undelimited_string("20011118") ;
cout << day_clock::local_day()    << endl;
cout << day_clock::universal_day() << endl;
\end{lstlisting} 

	\par date\_duration is based on days.
\begin{lstlisting}
days dd1(10), dd2(-100), dd3(255);
assert( dd1 > dd2 && dd1 < dd3);
assert( dd1 + dd2 == days(-90));
assert((dd1 + dd3).days() == 265);
assert( dd3 / 5 == days(51));

weeks w(3);
assert(w.days() == 21);
months m(5);
years y(2);
months m2 = y + m;
assert(m2.number_of_months() == 29);
assert((y * 2).number_of_years() == 4);	
\end{lstlisting}

	\par date\_period is left open, right close and includes two data\_points.
\begin{lstlisting}
date_period dp(date(2017,1,1), days(20));

assert(!dp.is_null());
assert(dp.begin().day() == 1);
assert(dp.last().day() == 20);
assert(dp.end().day() == 21);
assert(dp.length().days() == 20);

\end{lstlisting}

\begin{lstlisting}
date_period dp(date(2010,1,1), days(20));
assert(dp.is_after(date(2009,12,1)));
assert(dp.is_before(date(2010,2,1)));
assert(dp.contains(date(2010,1,10)));

date_period dp2(date(2010,1,5), days(10));
assert(dp.contains(dp2));
\end{lstlisting}

	\par date iterator
\begin{lstlisting}
date d(2007,9,28);
day_iterator d_iter(d);

assert(d_iter == d);
++d_iter;
assert(d_iter == date(2007,9,29));

year_iterator y_iter(*d_iter, 10);
assert(y_iter == d + days(1));
++y_iter;
assert(y_iter->year() == 2017);
\end{lstlisting}

\subsubsection{time}

	\par For time, we need to define time\_duration first. The accuracy is micro second.
\begin{lstlisting}
   time_duration td(1,10,30,1000);
assert(td.hours() == 1 && td.minutes() == 10 && td.seconds() == 30);
assert(td.total_seconds() == 1*3600+ 10*60 + 30);

#ifndef BOOST_DATE_TIME_POSIX_TIME_STD_CONFIG
	assert(td.total_milliseconds() == td.total_seconds()*1000 + 1);
	assert(td.fractional_seconds() == 1000);
#endif
\end{lstlisting}

	\par ptime is date + time\_duration. It's the core conception in data\_time library. It use 64 bit(micro) or 96 bit(nano) integral to save time. 
\begin{lstlisting}
ptime p(date(2017,7,7), hours(1));
ptime p1 = time_from_string("2017-7-7 01:00:00");
ptime p2 = from_iso_string("20170707T010000");
ptime p3 = second_clock::local_time();
ptime p4 = microsec_clock::universal_time();
\end{lstlisting}
	
\begin{lstlisting}
ptime p(date(2010,3,20), hours(12)+minutes(30));

date d = p.date();
time_duration td = p.time_of_day();
assert(d.month() == 3 && d.day() == 20);
assert(td.total_seconds() == 12*3600 + 30*60);

ptime p1(date(2010,3,20), hours(12)+minutes(30));
ptime p2 = p1 + hours(3);
\end{lstlisting}

\par time period
\begin{lstlisting}
ptime p(date(2017,1,1),hours(12)) ;
time_period tp1(p, hours(8));
time_period tp2(p + hours(8), hours(1));
assert(tp1.end() == tp2.begin() && tp1.is_adjacent(tp2));
assert(!tp1.intersects(tp2));

tp1.shift(hours(1));
assert(tp1.is_after(p));
assert(tp1.intersects(tp2));

tp2.expand(hours(10));
assert(tp2.contains(p) && tp2.contains(tp1));	
\end{lstlisting}


\subsubsection{summary of date and time}
	 The basice concept is time point, time duration and time period. period in boost is different with period in stl. Peroid in stl is tick accuracy. 
	\par Date is a kind of integral.
	\par Once we have time\_duration, we can define ptime(time point),  then time\_period.
	\par Know the usage of time part, output, format and iterator.
	\par std library have chrono library. It doesn't support date. Detail information can be find in "Time" section in Concurrent chapter.  

\subsection{utility}
	
	 There are two kinds of bool conception and they are not the same pattern. One is meant to re-use objects which are expensive to construct (threads, opengl resources, etc.). The other is meant to manage a lot of small objects, giving you more control than the standard allocator gives. pool in boost mainly deal with the second conception, not the first one. 
	
	\par pool and object\_bool. It is especially useful if many objects of the same size have to be created and destroyed frequently. In this case the required memory can be provided and released quickly.
	\begin{enumerate}
		\item As an allocator, calling malloc()/free() when appropriate. This is the basic pool-allocator usage, it helps to reduce memory fragmentation
		
		\item Construct a ton of temporary objects and don't bother to delete them.	
	\end{enumerate}
	
\begin{lstlisting}
#include <boost/pool/pool.hpp>
using namespace boost;

pool<> pl(sizeof(int));

int *p = static_cast<int*>(pl.malloc());
assert(pl.is_from(p));
pl.free(p);

for (int i = 0;i < 100; ++i){   
	pl.ordered_malloc(10);  
}	
\end{lstlisting}

\begin{lstlisting}
struct demo_class{
public:
	int a,b,c;
	demo_class(int x = 1, int y = 2, int z = 3): a(x),b(y),c(z){}
};
	
object_pool<demo_class> pl;

auto p = pl.malloc();
assert(pl.is_from(p));
assert(p->a!=1 || p->b != 2 || p->c !=3);

p = pl.construct(7, 8, 9);
assert(p->a == 7);

object_pool<string> pls;
for (int i = 0; i < 10 ; ++i){
	string *ps = pls.construct("hello object_pool");
	cout << *ps << endl;
}	
\end{lstlisting}
	\par Two good articles is "boost::pool\_allocator significantly slower than std::allocator" and "what's the difference between boost::pool<>::malloc and boost::pool<>::ordered\_malloc"

	\par noncopyable and ignore\_unused.  You can public or private inherited from noncopyable, it doesn't matter. 
\begin{lstlisting}
#include <boost/noncopyable.hpp>
#include <boost/core/ignore_unused.hpp>
using namespace boost;
class do_not_copy: boost::noncopyable //private inheritance 
{};

do_not_copy d2(d1); //fail
d3 = d1; //fail

int func(int x, int y){
	int i;
	ignore_unused(x, i);  //supress the unuse warning.
	return y;
}
\end{lstlisting}

	\par operator overload can be deducted from basic operator, for example, \texttt{a>=b} can be \texttt{!(a<b)} . \texttt{std::rel\_ops} provide four template operator overload: \texttt{!=, >, <=, >=}.  If you define \texttt{==, <}, then all other four can be implemented automatically. 

	\par Basic usage: 1) It's private inheritance, represents "has a", not "is a" relationship. 2) It use CRTP design pattern to add functions to existing class.  
\begin{lstlisting}
class point : less_than_comparable<point>{
	...
	friend bool operator<(const point& l, const point& r){
		return (l.x*l.x + l.y*l.y +l.z*l.z <
		r.x*r.x + r.y*r.y +r.z*r.z);
	}
}
	
\end{lstlisting}	
	\par Boost library apply the same idea, it supports totally\_ordered, additive, multiplicative, arithmetic, unit\_stoppable. 

\begin{tabular}{|c|c|c|}
	\hline
	name & provide & implement automatically \\
	\hline
	equality\_comparable & ==  & !=  \\
	\hline
	less\_than\_comparable& < & >, <=, >= \\
	\hline
	addable& += &  + \\
	\hline
	subtractable& -=  & - \\
	\hline
	incrementable& prefix ++ & postfix ++  \\
	\hline
	decrementable& prefix -- & postfix -- \\
	\hline
	equivalent& <  & == \\
	\hline
\end{tabular}
 
	\par We can use inheritance chain to combine more operator. Below point class only provide 4 operators, but in the end, we can have 10 operators available. totally\_odered combines equality\_comparableand less\_than\_comparable\textbf{}. additive combines addable and subtractable.
\begin{lstlisting}
class point : totally_ordered<point, additive<point> >{
	....
	friend bool operator<(const point& l, const point& r){
		return (l.x*l.x + l.y*l.y +l.z*l.z <
		r.x*r.x + r.y*r.y +r.z*r.z);
	}
	friend bool operator==(const point& l, const point& r){   
		return r.x == l.x && r.y == l.y && r.z == l.z;  
	}
	point& operator+=(const point& r) {
		x += r.x; y += r.y; z += r.z;
		return *this;
	}
	point& operator-=(const point& r) {
		x -= r.x; y -= r.y; z -= r.z;
		return *this;
	}
};
\end{lstlisting}

	\par Usage of dereference and index operator. It must use public inheritance, because it's not friend member function, such as less than operator. 
\begin{lstlisting}
template<typename T>
class my_smart_ptr: public dereferenceable<my_smart_ptr<T>, T* >{
	T *p;
public:
	...
	T& operator*() const {   
		return *p;  
	}
};

my_smart_ptr<string > p(new string("123"));
assert(p->size() == 3);

//////////////////////////////////////////
template<typename T>
class my_smart_array:
public indexable<my_smart_array<T>, int, T& >{
	T *p;
	// it needs operator + semantic to make indexable.  	
	friend iter_type operator+(const this_type& a, int n){
		return a.p + n;
	}
};

my_smart_array<double> ma(new double[10]);
ma[1] = 1.0;
*(ma + 1) = 2.0;
\end{lstlisting}


\subsection{string}
	 algorithm, prefix i means lowercase sensitive. suffix \_copy is no change to input, suffix \_if need a predict functor. There are five categories. Case conversion, predicates and classification, trimming, find and replace, split and join. 
\begin{lstlisting}
to_upper_copy, to_lower_copy	
starts_with, ends_with contains, equals, all
is_space, is alnum, is_alpha...
trim_left, trim_right, trim
find(replace/erase)_first, find(replace/erase)_last, find(replace/erase)_nth, find(replace/erase)_head, find(replace/erase)_tail
find_all, split
join
\end{lstlisting}
	
\begin{lstlisting}
string str("Power Bomb");

assert(iends_with(str, "bomb"));
assert(starts_with(str, "Pow"));
assert(contains(str, "er"));

string str2 = to_lower_copy(str);
assert(iequals(str, str2));
string str3("power suit");
assert(ilexicographical_compare(str, str3));
assert(all(str2.substr(0, 5), is_lower()));
\end{lstlisting}

	\par is\_punct() is classfied function, it returns functor, so it can be chain together. 
\begin{lstlisting}
trim_copy_if(str2, is_punct() || is_digit() || is_space());
\end{lstlisting}

\begin{lstlisting}
	//trim_left, trim_right, and trim
	
	typedef boost::tokenizer<boost::char_separator<char>> tokenizer;
	std::string s = "Boost C++ Libraries";
	boost::char_separator<char> sep{" "};
	tokenizer tok{s, sep};
	for (const auto &t : tok)
	std::cout << t << '\n';
\end{lstlisting}
	
%	\item xpressive.
%\begin{lstlisting} [mathescape=false]
%	using namespace boost::xpressive;
%	
%	cregex reg = cregex::compile("a.c");
%	
%	assert( regex_match("abc", reg));
%	assert( regex_match("a+c", reg));
%	
%	cregex reg = cregex::compile(
%	R"---(\d{6}(1|2)\d{3}(0|1)\d[0-3]\d\d{3}(X|\d))---",icase);
%	
%	assert( regex_match("999555197001019999", reg));
%	assert( regex_match("99955519700101999X", reg));
%	
%	 string str("readme.txt");
%	
%	sregex start_reg = sregex::compile("^re.*");
%	sregex end_reg = sregex::compile(".*txt$");
%	
%	assert(regex_match(str, start_reg));
%	assert(regex_match(str, end_reg));
%\end{lstlisting}
%
%\begin{lstlisting}[mathescape=false]
%	char str[] = "there is a POWER-suit item";
%	cregex reg =cregex::compile("(power)-(.{4})", icase);
%	
%	assert(regex_search(str, reg));
%	
%	cmatch what;
%	regex_search(str, what, reg);
%	assert(what.size() == 3);
%	
%	cout << what[1] << what[2] << endl;
%\end{lstlisting}
%
%\begin{lstlisting}[mathescape=false]
%	string str("readme.txt");
%	
%	sregex reg1 = sregex::compile("(.*)(me)");
%	sregex reg2 = sregex::compile("(t)(.)(t)");
%	
%	cout << regex_replace(str, reg1, "manual") << endl;
%	cout << regex_replace(str, reg1, "$1you") << endl;
%	
%\end{lstlisting}



\subsection{container}
	 dynamic\_bitset, The dynamic\_bitset class represents a set of bits. It provides accesses to the value of individual bits via an operator[] and provides all of the bitwise operators that one can apply to builtin integers, such as operator\& and operator<<. The number of bits in the set is specified at runtime via a parameter to the constructor of the dynamic\_bitset.
	
	The dynamic\_bitset class is nearly identical to the \texttt{std::bitset} class. The difference is that the size of the dynamic\_bitset (the number of bits) is specified at run-time during the construction of a dynamic\_bitset object, whereas the size of a \texttt{std::bitset} is specified at compile-time through an integer template parameter.
	
	
	\par bimap is a kind of multi\_index\_container. In addition to the classes shown above, Boost.Bimap provides the following: boost::bimaps::unordered\_set\_of, boost::bimaps::unordered\_multiset\_of, boost::bimaps::list\_of, boost::bimaps::vector\_of, and boost::bimaps::unconstrained\_set\_of. Except for boost::bimaps::unconstrained\_set\_of, all of the other container types operate just like their counterparts from the standard library.  Because boost::bimaps::set\_of is used by default for containers of type boost::bimap, the header file boost/bimap/set\_of.hpp does not need to be included explicitly. However, when using other container types, the corresponding header files must be included.

\begin{lstlisting}
typedef boost::bimap<boost::bimaps::unordered_set_of<int>, int> bimap;
bimap animals;
animals.insert({1, 2});
animals.insert({2, 3});
animals.insert({3, 2}); //insert fail, because right is set_of

for (auto it = animals.begin(); it != animals.end(); ++it)
std::cout << it->left << " has " << it->right << " legs\n";
\end{lstlisting}

\begin{lstlisting}
typedef boost::bimap<boost::bimaps::unordered_multiset_of<int>, int> bimap;
bimap animals;
animals.insert({1, 2});
animals.insert({2, 3});
animals.insert({1, 4});
auto const [lb, ub] = animals.left.equal_range(1);
for (auto it = lb; it != ub; ++it)
std::cout << it->first << "  " << it->second << " \n";
\end{lstlisting}
	
\begin{lstlisting}
#include <boost/bimap.hpp>
#include <boost/bimap/unconstrained_set_of.hpp>
#include <boost/bimap/support/lambda.hpp>

typedef boost::bimap<std::string, boost::bimaps::unconstrained_set_of<int>> bimap;
bimap animals;

animals.insert({"cat", 4});
animals.insert({"shark", 0});
animals.insert({"spider", 8});
auto it = animals.left.find("cat");
animals.left.modify_key(it, boost::bimaps::_key = "dog");
std::cout << it->first << '\n';	
\end{lstlisting}
	
	\par multi\_index\_container. Below is example.
	
\begin{figure}
	\centering
	\includegraphics[width=0.5\linewidth]{pics/multi_index}
	\caption{}
	\label{fig:multiindex}
\end{figure}

	
\begin{lstlisting}
#include <boost/multi_index_container.hpp>
#include <boost/multi_index/ordered_index.hpp>
#include <boost/multi_index/hashed_index.hpp>
#include <boost/multi_index/identity.hpp>
#include <boost/multi_index/mem_fun.hpp>
#include <boost/multi_index/member.hpp>

using std::cout;
using std::endl;
//using namespace std; // looks like conflict with std??
using namespace boost::multi_index;

class animal{
	public:
	std::string name1;
	std::string name2;
	bool operator<(const animal &a) const { return name1+name2 < a.name1+a.name2; }
	//const std::string &name() const { return name1; }
};

typedef multi_index_container<
	animal,

	indexed_by<
		ordered_unique< identity<animal>
		>,
	
		hashed_non_unique<
			member<
				animal, std::string, &animal::name1
			>
		>, 
	
		hashed_non_unique<
			member<
				animal, std::string, &animal::name2
			>
		>
	>
> animal_multi;

animal_multi animals;

animals.emplace("cat", "dog");
animals.emplace("shark", "dog");
animals.emplace("cat", "mouse");

//std::cout << animals.begin()->name() << '\n';

std::cout<< "zy="<<animals.size()<< '\n';

const auto &name_index = animals.get<1>();
std::cout << name_index.count("cat") << '\n';

const auto &name_index2 = animals.get<2>();
std::cout << name_index2.count("dog") << '\n';	
\end{lstlisting}	

	\par circular\_buffer. The capacity of the circular buffer is constant and set by you. The capacity doesn’t change automatically when you call a member function such as push\_back(). Only you can change the capacity of the circular buffer. The size of the circular buffer can not exceed the capacity you set. Despite constant capacity, you can call push\_back() as often as you like to insert elements into the circular buffer. If the maximum size has been reached and the circular buffer is full, elements are overwritten. A circular buffer makes sense when the amount of available memory is limited, and you need to prevent a container from growing arbitrarily big. Another example is continuous data flow where old data becomes irrelevant as new data becomes available. Memory is automatically reused by overwriting old data.

\begin{lstlisting}
typedef boost::circular_buffer<int> circular_buffer;
circular_buffer cb{3};

cb.push_back(0);
cb.push_back(1);
cb.push_back(2);
cb.push_back(3);

std::cout << std::boolalpha << cb.is_linearized() << '\n';

circular_buffer::array_range ar1, ar2;

ar1 = cb.array_one();
ar2 = cb.array_two();
std::cout << ar1.second << ";" << ar2.second << '\n';

for (int i : cb)
std::cout << i << '\n';

cb.linearize();

ar1 = cb.array_one();
ar2 = cb.array_two();
std::cout << ar1.second << ";" << ar2.second << '\n';		
\end{lstlisting}

	\par multi\_array. a library that simplifies using arrays with multiple dimensions. The most important advantage is that multidimensional arrays can be used like containers from the standard library. For example, there are member functions, such as begin() and end(), that let you access elements in multidimensional arrays through iterators. Iterators are easier to use than the pointers normally used with C arrays, especially with arrays that have many dimensions.

\begin{lstlisting}
#include <boost/multi_array.hpp>
boost::multi_array<char, 2> a{boost::extents[2][6]};

typedef boost::multi_array<char, 2>::array_view<1>::type array_view;
typedef boost::multi_array_types::index_range range;
array_view view = a[boost::indices[0][range{0, 5}]];

std::memcpy(view.origin(), "tsooB", 6);
std::reverse(view.begin(), view.end());	
std::cout << view.origin() << '\n';
boost::multi_array<char, 2>::reference subarray = a[1];
std::memcpy(subarray.origin(), "C++", 4);

std::cout << subarray.origin() << '\n';		
\end{lstlisting}

\par property\_tree. provides a tree structure to store key/value pairs. Tree structure means that a trunk exists with numerous branches that have numerous twigs. A file system is a good example of a tree structure. File systems have a root directory with subdirectories that themselves can have subdirectories and so on.

\begin{lstlisting}
{
	"conf":
	{
		"gui": 1,
		"theme": "matrix",
		"urls":
		{
			"url": "http://www.url1.com"
		},
		"clock_style": 24
	}
}	

#include <boost/property_tree/json_parser.hpp>
ptree pt;
read_json("conf.json", pt);

cout << pt.get<string>("conf.theme") << endl;
cout << pt.get<int>("conf.clock_style") << endl;
cout << pt.get<long>("conf.gui")<< endl;
cout << pt.get("conf.no_prop", 100)<< endl; 

for (auto& x : pt.get_child("conf.urls")){
	cout <<  x.second.data() << ",";    
}	
\end{lstlisting}



\subsection{graph}
	
	\begin{figure}
		\centering
		\includegraphics[width=0.7\linewidth]{pics/bcl}
		\caption{}
		\label{fig:bcl}
	\end{figure}
	

	 There are three ways in which the STL is generic.
\begin{enumerate}
	\item Algorithm/Data-Structure Interoperability. First, each algorithm is written in a data-structure neutral way, allowing a single template function to operate on many different classes of containers. The concept of an iterator is the key ingredient in this decoupling of algorithms and data-structures. The impact of this technique is a reduction in the STL's code size from O(M*N) to O(M+N), where M is the number of algorithms and N is the number of containers. 
	
	\item Extension through Function Objects. The second way that STL is generic is that its algorithms and containers are extensible. The user can adapt and customize the STL through the use of function objects. This flexibility is what makes STL such a great tool for solving real-world problems. Each programming problem brings its own set of entities and interactions that must be modeled. Function objects provide a mechanism for extending the STL to handle the specifics of each problem domain.
	
	\item Element Type Parameterization. The third way that STL is generic is that its containers are parameterized on the element type. Though hugely important, this is perhaps the least “interesting” way in which STL is generic. Generic programming is often summarized by a brief description of parameterized lists such as \texttt{std::list<T>}. This hardly scratches the surface!
	
\end{enumerate}


Like the STL, there are three ways in which the BGL is generic.

Algorithm/Data-Structure Interoperability
First, the graph algorithms of the BGL are written to an interface that abstracts away the details of the particular graph data-structure. Like the STL, the BGL uses iterators to define the interface for data-structure traversal. There are three distinct graph traversal patterns: traversal of all vertices in the graph, through all of the edges, and along the adjacency structure of the graph (from a vertex to each of its neighbors). There are separate iterators for each pattern of traversal.

This generic interface allows template functions such as breadth\_first\_search() to work on a large variety of graph data-structures, from graphs implemented with pointer-linked nodes to graphs encoded in arrays. Fortran. This severely limits the reuse of their graph algorithms.

In contrast, custom-made (or even legacy) graph structures can be used as-is with the generic graph algorithms of the BGL, using external adaptation (see Section How to Convert Existing Graphs to the BGL). External adaptation wraps a new interface around a data-structure without copying and without placing the data inside adaptor objects. The BGL interface was carefully designed to make this adaptation easy. To demonstrate this, we have built interfacing code for using a variety of graph structures (LEDA graphs, Stanford GraphBase graphs, and even Fortran-style arrays) in BGL graph algorithms.

Extension through Visitors
Second, the graph algorithms of the BGL are extensible. The BGL introduces the notion of a visitor, which is just a function object with multiple methods. In graph algorithms, there are often several key “event points” at which it is useful to insert user-defined operations. The visitor object has a different method that is invoked at each event point. The particular event points and corresponding visitor methods depend on the particular algorithm. They often include methods like start\_vertex(), discover\_vertex(), examine\_edge(), tree\_edge(), and finish\_vertex().

Vertex and Edge Property Multi-Parameterization
The third way that the BGL is generic is analogous to the parameterization of the element-type in STL containers, though again the story is a bit more complicated for graphs. We need to associate values (called “properties”) with both the vertices and the edges of the graph. In addition, it will often be necessary to associate multiple properties with each vertex and edge; this is what we mean by multi-parameterization. The STL std::list<T> class has a parameter T for its element type. Similarly, BGL graph classes have template parameters for vertex and edge “properties”. A property specifies the parameterized type of the property and also assigns an identifying tag to the property. This tag is used to distinguish between the multiple properties which an edge or vertex may have. A property value that is attached to a particular vertex or edge can be obtained via a property map. There is a separate property map for each property.

Traditional graph libraries and graph structures fall down when it comes to the parameterization of graph properties. This is one of the primary reasons that graph data-structures must be custom-built for applications. The parameterization of properties in the BGL graph classes makes them well suited for re-use.
	
	\par The adjacency\_list class is the general purpose “swiss army knife” of graph classes. It is highly parameterized so that it can be optimized for different situations: the graph is directed or undirected, allow or disallow parallel edges, efficient access to just the out-edges or also to the in-edges, fast vertex insertion and removal at the cost of extra space overhead, etc.
	
	\par build a graph with adjacency\_list.
	\begin{lstlisting}
		typedef boost::adjacency_list<boost::setS, boost::vecS,
		boost::undirectedS> graph;
		graph g;
		
		boost::adjacency_list<>::vertex_descriptor v1 = boost::add_vertex(g);
		boost::adjacency_list<>::vertex_descriptor v2 = boost::add_vertex(g);
		boost::add_vertex(g);
		boost::add_vertex(g);
		
		std::pair<graph::edge_descriptor, bool> p =
		boost::add_edge(v1, v2, g);
		std::cout.setf(std::ios::boolalpha);
		std::cout << p.second << '\n';
		
		p = boost::add_edge(v1, v2, g);
		std::cout << p.second << '\n';
		
		p = boost::add_edge(v2, v1, g);
		std::cout << p.second << '\n';
		
		std::pair<graph::edge_iterator,
		graph::edge_iterator> es = boost::edges(g);
		
		std::copy(es.first, es.second,
		std::ostream_iterator<graph::edge_descriptor>{std::cout, "\n"});
	\end{lstlisting}
	
	\par Dijkstra's Shortest Paths, Bellman-Ford Shortest Paths, Johnson's All-Pairs Shortest Paths
	Kruskal's Minimum Spanning Tree, Prim's Minimum Spanning Tree, Topological Sort, Transpose, Sequential Vertex Coloring, etc.. more can be google boost graph. They are generic and very flexible. However, it’s not always immediately clear how they should be used.
	
	\par breadth\_first\_search. on\_tree\_edge is event, distances.begin is property map. these two build record\_distance. A visitor created by boost::record\_distances() is algorithm independent, so you can use boost::record\_distances() with other algorithms. An adapter is used to bind an algorithm and a visitor. it calls boost::make\_bfs\_visitor() to create this adapter. This helper function returns a visitor as expected by the algorithm boost::breadth\_first\_search(). The adapter returned by boost::make\_bfs\_visitor() can’t be passed directly to the algorithm boost::breadth\_first\_search(). It has to be wrapped with boost::visitor() and then passed as a third parameter. The basice idea here is: algorithm need \textbf{visitor},  we can use \textbf{property map} and \textbf{event} to build \textbf{visitor}. 
	 
\begin{lstlisting}
enum { topLeft, topRight, bottomRight, bottomLeft };

std::array<std::pair<int, int>, 4> edges{{
		std::make_pair(topLeft, topRight),
		std::make_pair(topRight, bottomRight),
		std::make_pair(bottomRight, bottomLeft),
		std::make_pair(bottomLeft, topLeft)
}};

typedef boost::adjacency_list<boost::setS, boost::vecS,
boost::undirectedS> graph;
graph g{edges.begin(), edges.end(), 4};

boost::array<int, 4> distances{{0}};

boost::breadth_first_search(g, topLeft,
boost::visitor(
boost::make_bfs_visitor(
boost::record_distances(distances.begin(),
boost::on_tree_edge{}))));


std::copy(distances.begin(), distances.end(),
std::ostream_iterator<int>{std::cout, "\n"});
\end{lstlisting}
	
	\par dijkstra\_shortest\_paths
\begin{lstlisting}
enum { topLeft, topRight, bottomRight, bottomLeft };

std::array<std::pair<int, int>, 4> edges{{
		std::make_pair(topLeft, topRight),
		std::make_pair(topRight, bottomRight),
		std::make_pair(bottomRight, bottomLeft),
		std::make_pair(bottomLeft, topLeft)
}};

typedef boost::adjacency_list<boost::listS, boost::vecS,
boost::undirectedS, boost::no_property,
boost::property<boost::edge_weight_t, int>> graph;

std::array<int, 4> weights{{2, 1, 1, 1}};

graph g{edges.begin(), edges.end(), weights.begin(), 4};

boost::array<int, 4> directions;
boost::dijkstra_shortest_paths(g, bottomRight,
boost::predecessor_map(directions.begin()));

int p = topLeft;
while (p != bottomRight)
{
	std::cout << p << '\n';
	p = directions[p];
}
std::cout << p << '\n';
\end{lstlisting}




\subsection{math}
	 constants, pi, e, root\_two, root\_three, ln\_two. there are 100 digit precision. 
\begin{lstlisting}
	cout << setprecision(64);
	
	auto a = float_constants::pi * 2 * 2;
	cout << "area \t\t= " << a << endl;
	
	using namespace double_constants;
	
	auto x = root_two * root_three;
	cout << "root 2 * 3 \t= " << x << endl;
	
	cout << "root pi \t= " << root_pi << endl;
	cout << "pi pow e \t= " << pi_pow_e << endl;
\end{lstlisting}
	\par rational
\begin{lstlisting}
rational<int> a;
rational<int> b(20);
rational<int> c(31415, 10000);

rational<int> r;
r = 0x31;
r.assign(7, 8);
\end{lstlisting}
	

	\par ratio, this is important concept. std has the same conception. Its usage is like a math.constants. and it is a type. so you need to use typedef and :: symbol to access its member. You can pass ratio as a template type argument, which is what std::chrono::duration do
\begin{lstlisting}
 typedef ratio<1, 2> half;

assert(half::num == 1);
assert(half::den == 2);

#if 0
auto v = half::value();
cout << v << endl;
assert(v * 2 == 1);

half frac;
assert(frac().numerator() == frac.num);

typedef ratio<2, 4> two_fourth;
cout << two_fourth()() << endl;
assert(half::value() == two_fourth::value());
#endif

typedef ratio<12> dozen;
assert(2 * dozen::num == 24);
\end{lstlisting}

	\par crc
\begin{lstlisting}
crc_32_type crc32;

cout << hex;
cout << crc32.checksum() << endl;

crc32.process_byte('a');
cout << crc32.checksum() << endl;

crc32.process_bytes("1234567890", 10);
cout << crc32.checksum() << endl;

char szCh[] = "1234567890";
crc32.reset();

crc32.process_block(szCh, szCh + 10);
cout << crc32.checksum() << endl;
\end{lstlisting}


\subsection{system}
	 Filesystem has been merged into C++17. You need to include header file and namespace. 
\begin{lstlisting}
#include <filesystem>
namespace fs = std::filesystem
cout<<fs::current_path().root_name()<<endl;
\end{lstlisting}

	\par boost::filesystem::path is the central class in Boost library. \textbf{None} of the constructors of boost::filesystem::path validate paths or check whether the given file or directory exists.
	
	\begin{tabular}{|c|c|}
		\hline
	category	& API  \\
		\hline
		path &  \\
		\hline
		status,  & file\_status.type/permission, status,   \\
		\hline
		attribute & file\_size, last\_write\_time, space \\
		\hline
		manipulate & cretate\_directory, rename, remove, copy\_file, create\_symlink \\
		\hline
		iterator	& )recursive\_)directory\_iterator \\
		\hline
	\end{tabular}
		
\begin{lstlisting}
path p("/usr/local/include/xxx.hpp");

cout << p.string() << endl;

cout << p.parent_path() << endl;
cout << p.stem() << endl;
cout << p.filename() << endl;
cout << p.extension() << endl;

assert(p.is_absolute());
assert(system_complete(p).is_absolute());

cout << p.root_name() << endl;
cout << p.root_directory() << endl;
cout << p.root_path() << endl;

assert(!p.has_root_name());
assert( p.has_root_path());
assert( p.has_parent_path());

cout << p.replace_extension() << endl;
cout << p.replace_extension("hxx") << endl;
cout << p.remove_filename() << endl;
\end{lstlisting}

\par Usage of status function and file\_status class. 
\begin{lstlisting}
path p{"C:\\"};
try{
	file_status s = status(p);
	std::cout << std::boolalpha << is_directory(s) << '\n';
}
catch (filesystem_error &e){
	std::cerr << e.what() << '\n';
}	
\end{lstlisting}


\begin{lstlisting}
path p = current_path();
directory_iterator it{p};
while (it != directory_iterator{})
std::cout << *it++ << '\n';
\end{lstlisting}


	\par boost::filesystem::directory\_iterator is initialized with a path to retrieve an iterator pointing to the beginning of a directory. To retrieve the end of a directory, the class must be instantiated with the default constructor. Entries can be created or deleted while iterating without invalidating the iterator. However, whether changes become visible during the iteration is undefined. For example, the iterator might not point to newly created files. To ensure that all current entries are accessible, restart the iteration. To recursively iterate over a directory and subdirectories, Boost.Filesystem provides the iterator boost::filesystem::recursive\_directory\_iterator.

\begin{lstlisting}
vector<path> find_files(const path& dir, const string& filename){
	static xpressive::sregex_compiler rc;
	if (!rc[filename].regex_id()){
		string str = replace_all_copy(
		replace_all_copy(filename, ".", "\\."),
		"*", ".*");
		rc[filename] = rc.compile(str);
	}
	
	typedef vector<path> result_type;
	result_type v;
	
	if (!exists(dir) || !is_directory(dir))
	{   return v;    }
	
	rd_iterator end;
	for (rd_iterator pos(dir);pos != end; ++pos){
		if(!is_directory(*pos) &&
		regex_match(pos->path().filename().string(), rc[filename]))
		{
			v.push_back(pos->path());
		}
	}
	return v;
}	
\end{lstlisting}
	
	\par program\_options.
	
\begin{enumerate}
	\item Define command-line options. You give them names and specify which ones can be set to a value. If a command-line option is parsed as a key/value pair, you also set the type of the value – for example, whether it is a string or a number.
	
	\item Use a parser to evaluate the command line. You get the command line from the two parameters of main(), which are usually called argc and argv.
	
	\item Store the command-line options evaluated by the parser. Boost.ProgramOptions offers a class derived from std::map that saves command-line options as name/value pairs. Afterwards, you can check which options have been stored and what their values are.
\end{enumerate}

	\par Use the class boost::program\_options::options\_description to describe command-line options. An object of this type can be written to a stream such as std::cout to display an overview of available command-line options. The string passed to the constructor gives the overview a name that acts as a title for the command-line options.

	\par boost::program\_options::options\_description defines a member function add() that expects a parameter of type boost::program\_options::option\_description. You call this function to describe each command-line option. Instead of calling this function for every command-line option, Example 63.1 calls the member function add\_options(), which makes that task easier.

	\par add\_options() returns a proxy object representing an object of type boost::program\_options::options\_description. The type of the proxy object doesn’t matter. It’s more interesting that the proxy object simplifies defining many command-line options. It uses the overloaded operator operator(), which you can call to pass the required data to define a command-line option. This operator returns a reference to the same proxy object, which allows you to call operator() multiple times.

\begin{lstlisting}
using namespace boost::program_options;
void on_age(int age){  //call back function
	std::cout << "On age: " << age << '\n';
}

int main(int argc, const char *argv[]){
	try{
		options_description desc{"Options"};
		desc.add_options()
		("help,h", "Help screen")
		("pi", value<float>()->default_value(3.14f), "Pi")
		("age", value<int>()->notifier(on_age), "Age");
		
		variables_map vm;
		store(parse_command_line(argc, argv, desc), vm);
		notify(vm);
		
		if (vm.count("help"))
		std::cout << desc << '\n';
		else if (vm.count("age"))
		std::cout << "Age: " << vm["age"].as<int>() << '\n';
		else if (vm.count("pi"))
		std::cout << "Pi: " << vm["pi"].as<float>() << '\n';
	}
	catch (const error &ex){
		std::cerr << ex.what() << '\n';
	}
}
\end{lstlisting}

	\par More specifically, Boost.DateTime is about, well, dates and times. It has lots of functions for formatting dates for display according to locales and various other things. But there are also functions for getting dates and times, as well as operating on them.
	
	Boost.Chrono seems focused on dealing with time intervals. It has no measurement higher than "hours", and it has no concept of date at all. Indeed, moments in time are only supported as offsets to a particular moment in time (time since process started, time since a fixed "epoch" like Jan 1, 1970, etc).
	
	The two seem complementary, rather than competing, though there is some overlap. There is a lot that DateTime does that Chrono doesn't, and there are some things that Chrono does that DateTime doesn't. Sadly, there doesn't seem to be any interop between the two, so one will have to hand-convert Chrono's durations into DateType's equivalent.
	
	\par time\_point has close relationship with clock,  it must be generated by a clock, and marks the all the time since epoch.
\begin{lstlisting}
auto tp1 = system_clock::now();
cout << tp1 << endl;

auto d = tp1.time_since_epoch();
cout << duration_cast<hours>(d) << endl;
cout << duration_cast<day>(d) << endl;

auto tp2 = tp1 +minutes(1);
cout << tp2 << endl;
\end{lstlisting}

	\par A good article is "Difference between steady\_clock vs system\_clock?" in stackoverflow.
	
	


\subsection{signals2}
	 Implements the signal/slot concept. One or multiple functions – called slots which are linked with an object that can emit a signal. Every time the signal is emitted, the linked functions are called. The signal/slot concept can be useful when, for example, developing applications with graphical user interfaces. Buttons can be modelled so they emit a signal when a user clicks on them. They can support links to many functions to handle user input. That way it is possible to process events flexibly. std::function can also be used for event handling. One crucial difference between std::function and Boost.Signals2, is that Boost.Signals2 can associate more than one event handler with a single event. Therefore, Boost.Signals2 is better for supporting event-driven development and should be the first choice whenever events need to be handled.
	
\begin{lstlisting}
void slots1(){
	cout << "slot1 called" << endl;
}
void slots2(){
	cout << "slot2 called" << endl;
}

signal<void()> sig;
sig.connect(&slots1);
sig.connect(&slots2, at_front);

sig(); //trigger 
\end{lstlisting}

\subsection{asio}
	 If the run() method is called on an object of type boost::asio::io\_service, the associated handlers are invoked on the same thread. By using multiple threads, an application can call multiple run() methods simultaneously. Once an asynchronous operation has finished, the corresponding I/O service will then execute the handler on the corresponding thread. If a second operation has finished shortly after the first, the I/O service can execute the handler on a different thread without needing to wait for the first handler to terminate.
	
	An alternative approach is to have a pool of threads calling io\_service::run(). However, as this allows handlers to execute concurrently, we need a method of synchronisation when handlers might be accessing a shared, thread-unsafe resource.
\begin{lstlisting}
io_service ioservice;

steady_timer timer1{ioservice, std::chrono::seconds{3}};
timer1.async_wait([](const boost::system::error_code &ec)
{ std::cout << "3 sec\n"; });

steady_timer timer2{ioservice, std::chrono::seconds{3}};
timer2.async_wait([](const boost::system::error_code &ec)
{ std::cout << "3 sec\n"; });

std::thread thread1{[&ioservice](){ ioservice.run(); }};
std::thread thread2{[&ioservice](){ ioservice.run(); }};
thread1.join();
thread2.join();	
\end{lstlisting}
	


\section{JsonCpp}

\subsection{install}
     sudo apt-get install libjsoncpp-dev
\begin{lstlisting}[]
//profile.json
{
    "firstname":"Yan",
    "lastname":"Zhao"
}

//profile.cpp
#include <iostream>
#include <fstream>
#include <jsoncpp/json/json.h>

using namespace std;

int main(){
    ifstream ifs("profile.json");
    Json::Reader reader;
    Json::Value obj;
    reader.parse(ifs,obj);
    cout<<obj["lastname"].asString()<<endl;
    cout<<obj["firstname"].asString()<<endl;
}
//compile and test with below command;
g++ profile.cpp -o profile -ljsoncpp
./profile
\end{lstlisting}

\section{Curl}
\subsection{install}
	 sudo apt-get install libssl-dev
	\par download Curl source from web.
	\par cd source\_dir and mkdir build
	\par cd buil and cmake ..
	\par make 
	\par sudo make install. it will copy .h file and lib files to 
	$backslash$usr$backslash$local$backslash$include and $backslash$usr$backslash$local$backslash$lib
	\par sudo ldconfig, that is to make you exe can find .so file. 
	\par try below code to see if you intall properly.
	\begin{lstlisting}[]
		#include <iostream>
		#include <string>
		#include <curl/curl.h>
		static size_t WriteCallback(void *contents, size_t size, size_t nmemb, void *userp)
		{
			((std::string*)userp)->append((char*)contents, size * nmemb);
			return size * nmemb;
		}
		
		int main(void)
		{
			CURL *curl;
			CURLcode res;
			std::string readBuffer;
			
			curl = curl_easy_init();
			if(curl) {
				curl_easy_setopt(curl, CURLOPT_URL, "http://www.google.com");
				curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
				curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);
				res = curl_easy_perform(curl);
				curl_easy_cleanup(curl);
				
				std::cout << readBuffer << std::endl;
			}
			return 0;
		}
		//compile and test with below commands.
		g++ source -o curlapp -lcurl 
		./curlapp
	\end{lstlisting}
	



\fi

\chapter{Modern C++}
\section{Modern C++ coding style}
\subsection{Principle, naming}

	 It is important to remain consistent with your coding and name style and avoid changing it frequently. Don't sweat the small stuff, such as how many spaces to indent, whether to use spaces or tabs, or the necessity of comments, etc. 
	
	\par The mainstream style involves using descriptive names instead of comments. Code is typically read more often than it is written. By using well-chosen function and variable names, the need for comments can be minimized. Here are some guidelines to follow:
	\begin{itemize}
		\item Utilize descriptive variable names: Choose names that clearly convey the purpose and meaning of the variable. It helps enhance code clarity and maintainability.
		
		\item Use small functions with descriptive names to encapsulate logic: Breaking down code into smaller functions with meaningful names improves readability and understanding. Don't worry too much about performance. The compiler will inline small functions automatically.
		
		\item Avoid using abbreviated names unless they are widely recognized, such as CPU and TCP/IP.
	\end{itemize}
	
	
	\par A good example of using small functions is shown below. By turning the predicate loop into a predicate function, the code becomes clean and easy to understand.
	
\begin{lstlisting}[frame=single, language=c++]
for(v.begin()....){   //bad style
	if(it->IsSth){
		flag = true; 
		break;
	}
}
if(flag){
...do something
}


if(isHasSth()){ //change line 1~6 to a funciton isHasSth, this is good style.		
...do something
} 
\end{lstlisting}		
	
	\par You don't need to use type indicators for all variables. Hungarian notation does not provide any benefits for object-oriented languages, particularly since it cannot be used in generic programming. However, for certain generic concepts like references, pointers, and STL containers, you can use it, such as \texttt{ptr\_map\_dic}. Modern IDEs, such as Visual Studio and Understand, offer pop-up messages when you hover over a variable, making descriptive variable names more important than type indicators.
	
	\begin{itemize}
		\item Use UpperCamelCase for classes, structures, enumerations, typedefs, and constants.
		
		\item Use lowerCamelCase and verbs for functions, such as \texttt{getSth} and \texttt{doSth}.
		
		\item Use lowercase and underscores and nouns for variable and parameter names. This makes long variable names easier to read, such as \texttt{sth\_for\_dinner}.
		
		\item Use upper-case and underscores for pre-processor macros (e.g., \texttt{\#define MAX\_SIZE 100}).
		
		\item For global scope, use \texttt{g\_} prefix.
		
		\item For member variable in class, use tailing underscore. Why? 
		\begin{enumerate}
			\item A prefix underscore is typically used for reserved words. By using a trailing underscore, you avoid potential conflicts with these reserved words.
			
			\item When you use a trailing underscore, it improves auto-completion functionality. For instance, if you have a variable named \texttt{test\_}, it will appear when you type the letter 't'. However, for \texttt{\_test}, you would have to type \texttt{"\_t"}—two characters—and the list of suggestions would likely be longer than for \texttt{test\_}.
		\end{enumerate}
		
		\item For member variables in structs, use ordinary variable names.
		
		\item For constant name, use the \texttt{k\_} prefix and UpperCamelCase (e.g., \texttt{kConstantName}).
		
		
		
		\item Use \texttt{other} or \texttt{rhs} as names for copy constructors and assignment operators.
		
		\item The prefix \texttt{is} should be used for boolean variables and methods that return a boolean value. You can refer to the code example below that applies the previously mentioned naming conventions:
\begin{lstlisting}[numbers=none]
#define ARRAY_NUM 10 
bool isVisible; //prefix of variable "is", it's a bool variable.

enum BackgroundColor{ //UpperCamelCase for type
	Red,  //constant
	Green
};
class Teacher{   //UpperCamelCase for type
	name_;  // with trailing underscore, better than name "m_strName".  
};

typedef struct Student StuStruct ;
StuStruct g_global_variable;  //prefix g_
const int k_DaysInWeek = 7;   //prefix k_
main(){
	string teacher_name;  //descriptive variable name
}

printTeacherName(const string& name){...} //lowerCamelCase function name
\end{lstlisting}		
		
	\end{itemize}
	

	

\subsection{Code Convention}
	
	 \texttt{nullptr} is always a pointer type; therefore, avoid using \texttt{NULL} in C++. In the C language, \texttt{NULL} is simply 0, which can lead to ambiguity in strongly-typed C++ code, such as in scenarios like \texttt{f(int)}; and \texttt{f(foo*)};.
	
	\par When you want to comment a large block of code out, use \texttt{\#if 0} ...  \texttt{\#endif}, It's better than using /* ... */. 
	
	\par Symbols for pointers and references should be placed near the data type, rather than near the variable name. It's advisable to declare variables locally whenever possible and minimize the use of global variables.
	
	\par Format lambdas like blocks of code.
\begin{lstlisting}[frame=single, language=c++]
int cutoff = 7;
std::find(foo.begin(),foo.end(),
         [&](const Foo& a ) ->bool{
	         return a.blah<cutoff  //use reference to get local var
         });		
\end{lstlisting}		
	
	
	
	\par Use \texttt{const} to replace \texttt{\#define} when defining global constants. For defining constant class members, use static const. The const keyword indicates that the value will not change, so there's no need for multiple copies across objects, hence static is used. Avoid macros and prefer inline functions. To avoid magic numbers, use const and scoped enums instead.
	
	\par Use more \texttt{typedef} or \texttt{alias} to simplify complicated type expressions, it's helpful especially in generic programming. Alias(C++11) is better than typedef. 
	
\begin{lstlisting}[frame=single, language=c++]
typedef std::map< int, int > IntMap;
typedef IntMap::const_iterator IntMapConstIter;
for( IntMapConstIter it = layout.begin(); it != layout.end(); ++it ) ...

typedef int(*CB)(int, const char*);  //define a function pointer type 
CB callBack;  //decare a functions pointer. //use this type to define a variable.
int sort(int, const char*){..}
callBack = sort; // &operator is optional here!

//C++ alias style.
using UPtrMapSS = std::unique_ptr<std::unordered_map<std::string, int>>;
using CB = int(*)(int, const char*); //CB is a type here.	 	
\end{lstlisting}		
	
%	\par Create a zero-valued enumerator to indicate an invalid or default state and make it the first item.
	
	\par Declare all member variables private, then use getter and setter functions to access them.
	\begin{itemize}
		
		\item If external code needs to access an object's member variables, create a public interface function. This approach offers two advantages:
		\begin{enumerate}
			\item In the setter function, you can validate the input.
			
			\item In the getter function, even if the name of the member variable changes, you only need to modify the getter function, and all customer code will remain unchanged.
		\end{enumerate}	
		This decouples the implementation details of the class from the code that uses it.
		
		\item If only child class wants to access its parent member, declare it as protected.
		
	\end{itemize}
	
	\par Uses early exits to simplify code.
	
\begin{lstlisting}[numbers=none]
if(IsValid){   //bad style
	..do something here;
} else{
	return;
}

if(!IsValid) // A better style is
	return;
..do something here;	
\end{lstlisting}		
	
	
	\par Use \texttt{static\_assert} to test compile-time boolean conditions. It supports a message parameter and operates during the compilation process without needing to build or execute the application. If a condition fails, compilation stops immediately.
\begin{lstlisting}[numbers=none]
static_assert(sizeof(int) > 4, "int is too small");
\end{lstlisting}
	
	\par It's beneficial to use assert more frequently in your project. You do not need to include the file name and line number in the string passed to assert. The assert function automatically generates helpful messages that include this information in the following format: "Assertion failed: expression, file name, line number." This helps in identifying and debugging issues efficiently during development.
\begin{lstlisting}[numbers=none]
#include<cassert>
assert(index>=0 && " index is negative");		
\end{lstlisting}
	
	\par When you want to debug your program, use \texttt{\_FILE\_} and \texttt{\_LINE\_} to capture the current file name and line number. \texttt{assert} just uses this kind of macro inside.
	
	
	%	\item If you don't modify container inside loop, don't need to evaluate \texttt{end()} every time through for loop. Please remember below code block. \textbf{Just remember auto i,e ++i}
	%
	%\begin{lstlisting}[numbers=none]
	%vector<int> con={1,2,3}; //list initializer
	%for(auto i = con.begin, e = con.end();i!=e; ++i){
		%	...........
		%}
	%\end{lstlisting}
	
	%	\item The C++11 standard (23.2.1) mandates that end has O(1) complexity, so previous item has no efficiency meaning in C++11.
	
	
	
	

%\section{Efficiency}
	  Lazy evaluation encompasses several techniques aimed at optimizing performance and resource usage in programming:
	1) reference counting (to avoid extra copy).
	2) distinguish read from write.
	3) lazy fetching.
	4) lazy expression evaluation.
	Implementing lazy evaluation typically adds complexity to the codebase, as it involves managing state, dependencies, and ensuring correct synchronization where applicable. However, when used judiciously, lazy evaluation techniques can significantly enhance the efficiency and responsiveness of software systems.
	

\iffalse
	
\subsection{Comment}	

	
	 Comment is a little "obsolete" in modern C++ programming. This section mainly introduce the Doxygen tool, you can skip this section if you don't use this tool. 
	
	\par Below is suggestions about comment and document: There are five levels of comment: \\
	\begin{center}
		\begin{tabular}{|c|c|c|}
			\tophline 
			type & tool & user \\ 
			\tophline 
			good name convention & no & developer  \\ 
			\tophline 
			source code comment & with source code &  developer \\ 
			\tophline 
			API & source code+ doxgen  & developer + user  \\ 
			\tophline 
			developer document & latex &  developer \\ 
			\tophline 
			End user & Word, power point & end users 
			\bottomhline 
		\end{tabular} 
	\end{center}
	
	
	\par Only use comments when absolutely necessary. By giving functions and variables descriptive names, comments may become unnecessary. Source code comments are typically placed inside functions, while API comments are generally placed before functions and classes. Utilize Doxygen to generate HTML documentation from Doxygen-style comments. Prefer using C++ and Doxygen-style comments more often, and use C-style comments sparingly.
	
\begin{lstlisting}[numbers=none]
/// \brief fooFun does ...
///
///if \p flag is true, when happen
///\param [out] result will be filled
///\return 0 on success.
bool fooFun(bool flag, int& result);	
\end{lstlisting}	
	

	
	\par Avoid duplicating the function or class name in comments. If you change the name later, this inconsistency can confuse readers who rely on comments for understanding.
	
	\par Install Doxygen in linux, then run \linuxcommand{doxygen -g} in the terminal to produce configure file, the name is Doxyfile.  In Doxyfile, modify two items:
\begin{lstlisting}[numbers=none]
GENERATE_LATEX = NO
INPUT = ./src	
\end{lstlisting}	
	then run \linuxcommand{doxygen Doxyfile}, A html directory will be built.
	
	\par Install doxygen on Windows, you can run doxywizard application, or you can use GUI to set Doxyfile configuration file.
	
	\par Typically, projects follow a standard tree structure where each .cpp file is paired with a .h file. In such cases, it's advisable to include comments and documentation commands in the .h files. This is because .h files serve as interfaces to customers or users of your code, providing them with essential information about the classes, functions, and structures exposed by your codebase.
	
	\par If a .cpp file includes a .h file, Doxygen will not parse the .cpp file automatically. Instead, it parses all .h files in a specified directory and extracts information about types such as classes and structs. It's important to note that Doxygen does not extract information about functions and global variables from .cpp files. For classes and structs declared inside a .h file, Doxygen displays them under the "Classes" tab in the index.html output, even if they are not explicitly documented with comments.
	
	\par If you want global functions, variables, enums, typedefs, and defines to be documented, you should document the file in which these contents are located using a comment block containing a $\backslash$file (or @file) command. Even this global function is inside of .h file. With $\backslash$file in .h file, You'd better to use HIDE\_UNDOC\_MEMBERS to ignore all the other global function members without comment inside this .h file. It will make last result looks clean. In order to make Doxygen to parse a .cpp file , you need to put Doxygen command\textbf{$\backslash$file} in a separate line in the .cpp file, then Doxygen will parse this .cpp file and produce the corresponding html page.
	
	
	\par If you want global functions, variables, enums, typedefs, and defines to be documented, you should document the file in which these contents are located using a comment block containing a $\backslash$file (or @file) command. Even if a global function is inside a .h file, using $\backslash$file in the .h file ensures proper documentation. To maintain clarity in your documentation, you can use the HIDE\_UNDOC\_MEMBERS setting in Doxygen. This setting allows you to ignore all other global function members without comments inside the .h file, resulting in a cleaner final output. To ensure that Doxygen parses a .cpp file and generates the corresponding HTML page, you need to include the $\backslash$file command in a separate line at the beginning of the .cpp file. This informs Doxygen to parse the file and include its contents in the generated documentation.
	
	\par Given a C++ source code section, Doxygen will produce below html page.  \textbf{References} and \textbf{Referenced} can be turn on in the configure files.
	
\begin{lstlisting}[numbers=none]
/// \brief Return the function this instruction belongs to.
///
/// Note: it is undefined behavior to call this on an
/// instruction not currently inserted into a function.
const Function *getFunction() const;	
\end{lstlisting}	
	
	\begin{center}
		
		\includegraphics[scale=0.45]{pics/dox1.png}  \medskip
		
		\includegraphics[scale=0.45]{pics/dox2.png} 
		
	\end{center}
	

\fi



\section{C++11/C++14}
\subsection{New type and other language feature}

     The C++ standard doesn't define the exact bit size for arithmetic types. It only specifies that \texttt{int} must be at least 16 bits, \texttt{long} must be at least 32 bits, and \texttt{long long} must be at least 64 bits. In modern C++, new data types with specified sizes have been added, such as \texttt{char16\_t} and \texttt{char32\_t}. If you need a specific integer size for a particular application, instead of relying on the compiler to pick the size you want, include \texttt{<stdint.h>} (or \texttt{<cstdint>}) so you can use these types. All of these types end with \texttt{\_t}.
    
\begin{lstlisting}[numbers=none]
#include <limits>
int8_t and uint8_t
int16_t and uint16_t
int32_t and uint32_t
int64_t and uint64_t

cout<<numeric_limits<uint16_t>::min()<<endl;  //output 0
cout<<numeric_limits<uint16_t>::max()<<endl;  //output 65535
cout<<numeric_limits<uint16_t>::digits10<<endl; //output 4
//why min is function? because class static member must be int. 
//numeric_limits<float>::min should return float. 
\end{lstlisting}

    \par The fixed-width integers have two downsides: First, they may not be supported on architectures where those types can't be represented. Second, they may have lower performance than the built-in types on some architectures. To help address these downsides, C++11 defines two alternative sets of integers: \texttt{int\_least} and \texttt{int\_fast}. Below are some usage suggestions for integers:

\begin{itemize}
	
	\item \texttt{int} should be preferred when the size of the integer doesn't matter, for example, when the number will always fit within the range of a 2-byte signed integer. For tasks such as asking the user to enter their age or counting from 1 to 10, it doesn't matter whether \texttt{int} is 16 or 32 bits as the numbers will fit either way. This will cover the vast majority of cases you're likely to encounter.
	
	\item If you require a variable guaranteed to be a particular size and want to prioritize performance, use \texttt{std::int\_fast*\_t}.
	
	\item If you require a variable guaranteed to be a particular size and prioritize memory conservation over performance, use \texttt{std::int\_least*\_t}. This is most often used when allocating numerous variables.
\begin{lstlisting}
#include <cstdint>
int_fast16_t a = 100'000;
int_least16_t b = 0b10001000;
cout<<sizeof(a)<<endl;  //output 8 in 64 platform
cout<<sizeof(b)<<endl;  //output 2 
\end{lstlisting}
	
	\item Don't use unsigned types unless you have a compelling reason, such as when performing bit operations.
\end{itemize}


    \par Other syntactic improvements in C++14 includes the ability to use the prefix '0b' followed by binary digits, and the ability to use single quotes to make large numbers more readable. For instance, you can represent one million as 1'000'000.00 in C++.
    
\begin{lstlisting}[numbers=none]
int val = 0b11110000;
std::cout << 0b1000'0001'1000'0000;
std::cout<<300'000.00;
\end{lstlisting}

    \par Note that the syntax of C++ attribute-tokens may seem a bit unfamiliar. The list of attributes, including \texttt{[[deprecated]]}, comes after keywords like class or enum and before the entity name. A good article on this topic can be found by searching for 'Marking as deprecated in C++14.' This feature is especially useful for large and long-term projects. For instance, you can't simply delete class \texttt{flaky} because other people may still be using it in their code. However, when you mark it as \texttt{deprecated}, it will generate a compiler warning for future users.

\begin{lstlisting}[frame=single, language=c++]
class [[deprecated]] flaky {
};

[[deprecated("Consider using something other than cranky")]]
int cranky(){
   return 0;
}
\end{lstlisting}

	\par There are six major categories of literals in C++: integer, character, floating-point, string, boolean, and pointer. integer can have prefix and suffix.
\begin{lstlisting}
int i = 0xAA;  //prefix
long int i = 124L;  //suffix
bool flag = true; //true is literals.
int* p = nullptr //nullptr is literals.
\end{lstlisting}	
	
	\par Starting with C++11, you can define your own literals based on these categories to provide syntactic shortcuts for common idioms and enhance type safety. For instance, consider a \texttt{Distance} class. You could define literals for kilometers and miles, encouraging users to specify units explicitly, such as \texttt{auto d = 42.0\_km} or \texttt{auto d = 42.0\_mi}. User-defined literals offer no performance advantage or disadvantage; their primary purpose is convenience and compile-time type deduction.
\begin{lstlisting}
struct Distance{
private:
	explicit Distance(long double val) : kilometers(val){}
	friend Distance operator"" _km(long double val);
	friend Distance operator"" _mi(long double val);
	long double kilometers{ 0 };
public:
	const static long double km_per_mile;
};

const long double Distance::km_per_mile = 1.609344L;
Distance operator"" _km(long double val){
	return Distance(val);
}

Distance operator"" _mi(long double val){
	return Distance(val * Distance::km_per_mile);
}

Distance d1 = 402.0_km ; // construct using kilometers
Distance d2 = 402.0_mi; // construct using miles
Distance d3 = 36.0_mi + 42.0_km; 
\end{lstlisting}
	
	\par The Standard Library has user-defined literals for \texttt{std::string,} for \texttt{std::complex}, and for units in time and duration operations in the <chrono> library. Only the Standard Library is allowed to define literals without the underscore.
\begin{lstlisting}
ReturnType operator "" _a(unsigned long long int);   
ReturnType operator "" _b(long double);         
ReturnType operator "" _r(const char*);  // Raw literal operator, char* 
\end{lstlisting}

	\par Given cooked and raw version, cooked will be called first. Cooked version only accept limited argument. Detail can be found CPP reference.
\begin{lstlisting}
int operator""_yan(unsigned long long i){ //cooked
	return i; //only unsigned long long, or long double for arithmetic.
}
int operator""_yan(const char* p){ //const char*p is raw literal operator.
	return stoi(p); 
}

auto k = 12_yan; //will call cooked first.
\end{lstlisting}
	
	
		
	\par C++98-style enums are now known as unscoped enums. C++11 introduces scoped enums. 
		
\begin{lstlisting}[frame=single, language=c++]
enum Color { black, white, red }; //black, white.. are in same scope as Color
auto white = false; //define the same variable name "white",  compiler report error.

enum class Color { black, white, red }; //has class after enum, black is scoped to Color
auto white = false; // fine, 

Color c = white; // error!
Color c = Color::white; // fine, have to use scope qualifier here
auto c = Color::white; //fine

if (c < 14.5) { // fail, Implicit conversion is not legal any more
if (static_cast<double>(c) < 14.5) { // OK, unless you explicit convert it.
\end{lstlisting}
				
				
		\par Both scoped and unscoped enums support specification of the underlying type. The default underlying type for scoped enums is \texttt{int}, while unscoped enums have no default underlying type. Scoped enums can always be forward-declared. However, unscoped enums can only be forward-declared if their declaration specifies an underlying type.
				

\subsubsection{Alias declaration}

     Alias declaration is often preferred over typedef when declaring a function pointer because it's more clear and direct.
\begin{lstlisting}[frame=single, language=c++]
typedef void (*FP)(int, const std::string&); //FP is function pointer type
typedef void (FP)(int, const std::string&); //FP is function type

using FP = void (*)(int, const std::string&); //looks clean and simple.
\end{lstlisting}

    \par In C++98, typedef templates are not supported directly; they can only be used inside a struct. 
\begin{lstlisting}[frame=single, language=c++]
template<typename T> //C++ 98 style
struct MyAllocList { 
	typedef std::list<T, MyAlloc<T>> type;
};

MyAllocList<Widget>::type lw; // client code, must have ::type here.
template<typename T> 
class Foo { 
	typename MyAllocList<T>::type list;  //Don't forget typename 
};
\end{lstlisting}
\begin{description}
	\item[Line 9:] \texttt{MyAllocList<T>::type} is thus a dependent type, and one of C++'s many endearing rules is that the names of dependent types must be preceded by typename.
\end{description}


	\par In C++ 14, A better way is to use alias template.

\begin{lstlisting}[frame=single, language=c++]
template<typename T>  //C++ 14 style, use template alias,
using MyAllocList = std::list<T, MyAlloc<T>>;

MyAllocList<Widget> lw;  // client code, no ::type here
template<typename T>
class Widget {
	MyAllocList<T> list; //no typename here, no ::type either
};
\end{lstlisting}


	\par Another advantage of alias template is illustrated below. You can see the code become clear and has not compiling error.
\begin{lstlisting}[numbers=none]
template<typename T> //C++ 14, new style, use using alias.
using sometype = std::vector<T>;

template<typename T>
void someFunction(sometype<T> &myArg ); //don't need typename here.

std::vector<int> a;
someFunction(a); //OK, can deduce int directly.
\end{lstlisting}


	\par Based on alias template advantage, C++14 offers alias templates for all the C++11 type traits transformations.
\begin{lstlisting}[numbers=none]
template <class T>
using remove_const_t = typename remove_const<T>::type;

template <class T>
using remove_reference_t=typename remove_reference<T>::type;

template <class T>
using add_lvalue_reference_t=typename add_lvalue_reference<T>::type;

int *p = (std::remove_const_t<const int>*)0;
\end{lstlisting}



\subsubsection{noexcept}
     Typically, copy constructors, move constructors, copy assignment operators, move assignment operators, and destructors should not throw exceptions in principle. However, if any of these functions call (explicitly or implicitly) another function that is potentially throwing, then the calling function will also be treated as potentially throwing. For instance, if a class has a data member with a potentially throwing constructor, then the class's constructors will also be treated as potentially throwing.
    
    \par The following are potentially throwing:
        \begin{itemize}
            \item Normal function call. Most functions are exception-neutral rather than noexcept.
            
            \item An implicit call to a potentially-throwing function (such as an overloaded operator, an allocation function in a new-expression, a constructor for a function argument)
            
            \item \texttt{dynamic\_cast} and \texttt{typeid} expression.
        \end{itemize}

    \par \texttt{noexcept} is a new exception specification introduced in C++11. When an exception is thrown from an \texttt{noexcept} function, \texttt{std::terminate} is triggered. It is the responsibility of the programmer to ensure that the function is not throwing any exceptions. There are two good reasons for the use of \texttt{noexcept}: First, an exception specification documents the behavior of the function. If a function is specified as \texttt{noexcept}, it can be safely used in a non-throwing context. Second, it is an optimization opportunity for the compiler. If a function is declared as \texttt{noexcept}, it may not call \texttt{std::unexpected} and may not unwind the stack. For example, the initialization of a container may cheaply move elements into it if the move constructor is declared as \texttt{noexcept}. Otherwise, the elements may be expensively copied into the container.

    \par \texttt{noexcept} is part of a function's interface, and that means that callers may depend on it. \texttt{noexcept} functions are more optimizable than non-\texttt{noexcept} functions. \texttt{noexcept} is particularly valuable for the move operations, swap, memory deallocation functions, and destructors.

    \par Why \texttt{vector::operator[]} is not noexcept? The standard's policy on noexcept is to only mark functions that cannot or must not fail, Functions that get marked are things like swap (must not fail, because exception safety often relies on that) and \texttt{numeric\_limits::min} (cannot fail, returns a constant of a primitive type). But not those that simply are specified not to throw exceptions. In other words, all functions that have a limited domain (pass the wrong arguments and you get undefined behavior) are not noexcept, even when they are not specified to throw. In another word, \texttt{operator[]} will fail if it out-of-bound. At this time, maybe you want to throw an exception, in this way, make it noexcept is not suitable.


    \par The \texttt{noexcept} operator can be used inside functions. It takes an expression as an argument and returns \texttt{true} or \texttt{false} based on whether the compiler believes the expression will throw an exception. The \texttt{noexcept} operator is evaluated statically at compile-time and does not actually execute the input expression.
\begin{lstlisting}
void foo() {throw -1;}
void boo() {};
void goo() noexcept {};
struct S{};

constexpr bool b1{ noexcept(5 + 3) }; //true; ints are non-throwing
constexpr bool b2{ noexcept(foo()) }; //false; foo() throws an exception
constexpr bool b3{ noexcept(boo()) }; //false; boo() is implicitly noexcept(false)
constexpr bool b4{ noexcept(goo()) }; //true; goo() is explicitly noexcept(true)
constexpr bool b5{ noexcept(S{}) };   //true; default constructor is noexcept 
\end{lstlisting}

	\par A good example is \texttt{vector::size()}. You can observe three specifiers there: \texttt{constexpr}, \texttt{const}, and \texttt{noexcept}. These specifiers should be utilized whenever they can satisfy your semantic requirements. Another reason to use these specifiers is that the STL interface does not change frequently, so using them will not break the function's interface in client code in the future.
\begin{lstlisting}
constexpr size_type size() const noexcept;
\end{lstlisting}

\subsubsection{Variadic Templates}

There are four main usages of variadic templates:
\begin{itemize}
	\item Variadic data structures: A good example is \texttt{std::tuple}.
	
	\item Variadic function: With C++17, you can use fold expressions, eliminating the need for recursive implementations.
	
	\item Variadic template for catch-all functions: input various number and type parameter.
	
	\item Variadic template for forwarding.
\end{itemize}

\par Variadic templates can be used to implement catch-all functions. This example does not use the traditional recursive approach for implementing variadic templates but rather uses them to allow for 'any template parameters' to be passed. One example is writing a function that can print out standard library containers without acting on iterators. The function should work for any container with minimal input from the user. To achieve this, template template parameters are used. The \texttt{vector} template has two template parameters, while the \texttt{map} template has four. A parameter pack is used to handle this flexibility.


\begin{lstlisting}
template < template <typename, typename...> class ContainerType,
typename ValueType, typename... Args>  
// typename... Args is template parameter pack
void print_container(const ContainerType<ValueType, Args...>& c) {
	for (const auto& v : c) {
		std::cout << v << ' ';
	}
	std::cout << '\n';
}

print_container(vector<double> vd);
print_container(map<int,string> mi);	
\end{lstlisting}

\par Variadic templates for forwarding. This is a very typical usage for \texttt{make\_*} functions (object generators) in the STL. 
\begin{lstlisting}
std::unique_ptr<FooType> f = std::make_unique<FooType>(1, "str", 2.13);

template<typename T, typename... Args>
unique_ptr<T> make_unique(Args&&... args){
	return unique_ptr<T>(new T(std::forward<Args>(args)...));
}	
\end{lstlisting}

\par In previous code, you need to pay attention to the syntactic usage. An ellipsis is used in two ways by variadic templates. To the left of the parameter name, it signifies a parameter pack, and to the right of the parameter name, it expands the parameter packs into separate names.
\begin{lstlisting}
function(params...) expands function(param1, param2, ..., paramN).

function(std::forward<Tys>(params)...)  //expands to
function(std::forward<Tys1>(param1), std::forward<Tys2>(param2), ..., std::forward<TysN>(paramN))

function(std::forward<Tys>(params...)) //expands to
function(std::forward<Tys>(param1, param2, ..., paramN)) //Error here.	
\end{lstlisting}

\par Variadic templates make it possible to define data structures with an arbitrary number of fields, whose number can be configured per use. One primary example of this is a \texttt{std::tuple} class, which uses the recursive idea.
\begin{lstlisting}
template <typename... Ts> struct tuple {};

template <typename T, typename... Ts>
struct tuple<T, Ts...> : tuple<Ts...> {
	tuple(T t, Ts... ts) : tuple<Ts...>(ts...), tail(t) {}
	T tail;
};	
\end{lstlisting}


\begin{lstlisting}
tuple<double, uint64_t, const char*> t1(12.2, 42, "big");

struct tuple<double, uint64_t, const char* >: tuple<uint64_t, const char*>{ //1
	double tail;
}
struct tuple<uint64_t, const char*> : tuple<const char*> { //2
	uint64_t tail;
}
struct tuple<const char*> : tuple { //3
	const char* tail;
}
struct tuple {  //4
}	
\end{lstlisting}

\par Next, I will introduce how to implement a \texttt{get} function to access tuple elements. First, we build a helper type that lets us access the type of the k-th element in a tuple. Similar to adding new layers when building a tuple, accessing the n-th element involves peeling off layers using a recursive implementation.

\begin{lstlisting}
template <size_t, class> struct elem_type_holder;

template <class T, class... Ts>
struct elem_type_holder<0, tuple<T, Ts...>> {
	typedef T type;
};

template <size_t k, class T, class... Ts>
struct elem_type_holder<k, tuple<T, Ts...>> {
	typedef typename elem_type_holder<k - 1, tuple<Ts...>>::type type;
};	
\end{lstlisting}

\par With the help of this helper function, we can implement the \texttt{get} function as follows. \texttt{get} is a template function, which is why you need to use \texttt{get<3>} to initialize it.
\begin{lstlisting}
template <size_t k, class... Ts>
typename std::enable_if<
k == 0, typename elem_type_holder<0, tuple<Ts...>>::type&>::type
get(tuple<Ts...>& t) {
	return t.tail;
}

template <size_t k, class T, class... Ts>
typename std::enable_if<
k != 0, typename elem_type_holder<k, tuple<T, Ts...>>::type&>::type
get(tuple<T, Ts...>& t) {
	tuple<Ts...>& base = t; //we peel off one layer here. 
	return get<k - 1>(base);
}	
\end{lstlisting}

\par Don't worry about the performance of variadic template implementations. There's no actual recursion involved; instead, we have a sequence of function calls pre-generated at compile-time. This sequence is generally fairly short (variadic calls with more than 5-6 arguments are rare). Modern compilers aggressively inline code, likely resulting in machine code with no function calls. The result is similar to loop unrolling. A good article is "Variadic templates in C++".



\subsection{regex}
	 Usage of \textbf{std::regex\_match}, return a bool value.
\begin{lstlisting}
string s1 = "ab123cdef"; //
string s2 = "123456789"; //
regex ex("\\d+"); //

cout << s1 << " is all digit: " << regex_match(s1, ex) << endl; 
cout << s2 << " is all digit: " << regex_match(s2, ex) << endl;  
\end{lstlisting}
	\par Usage of \texttt{std::regex\_search}.
\begin{lstlisting}
string s = "ab123cdef"; // 
regex ex("\\d+");    // 

smatch match; // 
regex_search(s, match, ex); // 
cout << s << " contains digit: " << match[0] << endl; // 
\end{lstlisting}

	\par Search all matched parts. 
\begin{lstlisting}
std::string s1("{111,2222,333333}");
std::regex e(R"((\d{2})\d*)");
std::cout << s1 << std::endl;

std::sregex_iterator iter(s1.begin(), s1.end(), e);
std::sregex_iterator end;

while(iter != end){
	std::cout << "size: " << iter->size() << std::endl;
	for(unsigned i = 0; i < iter->size(); ++i){
		std::cout << "the " << i + 1 << "th match" << ": " << (*iter)[i] << std::endl;
	}
	++iter;
}
/* output is below:
size: 2               
the 1th match: 111    //The first match matches the whole
the 2th match: 11     //The second match matches the catch group
size: 2
the 1th match: 2222
the 2th match: 22
size: 2
the 1th match: 333333
the 2th match: 33
*/
\end{lstlisting}

	\par Replace by using \texttt{std::regex\_replace}.
\begin{lstlisting}
string s = "ab123cdef"; // 
regex ex("\\d+");    // 

string r = regex_replace(s, ex, "xxx"); // 
cout << r << endl; // 
\end{lstlisting}

\par The basic regex expression includes four big categories:1) Quantifier, such as ?, + , * and \{2,3\}. 2) Anchors, such as \verb|^|,  \$ and $\backslash$b match a word boundary. 3) Group and capturing, such as () and (?:). 4) Range, such as [a-z], $\backslash$d, all number $\backslash$s, any space. 

\par Based on the previous introduction, a regex expression example  \verb|^(?:\d{3}-){2}\d{4}$| (matching US telephone number, such as: 832-433-4125) can be understood as follows:
\begin{itemize}
	
	\item \verb|^|: Asserts the start of the string.

	\item \verb|(?:\d{3}-)|: This is a non-capturing group \verb|(?: ... )| that matches exactly three digits \verb|\d{3}| followed by a hyphen -.

	\item \{2\}: Quantifier that specifies the non-capturing group \verb|(?:\d{3}-)| should occur exactly 2 times consecutively.

	\item \verb|\d{4}|: Matches exactly four digits. \$: Asserts the end of the string.
\end{itemize}

	\par When writing regular expressions, you should use raw string literals to avoid excessive escaping. 
\begin{lstlisting}
R"delimiter( raw_characters )delimiter"
regex mask("\\t[0-9]+\\.[0-9]+\\t\\\\SUB"); //many escaping, bad
regex mask(R"(\t[0-9]+\.[0-9]+\t\\SUB)");  //with R"(, that is better
\end{lstlisting}

	\par The purpose of the parentheses is to allow you to specify a custom delimiter:
\begin{lstlisting}[mathescape=false]
string raw_str = R"~(^(?:\d{3}-){2}\d{4}$)~"; //~( and )~ are delimiters
\end{lstlisting}

	 \par Without delimiter, you would be in trouble if the string itself contained something like " (if you had just wanted R"..." as your raw string syntax) or )" (if the delimiter is empty). Both of those are perfectly common and frequent character sequences, especially in regular expressions, so it would be incredibly annoying if the decision whether or not you use a raw string depended on the specific content of your string.


\section{C++17}
\subsection{Language feature}
\subsubsection{Structured binding}

     Structured bindings can be used for structures with public data members, raw C-style arrays, and tuple-like objects. A structured binding declaration then performs the binding in one of three possible ways, depending on the type:
        \begin{enumerate}
            \item If type is an array type, then the names are bound to the array elements.
            
            \item If type is a non-union class type and \texttt{std::tuple\_size<E>} is a complete type with a member named value (regardless of the type or accessibility of such member), then the "tuple-like" binding protocol is used.
            
            \item If type is a non-union class type but \texttt{std::tuple\_size<E>} is not a complete type, then the names are bound to the accessible data members of type.
        \end{enumerate}
    
    
    \par \texttt{std::tuple} has its own \texttt{std::tuple\_size}, so it uses the tuple-like binding protocol. If you want your custom class to use the tuple-like binding protocol, you also need to define your own \texttt{std::tuple\_size} implementation. For a custom class, the binding structure needs to know two important pieces of information: the number of elements and the type of each element. This is why we also need to implement \texttt{tuple\_element} and a \texttt{get} function.

\begin{lstlisting}
template< class... Types > //partial specification of std::tuple_size
struct tuple_size< std::tuple<Types...> >
    : std::integral_constant<std::size_t, sizeof...(Types)> { };

namespace std{
template<>  //This should be full specification of std::tuple_size
struct std::tuple_size<Customer>{
  static constexpr int value = 3;
}
}
\end{lstlisting}

    \par With structured bindings, we don't need to use \texttt{std::tie}. Please compare the C++14 and C++17 code below. Note that the usage of \texttt{std::tie} in the compare function is still valid.

\begin{lstlisting}
Point p = {1, 2};
int x_coord, y_coord;
tie(x_coord, y_coord) = make_tuple(1, 2); //C++14, use tie

auto [x_coord, y_coord] = p ;//C++17, use structure bindings. 
\end{lstlisting}

	\par \texttt{std::tie} constructs and returns a tuple of references.
\begin{lstlisting}
int a;
tie(a) = make_tuple(24); //same tuple<int&>{a} = tuple<int>{24};
//You can understand above code in below way:
struct T { // substituent for std::tuple<int>
	int x;
};
struct Tr { // substituent for std::tuple<int&>
	int& xr;	
	auto operator=(const T& other){
		// std::get<I>(*this) = std::get<I>(other);
		xr = other.x;
	}
};
Tr{a} = T{24};
\end{lstlisting}

	\par What happens behind structured bindings? It's as if we had initialized a new entity \texttt{e} with \texttt{ms} and let \texttt{u} and \texttt{v} become alias names for the members of this new object. In other words, when we modify \texttt{u}, it will not affect \texttt{ms}.

\begin{lstlisting}
struct MyStruct{
	int i = 0;
	string s;
}
MyStruct ms;
auto [u,v] {ms} //auto[u,v] = ms;	

auto e = ms;
aliasname u = e.i;
aliasname v = e.s;	
\end{lstlisting}

	\par We can use qualifiers, such as const and references. Again, these qualifiers apply to the anonymous entity \texttt{e} as a whole. This time you can modify the original structure.
\begin{lstlisting}
MyStruct ms;
auto &[u,v] = ms; 
// MyStruct& e = ms; u is alias name of e.i, v is alias nme of e.s

u = 100;
cout<<ms.i;  // it will output 100 here. 
\end{lstlisting}
	
	\par Structured bindings use alias name with anonymous structure, so when you use \texttt{auto}, it will not decay. That is important point to remember when you use structure binding.
	
\begin{lstlisting}
struct S{
	const char x[6];
	const char y[3];
};

S s1{};
auto [a,b] = s1; //a's type is char[6], doesn't decay to pointer
auto a1 = a; // a1 decay to pointer. 	
\end{lstlisting}		

	\par Structured bindings are especially useful for functions that return structures or arrays. For example, consider a function that returns a structure. Structured bindings are particularly useful for working with \texttt{std::map}.
	
\begin{lstlisting}
MyStruct getStruct(){
	return MyStruct{42, "hello"};
}	
auto[id, val] = getStruct();
for(const auto& [key,value] : map){ //That is very useful pattern. 
	cout<<key<<value<<endl;
}
\end{lstlisting}
    
    \par Move semantics are supported too.  

\begin{lstlisting}
My Struct ms = {42, "jim"};
auto &&[v,n] = std::move(ms)
string s = std::move(n) //although n is &&, it is lvalue. because it has name.
auto[v,n] = std::move(ms) //ms is empty now.
\end{lstlisting}	


\subsubsection{Fold expression}

	
  There's a way to write functions that take an arbitrary number of arguments in a type-safe way and have all the argument handling logic resolved at compile-time, rather than run-time. Below are two examples. The whole idea is like the recursive function. But after C++ 17, we can use fold expression to replace recursive function definition. Fold expressions can make you write \textbf{variadic template function} much easier. You can compare two codes below:

\begin{lstlisting}
template<typename First>
First sum1(First&& value){
		return value;
}
template<typename First, typename Second, typename... Rest>
First sum1(First&& first, Second&& second, Rest&&... rest){
		return sum1(first+second, forward<Rest>(rest)...);
}

template<typename First, typename... Rest> //C++ 17, the first ...
First sum2(First&& first, Rest&&... rest){  // the second ...
		return (first+ ... + rest);   // the third ...
}
\end{lstlisting}

    \par With help of fold expression, we can implement \texttt{std::all} much easier.
\begin{lstlisting}
template<typename... Args>
bool all(Args... args){
	return(... && args);
}
\end{lstlisting}

    \par More explanation about ... syntax.
\begin{lstlisting}
(... op args) expands to ((arg1 op arg2) op arg3) op...
(args op ...) expands to arg1 op(arg2 op ..(argn-1 op argN))
(value op ... op args) expands to(((value op arg1) op arg2) op arg3) op....
(args op ... op value) expands to(arg1 op(arg2 op ...(argN op value)))
template<typename ... T>
auto foldSum(T... s){
  return (0 + ... +s); 
} 
\end{lstlisting}

    \par The first operand might be any operand, such as \texttt{std::cout}.
\begin{lstlisting}
template<typename...T>
void print (const T&... args){
  (std::cout<<...<<args)<<endl;
 //(    0    + ...+ aregs ) // The same idea, both + and << are operator, 
                            // std::cout is just like 0, it's operand. 
}   //print("hello", 42, "world") output hello42world.
\end{lstlisting}

    \par If you want to output space, you can use this way.
\begin{enumerate}
	\item In line 10, there is () around fold expression, because we have \texttt{endl} in the end of statement.
	
	\item  \texttt{std::cout} is a special operand.
	
	\item  ... applies to left, think left is init. then expands to \texttt{std::cout<<}. Then ... applies to right, expands to spaceBefore(arg1), spaceBefore(arg2), spaceBefore(arg3). In the end, we combine them together. \texttt{(std::cout<<spaceBefore(arg1))<<spaceBefore(arg2)...} . Hope that you can understand before explanation, this is a complex example, when you understand it, you will be able to understand simpler problems more easily. 
\end{enumerate}

\begin{lstlisting}
template<typename T>
const T& spaceBefore(const T& arg){
  std::cout<< ' ';
  return arg;
}
template <typename First, typename... Args>
void print(const First& firstarg, const Args&... args){
  std::cout<< firstarg;
  (std::cout<< ... << spaceBefore(args))<<endl;
  //cout<<(args<< ... << '\n' ); //will not work here. 
\end{lstlisting}


	\par Below figure demonstrate relationship between previous three important modern c++ feature: variadic template, fold expression and structure binding. 
\begin{center}
	\includegraphics[width=0.69\linewidth]{pics/Variadic.png}
\end{center}

\subsubsection{class template argument deduction}

	 Class template argument deduction (CTAD) is a significant improvement in C++17. You can omit the explicit definition of template arguments if the constructor can deduce all the template parameters. By using class template argument deduction, we can eliminate several convenience function templates that existed solely to allow the deduction of class template parameters from the passed call arguments.

\begin{lstlisting}
std::vector<int> vi{1, 2, 3, 4, 5}; //C++ 11
std::pair<std::vector<int>, int> pvi{vi, 100};
auto pi = std::make_pair(vi, 100); // you can use object generator idea.
std::mutex m;
std::lock_guard<std::mutex> lk{m};

std::pair pvi{vi, 100}; // In C++ 17, no need make_pair funciton here.
std::lock_guard lk{m};
\end{lstlisting}

	\par There is no type conversions used to deduce template parameters if there is ambiguities. 
\begin{lstlisting}
std::complex c{5, 5.1} //compile fail, 
\end{lstlisting}

    \par CTAD only uses the primary class constructor to deduce template arguments. Sometimes, CTAD doesn't work because it can only be used in some primary classes. Additionally, sometimes CTAD doesn't deduce the type that you want. In such cases, you can use deduction guides to help the compiler.
\begin{lstlisting}
//primary class is empty, so no primary class constructor to use.
template<typename T> 
struct wrap_ptr; 

template<typename T> 
struct wrap_ptr<T*> { //template specification 1
  wrap_ptr(T* p) : p_(p) {}
  ~wrap_ptr() { delete p_; }
  int *p_;
};

template<typename T> 
struct wrap_ptr<shared_ptr<T> > { //template specification 2
  wrap_ptr(shared_ptr<T> p) : p_(p) {}
  shared_ptr<T> p_;
};

wrap_ptr nptr{new int{100}}; //fail to deduct int*
shared_ptr<int> isp{new int {666}};
wrap_ptr sptr{isp};  //fail to deduct shared_ptr
\end{lstlisting}

    \par In order to resolve this problem, we can add below deduction guide.

\begin{lstlisting}
template<typename T>
wrap_ptr(T*) -> wrap_ptr<T*>;

template<typename T>
wrap_ptr(shared_ptr<T>) -> wrap_ptr<shared_ptr<T>>;
\end{lstlisting}

	\par When CTAD cannot properly deduce the argument, we can also use a deduction guide to help us. In the example below, we want to get \textbf{Force Decay}. However, when we use a reference, the array will not decay to pointer. Therefore, we add a deduction guide to tell the compiler to take its argument by value rather than by reference. If we use a value to take the argument, then decay will occur.
	
\begin{lstlisting}
template<typename T>
struct C{
  C(const T&){...}
  ...
};
template<typename T>  // take its argument by value, not by reference.
C(T) -> C<T>; 

C x{"hello"};//without the deduction guide, T will be char[6], 
             //with the deduction guide, T is const char*
\end{lstlisting}

    \par In general, CTAD automatically works when class templates have constructors whose signatures mention all of the class template parameters. However, sometimes constructors themselves are templated, which breaks the connection that CTAD relies on. In the code below, we want to make our '\texttt{my\_pair}' class accept any type of array and deduce T and U as the element types of the array. According to CTAD, we can just use the primary class constructor (not the template constructor) to deduce the argument. Therefore, we can use a deduction guide to deduce the \texttt{A} type in our second constructor (\#2), change it to the primary class constructor \#1, and then the compiler can use \#1 to continue its work properly.

\begin{lstlisting}
template<typename T, typename U>
struct my_pair {
	my_pair(T t, U u) : t_(t), u_(u) {} // #1
  
	template<typename A>
	my_pair(A a[]) : t_(a[0]), u_(a[1]) {}  // #2
};


template<typename A>  // Deduction Guide
my_pair(A []) -> my_pair<A, A>; //my_pair<A, A> is #1 style now

char ca[] = {'a', 'b'};
my_pair mp2{ca}; // my_pair<char, char>, T and U ar char
\end{lstlisting}

    \par The code below has some things to explain. \#1 is the deduction guide because it's a template that can be specialized. \#2 is simply specialized of deduction guide. You can see that the specification is simple: just to say that when we input a pointer array, it should be changed to a \texttt{string}. The third point is that we also use '\texttt{explicit}'. Then, the specification deduction rule is only used in the constructor, not the copy constructor. This is a good example that demonstrates some common technologies that are used in template deduction guides.

\begin{lstlisting}
template<typename A> // Deduction Guide
my_pair(A[]) -> my_pair<A, A>;  // #1

explicit my_pair(const char*[]) -> my_pair<string, string>; // #2

const char* stra[] = {"Yan", "Zhao"};
my_pair mp4{stra}; //use #2, deduct my_pair<string, string>

my_pair mp4copy = stra; //use #1, deduct my_pair<const char*, const char*>
\end{lstlisting}



\subsubsection{compile-time if}
	
	 Example code of compile-time if.
\begin{lstlisting}
template <typename T>
std::string asString(T x){
  if constexpr(std::is_same_v<T, std::string>){
    return x;
  }
  else if constexpr(std::is_arithmetic_v<T>){
    return std::to_string(x);
  }
  else{
    return std::string(x);// compile error if no conversion to string
  }
}
\end{lstlisting}

	\par The compile-time if statement impacts the return type of the function below. The return type can be either \texttt{int} or \texttt{void}. If a runtime if statement is used in this code, it will never compile because both return statements will be taken into account, resulting in a conflict. However, when we use a compile-time if statement, the code can compile successfully.
\begin{lstlisting}
auto foo(){ //You have to use auto here!
	if constexpr(sizeof(int)>4){
		return 42;
	}
}	
\end{lstlisting}

		\par Based on the previous introduction, we can return a \textbf{generic value}. The return value can be polymorphism, it's very interesting. 
\begin{lstlisting}
#include <functional>   // for std::forward()
#include <type_traits>  // for std::is_same<> and std::invoke_result<>

template<typename Callable, typename... Args>
decltype(auto) call(Callable op, Args&&... args){
  if constexpr(std::is_void_v<std::invoke_result_t<Callable, Args...>>) {
    	// return type is void:
    op(std::forward<Args>(args)...);
    	//...  do something before we return
    return;
  }
  else { // return type is not void:
    decltype(auto) ret{op(std::forward<Args>(args)...)};
    	//... something (with ret) before we return
    return ret;
  }
}
\end{lstlisting}

    \par Can be used to replace tag dispatch.

\begin{lstlisting}
if constexpr (std::is_convertible_v<cat, std::random_access_iterator_tag>){
   ...
}
else if constexpr(is_convertible_v<cat, bidirectional_access_iterator_tag){
   ...
}
\end{lstlisting}

	\par Typically, you only use a \texttt{if constexpr} in template contexts. Although it's not mandatory, if you don't use it in a template context, you must ensure that the body will compile at compile time, even if it would be discarded, just like with a plain old \texttt{if} statement.

\begin{lstlisting}
vector<int> vec; // that is not function template
if constexpr(has_x<decltype(vec)>()){
	cout << vec.x << endl;  //compile will fail, std::vector.x is invalid
}
else{
	cout << size(vec) << endl;
}
\end{lstlisting}


%\subsubsection{lambda extension}
%\begin{itemize}
%\end{itemize}

\subsubsection{Other features}
	
	 Lambdas are implicitly constexpr, and the compiler will determine this. If a lambda is not constexpr, and you try to use it in a constexpr context, the compiler will report an error.
\begin{lstlisting}
auto squared = [](auto val){ return val*val; };  //two ; here.
std::array<int, squared(5)> a; //Don't need constexpr when you use squared lambda.
\end{lstlisting}	
	
	\par You can pass copies of \texttt{this} to lambdas.
\begin{lstlisting}
Class C{
	....
	void foo(){
		auto l1 = [*this] {std::cout<<name <<'\n';};
	}
};	
\end{lstlisting}	
	
    \par In C++ 17, aggregate initialization supports base class initialization.
\begin{lstlisting}
struct Data{
  std::string name;
  double value;
};
Data x{"text1", 6.77} //don't need =

struct MoreData : Data{
  bool done;
}
MoreData y{{"test1", 6.77}, false}; //support base class initialization.
\end{lstlisting}

    \par In C++ 17, copy elision is mandatory, don't need any copy and move constructor in \texttt{MyClass}. This rule is only applied to temporary variable. 
\begin{lstlisting}
class MyClass
void foo(MyClass param)...

MyClass bar(){
  return MyClass{}; //must return a temporary variable.
}

foo(MyClass{}); // pass temporary to init
MyClass x = bar(); // use return temporary to init
foo(bar()); // use returned temporary to init parameter.
\end{lstlisting}


%\subsection{library feature}


\section{C++20}

\subsection{Concept}

\subsubsection{Define new conception}
	
     There are two ways to define a concept: 1) using a concept expression or type\_trait, and 2) using a \textbf{requires expression}.
    
\begin{lstlisting}
template < template-parameters>
concept _conceptName_ = _conceptExpression_; //method 1, concept expression

template < template-parameters> 
concept _conceptName_ = requires(_arguments_) {//method 2, requires expression
   _conceptExpression_;
};
\end{lstlisting}

\par Some defined concepts in STL library header \texttt{<concepts>}.  \\
\begin{tabular}{|p{0.22\textwidth}|p{0.65\textwidth}|}
	\hline
	concepts & description  \\
	\hline
	\texttt{std::same\_as} &  specifies that a type is the same as another type \\
	\hline
	\texttt{std::convertible\_to} & specifies that a type is implicitly convertible to another type \\
	\hline
	\texttt{std::integral} & specifies that a type is an integral type \\
	\hline
	\texttt{std::copyable} & specifies that an object of a type can be copied, moved, and swapped
	  \\
	\hline
	\texttt{std::invocable} & specifies that a callable type can be invoked with a given set of argument types \\
	\hline
\end{tabular}

	\par Below is a simple example using the C++ keyword "\texttt{concept}", which is mainly used in templates. In this example, We define a new concept based on an existing concept.
\begin{lstlisting}
template<typename T>  
concept Any = true;

template <typename T> 
concept Number = std::integral<T> || std::floating_point<T>; //concept expression	
\end{lstlisting}
    
    \par We can express our requirement for a template parameter to support a certain operation or operator through wishful writing. For example, if you require template parameters to be addable, you can create a concept for that using a requires expression.

\begin{lstlisting}
template <typename T>
concept Addable = requires (T a, T b) {
	a + b; 
};

template <typename T>
concept HasPower = requires (T t, int exponent) {
	t.power(exponent);
	t.sqrt();
};
\end{lstlisting}

    \par We can also use a requires expression for purposes other than declaring a concept, such as defining a constexpr variable. In this way, we can combine if constexpr and requires expressions together. The code below is very interesting, so please remember it. Pay attention to the usage \texttt{constexpr} here. 

\begin{lstlisting}
template <typename T>
void clever_swap(T& a, T& b) {
  constexpr bool has_member_swap = requires(T a, T b){ 
    a.swap(b); 
  };

  if constexpr (has_member_swap) {
    a.swap(b);
  }
  else {
    using std::swap;
    swap(a, b);
  }
}
\end{lstlisting}

    \par For these expressions to work, the function \texttt{square()} doesn't need to return precisely \texttt{int}. It will work for us if it returns \texttt{short} as well. If you want the type to be convertible to \texttt{int}, the syntax is:

\begin{lstlisting}
template <typename T>
concept HasSquare = requires (T t) {
	{t.square()} -> std::convertible_to<int>;
}; 
\end{lstlisting}

	%	\item With concepts, you can require both syntactic and semantic conditions. In terms of syntactic requirements, imagine that you can impose the existence of certain functions in the API of any class. For example, you can create a concept \texttt{Car} that requires the existence of an \texttt{accelerate} function:


\subsubsection{Use conception}
	 There are four different ways to use concept.
\begin{lstlisting}
#include <concepts>
template <typename T>
concept Number = std::integral<T> || std::floating_point<T>;

template <typename T>
requires Number<T>   //1) Use requires clause
auto addRequiresClause(T a, T b) {
	return a+b;
}

template <typename T>
requires std::integral<T> || std::floating_point<T> //1) requires clause
class WrappedNumber {
	// ...
};

template <typename T>  //2) trailing position
auto addTrailingRequiresClause(T a, T b) requires Number<T> {
	return a+b;
}

template <Number T>  //3) use concept directly to define template argument
auto addConstrainedTemplate(T a, T b) {
	return a+b;
}

//4) That is call conception auto variable usage.
auto addAbbreviatedFunctionTemplate(Number auto a, Number auto b) {
	return a+b;     
}	 
\end{lstlisting}	
	
	\par Take \texttt{std::convertible\_to} concept as an example, we can use previous 4 different ways to define functions below. 
\begin{lstlisting}
template <typename T>
requires std::convertible_to<T, std::string>
void func_with_template_postfix(const T& x) {
	std::string v = x;
}
	

void func_with_auto_postfix(const auto& x) //use auto here. 
requires std::convertible_to<decltype(x), std::string> {
	std::string v = x;
}

template <std::convertible_to<std::string> T>
void func_with_template_inline(const T& x) {
	std::string v = x;
}

//Note here, we use concept + auto here. 
void func_with_auto_inline(const std::convertible_to<std::string> auto& x) {
	std::string v = x;
}
\end{lstlisting}	
	
	\par When you define a concept, you use \textbf{requires expression}; When you use concept, you use \textbf{requires clauses}, they are different.
	
    \par You can use concept as compile-time bool.

\begin{lstlisting}
#include <concepts>

static_assert(std::is_same_v<int, long> ); //std::is_same_v is type trait
static_assert(std::same_as<int, long> )  // std::same_as is concept
\end{lstlisting}


	\par You can use concepts to constrain function return values as well as function parameters.
\begin{lstlisting}
template<typename T>
concept IntCon = std::integral<T>;

template<typename T>               //pay attention to auto usage here. 
constexpr IntCon auto returnInt(){ //use IntCon before auto
	T t{};
	return t;
}

cout<<returnInt<int>()<<endl;  //OK
cout<<returnInt<float>()<<endl; //compile error
\end{lstlisting}

\par You can combine concept with variadic template. Syntax is a little complex, but we are using \textbf{abstract-oriented programming} style :).
\begin{lstlisting}[basicstyle=\scriptsize]
template<typename T, typename ... U>
concept IsAnyOf = (std::same_as<T, U> || ...);

template<typename T>
concept IsPrintable = is_integer<T> ||
IsAnyOf<std::remove_cvref_t<std::remove_pointer_t<std::decay_t<T>>>, char, wchar_t>;

void println(IsPrintable auto const ... arguments){
	(std::wcout << ... << arguments) << '\n';
}

int main(){
	println("Example: ", 3, " : " , " : [" , 'a', L'-', L"Z]");
}	
\end{lstlisting}



\subsection{Module}
	
	 Advantages of module includes:
	\begin{itemize}
		\item No need to write separate files for the interface (.h) and the implementation (.cpp). 
		
		\item Faster compile / recompile. Include guards are not necessary.	
		
		\item Modules don’t have "side-effects" so the order in which modules are imported is not important.
		
		\item Precompiled headers can significantly speed up compile times. Additionally, removing implementation details from the interface file (e.g. using the PIMPL idiom) reduces the "ripple effect" and prevents unnecessary recompilation when small changes are introduced.
	\end{itemize}
	
	\par A module is a set of source code files that are compiled independently of the translation units that import them. Modules eliminate or greatly reduce many of the problems associated with using header files and can also potentially reduce compilation times. We recommend that new projects use modules rather than header files whenever possible. For larger existing projects under active development, we suggest experimenting with converting legacy headers to modules to determine if this leads to a significant reduction in compilation times.	
	
	\par C++ Modules introduce a new type of translation unit called a module unit. The definition is fairly simple: a module unit is a translation unit that contains a module declaration. In other words, it must include the keyword '\textbf{module}' in the module unit. 
\begin{lstlisting}
module-declaration:
["export"] "module" module-name [module-partition] [attribute-specifier-seq] ";" ;

module-partition:
":" module-name ;
\end{lstlisting}

\begin{center}
	\includegraphics[width=0.7\linewidth]{pics/module.drawio}
\end{center}
	

	\par If we have multiple functions that we want to export, the standard allows us to use an export block.

\begin{lstlisting}
export module mod;
export { //use export block
	void func();
	void func(int);
}	
\end{lstlisting}

	\par There are a lot of grammar restriction when you use module partition, you can follow below the pattern as a good starting point. 
	
	\begin{itemize}
		\item The primary interface unit for a module(\texttt{export module speech}) must export all of the interface partitions for the module (either directly or indirectly) via export import :<part-name>. Otherwise, the program is ill-formed, no diagnostic required.
		
		\item \texttt{export import} is only allowed for interface partitions, such as \texttt{export import :english}.
		
		\item All interface partitions must be re-exported from the primary interface unit.
	\end{itemize}
	
\begin{lstlisting}
// speech.cpp, primary module interface unit
export module speech;
export import :english; //use export import here.
export import :spanish; //Don't add module name before :

// speech_english.cpp, module partition interface
export module speech:english;  //must use export, otherwise line 2 fail.
export const char* get_phrase_en() {
	return "Hello, world!";
}

// main.cpp,  client code
import speech;
std::cout << get_phrase_en() << '\n';
\end{lstlisting}

	\par Just like the above code, but we don't use module partition interface(no export in speech\_english.cpp file.)

\begin{lstlisting}
// speech.cpp, This is module interface unit
export module speech;
import :english;
import :spanish;
export const char* get_phrase_en();
export const char* get_phrase_es();

// speech_english.cpp, This is module (partition) implementation unit.
module speech:english;  //module partition, has  :
const char* get_phrase_en() { //no export, so it's implementation unit
	return "Hello, world!";
}

// speech_spanish.cpp
module speech:spanish;
const char* get_phrase_es() {
	return "Hola Mundo";
}
\end{lstlisting}
	
	
	\par Guideline for a module structure.
	
\begin{lstlisting}
module;                      // global module fragment
#include <headers for libraries not modularized so far>

export module math;          // module declaration 
import <importing of other modules> 
<non-exported declarations>  // names with only visibility inside the module

export namespace math {
	<exported declarations>  // exported names 
}	
\end{lstlisting}

	\par To enable support for modules, compile with \texttt{experimental:module} and \texttt{std:c++20} or later (such as \texttt{std:c++latest}). In a Visual Studio project, right-click the project node in Solution Explorer and choose Properties. Set the Configuration drop-down to All Configurations, then choose Configuration Properties > C/C++ > Language > Enable C++ Modules (experimental).	
	
    \par A module example based on previous module structure.
     
\begin{itemize}
	\item global module fragment, that is where we include things we need. 
	
	\item main module, which we can export type and behavior. 
	
	\item private fragment. Purpose of private fragment is to separate implementation with interface. If we change implementation in the private module, client code doesn't need to re-compile. We can also put interface and module implementation into different files. 

\begin{lstlisting}
module; // 1) global module fragment
#include <iostream> //put #include statement here.

export module mod; //2) main module
import <vector> ; //don't forget ; here
export void func() {
	vector<int> vi = {1, 2, 3}
	invisible_fun();
    std::cout << "hello, world!\n"<<vi[0]<<endl;
}
export void func2(); only declaration, no implementation.
invisible_fun(){..} //this function is invisible from outside. 


module :private; // 3) private module fragment, no export here. 
void func2(){
	cout<<"func2"<<endl;
}
\end{lstlisting}

	\item Client code is below:
\begin{lstlisting}
import mod; // client code 
int main(){
    func();
}
\end{lstlisting}

\end{itemize}

    \par Separate module interface and module implementation, put them into the different files. 
\begin{lstlisting}
export module mod;  // func.cxx
export void fun();

module; //func_impl.cxx
#include <iostream>

module mod;
void func() {
    std::cout << "hello, world!\n";
}

g++ -c -std=c++20 -fmodules-ts func.cxx, g++ generates gcm.cache/mod.gcmthen
g++ -c -std=c++20 -fmodules-ts func_impl.cxx 
g++ main.o func.o func_impl.o -o App
\end{lstlisting}

	\par A good article is "Understanding C++ Modules: Part 1: Hello Modules, and Module Units"
	

\subsection{Coroutine}
\subsubsection{Basic implementation of coroutine}
	 In C++, coroutines are a language feature introduced in C++20 that allows a function to be executed asynchronously and cooperatively. Coroutines enable writing code that can be suspended and resumed later, facilitating non-blocking I/O operations and efficient event-driven programming. A coroutine is a special type of function that can be paused at any point during its execution and resumed later. The main difference between a coroutine and a regular function is that a coroutine can be paused and resumed without losing its state. This capability allows a coroutine to perform I/O operations without blocking the thread or process, making them particularly useful for writing high-performance network servers and other event-driven applications.
	
	\par Four important concepts in the coroutine: \textbf{invoke, suspend, resume, finalize}.
	
		\begin{center}
		\begin{tabular}{|c|c|}
			\hline
			concept	& c++ coroutine  \\
			\hline
			Invoke	&  call coroutine directly \\
			\hline
			Finalize & con\_return \\
			\hline
			Suspend	& co\_await, co\_yield  \\
			\hline
			Resume	& coroutine\_hand<P>::resume()  \\
			\hline
		\end{tabular}
	\end{center}
	
	\begin{center}
		\includegraphics[width=.5\linewidth]{pics/cor2.png}
	\end{center}
	
		
	\par In implementation level, The compiler will generate a coroutine framework of code around your coroutine. This code relies on \textbf{user-defined return and promise types}. Until we get some standard types in C++23, you will need to write these yourself. The coroutine frame includes three important component, they are \textbf{handle, promise and awaitable}. 
	
	\begin{center}
		\includegraphics[width=.63\linewidth]{pics/cor1.png}
	\end{center}


\subsubsection{Coroutine handle}

	
	 Coroutine is a function, which current state of it is bundled up somewhere on the heap and creates a callable object whose invocation continues execution of the current function. The callable object is of type \texttt{std::coroutine\_handle<>}. A coroutine handle behaves a lot like a C pointer. It can be easily copied, but it doesn’t have a destructor to free the memory associated with coroutine state. To avoid leaking memory, you must generally destroy coroutine state by calling the \texttt{coroutine\_handle::destroy()} method (though in certain cases a coroutine can destroy itself on completion). Also like a C pointer, once a coroutine handle has been destroyed, coroutine handles referencing that same coroutine will point to garbage and exhibit undefined behavior when invoked. On the plus side, a coroutine handle is valid for the entire execution of a coroutine, even as control flows in and out of the coroutine many times.

	\par We need to make the \texttt{coroutine\_handle} available to caller. To do that, we pass it through the \texttt{get\_return\_object()} call where we create it from the promise instance. Then the caller can either call \texttt{resume()} or \texttt{destroy()} on the suspended coroutine. Note that calling these methods on a coroutine that isn't suspended is undefined behaviour. It also makes sense to make the caller-level type move-only to avoid confusion over the handle ownership.

\begin{lstlisting}
struct ReturnType { //This is user-defined return type
	struct promise_type { 	// user-defined coroutine level promise type
		using Handle = std::coroutine_handle<promise_type>;
		ReturnType get_return_object() {
			return ReturnType{Handle::from_promise(*this)};
		}
		std::suspend_always initial_suspend() { return {}; }
		std::suspend_never final_suspend() noexcept { return {}; }
		void return_void() { }
		void unhandled_exception() { }
	};
	explicit ReturnType(promise_type::Handle coro) : coro_(coro) {}
	void destroy() { coro_.destroy(); }
	void resume() { coro_.resume(); }
private:
	promise_type::Handle coro_;
};

ReturnType myCoroutine() {
	co_await std::suspend_alwyas{}; // make it a coroutine
}
int main() {
	auto c = myCoroutine();
	c.resume();
}	
\end{lstlisting}

\par \texttt{ReturnType}, \texttt{promise\_type}, and \texttt{coroutine\_handle} are the main tools of the coroutine mechanism. \texttt{promise\_type} is a type within ReturnType.

\par The programmer's design for a coroutine (such as what type of value it returns? whether it suspends or continues execution after initialization? how it handles exceptions? etc.) is passed to the compiler through \texttt{promise\_type}, which is responsible for instantiating the promise object. The compiler fills the coroutine handle (coroutine\_handle) into the future object(\texttt{ReturnType} in the above example), exposing control of the coroutine to the caller.

\begin{center}
	\begin{tabular}{| p{0.21\textwidth} |p{0.58\textwidth}|p{0.1\textwidth}|}
		\hline
		\textbf{promise\_type } & \textbf{Function} & \textbf{Required} \\ \hline
		initial\_suspend() & Customize when the coroutine body begins execution & Yes \\ \hline
		final\_suspend() & Customize the behavior of the coroutine body after it completes & Yes \\ \hline
		get\_return\_object() & Obtain the holder that contains the coroutine return value & Yes \\ \hline
		unhandled\_exception() & Customize the behavior when an exception occurs during coroutine execution & Yes \\ \hline
		
		\specialcell[t]{return\_value(T) \\ return\_void()} & Customize the behavior of the co\_return xxx; statement in the coroutine body & No \\ \hline
		
		
		yield\_value() & Customize the behavior of the co\_yield xxx; statement in the coroutine body & No \\ \hline
		await\_transform() & Customize the behavior of the co\_await xxx; statement in the coroutine body. When this method is defined, the compiler will transform every co\_await xxx; in the coroutine body to co\_await promise.await\_transform(xxx) & No \\ \hline
	\end{tabular}
	
\end{center}



	\par \texttt{coroutine\_handle} also exposes multiple interfaces for controlling coroutine behavior and accessing its state. Unlike \texttt{promise\_type}, where we need to provide implementations for the interfaces since they are called by the compiler, \texttt{coroutine\_handle} interfaces do not require us to provide implementations as we can directly call them.
\begin{center}
\begin{tabular}{|c|c|}
	\hline
	\textbf{coroutine\_handle Interface} & \textbf{Function} \\ \hline
	from\_promise() & Create a coroutine\_handle from a promise object \\ \hline
	done() & Check if the coroutine has completed \\ \hline
	operator bool & Check if the current handle is a coroutine \\ \hline
	operator() & Resume the execution of a coroutine \\ \hline
	resume() & Resume the execution of a coroutine \\ \hline
	destroy() & Destroy a coroutine \\ \hline
	promise() & Get the promise object associated with the coroutine \\ \hline
	address() & Return a pointer to the coroutine\_handle \\ \hline
	from\_address() & Import a coroutine\_handle from a pointer \\ \hline
\end{tabular}
	
\end{center}


\par The execution process of a coroutine follows a basic pattern, but there are some customizable points (such as \texttt{initial\_suspend}) where you can input your own behaviors to control the behavior of the coroutine. The basic pattern is illustrated by below figure.

\begin{center}
	\includegraphics[width=.74\linewidth]{pics/cor3.drawio.png}
\end{center}


\subsubsection{awaitable}
	 The \texttt{co\_await} operator is a new unary operator that can be applied to a value. For example: \texttt{co\_await} someValue. The \texttt{co\_await} operator can only be used within the context of a coroutine. This is somewhat of a tautology though, since any function body containing use of the \texttt{co\_await} operator, by definition, will be compiled as a coroutine. A type that supports the \texttt{co\_await} operator is called an awaitable type.
	
	
	
	\par Similarly to the promise type, the compiler will generate code around the awaitable type. If the promise type provides a \texttt{await\_transform(expr)}; method, the \texttt{co\_await} expr; call will be transformed into \texttt{promise.await\_transform(expr)};. Therefore, the promise type can control which awaitable types are allowed to appear inside the coroutine body and potentially return different awaitables based on the expression (note that expr here doesn't have to be awaitable).

	\begin{itemize}
		\item 	Returning void or true indicates that the coroutine will yield back to the function that originally called or resumed it after suspension. 
		
		\item Returning false will resume the execution of the current coroutine, but unlike when \texttt{await\_ready} returns true, the coroutine has already been suspended, so \texttt{await\_suspend} returning false is equivalent to suspending and immediately resuming it.
		
		\item 	Returning another coroutine's \texttt{coroutine\_handle} object will resume the execution of the corresponding coroutine.
		
		\item 	Throwing an exception will resume the execution of the current coroutine and throw the exception within the coroutine."
	\end{itemize}
	
	\begin{center}
		\includegraphics[width=.74\linewidth]{pics/cor4.drawio.png}
	\end{center}
		
	\par It provide three functions which you can customize your personal logic there. The most important function is \texttt{awaitable.await\_suspend}. You will note that there are two other methods on Awaiter, because these are required by the language. \texttt{await\_ready} is an optimization. If it returns true, then \texttt{co\_await} does not suspend the function. Of course, you could achieve the same effect in \texttt{await\_suspend}, by resuming (or not suspending) the current coroutine, but before calling \texttt{await\_suspend}, the compiler must bundle all state into the heap object referenced by the coroutine handle, which is potentially expensive. Finally, the method \texttt{await\_resume} here returns void, but if instead it returned a value, this value would be the value of the \texttt{co\_await} expression.
	
	\par C++ provides two default simple awaitable types: \texttt{std::suspend\_always} and \texttt{std::suspend\_never}. \texttt{suspend\_always::await\_ready} always returns false, while \texttt{suspend\_never::await\_ready} always returns true. The other methods on these classes are empty and do nothing. 
		

	 \par Based on the previous introduction, below is a concise version of the code that the compiler generates when it expands your coroutine code.

\begin{lstlisting}
template <typename R, typename... Args> // Given coroutine function, 
R Func(Args... args) {
	auto ret = co_await Awaiter();
	co_yield ret;
	co_return;
}

// compiler expand coroutine function to below code
template <typename R, typename... Args>
R Func(Args... args) {
	using promise_t = typename coroutine_traits<R, Args...>::promise_type;
	
	promise_t promise;  // put it head, not stack, just for illustration purpose
	auto __return__ = promise.get_return_object();
	co_await promise.initial_suspend(); //initial_suspend is called here.
	
	try {		
		auto &&value = Awaiter();  // auto ret = co_await Awaiter();
		auto &&awaitable=get_awaitable(promise, static_cast<decltype(value)>(value));
		auto &&awaiter = get_awaiter(static_cast<decltype(awaitable)>(awaitable));
		if (!awaiter.await_ready()) {
			using handle_t = std::coroutine_handle<Promise>;
			using await_suspend_result_t =
			decltype(awaiter.await_suspend(handle_t::from_promise(promise)));
			// coroutine suspend
			if constexpr (std::is_void_v<await_suspend_result_t>) {
				awaiter.await_suspend(handle_t::from_promise(promise));
				return __return__;  // give control to caller or resumer
			} else {
				static_assert(std::is_same_v<await_suspend_result_t, bool>,
				"await_suspend() must return 'void' or 'bool'.");
				if (awaiter.await_suspend(handle_t::from_promise(promise))) {
					return __return__;  // give control to caller or resumer
				}
			}
			// resume pointer, come here after call handle.resume()
		}
		auto ret = awaiter.await_resume();  // return resume value
		
		co_await promise.yield_value(ret);  	// co_yield ret;
	
		promise.return_void(); 	// co_return;
		goto final_suspend;
	} catch (...) {
		promise.set_exception(std::current_exception());
	}
	
	final_suspend:
	co_await promise.final_suspend();
}	
\end{lstlisting}



\subsubsection{Common usages of coroutine}
	 The first example is a generator, below is the client code. 
	
\begin{lstlisting}
Generator sequence() {
	int i = 0;
	while (true) {
		co_await i++;
	}
}

int main() {
	auto gen = sequence();
	for (int i = 0; i < 5; ++i) {
		std::cout << gen.next() << std::endl;
	}
}	
\end{lstlisting}

	\par Below is \texttt{Generator} code. 
\begin{lstlisting}
struct Generator {
	struct promise_type {  // return type must includes promise_type.
		int value;
	
		std::suspend_always await_transform(int value) { // for co_await 
			this->value = value;
			return {};
		}
		//boiler plate code, will call Cenerator constructor in 
		 Generator get_return_object() {
			return Generator{ std::coroutine_handle<promise_type>::from_promise(*this) };
		}
		
		std::suspend_always initial_suspend() { return {}; }; //suspend in the beginning
		std::suspend_never final_suspend() noexcept {return {};} //no suspend in the end.
		void unhandled_exception() { } //suppose has not exception, keep it empty here.
		
		void return_void() { } //no return value
	};
	std::coroutine_handle<promise_type> handle;
	explicit Generator(std::coroutine_handle<promise_type> handle) noexcept
	 : handle(handle) {}
	 
	 ~Generator() {
	 	if (handle) handle.destroy();
	 }
	
	int next() {
		handle.resume();
		return handle.promise().value;
	}
};	
\end{lstlisting}


\begin{center}
	\includegraphics[width=0.8\linewidth]{pics/coroutine_promise.drawio.png}
	\label{fig:coroutinepromise}
\end{center}

	
	\par In a true asynchronous application, it is not necessary to synchronize between threads after every task is executed like this. Instead, new work should be appended onto existing tasks, and the return value of the preceding task should be passed as a parameter to the next task after it finishes.
	

%	\par if you want to sync, use future. 
%\begin{lstlisting}
%void sync_func()
%{
%	std::promise<void> pms;
%	std::future<void> ftr = pms.get_future();
%	async_sqr_cbk(7, [p = std::move(pms)](const int result) mutable
%	{
%		std::cout << "result = " << result;
%		p.set_value();
%	});
%	ftr.get();
%}
%\end{lstlisting}

	\par The most interesting thing is callback hell, that is very bad

\begin{lstlisting}
void power_8(const int value){
	std::promise<void> pms;
	std::future<void> ftr = pms.get_future();
	async_sqr_ftr(value, [p = std::move(pms)](const int squared) mutable
	{
		async_sqr_ftr(squared, [p = std::move(p)](const int fourth) mutable
		{
			async_sqr_ftr(fourth, [p = std::move(p)](const int result) mutable
			{
				std::cout << "result = " << result;
				p.set_value();
			});
		});
	});
	ftr.get();
}	
\end{lstlisting}

\par Coroutine implementation, much better now.

\begin{lstlisting}
int slow_sqr(const int value){
	std::cout<<"thread ID in slow_sqr"<<std::this_thread::get_id()<<std::endl;
	std::this_thread::sleep_for(2s); 
	std::cout<<" Yan "<<value*value<<std::endl;
	return value * value;
}

template <std::invocable<int> F>
void async_sqr_cbk(const int value, F&& continuation){
	std::thread thr([v = value, c = std::forward<F>(continuation)]() mutable{
		int i = slow_sqr(v);
		c(i);
	});
	thr.detach();
}

class sqr_awaitable final{
private:
	int value_ = 0;
	int result_ = 0;	
public:	
	explicit sqr_awaitable(const int value): value_(value) {}
	bool await_ready() const noexcept { return false; }
	
	void await_suspend(const std::coroutine_handle<> awaiting){
		async_sqr_cbk(value_, [this, awaiting](const int result)
		{
			result_ = result; 
			awaiting(); // resume coroutine, awaiting.resume() is also ok
		});
	}
	
	// co_await return this value when resume.
	int await_resume() const noexcept { return result_; }
};	


task<void> power_8_async(const int value){
	std::cout<<"thread ID in power 1"<<std::this_thread::get_id()<<std::endl;
	const int squared = co_await sqr_awaitable{value};
	std::cout<<"thread ID in power 2"<<std::this_thread::get_id()<<std::endl;
	const int fourth = co_await sqr_awaitable{squared};
	std::cout<<"thread ID in power 3"<<std::this_thread::get_id()<<std::endl;
	const int result = co_await sqr_awaitable{fourth};
	std::cout << "result = " << result;
}		
\end{lstlisting}

\begin{lstlisting}
std::cout<<"thread ID in main"<<std::this_thread::get_id()<<std::endl;
power_8_async(3);
for(int i = 0;i<8;i++){
	std::this_thread::sleep_for(1s);
	cout<<"in main thread"<<endl;
}
thread ID in main140461981677376
thread ID in power1 140461981677376
thread ID in slow_sqr140461979203136
in main thread
Yan 9
thread ID in power2 140461979203136
in main thread
thread ID in slow_sqr140461970810432
in main thread
Yan 81
thread ID in powe3 140461970810432
in main thread
thread ID in slow_sqr140461979203136
in main thread
Yan 6561
result = 6561
in main thread
in main thread
in main thread
\end{lstlisting}
	\par Above code is good example about async, it can be run in the compiler explore. It avoid call back hell. But you can see the thread ID is messy. The same coroutine can be run in the different threads. The code can be found in  https://github.com/zhaoyan/coroutine\_examples. 
	
	
	
	\par \textbf{One basic idea is}:  thread use CPU concurrent, asio non block IO by using call back, and coroutine "chain call back" to avoid call back hell. That is the core idea of these three ideas. 
	
	Boost.Thread is another library that makes it possible to execute operations concurrently. The difference between Boost.Thread and Boost.Asio is that with Boost.Thread, you access resources inside of a program, and with Boost.Asio, you access resources outside of a program. For example, if you develop a function which needs to run a time-consuming calculation, you can call this function in a thread and make it execute on another CPU core. Threads allow you to access and use CPU cores. From the point of view of your program, CPU cores are an internal resource. If you want to access external resources, you use Boost.Asio.
	
	Network connections are an example of external resources. If data has to be sent or received, a network card is told to execute the operation. For a send operation, the network card gets a pointer to a buffer with the data to send. For a receive operation the network card gets a pointer to a buffer it should fill with the data being received. Since the network card is an external resource for your program, it can execute the operations independently. It only needs time – time you could use in your program to execute other operations. Boost.Asio allows you to use the available devices more efficiently by benefiting from their ability to execute operations concurrently.
	
	Coroutines let you create a structure that mirrors the actual program logic. Asynchronous operations don’t split functions, because there are no handlers to define what should happen when an asynchronous operation completes. Instead of having handlers call each other, the program can use a sequential structure.

	\par Three codes examples are here:
	https://github.com/zhaoyan/coroutine\_examples/. There is github project, which includes a good coroutine example: https://github.com/zhaoyan/study
	


\subsection{Others features in C++ 20}

\subsubsection{Time and date}

	 The core of the chrono library consists of the following types or concepts: 1) clock, 2) time point, 3) time duration, 4) time zone, and 5) calendar. Time duration is defined based on \texttt{std::ratio}. These abstract mechanisms are essential for specifying and handling points in time and durations. Although this design may not seem very intuitive at first, it offers flexibility and prevents the need to redefine many classes in the future if higher resolution is required.
	

	
	\par The entire chrono library begins with clocks. There are three types of clocks, each of which includes a default \texttt{period} and epoch. This \texttt{period} type is a \texttt{std::ratio} type representing the tick period (precision) of the clock, in \texttt{std::ratio} of seconds. There are three different kind of clocks:
		\begin{itemize}
			\item \texttt{std::chrono::sytem\_clock} is the system-wide real-time clock (wall-clock). The clock has the auxiliary functions \texttt{to\_time\_t} and \texttt{from\_time\_t} to convert time points into dates in C language. 
			\begin{figure}[ht]
				\centering
				\includegraphics[width=0.6\linewidth]{pics/tm}
				\label{fig:chrono1}
			\end{figure}
			
			\item \texttt{std::chrono::steady\_clock} provides the guarantee that it cannot be adjusted. Therefore, \texttt{std::chrono::steady\_clock} is the preferred clock to use when waiting for a time duration or until a specific time point.
			
			\item \texttt{std::chrono::high\_resolution\_clock} has the highest accuracy but it can be a synonym for the clocks \texttt{std::chrono::system\_clock} or \texttt{std::chrono::steady\_clock}.
			
			\item The \texttt{std::steady\_clock} is important to compare or compute the difference of two times in your program, where you processed the current point in time. If you're holding a \texttt{std::system\_clock} in your hand, you would call it a watch, and it would tell you what time it is. If you're holding a \texttt{std::steady\_clock} in your hand, you would call it a stopwatch, and it would tell you how fast someone ran a lap, but it would not tell you what time it is. 
			
			\item The C++ standard provides no guarantee about the clocks' accuracy, starting point, or valid time range. Typically, the starting point (epoch) of \texttt{std::chrono:system\_clock} is the 1.1.1970, the so-called UNIX-epoch. For \texttt{std::chrono::steady\_clock}, typically the boot time of your PC.
		\end{itemize}
		
		\par For each clock type, it defines \texttt{period} type inside. It is a \texttt{std::ratio} based on second and represents the accuracy. \texttt{std::ratio} is a type, not a value. So \texttt{std::ratio<1, 1,000,000,000>} based on second can be thought as nano second. In a linux system, we can run below code and check the output. The \texttt{std::system\_clock}'s peroid (precision) in linux system is nano second
		
\begin{lstlisting}
template <typename T>
void printRatio(){ 
	cout << "precision:" << T::num << "/" << T::den << "second";
	typedef typename std::ratio_multiply<T,std::kilo>::type MillSec;
	typedef typename std::ratio_multiply<T,std::mega>::type MicroSec;
	//1 second equals 1*1000 millsecond. 
	cout<<static_cast<double>(MillSec::num)/MillSec::den<<"milliseconds";
	cout<<static_cast<double>(MicroSec::num)/MicroSec::den <<"microseconds";
}
printRatio<std::chrono::system_clock::period>();  

//output is below:
precision: 1/1000000000 second //Equals 0.0000000001 second
0.000001 millisecond
0.001 microseconds	
\end{lstlisting}					
		
\begin{center}
	
	\begin{tabular}{|l|l|l|}
		\hline
		\textbf{Prefix} & \textbf{Definition} & \textbf{Exponent} \\ \hline
		\texttt{nano (since C++11)}  & \texttt{std::ratio<1, 1000000000>} & $(10^{-9})$  \\ \hline
		\texttt{micro (since C++11)} & \texttt{std::ratio<1, 1000000>}    & $(10^{-6})$  \\ \hline
		\texttt{milli (since C++11)} & \texttt{std::ratio<1, 1000>}       & $(10^{-3})$  \\ \hline
		\texttt{deca (since C++11)}  & \texttt{std::ratio<10, 1>}         & $(10^{1})$   \\ \hline
		\texttt{kilo (since C++11)}  & \texttt{std::ratio<1000, 1>}       & $(10^{3})$   \\ \hline
		\texttt{mega (since C++11)}  & \texttt{std::ratio<1000000, 1>}    & $(10^{6})$   \\ \hline
		\texttt{giga (since C++11)}  & \texttt{std::ratio<1000000000, 1>} & $(10^{9})$   \\ \hline
	\end{tabular}
	
\end{center}
		

				
		\par For duration, definition is below:
\begin{lstlisting}
template<class Rep, class Period = std::ratio<1> > 
class duration;

chrono::nanoseconds is duration</*signed int  64 bits*/, std::nano>
chrono::microseconds is duration</*signed int at least 55 bits*/, std::micro>
chrono::seconds is duration</*signed int at least 35 bits*/>
chrono::minutes is duration</*signed int at least 29 bits*/, std::ratio<60>>
chrono::hours is duration</*signed int at least 23 bits*/, std::ratio<3600>>
\end{lstlisting}		
		
		The duration is based on a \texttt{std::ratio}. A duration of time is defined as a specific number of ticks over a time unit. One example is a duration such as “3 minutes” (3 ticks of a “minute”). 		
		
		
		\par Once we have a clock, we can define a time point based on it. A time point is a combination of a duration and a starting point in time (the so-called epoch). A typical example is a time point representing "New Year's Midnight 2000," described as "1,262,300,400 seconds since January 1, 1970" (the epoch of the UNIX and POSIX system clocks). In other words, a time point is defined as a duration before or after an epoch, which is determined by a clock. The concept of a time point is parameterized by a clock, which defines the epoch of the time point. Thus, different clocks have different epochs. \textbf{In general, operations dealing with multiple time points, such as processing the duration or difference between two time points, require using the same epoch/clock.} A clock also provides a convenient function to yield the current time point.
\begin{lstlisting}[numbers=none, basicstyle=\scriptsize]
const chrono::time_point<std::chrono::system_clock> now = std::chrono::system_clock::now();
const auto end = std::chrono::steady_clock::now();  //end is time_point
\end{lstlisting}

	\par The main component in chrono library can be illustrated by below figure: 
\begin{center}
	\includegraphics[width=0.48\linewidth]{pics/chrono.drawio.png}
\end{center}
	
	

	\par Usage of time point. You can define time point based on certain duration, such as second. Default is corresponding clock precision (duration). 
\begin{lstlisting}[numbers=none]
using namespace std::chrono;
system_clock::time_point tp_epoch;	// epoch value
time_point <system_clock, duration<int>> tp_seconds (duration<int>(3)); 
//3 second after epoch

system_clock::time_point tp (tp_seconds); //point based on system clock period

std::cout << "1 second since system_clock epoch = ";
std::cout << tp.time_since_epoch().count();
std::cout << " system_clock periods." << std::endl;

std::time_t tt = system_clock::to_time_t(tp); // display time_point:
std::cout << "time_point tp is: " << ctime(&tt);		
\end{lstlisting}		
	
	\par Duration's type is decided by the clock. That is why the first duration return nanosecond. 
\begin{lstlisting}[numbers=none]	
auto timeNow= std::chrono::system_clock::now(); //timeNow is time point.
auto duration= timeNow.time_since_epoch();  //change from time point to time duration.
std::cout << duration.count() << " nanoseconds " << std::endl;

typedef std::chrono::duration<long double,std::ratio<1,1000>> MyMilliSecondTick;
typedef std::chrono::duration<double, std::ratio<60*60>> MyHourTick;
MyHourTick myHour{duration}; //change nano seconds to hour
std::cout << myHour.count() << " hours" << std::endl;		
\end{lstlisting}		
	
	\par How long does your programme run? 1) select a clock, 2) get two time points, 3) subtract two time points to get a duration, 4) change clock duration to your own duration (different time units). Pay attention to the usage of \texttt{chrono::duration\_cast}. 
\begin{lstlisting}
std::chrono::time_point<std::chrono::steady_clock> begin = steady_clock::now();
std::this_thread::sleep_for(std::chrono::milliseconds(20));
auto end = steady_clock::now();
cout << "time " << duration_cast<milliseconds>(end - begin).count() << endl;
cout << chrono::duration_cast<chrono::microseconds>(end - start).count()
<< chrono::duration_cast<chrono::seconds>(end - start).count()		
\end{lstlisting}		


	\par From time\_point, we can change it to different time\_zone. 
\begin{lstlisting}[numbers=none, basicstyle=\scriptsize]
const std::chrono::zoned_time zt{locate_zone("Europe/Rome", std::chrono::system_clock::now()}; 
std::cout <<"- Zoned Time:" << zt <<'\n';
\end{lstlisting}
	
	

	\par From time\_point, we can also deduct calendar time. Use system\_time here, and also floors accept one time\_point(mill seconds duration (precision) ), and return another time\_point (days duration (precision) ) with different duration.
	At the same time, year\_month\_day accept \texttt{std::sys\_days} as input argument. 
\begin{lstlisting}
using sys_time = std::chrono::time_point<std::chrono::system_clock, Duration>;
using sys_days = sys_time<std::chrono::days>;

const std::chrono::time_point now{std::chrono::system_clock::now()};
const std::chrono::year_month_day ymd{std::chrono::floor<std::chrono::days>(now)};

std::cout << "Current Year: " << static_cast<int>(ymd.year())
<< ", Month: " << static_cast<unsigned>(ymd.month())
<< ", Day: " << static_cast<unsigned>(ymd.day()) << '\n';	
\end{lstlisting}


	\par we can also from clock to get \texttt{std::time\_t}, then use C language time functions.  
\begin{lstlisting}
const std::time_t t_c = std::chrono::system_clock::to_time_t(now - 24h);
std::cout << "24 hours ago, the time was "
<< std::put_time(std::localtime(&t_c), "%F %T.\n") << std::flush;
\end{lstlisting}
	
	\par There are two sorts of timeouts that you may wish to specify: a duration-based timeout and an absolute timeout. The variants that handle the duration-based timeouts have a \texttt{\_for} suffix, while those that handle the absolute timeouts have an \texttt{\_until} suffix. Durations and timepoints can be used to block threads or programs (i.e., the main thread). These blocks can be conditionless or can be used to specify a maximum duration when waiting for a lock, a condition variable, or another thread to end.
	
\begin{lstlisting}
sleep_for and sleep_until; try_lock_for and try_lock_until; wait_for and wait_until.
\end{lstlisting}		
	

	
%	\par There is no date type in c++ standard, you can use \texttt{boost::date} type. Detail can be see in the "common used libs" in this book. Or you can use \texttt{std::system\_clock} and convert it to \texttt{time\_t} and \texttt{tm} in C language. 
	

	
	\par There is a simple rule to follow with the <chrono> library. The rule is actually not completely correct (thus it is a guideline). But it is close enough to correct to be a guideline that is nearly always followed: Don't use \texttt{count()} and don't use \texttt{time\_since\_epoch()}. The <chrono> library is designed around a type-safe system meant to protect you from units conversions mistakes. If you accidentally attempt an unsafe conversion, the error is caught at compile time (as opposed to it being a run time error). The member functions \texttt{count()} and \texttt{time\_since\_epoch()} are "escape hatches" out of this type-safe system ... to be used only in cases of emergency or IO. In another word, both duration and time\_point are type safe, you can't mix the wrong type together, such as add \texttt{int} to \texttt{string}.   
\begin{lstlisting}[basicstyle=\scriptsize]
struct DataHolder{
	std::chrono::system_clock::time_point
	getTimestamp(){
		using namespace std::chrono;
		return system_clock::time_point{milliseconds{1437520382241}};
	}
};

uint64_t now = duration_cast<milliseconds>(steady_clock::now().time_since_epoch()).count();
bool is_old = (120 * 1000 < (now - data_holder->getTimestamp()));
//above is bad code, below is correct code

auto data_holder = std::unique_ptr<DataHolder>(new DataHolder);
auto now = system_clock::now();
bool is_old = minutes{2} < now - data_holder->getTimestamp();
//after C++14, minutes{2} can be written as 2min
\end{lstlisting}

	\par Summary: the main components in the chrono library illustrated by following diagram. 

\begin{center}
	\includegraphics[width=0.7\linewidth]{pics/time.drawio.png}
\end{center}
		
	\par Three good article are "The C++ standard Library: Utilities" and "Difference between steady\_clock vs system\_clock?" and "https://paul.pub/cpp-date-time/"
	
	
\subsubsection{Spaceship operator}

	
	 The three-way comparison operator, also called the spaceship operator, provides three types of ordering: \texttt{std::strong\_ordering},  \texttt{std::weak\_ordering} and \texttt{std::partial\_ordering}. What are the differences between them? For an object of a certain type, if you want to "strictly compare" all of its members, you should use \texttt{std::strong\_ordering}. Otherwise, use \texttt{std::weak\_ordering}.
	
	There are two examples about choosing between \texttt{std::strong\_ordering} and \texttt{std::weak\_ordering}:
	\begin{enumerate}
		\item Strict Comparison: If each character is compared, you can choose \texttt{std::strong\_ordering}. If I want to perform a case-insensitive comparison, the return type should be texttt{std::weak\_ordering}.
		
		\item All Members: I have included all three members, first\_name, mid\_name, and last\_name, of Name in the comparison scope, so it is \texttt{std::strong\_ordering}. If only one or two of them are compared, return \texttt{std::weak\_ordering}.
	\end{enumerate}
With the C++20 operator<=>, you will most likely always implement this as a member function.

	
\begin{lstlisting}
struct Name {
	string first_name;
	string mid_name;
	string last_name;
	bool operator<(const Name& other) const { //C++11 style
		return std::tie(first_name, mid_name, last_name) < 
		std::tie(other.first_name, other.mid_name, other.last_name);
	}
	auto operator<=>(const Name&) const = default; //auto is std::strong_ordering
	// get all six comparison operators: ==, !=, <, <=, >, and >= 
};
\end{lstlisting}	

	\par If you define your own spaceship operator, compiler will not generate \texttt{==} operator. The reason why equality and ordering are separated is that there are many scenarios where automatically implementing \texttt{==} in terms of \texttt{<=>} could be quite inefficient. 

\begin{center}
	\begin{tabular}{|c|c|c|}
		\hline
		&  Equality & Ordering  \\
		\hline
		Primary & ==  &  <=> \\
		\hline
		Secondary& != & <, >, <=, >=  \\
		\hline
	\end{tabular}
\end{center}

	
	\par Spaceship operator returns three ordering type. You can convert strong to weak, and weak to partial. These type supports comparison with 0. Why do we have three return types? It can make compiler to distinguish type mismatch error.  Please see the following code: 
\begin{lstlisting}
struct Int{
	int intNum_;
	std::strong_ordering operator<=>(const Int& rhs) const = default;
};
struct Float{
	float floatNum_;
	auto operator<=>(const Float& rhs) const = default;
};
struct Numbers{
	Int first_;
	Float second_;
	std::strong_ordering operator<=>(const& Numbers rhs) const{
		if(auto cmp = first_<=> rhs.first_; cmp != 0)
		{return cmp;}
		return second_ <=> rhs.second_;
	}
};

\end{lstlisting}


\begin{footnotesize}
\begin{verbatim}
error: couldn't convert '((const NumericWrapper*)this->NumericWrapper::second_.FloatWrapper
::operator<=>(rhs.NumericWrapper::second)' from std::partial_ordering to std::strong_ordering
|        return second_ <=> rhs.second_;
|               ~~~~~~~~~^~~~~~~~~~~~~~~
|                        |
|                       std::partial_ordering
\end{verbatim}
\end{footnotesize}


\section{Example of Modern C++}
    
	 

	\par We want to build a function to make an array, the basic idea is just like \texttt{std::make\_pair}. One implementation looks like the following. We mainly use three features from C++11/14: 1) \texttt{std::array}, 2) list initialization(return \{\} ) 3) variadic templates.

\begin{lstlisting}
template<typename VT, typename ... Params>
std::array<VT, sizeof ... (Params)+1>  //pay attention sizeof usage.
get_data(const VT &v1, const Params& ... params){
	return {v1, params...} //return a std::array
}
\end{lstlisting}	


	\par With the help of modern C++, \texttt{get\_data} can become a little easier. This does not make C++ easier to teach, but it does allow for a higher level of efficiency. Compared to the previous example, the disappearance of VT is not because a fold expression substitutes a recursive variadic template definition, but because we can deduce the \texttt{std::array} type from the parameters automatically (C++17). We mainly use: 1) \texttt{std::array} c++11 2) auto template 3) auto return deduction 4) template parameter deduction 5) forward and rvalue reference
\begin{lstlisting}
auto get_data(const auto& ...params){
	return std::array{std::forward<decltype(params)>(params)...};
}
\end{lstlisting}


	\par It demonstrates some very useful modern C++ features, based on these features, you can find that it make you to write the code much easier. 

	
\begin{lstlisting}
void print_map(const auto& map, const std::string_view key_desc = "key",
							const std::string_view value_desc = "value"){
	const auto print_key_value = [&](const auto &data){ //below define a lambda
		const auto &[key, value] = data;
		puts(std::format("{}: '{}' {}: '{}'", key_desc, key, value_desc, value).c_str());
	}
	ranges::for_each(map, print_key_value); //use lambda in for_each loop.
	//or use range-based for below 
	for( const auto &[key, value]: map){
		puts(format("{}: '{}' {}: '{}'", key_desc, key, value_desc, value).c_str());
	}	
}	
\end{lstlisting}	

    \par In above code, I mainly demonstrate below C++ language features:
    
    \begin{itemize}
    	\item C++ 98: \texttt{const}, template and STL container.
    	
    	\item C++ 11: \texttt{std::array}, list initialization, variadic template, \texttt{constexpr}, auto, lambdas, range-base for loops, rvalue references, default and deleted functions, smart pointers.
    	
    	\item c++ 14: generic and variadic lambdas, return type deductions, \texttt{std::make\_unique}.
    	
    	\item C++ 17: structured bindings, \texttt{std::string\_view}, class template argument deduction, guaranteed copy elision, fold Expressions.
    	
    	\item C++ 20: format, range, concept. 
    \end{itemize}
    
  \par Below table give corresponding rules you should follow when you write modern C++ code.
  
  \begin{center}
  	\begin{tabular}{|p{0.33\textwidth}|p{0.57\textwidth}|}
  		\hline 
  		\textbf{Old C++} & \textbf{Modern C++}  \\ 
  		
  		\hline 
  		manual data structure, for loop & container(tuple, variant) or algorithem \\ 
  		
  		\hline 
  		new & \texttt{std::uniqu\_ptr}, \texttt{std::shared\_ptr} \\ 
  		
  		\hline 
  		return null, union, \texttt{void*} & \texttt{std::optional, std::variant, std::any} \\ 
  		
  		\hline 
  		function pointer & \texttt{std::function} or lambda  \\ 
  		
  		\hline 
  		initialization  & auto, list initialization, member initialization, template deduction  \\ 
  		
  		\hline 
  		const  & const and constexpr \\ 
  		
  		\hline 
  		typedef & alias \\ 
  		
  		\hline 
  		enum & scope enum \\ 
  		
  		\hline 
  		tie & structured binding \\ 
  		
  		\hline 
  		random &  mt19937 \\ 
  		
  		\hline 
  		ctime &  \texttt{std::chrono}, duration \\ 
  		
  		\hline 
  		recursive template function &  fold expression \\ 
  		
  		\hline 
  		const reference string and array &  \texttt{std::span} and \texttt{std::string\_view} \\ 
  		
  		\hline 
  		N/A &  override and final, deleted or defaulted \\ 
  		
  		\hline 
  		N/A &  \texttt{std::filesystem, std::format, std::regex} \\ 
  		
  		\hline 
  		N/A &  R"", \texttt{std::quoted} and user-defined literals. \\ 
  		
  		\hline 
  	\end{tabular} 
  	
  \end{center}  


\textbf{To be continue...}
In 2023, as I wrote this book, the latest C++ standard C++ 23 has just been released. Therefore, the upcoming eighth edition of this book will cover additional features in C++ 23. Additionally, I plan to add two chapters: one is "Embedded Systems" and the other is "Commonly Used Libraries". Furthermore, I will enhance the Modern C++ chapter with more detailed explanations and additional content. Moving forward, I plan to publish a new edition each year to incorporate the latest advancements in the C++ language.
\newline
\textbf{"I'll be back"}




%\end{CJK*}
\end{document}

